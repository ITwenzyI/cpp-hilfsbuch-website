[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          { "title": "Namensgebung", "content": { "text": [], "code": [] } },
          { "title": "Begriffe", "content": {
            "text": [
            "### === Wichtige Begriffe in C++ erkl√§rt ===\n",
            "Hier findest du eine √úbersicht zentraler Begriffe in der C++-Programmierung, kompakt erkl√§rt.\n",
            "\n",
            "#### Compiler\n",
            "- √úbersetzt C++-Code in Maschinenprogramm, das dein Computer ausf√ºhren kann\n",
            "\n",
            "#### Pr√§prozessor\n",
            "- F√ºhrt Anweisungen wie `#include` und `#define` vor dem Kompilieren aus\n",
            "\n",
            "#### Header-Datei\n",
            "- Datei mit Deklarationen von Funktionen, Klassen oder Konstanten (`.hpp`)\n",
            "\n",
            "#### Deklaration vs. Definition\n",
            "- Deklaration: Nur Ank√ºndigung (z.B. `int x;`)\n",
            "- Definition: Speicher wird wirklich zugewiesen (z.B. `int x = 5;`)\n",
            "\n",
            "#### Variable\n",
            "- Speicherstelle mit Namen, die Daten aufnehmen kann (z.B. `int zahl = 10;`)\n",
            "\n",
            "#### Funktion\n",
            "- Codeblock, der mehrfach ausf√ºhrbar ist - mit `return`-Wert und Parametern\n",
            "\n",
            "#### R√ºckgabewert\n",
            "- Der Wert, den eine Funktion mit `return` zur√ºckliefert\n",
            "\n",
            "#### Parameter vs. Argument\n",
            "- Parameter: Platzhalter in der Funktionsdefinition (`int add(int a, int b)`)\n",
            "- Argument: Konkreter Wert beim Aufruf (`add(5, 7)` ‚Üí 5 und 7)\n",
            "\n",
            "#### Block / Scope\n",
            "- Bereich mit `{}` - darin gelten lokale Variablen\n",
            "\n",
            "#### G√ºltigkeitsbereich (Scope)\n",
            "- Gibt an, wo im Code eine Variable sichtbar/nutzbar ist (z.B. lokal vs. global)\n",
            "\n",
            "#### Initialisierung\n",
            "- Erstmalige Zuweisung eines Werts an eine Variable (`int x = 5;`)\n",
            "\n",
            "#### Operatoren\n",
            "- Rechenzeichen oder Symbole zur Verarbeitung (`+`, `-`, `==`, `&&`, `++`, `<<`)\n",
            "\n",
            "#### Kontrollstrukturen\n",
            "- Anweisungen zur Ablaufsteuerung: `if`, `while`, `for`, `switch`\n",
            "\n",
            "#### Schleife\n",
            "- Wiederholt Anweisungen: `while`, `for`, `do-while`\n",
            "\n",
            "#### Bedingung\n",
            "- Ausdruck, der `true` oder `false` ergibt (z.B. `x > 5`)\n",
            "\n",
            "#### Klasse / Objekt\n",
            "- Klasse: Bauplan f√ºr Objekte (enth√§lt Daten + Funktionen)\n",
            "- Objekt: Konkrete Instanz einer Klasse\n",
            "\n",
            "#### Konstruktor / Destruktor\n",
            "- Konstruktor: Wird beim Erzeugen eines Objekts automatisch aufgerufen\n",
            "- Destruktor: Wird beim L√∂schen automatisch aufgerufen (`~Klassenname()`)\n",
            "\n",
            "#### this-Zeiger\n",
            "- Zeigt innerhalb einer Klasse auf das aktuelle Objekt (`this->variable`)\n",
            "\n",
            "#### new / delete\n",
            "- `new`: Reserviert Speicher auf dem Heap (`int* p = new int;`)\n",
            "- `delete`: Gibt diesen Speicher wieder frei\n",
            "\n",
            "#### Referenz (&)\n",
            "- Alias auf eine bestehende Variable (z.B. `int& r = x;`)\n",
            "\n",
            "#### Zeiger (*)\n",
            "- Variable, die eine Speicheradresse speichert (`int* p = &x;`)\n",
            "\n",
            "#### nullptr\n",
            "- Null-Zeiger, zeigt auf ‚Äûnichts‚Äú (`int* p = nullptr;`)\n",
            "\n",
            "#### √úberladung\n",
            "- Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Signatur\n",
            "\n",
            "#### Vererbung\n",
            "- Eine Klasse √ºbernimmt Eigenschaften einer anderen Klasse\n",
            "\n",
            "#### Polymorphie\n",
            "- F√§higkeit, Objekte √ºber gemeinsame Schnittstellen unterschiedlich zu behandeln\n",
            "\n",
            "#### Template\n",
            "- Erm√∂glicht generischen Code (z.B. Funktionen f√ºr beliebige Typen)\n",
            "\n",
            "#### Lambda\n",
            "- Anonyme Funktion, oft f√ºr kurze Aktionen in `std::for_each`, `sort`, ...\n",
            "\n",
            "#### Iterator\n",
            "- Zeiger-√§hnliches Objekt zum Durchlaufen von Containern (`v.begin()`, `v.end()`)\n",
            "---\n"
            ],
            "code": []
          } 
        },
          { "title": "Datentypen", "content": {
            "text": [
              "### === Datentypen in C++ ===\n",
              "C++ kennt viele eingebaute Typen und erlaubt die Definition eigener Typen.\n",
              "\n",
              "---\n",
              "### Standard-Datentypen\n",
              "- `int`: Ganzzahl (z.B. `int x = 5;`)\n",
              "- `float`: Flie√ükommazahl mit einfacher Genauigkeit\n",
              "- `double`: Flie√ükommazahl mit doppelter Genauigkeit\n",
              "- `char`: Einzelnes Zeichen (z.B. `'A'`)\n",
              "- `bool`: Wahrheitswert (`true` / `false`)\n",
              "- `void`: Kein R√ºckgabewert (z.B. bei `void funktion()`)\n",
              "\n",
              "---\n",
              "### Erweiterte Grundtypen\n",
              "- `long`, `long long`, `unsigned`, `short`: Varianten von `int`\n",
              "- `wchar_t`, `char16_t`, `char32_t`: Unicode-Zeichentypen\n",
              "- `std::string`: String-Klasse (aus `<string>`)\n",
              "- `std::size_t`: Unsigned Ganzzahl f√ºr Gr√∂√üen (z.B. `v.size()`)\n",
              "- `nullptr_t`: Typ des Literals `nullptr`\n",
              "\n",
              "---\n",
              "### Automatische Typableitung\n",
              "- `auto`: Typ wird automatisch aus dem Ausdruck ermittelt\n",
              "- `decltype(...)`: Liefert den Typ eines Ausdrucks\n",
              "- Beispiel:\n",
              "```cpp\nint x = 5;\nauto y = x * 2;         // y ist int\ndecltype(y) z = 10;      // z ist auch int\n```\n",
              "\n",
              "---\n",
              "### Eigene Typen\n",
              "- `struct`: F√ºr einfache Strukturen mit mehreren Feldern\n",
              "- `class`: F√ºr Klassen mit Methoden und Zugriffskontrolle (public/private)\n",
              "- `enum`: F√ºr aufz√§hlbare Werte\n",
              "\n",
              "#### `enum` Erkl√§rung:\n",
              "- `enum` erstellt eigene ganzzahlige Werte (standardm√§√üig beginnend bei 0)\n",
              "- Beispiel:\n",
              "```cpp\nenum Farbe { Rot, Gruen, Blau };  // Rot = 0, Gruen = 1, Blau = 2\n```\n",
              "- Man kann Werte auch selbst zuweisen:\n",
              "```cpp\nenum Status { OK = 1, FEHLER = 404, NICHT_GEFUNDEN = 4040 };\n```\n",
              "- Zugriff auf Zahlwert mit `static_cast<int>(enumWert)`:\n",
              "```cpp\nStatus s = FEHLER;\nstd::cout << static_cast<int>(s);  // Ausgabe: 404\n```\n",
              "- `enum class` (modernes C++): Streng typisiert, Zugriff nur mit `Status::FEHLER`\n",
              "\n",
              "---\n",
              "### `using/typedef` Erkl√§rung:\n",
              "- `typedef` (alt) und `using` (modern): Eigene Namen f√ºr bestehende Typen\n",
              "- Beispiel:\n",
              "```cpp\ntypedef unsigned int uint;\nusing Score = double;\n```",
              "\n",
              "---\n",
              "### Typumwandlung (Casting)\n",
              "- `static_cast<T>(wert)`: Sicherer Cast zwischen kompatiblen Typen\n",
              "- `const_cast<T>`: Entfernt `const`\n",
              "\n",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <string>\n#include <typeinfo>\n\n// Eigene Struktur\nstruct Person {\n    std::string name;\n    int alter;\n};\n\n// Typalias\nusing Zahl = unsigned int;\n\nenum Farbe { Rot, Gruen, Blau };           // Rot = 0, Gruen = 1, Blau = 2\nenum Status { OK = 1, FEHLER = 404 };      // eigene Werte\n\nint main() {\n    int a = 10;\n    auto b = 3.14;                          // automatisch double\n    decltype(a) c = 5;                      // ebenfalls int\n\n    Person p = {\"Kilian\", 21};\n    Zahl punkte = 150;\n\n    Farbe f = Gruen;\n    Status s = FEHLER;\n\n    std::cout << \"Name: \" << p.name << \", Alter: \" << p.alter << std::endl;         // Ausgabe: Name: Kilian, Alter: 21\n    std::cout << \"Punkte: \" << punkte << std::endl;                                  // Ausgabe: Punkte: 150\n    std::cout << \"Typ von b: \" << typeid(b).name() << std::endl;                     // Ausgabe: Typ von b: double (compilerabh√§ngig)\n    std::cout << \"Fehlercode: \" << static_cast<int>(s) << std::endl;                // Ausgabe: Fehlercode: 404\n\n    return 0;\n}"
              ]
            } 
          },
          { "title": "I/O Grundprinzipien", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          { "title": "Arithmetische Operatoren", "content": { "text": [], "code": [] } },
          { "title": "Vergleichsoperatoren", "content": { "text": [], "code": [] } },
          { "title": "Logische Operatoren", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          { "title": "const Variablen", "content": { "text": [], "code": [] } },
          { "title": "const Parameter", "content": { "text": [], "code": [] } },
          { "title": "const Klassenmember", "content": { "text": [], "code": [] } },
          { "title": "const √úberladen", "content": { 
            "text": [
              "### === `const` √úberladen ===\n",
              "In C++ kann man Funktionen **√ºberladen**, indem man einmal eine `const`- und einmal eine **nicht-`const`-Version** erstellt.\n",
              "\n",
              "---\n",
              "### Warum?\n",
              "- `const`-Objekte d√ºrfen nur `const`-Funktionen aufrufen.\n",
              "- So kann dieselbe Funktion **unterschiedliches Verhalten** haben - je nach `const`-Zustand des Objekts.\n",
              "\n",
              "---\n",
              "### `const` am Ende einer Methode:\n",
              "- Bedeutet: Diese Funktion **ver√§ndert keine Membervariablen** (au√üer `mutable`)\n",
              "- Wichtig f√ºr **Zugriffsmethoden (Getter)** oder bei Funktionen, die nur lesen\n",
              "\n",
              "üëâ `const` ist Teil der Funktionssignatur und wird bei der √úberladung beachtet.\n",
              "---\n"
              ], 
              "code": [    
              "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n  std::string name;\n\npublic:\n  Person(std::string n) : name(n) {}\n\n  // Nicht-const-Version\n  std::string& getName() {\n    std::cout << \"Nicht-const Version\" << std::endl;\n    return name;\n  }\n\n  // Const-Version (f√ºr const Objekte)\n  const std::string& getName() const {\n    std::cout << \"Const-Version\" << std::endl;\n    return name;\n  }\n};\n\nint main() {\n  Person p1(\"Kilian\");\n  const Person p2(\"Lisa\");\n\n  std::cout << p1.getName() << std::endl;  // Ausgabe: Nicht-const Version\\nKilian\n  std::cout << p2.getName() << std::endl;  // Ausgabe: Const-Version\\nLisa\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "constexpr", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          { "title": "cout", "content": { "text": [], "code": [] } },
          { "title": "cin", "content": { "text": [], "code": [] } },
          { "title": "getline", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "ifstream", "content": { "text": [], "code": [] } },
          { "title": "ofstream", "content": { "text": [], "code": [] } },
          { "title": "fstream", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          { "title": "if / else", "content": { "text": [], "code": [] } },
          { "title": "switch", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          { "title": "for", "content": { "text": [], "code": [] } },
          { "title": "while", "content": { "text": [], "code": [] } },
          { "title": "do-while", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          { "title": "Funktionsdefinition", "content": { "text": [], "code": [] } },
          { "title": "Parameter & R√ºckgabe", "content": { "text": [], "code": [] } },
          { "title": "√úberladen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          { "title": "inline", "content": { "text": [], "code": [] } },
          { "title": "constexpr Funktionen", "content": { "text": [], "code": [] } },
          { "title": "Lambda-Funktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          { "title": "C-Arrays", "content": { "text": [], "code": [] } },
          { "title": "std::array", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          { "title": "C-Strings", "content": { "text": [], "code": [] } },
          { "title": "std::string", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          { "title": "Pointer Basics", "content": { "text": [], "code": [] } },
          { "title": "Pointer Arithmetik", "content": { "text": [], "code": [] } },
          { "title": "Nullpointer", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          { "title": "Referenzen Basics", "content": { "text": [], "code": [] } },
          { "title": "Referenzparameter", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          { "title": "Stack vs Heap", "content": { "text": [], "code": [] } },
          { "title": "new / delete", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          { "title": "RAII Prinzip", "content": { "text": [], "code": [] } },
          { "title": "Smart Pointer", "content": {
            "text": [
              "### === Smart Pointer in C++ ===\n",
              "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
              "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
              "\n",
              "---\n",
              "### Warum Smart Pointer?\n",
              "- Kein manuelles `delete` n√∂tig\n",
              "- Klare Besitzverh√§ltnisse\n",
              "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
              "\n",
              "---\n",
              "### üîπ `std::unique_ptr<T>`\n",
              "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
              "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
              "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
              "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
              "\n",
              "---\n",
              "### üîπ `std::shared_ptr<T>`\n",
              "- **Mehrere Besitzer** teilen sich das Objekt\n",
              "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
              "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
              "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
              "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
              "\n",
              "---\n",
              "### üîπ `std::weak_ptr<T>`\n",
              "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
              "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
              "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
              "\n",
              "---\n",
              "### üîç Vergleichstabelle:\n",
              "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
              "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
              "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
              "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        { "title": "<iostream>", "content": { "text": [], "code": [] } },
        { "title": "<fstream>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } },
        { "title": "<iomanip>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
        { "title": "<string>", "content": { "text": [], "code": [] } },
        { "title": "<string_view>", "content": { "text": [], "code": [] } },
        { "title": "<cstring>", "content": { "text": [], "code": [] } },
        { "title": "<cctype>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        { "title": "<cmath>", "content": { "text": [], "code": [] } },
        { "title": "<cstdlib>", "content": { "text": [], "code": [] } },
        { "title": "<random>", "content": { "text": [], "code": [] } },
        { "title": "<limits>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        { "title": "<chrono>", "content": { "text": [], "code": [] } },
        { "title": "<ctime>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        { "title": "<thread>", "content": { "text": [], "code": [] } },
        { "title": "<future>", "content": { "text": [], "code": [] } },
        { "title": "<typeinfo>", "content": { "text": [], "code": [] } },
        { "title": "<new>", "content": { "text": [], "code": [] } },
        { "title": "<memory>", "content": { "text": [], "code": [] } },
        { "title": "<cstdio>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
        { "title": "<algorithm>", "content": { "text": [], "code": [] } },
        { "title": "<iterator>", "content": { "text": [], "code": [] } },
        { "title": "<functional>", "content": { "text": [], "code": [] } },
        { "title": "<initializer_list>", "content": { "text": [], "code": [] } },
        { "title": "<tuple>", "content": { "text": [], "code": [] } },
        { "title": "<utility> (pair, swap)", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
          { "title": "Klassen Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren & Destruktoren", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
          { "title": "Basisklassen", "content": { "text": [], "code": [] } },
          { "title": "Polymorphie", "content": { "text": [], "code": [] } },
          { "title": "virtual / override", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
          { "title": "struct Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "struct vs class", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
          { "title": "enum Grundlagen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
          { "title": "enum class Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "enum class vs enum", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
          { "title": "namespace Grundlagen", "content": {
            "text": [
                "### === Namespaces in C++ ===\n",
                "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
                "\n",
                "---\n",
                "### Warum Namespaces?\n",
                "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
                "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
                "\n",
                "---\n",
                "### Verwendung von Namespaces\n",
                "- Definition:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
                "- Aufruf:\n",
                "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
                "\n",
                "---\n",
                "### Anonyme Namespaces (Datei-spezifisch)\n",
                "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
                "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
                "\n",
                "---\n",
                "### Verschachtelte Namespaces (modernes C++)\n",
                "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
                "\n",
                "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
                "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
                "---\n"
              ],
              "code": [
                "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
              ]
            } 
          },
          { "title": "using namespace", "content": { 
            "text": [
                "### `using namespace` (nicht immer empfohlen)\n",
                "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
                "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
                "- Besser: Nur gezielt importieren\n",
                "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
                "\n"
              ], 
            "code": [] } },
          { "title": "namespace vs. class", "content": { 
            "text": [ 
                "### === Unterschied: Namespace vs. Class ===\n",
                "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
                "\n",
                "---\n",
                "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
                "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
                "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
                "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
                "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
                "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
                "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
                "\n",
                "---\n",
                "### Beispiel zur Verdeutlichung:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
                "\n",
                "### üëâ Merksatz",
                "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
                "---\n"
            ], 
            "code": [] 
            } 
          }
        ]
      },
      {
        "name": "Klassenmember & Attribute",
        "icon": "üß©",
        "topics": [
          { "title": "static Member", "content": { 
            "text": [    
              "### === `static` in C++ ===\n",
              "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
              "\n",
              "---\n",
              "### üîπ `static` innerhalb einer Funktion:\n",
              "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
              "- Bleibt zwischen Aufrufen **erhalten**\n",
              "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
              "- Variable geh√∂rt **zur Klasse, nicht zum Objekt**\n",
              "- Wird **au√üerhalb der Klasse** definiert\n",
              "- Gleicher Wert f√ºr **alle Instanzen**\n",
              "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Klassenfunktionen:\n",
              "- Funktion geh√∂rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
              "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
              "- Wird √ºber `Klassenname::Funktion()` aufgerufen\n",
              "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
              "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
              "- N√ºtzlich zur Kapselung beim Modularisieren\n",
              "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
              "\n",
              "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschr√§nken**.\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion au√üerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
              ] 
            } 
          },
          { "title": "mutable Member", "content": { 
            "text": [  
              "### === `mutable` in C++ ===\n",
              "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu ver√§ndern**.\n",
              "\n",
              "---\n",
              "### Wann braucht man das?\n",
              "- Normalerweise d√ºrfen `const`-Funktionen **keine Membervariablen ver√§ndern**.\n",
              "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. f√ºr Logging, Caching oder Zugriffsz√§hler.\n",
              "\n",
              "---\n",
              "### Auch ohne `const` n√ºtzlich:\n",
              "- `mutable`-Member sind **immer unabh√§ngig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
              "- Sie k√∂nnen **immer ver√§ndert werden**, auch au√üerhalb von `const`-Kontexten - z.B. als interne Z√§hler oder Zust√§nde.\n",
              "\n",
              "---\n",
              "### Wichtig:\n",
              "- `mutable` funktioniert **nur bei Membervariablen**.\n",
              "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** f√ºr Klassenmitglieder.\n",
              "\n",
              "üëâ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZ√§hler = 0;  // darf auch in const-Funktion ver√§ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZ√§hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZ√§hler() const {\n    return leseZ√§hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZ√§hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "const Memberfunktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
          { "title": "Funktionstemplates", "content": { "text": [], "code": [] } },
          { "title": "Klassentemplates", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
          { "title": "vector", "content": { "text": [], "code": [] } },
          { "title": "array", "content": { "text": [], "code": [] } },
          { "title": "deque", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "map", "content": { "text": [], "code": [] } },
          { "title": "set", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
          { "title": "stack", "content": { "text": [], "code": [] } },
          { "title": "queue", "content": { "text": [], "code": [] } },
          { "title": "priority_queue", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Utility Types",
        "icon": "üß∞",
        "topics": [
          { "title": "pair", "content": { "text": [], "code": [] } },
          { "title": "tuple", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Fehlerbehandlung (try/catch)", "content": { "text": [], "code": [] } },
          { "title": "Pr√§prozessor (#define)", "content": { "text": [], "code": [] } },
          { "title": "CMake Basics", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Windows / Clion",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Console Ausgabe UTF-8 Windows", "content": {
            "text": [
              "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
              "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
              "---\n",
              "## üîπ FONT Einstellen:",
              "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
              "### üîπ Einstellung in CLion\n",
              "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
              "---\n",
              "### CODE in main.lua:"
              ],
            "code": [
              "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
              ]
            } 
          },
          { "title": "Working Directory in CLion", "content": {
            "text": [
              "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
              "Standardm√§√üig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen m√∂chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis (‚ÄûWorking Directory‚Äú) √§ndern.\n",
              "\n",
              "### üîπ Zielstruktur\n",
              "```",
              "Projektordner/\n",
              "‚îú‚îÄ‚îÄ CMakeLists.txt\n",
              "‚îú‚îÄ‚îÄ data/\n",
              "‚îî‚îÄ‚îÄ cmake-build-debug/",
              "```",
              "\n",
              "### üîπ Einstellung in CLion\n",
              "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
              "2. W√§hle **‚ÄûEdit Configurations‚Ä¶‚Äú**.\n",
              "3. W√§hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
              "4. Im Feld **‚ÄûWorking directory‚Äú** tr√§gst du ein: `$ProjectFileDir$`\n",
              "   ‚Üí Das sorgt daf√ºr, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
              "\n",
              "### üîπ Pr√ºfen im Code\n",
              "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
              "\n",
              "```cpp",
              "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
              "```",
              "\n",
              "---\n",
              "### üîπ Hinweis\n",
              "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
              "```cpp",
              "std::filesystem::create_directories(\"data\");",
              "```",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
          { "title": "main.cpp Grundger√ºst", "content": { "text": [], "code": [] } },
          { "title": "Hello World Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Input/Output Vorlage", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
          { "title": "Klasse mit Header & cpp", "content": { "text": [], "code": [] } },
          { "title": "Getter & Setter", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
          { "title": "vector Beispiel", "content": { "text": [], "code": [] } },
          { "title": "map Beispiel", "content": { "text": [], "code": [] } },
          { "title": "tuple / pair Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "CMakeLists.txt Minimal", "content": { "text": [], "code": [] } },
          { "title": "Ordnerstruktur Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Modulares Projekt Setup", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Datenbanken",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SQLite",
        "icon": "üß±",
        "topics": [
          { "title": "SQLite Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "prepare / bind / step / finalize", "content": { "text": [], "code": [] } },
          { "title": "CRUD Operationen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  }

]
