[
  {
    "category": "Grundlagen",
    "subtopics": [
      {
        "title": "Console Ausgabe UTF-8 Windows",
        "content": {
          "text": [
            "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
            "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
            "### FONT Einstellen:",
            "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
            "In Clion: Einstellungen/Editor/General/Font dort Font: Consolar Size: 13.0 Line height: 1.2\n\n\n",
            "### CODE in main.lua:"
          ],
          "code": [
            "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
          ]
        }
      },
      {
        "title": "Begriffe",
        "content": {
          "text": [
          "### === Wichtige Begriffe in C++ erkl√§rt ===\n",
          "Hier findest du eine √úbersicht zentraler Begriffe in der C++-Programmierung, kompakt erkl√§rt.\n",
          "\n",
          "#### Compiler\n",
          "- √úbersetzt C++-Code in Maschinenprogramm, das dein Computer ausf√ºhren kann\n",
          "\n",
          "#### Pr√§prozessor\n",
          "- F√ºhrt Anweisungen wie `#include` und `#define` vor dem Kompilieren aus\n",
          "\n",
          "#### Header-Datei\n",
          "- Datei mit Deklarationen von Funktionen, Klassen oder Konstanten (meist `.h` oder `.hpp`)\n",
          "\n",
          "#### Deklaration vs. Definition\n",
          "- Deklaration: Nur Ank√ºndigung (z.‚ÄØB. `int x;`)\n",
          "- Definition: Speicher wird wirklich zugewiesen (z.‚ÄØB. `int x = 5;`)\n",
          "\n",
          "#### Variable\n",
          "- Speicherstelle mit Namen, die Daten aufnehmen kann (z.‚ÄØB. `int zahl = 10;`)\n",
          "\n",
          "#### Funktion\n",
          "- Codeblock, der mehrfach ausf√ºhrbar ist ‚Äì mit `return`-Wert und Parametern\n",
          "\n",
          "#### R√ºckgabewert\n",
          "- Der Wert, den eine Funktion mit `return` zur√ºckliefert\n",
          "\n",
          "#### Parameter vs. Argument\n",
          "- Parameter: Platzhalter in der Funktionsdefinition (`int add(int a, int b)`)\n",
          "- Argument: Konkreter Wert beim Aufruf (`add(5, 7)` ‚Üí 5 und 7)\n",
          "\n",
          "#### Block / Scope\n",
          "- Bereich mit `{}` ‚Äì darin gelten lokale Variablen\n",
          "\n",
          "#### G√ºltigkeitsbereich (Scope)\n",
          "- Gibt an, wo im Code eine Variable sichtbar/nutzbar ist (z.‚ÄØB. lokal vs. global)\n",
          "\n",
          "#### Initialisierung\n",
          "- Erstmalige Zuweisung eines Werts an eine Variable (`int x = 5;`)\n",
          "\n",
          "#### Operatoren\n",
          "- Rechenzeichen oder Symbole zur Verarbeitung (`+`, `-`, `==`, `&&`, `++`, `<<`)\n",
          "\n",
          "#### Kontrollstrukturen\n",
          "- Anweisungen zur Ablaufsteuerung: `if`, `while`, `for`, `switch`\n",
          "\n",
          "#### Schleife\n",
          "- Wiederholt Anweisungen: `while`, `for`, `do-while`\n",
          "\n",
          "#### Bedingung\n",
          "- Ausdruck, der `true` oder `false` ergibt (z.‚ÄØB. `x > 5`)\n",
          "\n",
          "#### Klasse / Objekt\n",
          "- Klasse: Bauplan f√ºr Objekte (enth√§lt Daten + Funktionen)\n",
          "- Objekt: Konkrete Instanz einer Klasse\n",
          "\n",
          "#### Konstruktor / Destruktor\n",
          "- Konstruktor: Wird beim Erzeugen eines Objekts automatisch aufgerufen\n",
          "- Destruktor: Wird beim L√∂schen automatisch aufgerufen (`~Klassenname()`)\n",
          "\n",
          "#### this-Zeiger\n",
          "- Zeigt innerhalb einer Klasse auf das aktuelle Objekt (`this->variable`)\n",
          "\n",
          "#### new / delete\n",
          "- `new`: Reserviert Speicher auf dem Heap (`int* p = new int;`)\n",
          "- `delete`: Gibt diesen Speicher wieder frei\n",
          "\n",
          "#### Referenz (&)\n",
          "- Alias auf eine bestehende Variable (z.‚ÄØB. `int& r = x;`)\n",
          "\n",
          "#### Zeiger (*)\n",
          "- Variable, die eine Speicheradresse speichert (`int* p = &x;`)\n",
          "\n",
          "#### nullptr\n",
          "- Null-Zeiger, zeigt auf ‚Äûnichts‚Äú (`int* p = nullptr;`)\n",
          "\n",
          "#### √úberladung\n",
          "- Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Signatur\n",
          "\n",
          "#### Vererbung\n",
          "- Eine Klasse √ºbernimmt Eigenschaften einer anderen Klasse\n",
          "\n",
          "#### Polymorphie\n",
          "- F√§higkeit, Objekte √ºber gemeinsame Schnittstellen unterschiedlich zu behandeln\n",
          "\n",
          "#### Template\n",
          "- Erm√∂glicht generischen Code (z.‚ÄØB. Funktionen f√ºr beliebige Typen)\n",
          "\n",
          "#### Lambda\n",
          "- Anonyme Funktion, oft f√ºr kurze Aktionen in `std::for_each`, `sort`, ...\n",
          "\n",
          "#### Iterator\n",
          "- Zeiger-√§hnliches Objekt zum Durchlaufen von Containern (`v.begin()`, `v.end()`)\n"
        ],
          "code": [
            "#include <iostream>\n\n\nint main() {\n  std::cout << \"NICHTS ZU KOPIEREN :C\" << std::endl;\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Typen",
        "content": {
          "text": [
            "### === Datentypen in C++ ===\n",
            "C++ kennt viele eingebaute Typen und erlaubt die Definition eigener Typen.\n",
            "\n",
            "### Standard-Datentypen\n",
            "- `int`: Ganzzahl (z.‚ÄØB. `int x = 5;`)\n",
            "- `float`: Flie√ükommazahl mit einfacher Genauigkeit\n",
            "- `double`: Flie√ükommazahl mit doppelter Genauigkeit\n",
            "- `char`: Einzelnes Zeichen (z.‚ÄØB. `'A'`)\n",
            "- `bool`: Wahrheitswert (`true` / `false`)\n",
            "- `void`: Kein R√ºckgabewert (z.‚ÄØB. bei `void funktion()`)\n",
            "\n",
            "### Erweiterte Grundtypen\n",
            "- `long`, `long long`, `unsigned`, `short`: Varianten von `int`\n",
            "- `wchar_t`, `char16_t`, `char32_t`: Unicode-Zeichentypen\n",
            "- `std::string`: String-Klasse (aus `<string>`)\n",
            "- `std::size_t`: Unsigned Ganzzahl f√ºr Gr√∂√üen (z.‚ÄØB. `v.size()`)\n",
            "- `nullptr_t`: Typ des Literals `nullptr`\n",
            "\n",
            "### Automatische Typableitung\n",
            "- `auto`: Typ wird automatisch aus dem Ausdruck ermittelt\n",
            "- `decltype(...)`: Liefert den Typ eines Ausdrucks\n",
            "- Beispiel:\n",
            "```cpp\nint x = 5;\nauto y = x * 2;         // y ist int\ndecltype(y) z = 10;      // z ist auch int\n```\n",
            "\n",
            "### Eigene Typen\n",
            "- `struct`: F√ºr einfache Strukturen mit mehreren Feldern\n",
            "- `class`: F√ºr Klassen mit Methoden und Zugriffskontrolle (public/private)\n",
            "- `enum`: F√ºr aufz√§hlbare Werte\n",
            "\n",
            "#### `enum` Erkl√§rung:\n",
            "- `enum` erstellt eigene ganzzahlige Werte (standardm√§√üig beginnend bei 0)\n",
            "- Beispiel:\n",
            "```cpp\nenum Farbe { Rot, Gruen, Blau };  // Rot = 0, Gruen = 1, Blau = 2\n```\n",
            "- Man kann Werte auch selbst zuweisen:\n",
            "```cpp\nenum Status { OK = 1, FEHLER = 404, NICHT_GEFUNDEN = 4040 };\n```\n",
            "- Zugriff auf Zahlwert mit `static_cast<int>(enumWert)`:\n",
            "```cpp\nStatus s = FEHLER;\nstd::cout << static_cast<int>(s);  // Ausgabe: 404\n```\n",
            "- `enum class` (modernes C++): Streng typisiert, Zugriff nur mit `Status::FEHLER`\n",
            "\n",
            "- `typedef` (alt) und `using` (modern): Eigene Namen f√ºr bestehende Typen\n",
            "- Beispiel:\n",
            "```cpp\ntypedef unsigned int uint;\nusing Score = double;\n```",
            "\n",
            "### Typumwandlung (Casting)\n",
            "- `static_cast<T>(wert)`: Sicherer Cast zwischen kompatiblen Typen\n",
            "- `reinterpret_cast<T>`: F√ºr Low-Level-Zugriff (meist vermeiden!)\n",
            "- `const_cast<T>`: Entfernt `const`\n",
            "- `dynamic_cast<T>`: F√ºr Vererbung und Polymorphie (mit RTTI)\n",
            "\n",
            "üëâ F√ºr sichere Typpr√ºfung: `typeid(variable).name()` (aus `<typeinfo>`) oder `std::is_same<T, U>()` (aus `<type_traits>`)\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <typeinfo>\n\n// Eigene Struktur\nstruct Person {\n    std::string name;\n    int alter;\n};\n\n// Typalias\nusing Zahl = unsigned int;\n\nenum Farbe { Rot, Gruen, Blau };           // Rot = 0, Gruen = 1, Blau = 2\nenum Status { OK = 1, FEHLER = 404 };      // eigene Werte\n\nint main() {\n    int a = 10;\n    auto b = 3.14;                          // automatisch double\n    decltype(a) c = 5;                      // ebenfalls int\n\n    Person p = {\"Kilian\", 21};\n    Zahl punkte = 150;\n\n    Farbe f = Gruen;\n    Status s = FEHLER;\n\n    std::cout << \"Name: \" << p.name << \", Alter: \" << p.alter << std::endl;         // Ausgabe: Name: Kilian, Alter: 21\n    std::cout << \"Punkte: \" << punkte << std::endl;                                  // Ausgabe: Punkte: 150\n    std::cout << \"Typ von b: \" << typeid(b).name() << std::endl;                     // Ausgabe: Typ von b: double (compilerabh√§ngig)\n    std::cout << \"Fehlercode: \" << static_cast<int>(s) << std::endl;                // Ausgabe: Fehlercode: 404\n\n    return 0;\n}"
          ]
        }
      },
      {
        "title": "Header",
        "content": {
          "text": [
            "### === Wichtige Header-Dateien in C++ ===\n",
            "Header-Dateien enthalten Deklarationen von Funktionen, Klassen und Datentypen. Standard-Header kommen aus der C++-Standardbibliothek, eigene erstellt man selbst.\n",
            "\n",
            "### Arten von `#include`\n",
            "- `#include <...>`: F√ºr Standardbibliothek (z.‚ÄØB. `<iostream>`, `<vector>`, ...)\n",
            "- `#include \"...\"`: F√ºr eigene Dateien (z.‚ÄØB. `\"meinmodul.hpp\"`)\n",
            "\n",
            "### Eigene Header-Dateien\n",
            "- Eigene Header enden meist auf `.h` oder `.hpp`\n",
            "- Sie enthalten **Deklarationen**, keine Implementierungen\n",
            "- Die zugeh√∂rige `.cpp`-Datei enth√§lt dann die **Definitionen**\n",
            "\n",
            "#### Beispiel ‚Äì Header-Datei: `meinmodul.h`\n",
            "```cpp\n#ifndef MEINMODUL_H\n#define MEINMODUL_H\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n```\n",
            "\n",
            "#### Beispiel ‚Äì Implementierung: `meinmodul.cpp`\n",
            "```cpp\n#include <iostream>\n#include \"meinmodul.h\"\n\nvoid begruessung() {\n    std::cout << \"Hallo!\";\n}\n```\n",
            "\n",
            "#### In `main.cpp` verwenden:\n",
            "```cpp\n#include \"meinmodul.h\"\n\nint main() {\n    begruessung();\n    return 0;\n}\n```\n",
            "\n",
            "üëâ Vorteil: strukturierter Code, Wiederverwendbarkeit und Trennung von Schnittstelle & Implementierung\n",
            "\n",
            "### Include Guards (Schutz vor Mehrfacheinbindung)\n",
            "- Jeder eigene Header sollte mit einem **Include Guard** versehen werden:\n",
            "```cpp\n#ifndef MEIN_HEADER_H\n#define MEIN_HEADER_H\n\n// Inhalte des Headers\n\n#endif\n```\n",
            "- Verhindert doppelte Definitionen beim mehrfachen Einbinden\n",
            "\n",
            "### √úbersicht wichtiger Standard-Header:\n",
            "\n",
            "#### Ein- und Ausgabe\n",
            "- `<iostream>`: `std::cin`, `std::cout`, `std::cerr`\n",
            "- `<iomanip>`: `std::setw`, `std::setprecision`, `std::fixed`, `std::put_time`\n",
            "- `<fstream>`: Datei-I/O mit `ifstream`, `ofstream`, `fstream`\n",
            "\n",
            "#### Strings und Streams\n",
            "- `<string>`: `std::string`\n",
            "- `<sstream>`: `std::stringstream` f√ºr String-Parsing und Umwandlungen\n",
            "\n",
            "#### Mathematisches\n",
            "- `<cmath>`: `sqrt`, `pow`, `abs`, `round`, `sin`, `log`\n",
            "- `<cstdlib>`: `rand`, `srand`, `atoi`, `atof`\n",
            "- `<limits>`: `numeric_limits<T>::max()` / `min()`\n",
            "\n",
            "#### Zeit und Threads\n",
            "- `<ctime>`: `std::time`, `std::localtime`\n",
            "- `<chrono>`: Zeitmessung (z.‚ÄØB. `high_resolution_clock`)\n",
            "- `<thread>`: `std::this_thread::sleep_for()`\n",
            "\n",
            "#### Container & Algorithmen\n",
            "- `<vector>`, `<array>`, `<set>`, `<map>`\n",
            "- `<stack>`, `<queue>`\n",
            "- `<algorithm>`: `sort`, `find`, `remove`, `for_each`, ...\n",
            "- `<iterator>`: Iteratorfunktionen wie `begin()`/`end()`\n",
            "\n",
            "#### Weitere n√ºtzliche Header\n",
            "- `<exception>`: `std::exception`, `std::runtime_error`\n",
            "- `<functional>`: Funktionsobjekte, Lambdas, `std::function`\n",
            "- `<typeinfo>`: Laufzeittypinfo (`typeid`)\n",
            "- `<cassert>`: `assert()` f√ºr Debug-Checks\n",
            "- `<bitset>`: bin√§re Felder\n",
            "- `<utility>`: `std::pair`, `std::swap`, `std::move`\n",
            "- `<memory>`: Smart Pointers wie `unique_ptr`, `shared_ptr`\n"
          ],
          "code": [
            "#ifndef MEINMODUL_H \n#define MEINMODUL_H \n\nvoid begruessung(); // Funktionsdeklaration \n\n#endif",
            "void begruessung() {\n   std::cout << \"Hallo!\"; \n}\n",
            "#include \"meinmodul.h\"\n"
          ]
        }
      },
      {
  "title": "Initialisierung  : vs. {}",
  "content": {
    "text": [
      "### === Initialisierung mit `:` vs. `{}` in C++ ===\n",
      "C++ bietet verschiedene M√∂glichkeiten, wie Variablen und Klassenmitglieder initialisiert werden k√∂nnen. Besonders wichtig sind:\n",
      "- `:` ‚Üí Initialisierungsliste bei Konstruktoren\n",
      "- `{}` ‚Üí Einheitliche Initialisierung (Brace-Initialization / Uniform Initialization)\n",
      "\n",
      "### Initialisierungsliste mit `:`\n",
      "- Wird in Konstruktoren verwendet, um Member **direkt zu initialisieren**, bevor der Body ausgef√ºhrt wird\n",
      "- **Effizienter** als Zuweisung im Konstruktorblock (insbesondere bei `const`- oder Referenz-Membern)\n",
      "\n",
      "```cpp\nclass Auto {\nprivate:\n    int ps;\npublic:\n    Auto(int p) : ps(p) {}   // Initialisierung mit Doppelpunkten\n};\n```\n",
      "\n",
      "### Warum `:` statt `=` im Body?\n",
      "- `:` initialisiert direkt beim Erzeugen ‚Üí **vermeidet unn√∂tige Standardinitialisierung + sp√§tere Zuweisung**\n",
      "- Pflicht bei `const` oder Referenzen:\n",
      "```cpp\nclass Test {\n    const int wert;\npublic:\n    Test(int w) : wert(w) {}  // Muss so gemacht werden\n};\n```\n",
      "\n",
      "### Einheitliche Initialisierung mit `{}`\n",
      "- Eingef√ºhrt mit C++11\n",
      "- Kann **Konstruktoren**, **Arrays**, **STL-Container** und **structs** initialisieren\n",
      "- **Vermeidet Verwechslungen** mit Funktionsdeklarationen (Most Vexing Parse)\n",
      "\n",
      "```cpp\nint a{5};                  // Direktinitialisierung\nstd::vector<int> zahlen{1, 2, 3};\nAuto b{150};                // ruft Konstruktor mit `int` auf\n```\n",
      "\n",
      "### Kombination\n",
      "- Beides l√§sst sich kombinieren:\n",
      "```cpp\nclass Zahl {\n    int wert;\npublic:\n    Zahl(int w) : wert{w} {}  // Doppelt sicher: Initialisierungsliste + {}\n};\n```\n",
      "\n",
      "üëâ Faustregel:\n",
      "- **Konstruktoren mit `:` initialisieren Member**\n",
      "- **`{}` ist sicherer, universeller Stil ab C++11**\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Beispiel {\nprivate:\n    const int wert;\n    std::vector<int> zahlen;\n\npublic:\n    // Initialisierung mit : und {}\n    Beispiel(int w) : wert(w), zahlen{1, 2, 3} {}\n\n    void anzeigen() {\n        std::cout << \"Wert: \" << wert << \" | Erster Wert: \" << zahlen[0] << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b{42};      // Konstruktor-Aufruf mit {} Initialisierung\n    b.anzeigen();         // Ausgabe: Wert: 42 | Erster Wert: 1\n\n    int x{10};            // Brace-Initialisierung einer einfachen Variable\n    std::cout << \"x: \" << x << std::endl;\n\n    return 0;\n}"
    ]
  }
}

    ]
  },
  {
    "category": "Ein-/Ausgabe",
    "subtopics": [
      {
        "title": "Eingabe",
        "content": {
          "text": [
            "### === Benutzereingabe in C++ ===\n",
            "F√ºr die Eingabe in C++ wird meist `std::cin` verwendet. Dabei wird direkt aus der Konsole gelesen.\n",
            "\n",
            "### `std::cin`\n",
            "- Liest eine Eingabe **bis zum ersten Leerzeichen**\n",
            "- Nur f√ºr einzelne W√∂rter oder Zahlen geeignet\n",
            "\n",
            "### `std::getline`\n",
            "- Liest eine ganze **Zeile** (inklusive Leerzeichen)\n",
            "- Ideal f√ºr Namen, Adressen, ganze S√§tze usw.\n",
            "- Wichtig: vorher `std::cin.ignore()` nutzen, wenn zuvor `cin` verwendet wurde\n",
            "\n",
            "### `std::cin.ignore()`\n",
            "- Leert den Eingabepuffer, z.‚ÄØB. nach `cin` vor `getline`\n",
            "- Typisch: `std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');`\n",
            "\n",
            "### `std::stringstream`\n",
            "- Konvertiert zwischen Strings und Zahlen\n",
            "- N√ºtzlich f√ºr Eingaben mit vielen Werten in einer Zeile\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <limits> // f√ºr std::numeric_limits\n\nint main() {\n  std::string name;\n  int alter;\n\n  // Eingabe eines einzelnen Werts\n  std::cout << \"Wie alt bist du? \";\n  std::cin >> alter;\n\n  // Eingabepuffer leeren (wichtig vor getline)\n  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n  // Eingabe einer ganzen Zeile\n  std::cout << \"Wie hei√üt du? \";\n  std::getline(std::cin, name);\n\n  std::cout << \"Hallo \" << name << \", du bist \" << alter << \" Jahre alt.\" << std::endl;\n\n  // Stringstream Beispiel\n  std::string eingabe = \"23 42 99\";\n  std::stringstream ss(eingabe);\n  int zahl1, zahl2, zahl3;\n  ss >> zahl1 >> zahl2 >> zahl3;\n  std::cout << \"Zahlen aus dem String: \" << zahl1 << \", \" << zahl2 << \", \" << zahl3 << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Ausgabe",
        "content": {
          "text": [
            "### === Ausgabe mit `std::cout` in C++ ===\n",
            "`std::cout` ist der Standardausgabestrom in C++ und wird f√ºr Konsolenausgaben verwendet.\n",
            "\n",
            "### Grundlegende Ausgabe\n",
            "`std::cout << \"Text\" << variable;`\n",
            "- Die `<<`-Operatoren h√§ngen Inhalte aneinander\n",
            "- Mit `\\n` oder `std::endl` wird eine Zeile beendet\n",
            "\n",
            "### Formatierung mit `<iomanip>`\n",
            "- `std::setw(n)`: Feldbreite setzen\n",
            "- `std::setprecision(n)`: Genauigkeit f√ºr Nachkommastellen\n",
            "- `std::fixed`: Kommazahlen mit fester Nachkommastellenzahl\n",
            "- `std::left` / `std::right`: Ausrichtung\n",
            "\n",
            "### Fehlerausgabe mit `std::cerr` und `std::clog`\n",
            "- `std::cerr`: Wird f√ºr **Fehlermeldungen** verwendet (ungespeichert)\n",
            "- `std::clog`: Wird f√ºr **Logmeldungen** verwendet (gepuffert)\n",
            "- Beide gehen wie `std::cout` in die Konsole, k√∂nnen aber **umgeleitet** werden\n",
            "\n",
            "### Zahlenformat: `dec`, `hex`, `oct`\n",
            "- `std::dec`: Ausgabe als Dezimalzahl (Standard)\n",
            "- `std::hex`: Ausgabe als Hexadezimalzahl\n",
            "- `std::oct`: Ausgabe als Oktalzahl\n",
            "- Wichtig bei Bin√§rformaten, Flags oder Speicheradressen\n"
          ],
          "code": [
            "#include <iostream>\n#include <iomanip>\n\nint main() {\n  std::string name = \"Kilian\";\n  int alter = 21;\n  double kontostand = 1234.56789;\n\n  // Einfache Begr√º√üung\n  std::cout << \"Hallo, \" << name << \"!\\n\"; // Ausgabe: Hallo, Kilian!\n\n  // Formatierte Tabelle\n  std::cout << std::left << std::setw(10) << \"Name\"\n            << std::right << std::setw(10) << \"Alter\"\n            << std::setw(15) << \"Kontostand\" << std::endl; // Ausgabe: Name           Alter     Kontostand\n\n  std::cout << std::left << std::setw(10) << name\n            << std::right << std::setw(10) << alter\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl; // Ausgabe: Kilian             21         1234.57\n\n  // Zahlenformat\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;       // Ausgabe: Dezimal: 42\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;  // Ausgabe: Hexadezimal: 2a\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;         // Ausgabe: Oktal: 52\n\n  // Fehlermeldung und Logausgabe\n  std::cerr << \"Dies ist eine Fehlermeldung!\" << std::endl; // Ausgabe (in stderr): Dies ist eine Fehlermeldung!\n  std::clog << \"Dies ist eine Logmeldung.\" << std::endl;    // Ausgabe (in clog): Dies ist eine Logmeldung.\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Datei",
        "content": {
          "text": [
            "### === Datei-Ein-/Ausgabe in C++ ===\n",
            "F√ºr das Lesen und Schreiben von Dateien verwendet man `<fstream>`.\n",
            "\n",
            "### Typen aus `<fstream>`\n",
            "- `std::ofstream`: Schreiben (`output file stream`)\n",
            "- `std::ifstream`: Lesen (`input file stream`)\n",
            "- `std::fstream`: Beides\n",
            "\n",
            "### Datei √∂ffnen\n",
            "- `std::ofstream f(\"name.txt\");` ‚Äì zum Schreiben (√ºberschreibt!)\n",
            "- `std::ofstream f(\"name.txt\", std::ios::app);` ‚Äì **zum Anh√§ngen** (append)\n",
            "- `std::ifstream f(\"name.txt\");` ‚Äì zum Lesen\n",
            "\n",
            "### Datei pr√ºfen\n",
            "- Mit `.is_open()` oder √ºber `if (stream)`\n",
            "\n",
            "### Zeilenweise lesen\n",
            "- Mit `std::getline(stream, zeile)` liest man eine Datei Zeile f√ºr Zeile\n",
            "- Praktisch zum Bearbeiten einzelner Inhalte\n",
            "\n",
            "### Dateiinhalt ver√§ndern (Schritt 4)\n",
            "- Gelesene Zeilen z.‚ÄØB. in `std::vector<std::string>` speichern\n",
            "- Dann gezielt Zeilen √§ndern, z.‚ÄØB. `inhalt[1] = \"[GE√ÑNDERT] \" + inhalt[1];`\n",
            "- Index 1 entspricht der **zweiten Zeile** (0-basiert)\n",
            "- Vorher pr√ºfen, ob die Zeile existiert: `inhalt.size() >= 2`\n",
            "\n",
            "### Datei neu schreiben (Schritt 5)\n",
            "- Danach wird die Datei **neu ge√∂ffnet im Schreibmodus** (√ºberschreibt alten Inhalt)\n",
            "- Mit einer Schleife schreibt man alle bearbeiteten Zeilen zur√ºck:\n",
            "```cpp\n for (const std::string& z : inhalt) {\n   datei << z << \"\\n\";\n }\n```\n",
            "- Das ist der g√§ngige Weg, um gezielt Inhalte zu ver√§ndern\n"
          ],
          "code": [
            "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nint main() {\n  // 1. Neue Datei anlegen und Zeilen reinschreiben\n  std::ofstream out(\"daten.txt\");\n  if (out.is_open()) {\n    out << \"Zeile 1\\n\";                  // erste Zeile\n    out << \"Zeile 2\\n\";                  // zweite Zeile\n    out << \"Zeile 3\\n\";                  // dritte Zeile\n    out.close();\n    std::cout << \"Datei erstellt.\" << std::endl; // Ausgabe: Datei erstellt.\n  } else {\n    std::cerr << \"Fehler beim Schreiben!\" << std::endl;\n  }\n\n  // 2. Zeile anh√§ngen (append-Modus)\n  std::ofstream anhang(\"daten.txt\", std::ios::app);\n  if (anhang) {\n    anhang << \"Neue Zeile am Ende\\n\";      // wird angeh√§ngt\n    anhang.close();\n    std::cout << \"Zeile angeh√§ngt.\" << std::endl; // Ausgabe: Zeile angeh√§ngt.\n  }\n\n  // 3. Datei zeilenweise einlesen\n  std::ifstream lesen(\"daten.txt\");\n  std::string zeile;\n  std::vector<std::string> inhalt;           // Zwischenspeicher f√ºr Zeilen\n\n  if (lesen) {\n    std::cout << \"Dateiinhalt:\" << std::endl; // Ausgabe: Dateiinhalt:\n    while (std::getline(lesen, zeile)) {\n      std::cout << zeile << std::endl;        // Ausgabe: Zeile n\n      inhalt.push_back(zeile);                // Zeile speichern\n    }\n    lesen.close();\n  } else {\n    std::cerr << \"Fehler beim Lesen der Datei!\" << std::endl;\n  }\n\n  // 4. Zeile 2 bearbeiten (Index 1 pr√ºfen)\n  if (inhalt.size() >= 2) {\n    inhalt[1] = \"[GE√ÑNDERT] \" + inhalt[1];    // Zeile 2 ver√§ndern\n  } else {\n    std::cerr << \"Nicht genug Zeilen zum Bearbeiten!\" << std::endl;\n  }\n\n  // 5. Datei neu schreiben mit bearbeiteten Inhalten\n  std::ofstream neu(\"daten.txt\");\n  if (neu) {\n    for (const std::string& z : inhalt) {\n      neu << z << \"\\n\";                       // Zeilen zur√ºckschreiben\n    }\n    neu.close();\n    std::cout << \"Datei aktualisiert.\" << std::endl; // Ausgabe: Datei aktualisiert.\n  } else {\n    std::cerr << \"Fehler beim √úberschreiben der Datei!\" << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Date/Time",
        "content": {
          "text": [
            "### === Datum und Uhrzeit in C++ ===\n",
            "C++ bietet mehrere M√∂glichkeiten, um mit Datum und Zeit zu arbeiten.\n",
            "\n",
            "### `std::time` & `std::localtime`\n",
            "- `std::time(nullptr)` liefert aktuelle Zeit (Sekunden seit 01.01.1970)\n",
            "- `std::localtime()` wandelt sie in eine `tm`-Struktur f√ºr lesbares Datum um\n",
            "\n",
            "### `std::put_time()` (aus `<iomanip>`) f√ºr Formatierung\n",
            "- `std::put_time()` funktioniert wie `strftime`\n",
            "- Beispiel-Formate: `%d.%m.%Y`, `%H:%M:%S`, `%Y-%m-%d_%H-%M`\n",
            "- Mit `std::ostringstream` kann man Datum/Zeit auch als `std::string` speichern\n",
            "\n",
            "### Zeitmessung mit `<chrono>`\n",
            "- Nutze `std::chrono::high_resolution_clock` f√ºr pr√§zise Messungen\n",
            "- `std::this_thread::sleep_for(...)` pausiert das Programm gezielt\n"
          ],
          "code": [
            "#include <iostream>\n#include <ctime>        // time, localtime\n#include <iomanip>      // put_time\n#include <sstream>      // ostringstream f√ºr string-Formate\n#include <chrono>       // chrono f√ºr Zeitmessung\n#include <thread>       // sleep_for\n\nint main() {\n  // 1. Aktuelle Uhrzeit formatieren und anzeigen\n  std::time_t jetzt = std::time(nullptr);               // Sekunden seit 1970\n  std::tm* lokal = std::localtime(&jetzt);              // lokale Zeitstruktur\n\n  std::cout << \"Aktuelle Uhrzeit: \"\n            << std::put_time(lokal, \"%d.%m.%Y %H:%M:%S\") << std::endl; // Ausgabe: 28.05.2025 19:45:12\n\n  // 2. Zeit als String speichern\n  std::ostringstream oss;\n  oss << std::put_time(lokal, \"%Y-%m-%d_%H-%M-%S\");\n  std::string zeitString = oss.str();\n  std::cout << \"Als String gespeichert: \" << zeitString << std::endl; // Ausgabe: 2025-05-28_19-45-12\n\n  // 3. Kurze Pause (Thread schlafen lassen)\n  std::cout << \"Warte 1 Sekunde...\" << std::endl;\n  std::this_thread::sleep_for(std::chrono::seconds(1)); // Pause f√ºr 1 Sekunde\n  std::cout << \"Weiter!\" << std::endl; // Ausgabe: Weiter!\n\n  // 4. Zeitmessung mit chrono\n  auto start = std::chrono::high_resolution_clock::now();\n\n  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 0,5 Sek warten\n\n  auto ende = std::chrono::high_resolution_clock::now();\n  auto dauer = std::chrono::duration_cast<std::chrono::milliseconds>(ende - start);\n\n  std::cout << \"Verstrichene Zeit: \" << dauer.count() << \" ms\" << std::endl; // Ausgabe: Verstrichene Zeit: 500 ms\n\n  return 0;\n}"
          ]
        }
      }
    ]
  },
  {
    "category": "Container",
    "subtopics": [
      {
        "title": "Strings",
        "content": {
          "text": [
            "### === String-Funktionen in C++ ===\n",
            "",
            "```cpp",
            "std::string example = \"Hello, World\";\n",
            "std::string number = \"42\";",
            "```\n",
            "",
            "-> `.size()` ‚Äì Gibt die L√§nge des Strings zur√ºck\n",
            "```cpp",
            "example.size(); // 12",
            "```\n",
            "",
            "-> `.substr(start, length)` ‚Äì Teilstring ab Startindex\n",
            "```cpp",
            "example.substr(3, 5); // \"lo, W\"",
            "```\n",
            "",
            "-> `.replace(start, count, string)` ‚Äì Ersetzt einen Teil des Strings\n",
            "```cpp",
            "example.replace(7, 5, \"Universe\"); // Hello, Universe",
            "```\n",
            "",
            "-> `.empty()` ‚Äì Pr√ºft ob der String leer ist\n",
            "-> `example[1]` ‚Äì Zugriff auf Zeichen an Position\n",
            "-> `.find(\"text\")` ‚Äì Sucht ein Teilwort im String\n",
            "",
            "### === String <-> Zahl ===\n",
            "",
            "```cpp",
            "int i = std::stoi(\"42\");     // ‚Üí 42\n",
            "double d = std::stod(\"3.14\"); // ‚Üí 3.14\n",
            "std::string s = std::to_string(100); // ‚Üí \"100\"",
            "```\n",
            "",
            "### === String-Konkatenation & Vergleich ===\n",
            "",
            "```cpp",
            "std::string s1 = \"Hello\";\n",
            "std::string s2 = \"World\";\n",
            "std::string s3 = s1 + \" \" + s2; // \"Hello World\"\n",
            "s1.compare(s2); // < 0 ‚Üí s1 < s2",
            "```\n",
            "",
            "### === Gro√ü- und Kleinschreibung ===\n",
            "",
            "-> `#include <cctype>`, `#include <algorithm>` f√ºr toupper/tolower\n",
            "",
            "```cpp",
            "std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n",
            "std::transform(str.begin(), str.end(), str.begin(), ::tolower);",
            "```\n",
            "",
            "-> Einzelzeichen:\n",
            "```cpp",
            "std::toupper('a'); // ‚Üí 'A'\n",
            "std::islower('B'); // ‚Üí false\n",
            "std::isalpha('x'); // ‚Üí true\n",
            "std::isdigit('9'); // ‚Üí true",
            "```\n",
            "",
            "### === istringstream: String analysieren ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::string zeile = \"3 Apfel 1.99\";\n",
            "std::istringstream iss(zeile);\n",
            "int menge; std::string produkt; double preis;\n",
            "iss >> menge >> produkt >> preis;\n",
            "// menge = 3, produkt = Apfel, preis = 1.99",
            "```\n",
            "",
            "### === ostringstream: String zusammensetzen ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::ostringstream oss;\n",
            "oss << menge << \" \" << produkt << \" kosten \" << (menge * preis);\n",
            "std::string ausgabe = oss.str();",
            "```"
          ],
          "code": [
            "#include <iostream>\n#include <string>",
            
            "int main() {\n  std::string text = \"C++ macht Spa√ü!\";",
            
            "  // L√§nge\n  std::cout << \"L√§nge: \" << text.length() << std::endl; // Ausgabe: 15",
            
            "  // Teilstring\n  std::string teil = text.substr(4, 5);\n  std::cout << \"Teilstring: \" << teil << std::endl; // Ausgabe: macht",
            
            "  // finden\n  size_t pos = text.find(\"Spa√ü\");\n  if (pos != std::string::npos)\n    std::cout << \"\\\"Spa√ü\\\" gefunden an Position: \" << pos << std::endl; // Ausgabe: 11",
            
            "  // ersetzen\n  text.replace(4, 5, \"ist cool\");\n  std::cout << \"Nach replace: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü!",
            
            "  // anh√§ngen\n  text += \" :)\";\n  std::cout << \"Nach Anf√ºgen: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü! :)",
            
            "  // einf√ºgen\n  text.insert(0, \"[INFO] \");\n  std::cout << \"Mit Prefix: \" << text << std::endl; // Ausgabe: [INFO] C++ ist cool Spa√ü! :)",
            
            "  // l√∂schen\n  text.erase(0, 7);\n  std::cout << \"Ohne Prefix: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü! :)",
            
            "  // vergleichen\n  std::string a = \"Apfel\", b = \"Banane\";\n  if (a.compare(b) < 0)\n    std::cout << a << \" kommt vor \" << b << std::endl; // Ausgabe: Apfel kommt vor Banane",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Vektor",
        "content": {
          "text": [
            "### === Vector-Funktionen in C++ ===\n",
            "-> `std::vector<int> zahlen = {5, 3, 8, 1};` // Initialisierung eines Vektors\n",
            "-> `zahlen.push_back(element);` // F√ºgt ein Element hinten an (kopiert oder verschiebt es)\n",
            "-> `zahlen.emplace_back(argumente);` // Baut das Element direkt im Vektor (konstruiert es vor Ort)\n",
            "### Unterschied `push_back` und `emplace_back`",
            "`push_back` erwartet ein fertiges Objekt,\n",
            "`emplace_back` √ºbernimmt die Konstruktion direkt im Speicher des Vektors.\n",
            "Besonders n√ºtzlich bei komplexen Typen wie `std::pair` oder eigenen Klassen.\n",
            "```cpp",
            "Beispiel: v.emplace_back(\"Text\", 42); statt: v.push_back(std::make_pair(\"Text\", 42));",
            "```\n",
            "-> `zahlen.size();` // Gibt die Anzahl der Elemente im Vektor zur√ºck\n",
            "-> `zahlen[2];` // Greift direkt auf das Element mit Index 2 zu (kein Bounds-Check)\n",
            "-> `zahlen.at(1);` // Greift sicher auf Index 1 zu (mit Bounds-Check)\n",
            "-> `zahlen.front();` // Gibt das erste Element im Vektor zur√ºck\n",
            "-> `zahlen.back();` // Gibt das letzte Element im Vektor zur√ºck\n",
            "-> `zahlen.empty();` // Pr√ºft, ob der Vektor leer ist (true/false)\n",
            "-> `std::find(zahlen.begin(), zahlen.end(), 3);` // Sucht nach Wert 3 im Vektor\n",
            "-> `zahlen.insert(zahlen.begin() + 1, 42);` // F√ºgt 42 an Position 1 ein\n",
            "-> `std::sort(zahlen.begin(), zahlen.end());` // Sortiert den Vektor aufsteigend\n",
            "-> `std::reverse(zahlen.begin(), zahlen.end());` // Dreht die Reihenfolge um\n",
            "\n",
            "-> `zahlen.erase(zahlen.begin());` // L√∂scht das erste Element\n",
            "-> `zahlen.erase(zahlen.begin(), zahlen.begin() + 2);` // L√∂scht die ersten zwei Elemente\n",
            "-> `zahlen.erase(zahlen.begin() + 2);` // L√∂scht das Element an Index 2\n",
            "-> `zahlen.clear();` // L√∂scht alle Elemente aus dem Vektor\n",
            "-> `zahlen.pop_back();` // Entfernt das letzte Element im Vektor\n",
            "\n",
            "-> `zahlen.assign(5, 7);` // Setzt den Vektor auf 5 Elemente mit dem Wert 7\n",
            "-> `std::remove(zahlen.begin(), zahlen.end(), 5);` // Entfernt alle Vorkommen von 5 (nutzt erase danach!)\n",
            "-> `std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x; });` // Wendet eine Funktion auf alle Elemente an\n",
            "\n",
            "### === 2D Vektor in C++ ===\n",
            "-> `std::vector<std::vector<int>> v3 = {{1}, {2, 3}, {4, 5, 6}};` // 2D vector\n",
            "Erstellt 2D-Vektor (Vektoren von Vektoren)\n",
            "`v3` hat drei Zeilen: `v3[0] = {1}; v3[1] = {2, 3}; v3[2] = {4, 5, 6}`\n",
            "`v3[2][2]` gibt `6` zur√ºck (Zeile 3, Spalte 3)\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr sort()",
            
            "int main() {\n  // Vektor mit Werten initialisieren\n  std::vector<int> zahlen = {4, 2, 7};",
            
            "  // Element hinzuf√ºgen\n  zahlen.push_back(5); // Vektor = {4, 2, 7, 5}",
            
            "  // Gr√∂√üe des Vektors\n  std::cout << \"Anzahl Elemente: \" << zahlen.size() << std::endl; // Ausgabe: 4",
            
            "  // Zugriff auf Elemente\n  std::cout << \"Erstes Element: \" << zahlen[0] << std::endl; // Ausgabe: 4\n  std::cout << \"Zweites Element: \" << zahlen.at(1) << std::endl; // Ausgabe: 2\n  std::cout << \"Letztes Element: \" << zahlen.back() << std::endl; // Ausgabe: 5",
            
            "  // Ausgabe mit Schleife\n  std::cout << \"Alle Elemente: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 4 2 7 5\n  std::cout << std::endl;",
            
            "  // Element entfernen (letztes)\n  zahlen.pop_back(); // entfernt 5\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end()); // Vektor = {2, 4, 7}",
            
            "  // Ausgabe nach Sortierung\n  std::cout << \"Sortiert: \";\n  for (size_t i = 0; i < zahlen.size(); ++i) {\n    std::cout << zahlen[i] << \" \";\n  } // Ausgabe: 2 4 7\n  std::cout << std::endl;",
            
            "  // leeren Vektor pr√ºfen\n  if (!zahlen.empty()) {\n    std::cout << \"Vektor ist NICHT leer\" << std::endl;\n  }",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Sets",
        "content": {
          "text": [
            "### === Sets in C++ ===\n",
            "-> `#include <set>`       // F√ºr std::set\n",
            "\n",
            "**--- Grundlagen ---**\n",
            "-> `std::set<char> s1 = {'H', 'E', 'L', 'L', 'O'};`\n",
            "   Ein Set speichert nur eindeutige Elemente ‚Äì doppelte 'L' werden entfernt\n",
            "   Ergebnis: `{ 'E', 'H', 'L', 'O' }` (automatisch sortiert nach ASCII)\n",
            "-> `s1.size()` Gibt die Anzahl der eindeutigen Elemente zur√ºck ‚Üí 4\n",
            "-> `s1.contains('E')` Pr√ºft, ob 'E' im Set enthalten ist ‚Üí true (1)\n",
            "-> `s1.contains('X')` Pr√ºft, ob 'X' im Set enthalten ist ‚Üí false (0)\n",
            "\n",
            "**--- Elemente hinzuf√ºgen/entfernen ---**\n",
            "-> `s1.insert('!')` F√ºgt ein neues Element hinzu ‚Üí `{ '!', 'E', 'H', 'L', 'O' }`\n",
            "-> `s1.erase('O')` Entfernt das Element 'O' aus dem Set\n",
            "-> `s1.clear()` Entfernt alle Elemente aus dem Set\n",
            "-> `s1.empty()` Pr√ºft, ob das Set leer ist ‚Üí true (1)\n",
            "\n",
            "**--- Vergleich von Sets ---**\n",
            "-> `std::set<int> a = {1, 2};`\n",
            "-> `std::set<int> b = {2, 1};`\n",
            "-> `a == b` ‚Üí true (1), Reihenfolge ist egal, nur Inhalte z√§hlen\n",
            "\n",
            "-> `std::set<int> c = {1, 2, 2};`\n",
            "-> `std::set<int> d = {1, 1, 2};`\n",
            "-> `c == d` ‚Üí true (1), da doppelte Eintr√§ge ignoriert werden\n",
            "\n",
            "_Hinweis: `std::set` speichert die Elemente automatisch sortiert,_\n",
            "_Erlaubt keine Duplikate und bietet schnellen Zugriff._\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>",
            
            "int main() {\n  // Set mit Ganzzahlen\n  std::set<int> zahlen;",
            
            "  // Elemente einf√ºgen (werden automatisch sortiert)\n  zahlen.insert(5);\n  zahlen.insert(2);\n  zahlen.insert(8);\n  zahlen.insert(2); // Duplikat ‚Äì wird ignoriert",
            
            "  // Ausgabe der Elemente\n  std::cout << \"Inhalt des Sets: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 2 5 8\n  std::cout << std::endl;",
            
            "  // Pr√ºfen, ob ein Element enthalten ist\n  if (zahlen.count(5) > 0) {\n    std::cout << \"5 ist enthalten\" << std::endl;\n  }",
            
            "  // Alternative mit find()\n  if (zahlen.find(3) == zahlen.end()) {\n    std::cout << \"3 ist NICHT enthalten\" << std::endl;\n  }",
            
            "  // Anzahl der Elemente\n  std::cout << \"Set-Gr√∂√üe: \" << zahlen.size() << std::endl; // Ausgabe: 3",
            
            "  // Element l√∂schen\n  zahlen.erase(2);\n  std::cout << \"Nach L√∂schen von 2: \";\n  for (int x : zahlen) std::cout << x << \" \"; // Ausgabe: 5 8\n  std::cout << std::endl;",
            
            "  // Set leeren\n  zahlen.clear();\n  std::cout << \"Nach clear(): Gr√∂√üe = \" << zahlen.size() << std::endl; // Ausgabe: 0",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Maps",
        "content": {
          "text": [
            "### === Maps in C++ ===\n",
            "-> `#include <map>`       // F√ºr std::map\n",
            "-> `#include <string>`    // F√ºr std::string als Schl√ºssel/Wert\n",
            "\n",
            "**--- Grundlagen ---**\n",
            "-> `std::map<std::string, int> m1;` Leere Map von string ‚Üí int\n",
            "-> `m1[\"C++\"] = 100;` F√ºgt Schl√ºssel \"C++\" mit Wert 100 ein\n",
            "-> `m1[\"Java\"] = 90; m1[\"Python\"] = 85;` Weitere Eintr√§ge\n",
            "   Map speichert Schl√ºssel-Wert-Paare, automatisch sortiert nach Schl√ºssel\n",
            "\n",
            "**--- Zugriff & Erstellung ---**\n",
            "-> `std::map<std::string, std::string> m2 = {{\"de\", \"Berlin\"}, {\"fr\", \"Paris\"}, {\"opf\", \"Regensburg\"}};`\n",
            "-> `m2.size()` ‚Üí Anzahl der Paare in der Map ‚Üí 3\n",
            "-> `m2[\"de\"]` ‚Üí Zugriff auf den Wert zu \"de\" ‚Üí \"Berlin\"\n",
            "-> `m2[\"en\"]` ‚Üí Nicht vorhanden ‚Üí erstellt Eintrag mit leerem String als Wert\n",
            "\n",
            "**--- Sichere Abfrage mit at() ---**\n",
            "-> `m1.at(\"C++\")` ‚Üí Gibt den Wert zu \"C++\" zur√ºck ‚Üí 100\n",
            "`// m1.at(\"C\")` w√ºrde abst√ºrzen (throw std::out_of_range), wenn Schl√ºssel nicht existiert!\n",
            "\n",
            "**--- Existenz pr√ºfen mit count() ---**\n",
            "-> `m1.count(\"Java\")` ‚Üí Gibt 1 zur√ºck, wenn vorhanden\n",
            "-> `m1.count(\"Cobol\")` ‚Üí Gibt 0 zur√ºck, wenn nicht vorhanden\n",
            "\n",
            "**--- Entfernen & Pr√ºfen ---**\n",
            "-> `m1.clear()` ‚Üí Entfernt alle Schl√ºssel-Wert-Paare\n",
            "-> `m1.empty()` ‚Üí Pr√ºft, ob Map leer ist ‚Üí true (1)\n",
            "\n",
            "**--- Vergleich von Maps ---**\n",
            "-> `std::map<int, char> mA = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mB = {{1, 'x'}, {2, 'z'}};`\n",
            "-> `mA == mB` ‚Üí false, da Werte unterschiedlich\n",
            "\n",
            "-> `std::map<int, char> mC = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mD = {{2, 'y'}, {1, 'x'}};`\n",
            "-> `mC == mD` ‚Üí true, Reihenfolge ist egal, Inhalte gleich\n",
            "\n",
            "-> `std::map<int, char> mE = {{2, 'y'}, {1, 'x'}, {1, 'x'}};`\n",
            "-> `mC == mE` ‚Üí true, mehrfacher identischer Eintrag z√§hlt nicht doppelt\n",
            "\n",
            "_Hinweis: `std::map` speichert die Schl√ºssel automatisch sortiert ‚Äî bei `int` aufsteigend (1, 2, 3, ...), bei `string` alphabetisch (a, b, c, ...) und erlaubt keine Duplikate._\n"
          ],
          "code": [
            "#include <iostream>\n#include <map>\n#include <string>",
            
            "int main() {\n  // Map von Namen zu Alter\n  std::map<std::string, int> personen;",
            
            "  // Eintr√§ge hinzuf√ºgen\n  personen[\"Anna\"] = 23;\n  personen[\"Bob\"] = 30;\n  personen.insert({\"Clara\", 27});",
            
            "  // Werte lesen\n  std::cout << \"Anna ist \" << personen[\"Anna\"] << \" Jahre alt.\" << std::endl; // Ausgabe: Anna ist 23 Jahre alt.",
            
            "  // Map durchgehen (automatisch sortiert nach Schl√ºssel)\n  std::cout << \"Alle Eintr√§ge:\\n\";\n  for (const auto& eintrag : personen) {\n    std::cout << eintrag.first << \": \" << eintrag.second << std::endl;\n  } // Ausgabe: Anna: 23 / Bob: 30 / Clara: 27 (alphabetisch)",
            
            "  // Existenz pr√ºfen\n  if (personen.count(\"Bob\") > 0) {\n    std::cout << \"Bob ist vorhanden.\" << std::endl; // Ausgabe: Bob ist vorhanden.\n  }",
            
            "  // Mit find() pr√ºfen und Zugriff\n  auto it = personen.find(\"Dora\");\n  if (it == personen.end()) {\n    std::cout << \"Dora ist NICHT vorhanden.\" << std::endl;\n  }",
            
            "  // Wert √§ndern\n  personen[\"Anna\"] = 24; // Anna hat jetzt Geburtstag\n\n  // Eintrag l√∂schen\n  personen.erase(\"Bob\");",
            
            "  // Ausgabe nach √Ñnderungen\n  std::cout << \"Nach √Ñnderungen:\\n\";\n  for (const auto& p : personen) {\n    std::cout << p.first << \": \" << p.second << std::endl;\n  } // Ausgabe: Anna: 24 / Clara: 27",
            
            "  // Gr√∂√üe der Map\n  std::cout << \"Anzahl Personen: \" << personen.size() << std::endl; // Ausgabe: 2\n\n  // Map leeren\n  personen.clear();\n  std::cout << \"Nach clear(): \" << personen.size() << std::endl; // Ausgabe: 0",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Stack/Queue",
        "content": {
          "text": [
            "### === Stack/Queue in C++ ===\n",
            "-> `#include <stack>`   // F√ºr std::stack\n",
            "-> `#include <queue>`   // F√ºr std::queue\n",
            "-> `#include <string>`  // F√ºr std::string\n",
            "\n",
            "**--- STACK (LIFO - Last In, First Out) ---**\n",
            "-> `std::stack<std::string> s1;` Erstellt einen leeren Stack vom Typ std::string\n",
            "-> `s1.push(\"Hello\");` F√ºgt 'Hello' oben auf den Stack\n",
            "-> `s1.push(\"World\");` F√ºgt 'World' oben auf den Stack\n",
            "   Stack-Inhalt (von unten nach oben): [`Hello`, `World`]\n",
            "-> `s1.top();` Gibt das oberste Element zur√ºck ‚Üí \"World\"\n",
            "-> `s1.pop();` Entfernt das oberste Element (\"World\")\n",
            "-> `s1.size();` Gibt die Anzahl der Elemente im Stack zur√ºck ‚Üí 1\n",
            "-> `s1.empty();` Pr√ºft, ob der Stack leer ist (true/false)\n",
            "\n",
            "**--- QUEUE (FIFO - First In, First Out) ---**\n",
            "-> `std::queue<std::string> q1;` Erstellt eine leere Queue f√ºr std::string\n",
            "-> `q1.push(\"Hello\");` F√ºgt 'Hello' hinten in die Queue ein\n",
            "-> `q1.push(\"World\");` F√ºgt 'World' hinten in die Queue ein\n",
            "   Reihenfolge: front ‚Üí back = [`Hello`, `World`]\n",
            "-> `q1.front();` Gibt das erste (√§lteste) Element zur√ºck ‚Üí \"Hello\"\n",
            "-> `q1.back();` Gibt das letzte (neueste) Element zur√ºck ‚Üí \"World\"\n",
            "-> `q1.pop();` Entfernt das erste Element (\"Hello\")\n",
            "-> `q1.size();` Gibt die Anzahl der Elemente in der Queue zur√ºck ‚Üí 1\n",
            "-> `q1.empty();` Pr√ºft, ob die Queue leer ist (true/false)\n"
          ],
          "code": [
            "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>",
            
            "int main() {",
            
            "  // -------- STACK (LIFO) --------\n  std::stack<int> stapel;\n  stapel.push(10);\n  stapel.push(20);\n  stapel.push(30); // Stapel: 10, 20, 30 (oben)",
            
            "  std::cout << \"[STACK] Oberstes Element: \" << stapel.top() << std::endl; // Ausgabe: 30\n  stapel.pop();\n  std::cout << \"[STACK] Nach pop(): \" << stapel.top() << std::endl; // Ausgabe: 20",
            
            "  std::cout << \"[STACK] Gr√∂√üe: \" << stapel.size() << std::endl; // Ausgabe: 2\n  if (!stapel.empty()) {\n    std::cout << \"[STACK] Nicht leer.\" << std::endl;\n  }",
            
            "  // -------- QUEUE (FIFO) --------\n  std::queue<std::string> warteschlange;\n  warteschlange.push(\"Anna\");\n  warteschlange.push(\"Bob\");\n  warteschlange.push(\"Clara\"); // Reihenfolge: Anna, Bob, Clara",
            
            "  std::cout << \"[QUEUE] Vorne: \" << warteschlange.front() << std::endl; // Ausgabe: Anna\n  std::cout << \"[QUEUE] Hinten: \" << warteschlange.back() << std::endl; // Ausgabe: Clara",
            
            "  warteschlange.pop();\n  std::cout << \"[QUEUE] Nach pop(): Vorne ist jetzt \" << warteschlange.front() << std::endl; // Ausgabe: Bob",
            
            "  std::cout << \"[QUEUE] Gr√∂√üe: \" << warteschlange.size() << std::endl; // Ausgabe: 2\n  if (!warteschlange.empty()) {\n    std::cout << \"[QUEUE] Nicht leer.\" << std::endl;\n  }",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Pairs/Tuples",
        "content": {
          "text": [
            "### === Pairs & Tuples in C++ ===\n",
            "-> `#include <utility>`   // F√ºr std::pair\n",
            "-> `#include <tuple>`     // F√ºr std::tuple\n",
            "-> `#include <string>`    // F√ºr std::string\n",
            "-> `#include <vector>`    // F√ºr std::vector\n",
            "\n",
            "**--- std::pair ---**\n",
            "-> `std::pair<std::string, int> p1 = std::make_pair(\"Regensburg\", 199000);`\n",
            "-> `std::pair<std::string, int> p2 = std::make_pair(\"Weiden\", 43000);`\n",
            "-> `std::pair<std::string, int> p3 = std::make_pair(\"Amberg\", 42000);`\n",
            "   Ein Pair enth√§lt genau zwei Werte unterschiedlichen Typs\n",
            "-> `p1.first` ‚Üí Gibt das erste Element zur√ºck ‚Üí \"Regensburg\"\n",
            "-> `p1.second` ‚Üí Gibt das zweite Element zur√ºck ‚Üí 199000\n",
            "-> `std::vector<std::pair<std::string, int>> cities = {p1, p2, p3};` // Liste von St√§dten mit Einwohnern\n",
            "-> `cities[1].first` ‚Üí Zugriff auf den Namen der zweiten Stadt ‚Üí \"Weiden\"\n",
            "\n",
            "**--- std::tuple ---**\n",
            "-> `std::tuple<std::string, int, double> t1 = std::make_tuple(\"Lisa\", 123, 1.0);`\n",
            "-> `std::tuple<std::string, int, double> t2 = std::make_tuple(\"Bart\", 456, 3.7);`\n",
            "-> `std::tuple<std::string, int, double> t3 = std::make_tuple(\"Nelson\", 666, 5.0);`\n",
            "   Ein Tuple kann beliebig viele Werte enthalten\n",
            "-> `std::get<0>(t1)` ‚Üí Zugriff auf das erste Element ‚Üí \"Lisa\"\n",
            "-> `std::get<1>(t2)` ‚Üí Zugriff auf das zweite Element ‚Üí 456\n",
            "-> `std::get<2>(t3)` ‚Üí Zugriff auf das dritte Element ‚Üí 5.0\n",
            "\n",
            "`std::tuple<T1, T2, T3>`: Bei Tuples muss der Index zur Compilezeit bekannt sein ‚Üí `std::get<1>(...)`\n",
            "   Das bedeutet: `std::get<0>(...)` gibt das erste Element vom Typ `T1` zur√ºck\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <utility>  // f√ºr pair, make_pair\n#include <tuple>    // f√ºr tuple, make_tuple, get, tie",
            
            "int main() {",
            
            "  // -------- PAIR --------\n  std::pair<std::string, int> person = {\"Anna\", 25};\n  std::cout << \"[PAIR] Name: \" << person.first << \", Alter: \" << person.second << std::endl; // Ausgabe: Anna, 25",
            
            "  // Alternative mit make_pair\n  auto student = std::make_pair(\"Bob\", 30);\n  std::cout << \"[PAIR] Student: \" << student.first << \" - \" << student.second << std::endl;",
            
            "  // Vergleich\n  std::pair<int, int> a = {1, 2};\n  std::pair<int, int> b = {1, 3};\n  if (a < b) {\n    std::cout << \"[PAIR] a < b (lexikografisch)\" << std::endl;\n  }",
            
            "  // -------- TUPLE --------\n  std::tuple<std::string, int, double> daten = {\"Clara\", 28, 1.65};",
            
            "  std::cout << \"\\n[TUPLE] Name: \" << std::get<0>(daten)\n            << \", Alter: \" << std::get<1>(daten)\n            << \", Gr√∂√üe: \" << std::get<2>(daten) << std::endl; // Ausgabe: Clara, 28, 1.65",
            
            "  // Alternative mit make_tuple\n  auto eintrag = std::make_tuple(\"David\", 32, 1.80);",
            
            "  // Entpacken mit tie\n  std::string name;\n  int alter;\n  double groesse;\n  std::tie(name, alter, groesse) = eintrag;\n  std::cout << \"[TUPLE] Entpackt: \" << name << \", \" << alter << \", \" << groesse << std::endl;",
            
            "  // Gr√∂√üe des Tupels\n  std::cout << \"[TUPLE] Anzahl Elemente: \" << std::tuple_size<decltype(eintrag)>::value << std::endl; // Ausgabe: 3",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Iteratoren",
        "content": {
          "text": [
            "### === Iteratoren in C++ ===\n",
            "-> `#include <vector>`   // F√ºr std::vector\n",
            "-> `#include <list>`     // F√ºr std::list\n",
            "-> `#include <set>`      // F√ºr std::set\n",
            "-> `#include <algorithm>`// F√ºr std::copy, std::sort, std::merge\n",
            "-> `#include <iterator>` // F√ºr std::back_inserter\n",
            "\n",
            "**=== Iteratoren ‚Äì Grundlagen in C++ ===**\n",
            "-> Iteratoren sind bewegliche Zeiger, die auf ein Element eines Containers zeigen.\n",
            "-> Typbeispiel: `std::vector<std::string>::iterator`\n",
            "\n",
            "**--- Iterator-Zugriff & Navigation ---**\n",
            "-> `container.begin()` ‚Üí Iterator auf das erste Element\n",
            "-> `container.end()` ‚Üí Iterator auf das Element *nach* dem letzten\n",
            "-> `*it` ‚Üí aktuelles Element\n",
            "-> `it->member` entspricht `(*it).member`\n",
            "-> `++it`, `--it` ‚Üí n√§chstes/vorheriges Element (nur r√ºckw√§rts bei bidirektional)\n",
            "-> `it += x` ‚Üí x Schritte vor (nur Random-Access, z.B. bei `std::vector`)\n",
            "\n",
            "**--- Iterator-Vergleich ---**\n",
            "-> `it == it2`, `it != it2` ‚Üí Vergleich\n",
            "-> `it < it2` ‚Üí Nur bei Random-Access m√∂glich\n",
            "\n",
            "**--- Iterator-Arten nach Container ---**\n",
            "`std::vector`, `std::array` ‚Üí Random-Access\n",
            "`std::list`, `std::set`, `std::map` ‚Üí Bidirektional\n",
            "`std::forward_list` ‚Üí Forward-only\n",
            "\n",
            "**--- Klassischer Iterator-Loop ---**\n",
            "```cpp\nstd::vector<int> v = {1, 2, 3};\nfor (auto it = v.begin(); it != v.end(); ++it)\n  std::cout << *it << std::endl;\n```\n",
            "\n",
            "**--- Laufindex (C-Style) ---**\n",
            "```cpp\nfor (int i = 0; i < v.size(); i++) std::cout << v[i];\n```\n",
            "\n",
            "**--- Range-based for loop ---**\n",
            "```cpp\nfor (int vi : v) std::cout << vi;\n```\n",
            "\n",
            "**--- Iterator f√ºr jedes 2. Element ---**\n",
            "```cpp\nfor (auto it = v.begin() + 1; it < v.end(); it += 2)\n  std::cout << *it;\n```\n",
            "\n",
            "**--- Iterator f√ºr Kopieren, Sortieren ---**\n",
            "```cpp\nstd::copy(v.begin(), v.end(), std::back_inserter(l));\nv.erase(v.begin() + 3);\nstd::sort(v.begin() + 1, v.end() - 1);\n```\n",
            "\n",
            "**--- Iterator bei set: find() ---**\n",
            "```cpp\nstd::set<int> s = {2, 4, 6};\nauto it = s.find(4);\nif (it != s.end()) std::cout << *it;\n```\n",
            "-> `find()` gibt `end()` zur√ºck, wenn das Element nicht vorhanden ist\n",
            "-> Sets haben keine Indexe, nur Iteratoren\n",
            "\n",
            "**--- std::merge (zwei Container zusammenf√ºhren) ---**\n",
            "```cpp\nstd::merge(s.begin(), s.end(), v.begin(), v.end(), std::back_inserter(l));\n```\n",
            "-> F√ºgt sortiert alle Elemente aus `s` und `v` in `l` ein\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <iterator>  // f√ºr advance, distance\n#include <algorithm>",

            "int main() {\n  std::vector<int> zahlen = {10, 20, 30, 40, 50};",
            
            "  // Iteration mit explizitem Iterator\n  std::cout << \"Normale Iteration: \";\n  for (std::vector<int>::iterator it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  } // Ausgabe: 10 20 30 40 50\n  std::cout << std::endl;",
            
            "  // Iteration mit auto\n  std::cout << \"Mit auto: \";\n  for (auto it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;",
            
            "  // R√ºckw√§rts iterieren\n  std::cout << \"R√ºckw√§rts: \";\n  for (auto rit = zahlen.rbegin(); rit != zahlen.rend(); ++rit) {\n    std::cout << *rit << \" \";\n  } // Ausgabe: 50 40 30 20 10\n  std::cout << std::endl;",
            
            "  // Zugriff & √Ñnderung √ºber Iterator\n  auto it = zahlen.begin();\n  *it = 100; // √Ñndert erstes Element\n  std::cout << \"Nach √Ñnderung: \" << zahlen[0] << std::endl; // Ausgabe: 100",
            
            "  // std::advance: verschiebe Iterator um 3 Positionen\n  std::advance(it, 3);\n  std::cout << \"Iterator +3: \" << *it << std::endl; // Ausgabe: 40",
            
            "  // std::distance: Abstand zwischen zwei Iteratoren\n  int abstand = std::distance(zahlen.begin(), it);\n  std::cout << \"Abstand: \" << abstand << std::endl; // Ausgabe: 3",
            
            "  return 0;\n}"
          ]
        }
      },
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Allgemeine Funktionen f√ºr STL-Container ===\n",
            "-> `begin()`: Gibt Iterator zum ersten Element zur√ºck.\n",
            "   Beispiel: `auto it = container.begin();`\n",
            "-> `end()`: Iterator hinter dem letzten Element.\n",
            "   Beispiel: `for (auto it = c.begin(); it != c.end(); ++it)`\n",
            "-> `size()`: Gibt Anzahl der Elemente zur√ºck.\n",
            "   Beispiel: `std::cout << v.size();`\n",
            "-> `empty()`: Pr√ºft, ob Container leer ist.\n",
            "   Beispiel: `if (v.empty()) std::cout << \"leer\";`\n",
            "-> `clear()`: L√∂scht alle Elemente.\n",
            "   Beispiel: `v.clear();`\n",
            "-> `erase()`: Entfernt ein Element (Iterator oder Wert).\n",
            "   Beispiel: `v.erase(v.begin());`\n",
            "-> `insert()`: F√ºgt Element(e) hinzu.\n",
            "   Beispiel: `s.insert(42);`\n",
            "-> `find()`: Sucht Element (bei set/map).\n",
            "   Beispiel: `if (s.find(3) != s.end()) { ... }`\n",
            "-> `front()`: Erstes Element (z.‚ÄØB. bei vector, queue).\n",
            "   Beispiel: `std::cout << v.front();`\n",
            "-> `back()`: Letztes Element (z.‚ÄØB. bei vector).\n",
            "   Beispiel: `std::cout << v.back();`\n",
            "-> `at()`: Zugriff mit Bounds-Check.\n",
            "   Beispiel: `v.at(2);`\n",
            "-> `operator[]`: Zugriff ohne Check (nur bei vector, string, map).\n",
            "   Beispiel: `v[0] = 42;`\n",
            "-> `swap()`: Tauscht Inhalt zweier Container.\n",
            "   Beispiel: `v1.swap(v2);`\n",
            "-> `assign()`: Ersetzt Inhalt (z.‚ÄØB. bei vector oder string).\n",
            "   Beispiel: `v.assign(5, 0); // 5 Nullen`\n",
            "-> `resize()`: Gr√∂√üe √§ndern (nur bei Sequenzcontainern).\n",
            "   Beispiel: `v.resize(10);`\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>",
            
            "int main() {\n  std::set<int> s = {1, 2, 3};",
            
            "  // empty()\n  if (!s.empty()) {\n    std::cout << \"Set ist NICHT leer\" << std::endl; // Ausgabe: Set ist NICHT leer\n  }",
            
            "  // size()\n  std::cout << \"Anzahl Elemente: \" << s.size() << std::endl; // Ausgabe: 3",
            
            "  // insert()\n  s.insert(4);\n  s.insert(2); // 2 ist bereits enthalten, wird ignoriert",
            
            "  // erase()\n  s.erase(3); // entfernt 3, falls vorhanden",
            
            "  // find()\n  auto it = s.find(2);\n  if (it != s.end()) {\n    std::cout << \"2 gefunden\" << std::endl;\n  }",
            
            "  // count()\n  if (s.count(5) == 0) {\n    std::cout << \"5 ist NICHT enthalten\" << std::endl;\n  }",
            
            "  // swap()\n  std::set<int> s2 = {10, 20};\n  s.swap(s2); // jetzt enth√§lt s die Elemente von s2",
            
            "  std::cout << \"Nach swap(): Set enth√§lt: \";\n  for (int x : s) std::cout << x << \" \"; // Ausgabe: 10 20\n  std::cout << std::endl;",
            
            "  // clear()\n  s.clear();\n  std::cout << \"Nach clear(): Gr√∂√üe = \" << s.size() << std::endl; // Ausgabe: 0",
            
            "  return 0;\n}"
          ]
        }
      }
    ]
  },
  {
    "category": "Klassen",
    "subtopics": [
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Klassen in C++ ===\n",
            "Eine Klasse ist ein Bauplan f√ºr Objekte. Sie definiert Eigenschaften (Attribute) und F√§higkeiten (Methoden), die ein Objekt haben kann.\n",
            "-> Mit einer Klasse kann man eigene Datentypen erstellen, die sowohl Daten als auch Funktionen enthalten.\n",
            "-> Klassen helfen beim Strukturieren von Code und sind ein zentrales Konzept der objektorientierten Programmierung.\n",
            "\n",
            "### Aufbau einer Klasse\n",
            "`class Klassenname { ... };` definiert eine Klasse. Darin legt man Member-Variablen (Attribute) und Member-Funktionen (Methoden) fest.\n",
            "Die Sichtbarkeit wird mit `public`, `private` oder `protected` gesteuert:\n",
            "- `private`: Nur innerhalb der Klasse sichtbar (Standard)\n",
            "- `public`: Von au√üen sichtbar\n",
            "- `protected`: Kein Zugriff von z.B main. Zugriff aus abgeleiteten Klassen und aus eigener Klasse ist erlaubt.\n",
            "\n",
            "### Objekt-Erzeugung\n",
            "Mit `Klassenname objektname;` wird ein Objekt erstellt. Danach kann man mit `objektname.funktion()` Methoden aufrufen.\n",
            "\n",
            "### Konstruktor\n",
            "Ein Konstruktor ist eine spezielle Methode, die automatisch beim Erzeugen eines Objekts aufgerufen wird. Er tr√§gt den Namen der Klasse.\n",
            "\n",
            "### this-Zeiger\n",
            "`this` ist ein Zeiger auf das aktuelle Objekt. Wird oft in Methoden verwendet, wenn man auf die eigene Instanz zugreifen m√∂chte.\n"
          ],
            "code": [
            "#include <iostream>\n\n// Definition einer Klasse\nclass Auto {\nprivate:\n  std::string marke;\n  int baujahr;\n\npublic:\n  // Konstruktor\n  Auto(std::string m, int bj) {\n    marke = m;\n    baujahr = bj;\n  }\n\n  // Methode zur Ausgabe\n  void anzeigen() {\n    std::cout << \"Marke: \" << marke << \", Baujahr: \" << baujahr << std::endl;\n  }\n};",
            "int main() {\n  // Objekt erzeugen\n  Auto meinAuto(\"BMW\", 2020);\n  meinAuto.anzeigen(); // Ausgabe: Marke: BMW, Baujahr: 2020\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Public / Private / Protected",
  "content": {
    "text": [
      "### === Zugriffsmodifizierer: `public`, `private`, `protected` ===\n",
      "In C++ bestimmt man mit Zugriffsmodifizierern, welche Teile einer Klasse **von au√üen sichtbar** oder **gesch√ºtzt** sind.\n",
      "\n",
      "-> **Standard in `class`** ist: `private` (bei `struct` dagegen `public`)\n",
      "\n",
      "### üîí `private:` (Standard)\n",
      "- Nur innerhalb der Klasse sichtbar\n",
      "- Gut f√ºr: Datenkapselung, interne Logik\n",
      "- Nicht sichtbar in Unterklassen\n",
      "\n",
      "### üîì `public:`\n",
      "- Frei von √ºberall zug√§nglich\n",
      "- Wird verwendet f√ºr Schnittstellen (z.‚ÄØB. Methoden wie `anzeigen()`)\n",
      "\n",
      "### üü® `protected:`\n",
      "- Wie `private`, aber auch **in Unterklassen sichtbar**\n",
      "- Von **au√üen weiterhin nicht zugreifbar**\n",
      "- Gut, wenn **abgeleitete Klassen** auf interne Daten zugreifen sollen\n",
      "\n",
      "### ‚ûï Vergleich:\n",
      "| Modifizierer | Sichtbar in Klasse | Sichtbar in Unterklasse | Sichtbar au√üerhalb |\n",
      "| private      | ‚úÖ                 | ‚ùå                       | ‚ùå                  |\n",
      "| protected    | ‚úÖ                 | ‚úÖ                       | ‚ùå                  |\n",
      "| public       | ‚úÖ                 | ‚úÖ                       | ‚úÖ                  |\n",
      "\n",
      "üëâ `protected` wird v.‚ÄØa. bei Vererbung verwendet, wenn man Unterklassen erweiterten, aber kontrollierten Zugriff geben m√∂chte."
    ],
    "code": [
      "#include <iostream>\n\nclass Konto {\nprivate:\n  int kontoNummer = 12345;        // Nur innerhalb der Klasse sichtbar\n\nprotected:\n  double kontostand = 100.0;      // F√ºr Unterklassen sichtbar\n\npublic:\n  void einzahlen(double betrag) {\n    kontostand += betrag;\n  }\n\n  void anzeigen() {\n    std::cout << \"Kontostand: \" << kontostand << \" EUR\" << std::endl;\n  }\n};\n\nclass KinderKonto : public Konto {\npublic:\n  void abheben(double betrag) {\n    kontostand -= betrag; // Zugriff auf protected-Mitglied erlaubt\n  }\n\n  void kontoInfo() {\n    // std::cout << kontoNummer; // ‚ùå Fehler: private in Basisklasse\n    std::cout << \"Zugriff auf gesch√ºtzten Kontostand m√∂glich: \" << kontostand << std::endl;\n  }\n};\n\nint main() {\n  KinderKonto k;\n  k.einzahlen(50);\n  k.abheben(30);\n  k.anzeigen(); // Ausgabe: Kontostand: 120 EUR\n\n  // k.kontostand = 999;      // ‚ùå Fehler: protected von au√üen nicht sichtbar\n  // k.kontoNummer = 11111;   // ‚ùå Fehler: private von au√üen nicht sichtbar\n\n  k.kontoInfo(); // Zugriff auf protected innerhalb der Unterklasse\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Konstruktor / Destruktor",
        "content": {
          "text": [
            "### === Konstruktoren & Destruktoren in C++ ===\n",
            "Konstruktoren und Destruktoren sind spezielle Methoden, die automatisch beim Erzeugen bzw. Zerst√∂ren eines Objekts aufgerufen werden.\n",
            "\n",
            "### Konstruktor\n",
            "-> Wird beim Erzeugen eines Objekts aufgerufen\n",
            "-> Hat den **gleichen Namen wie die Klasse**, kein R√ºckgabewert (auch kein `void`)\n",
            "-> Wird oft verwendet, um Startwerte zu setzen oder Ressourcen zu reservieren\n",
            "\n",
            "### Destruktor\n",
            "-> Wird beim L√∂schen eines Objekts aufgerufen (z.‚ÄØB. am Ende des G√ºltigkeitsbereichs)\n",
            "-> Hat den gleichen Namen wie die Klasse, aber mit einem **Tilde-Zeichen `~`** davor\n",
            "-> Wird genutzt, um Ressourcen wie Speicher oder Dateien freizugeben\n",
            "\n",
            "### Wichtig\n",
            "- Es kann mehrere Konstruktoren geben (√úberladung), aber **nur einen Destruktor** pro Klasse\n",
            "- In modernen C++-Projekten ist der Destruktor vor allem bei dynamischem Speicher wichtig\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Tier {\nprivate:\n  std::string name;\n\npublic:\n  // Konstruktor\n  Tier(std::string n) {\n    name = n;\n    std::cout << \"Tier erstellt: \" << name << std::endl;\n  }\n\n  // Destruktor\n  ~Tier() {\n    std::cout << \"Tier gel√∂scht: \" << name << std::endl;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht Ger√§usche.\" << std::endl;\n  }\n};",
            "int main() {\n  Tier katze(\"Miezi\");\n  katze.sprich();\n\n  // Am Ende von main wird automatisch der Destruktor aufgerufen\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Friend",
        "content": {
          "text": [
            "### === `friend` in C++ ===\n",
            "Ein `friend` erlaubt einer Funktion oder einer anderen Klasse den **Zugriff auf private oder protected Member** einer Klasse.\n",
            "Damit kann gezielt und kontrolliert eine Ausnahme von der Kapselung gemacht werden.\n",
            "\n",
            "### friend-Funktion\n",
            "-> Wird **au√üerhalb** der Klasse definiert,\n",
            "-> hat aber Zugriff auf private Member,\n",
            "-> muss **innerhalb** der Klasse mit `friend` deklariert werden.\n",
            "\n",
            "### friend-Klasse\n",
            "-> Eine ganze Klasse kann als `friend` einer anderen Klasse deklariert werden,\n",
            "-> Sie bekommt vollen Zugriff auf alle privaten Elemente der Klasse.\n",
            "\n",
            "### Wann verwendet man `friend`?\n",
            "- Wenn bestimmte Funktionen eng mit der Klasse zusammenarbeiten m√ºssen,\n",
            "- z.‚ÄØB. f√ºr Vergleichsfunktionen oder externe Operator√ºberladungen.\n",
            "- Sollte **sparsam und gezielt** verwendet werden, da es die Kapselung aufbricht.\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Geheimnis {\nprivate:\n  int geheimerWert = 42;\n\n  // friend-Funktion erlauben\n  friend void zeigeGeheimnis(const Geheimnis& g);\n};\n\n// Definition der friend-Funktion\nvoid zeigeGeheimnis(const Geheimnis& g) {\n  std::cout << \"Geheimer Wert: \" << g.geheimerWert << std::endl;\n}",
            "int main() {\n  Geheimnis objekt;\n  zeigeGeheimnis(objekt); // Ausgabe: Geheimer Wert: 42\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Vererbung",
  "content": {
    "text": [
      "### === Vererbung in C++ ===\n",
      "Vererbung ist ein zentrales Konzept der objektorientierten Programmierung.\n",
      "Damit kann eine neue Klasse (`Kindklasse`) die Eigenschaften und Methoden einer bestehenden Klasse (`Basisklasse`) √ºbernehmen.\n",
      "\n",
      "### Vorteile\n",
      "- Code-Wiederverwendung\n",
      "- Erweiterbarkeit\n",
      "- Strukturierte Hierarchien\n",
      "\n",
      "### Syntax\n",
      "`class Kindklasse : public Basisklasse { ... };`\n",
      "-> `public` bedeutet: √∂ffentliche Mitglieder der Basisklasse bleiben auch in der Kindklasse √∂ffentlich.\n",
      "-> `protected` bedeutet: √∂ffentliche Mitglieder der Basisklasse werden in der Kindklasse protected.\n",
      "-> `private` bedeutet: √∂ffentliche Mitglieder der Basisklasse werden in der Kindklasse private.\n",
      "\n",
      "### Konstruktoren in Vererbung\n",
      "-> Konstruktor der Basisklasse wird **automatisch zuerst** aufgerufen.\n",
      "-> Kann im Initialisierungsbereich der Kindklasse explizit aufgerufen werden.\n",
      "\n",
      "### Vererbungsmodi in C++\n",
      "C++ kennt drei Vererbungsmodi: `public`, `protected` und `private`.\n",
      "- Sie bestimmen, wie sich die Sichtbarkeit von geerbten Attributen und Methoden in der abgeleiteten Klasse ver√§ndert.\n",
      "- Der Modus ist eine **obere Schranke**: `public` l√§sst alles wie es ist, `private` versteckt fast alles.\n",
      "\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n"
    ],
"code": [
  "#include <iostream>\n\n// Basisklasse\nclass Tier {\nprotected:\n  std::string name;\n\npublic:\n  Tier(std::string n) {\n    name = n;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht ein Ger√§usch.\" << std::endl;\n  }\n};\n\n// Abgeleitete Klasse\nclass Hund : public Tier {\npublic:\n  Hund(std::string n) : Tier(n) {}\n\n  void bell() {\n    std::cout << name << \" bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  rex.sprich(); // Ausgabe: Rex macht ein Ger√§usch.\n  rex.bell();   // Ausgabe: Rex bellt.\n\n  return 0;\n}",
  "// Zus√§tzliche Beispiele zur Vererbungsart:\n\nclass base {\npublic:\n  void f() {}\nprotected:\n  void g() {}\nprivate:\n  int x;\n};\n\nclass derived_1 : public base {\n  // f() bleibt public\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_2 : protected base {\n  // f() wird protected\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_3 : private base {\n  // f() wird private\n  // g() wird private\n  // x ist nicht zugreifbar\n};"
]
  }
},
{
  "title": "Copy Constructor & Assignment",
  "content": {
    "text": [
      "### === Copy Constructor & Copy Assignment ===\n",
      "Wenn Objekte kopiert oder zugewiesen werden, kommen spezielle Funktionen ins Spiel:\n",
      "\n",
      "- **Copy Constructor**: Wird aufgerufen bei z.‚ÄØB. `Objekt b = a;`\n",
      "- **Copy Assignment Operator**: Wird aufgerufen bei `b = a;`, wenn `b` schon existiert\n",
      "\n",
      "### Warum ist das wichtig?\n",
      "Standardm√§√üig macht C++ eine **flache Kopie** (Shallow Copy):\n",
      "- Zeiger werden 1:1 √ºbernommen\n",
      "- F√ºhrt bei `delete` oft zu Abst√ºrzen oder doppelt gel√∂schtem Speicher\n",
      "\n",
      "Daher sollte man bei dynamischem Speicher (z.‚ÄØB. `new`) eine **tiefe Kopie (Deep Copy)** schreiben:\n",
      "- Es wird ein **neuer Speicher** erstellt und der Inhalt kopiert\n",
      "\n",
      "### Die Rule of 3:\n",
      "Wenn du eins dieser 3 selbst schreibst, solltest du alle schreiben:\n",
      "- Destruktor (`~Klasse()`)\n",
      "- Copy Constructor\n",
      "- Copy Assignment Operator\n",
      "\n",
      "üëâ Ab C++11 gibt es auch die Rule of 5 (inkl. Move Constructor und Move Assignment)\n",
      "\n",
      "### ‚ùó `if (this != &other)` ‚Äì warum?\n",
      "Beim Zuweisungsoperator **kann es passieren**, dass ein Objekt sich selbst zugewiesen wird:\n",
      "```cpp\nobj = obj;\n```\n",
      "Ohne `if (this != &other)` w√ºrde man:\n",
      "- Speicher **l√∂schen**, der gleich danach **benutzt** wird ‚Üí ‚ùå Absturz!\n",
      "- Oder unn√∂tig neu kopieren\n",
      "‚úÖ Mit dem Vergleich wird sichergestellt, dass bei **Selbstzuweisung** nichts passiert."
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n    }\n\n    // Copy Constructor (tiefe Kopie)\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n    }\n\n    // Copy Assignment Operator (tiefe Kopie)\n    Person& operator=(const Person& andere) {\n        if (this != &andere) { // wichtig bei Selbstzuweisung!\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Person p1(\"Kilian\");\n    Person p2 = p1;         // Copy Constructor wird genutzt\n    Person p3(\"Test\");\n    p3 = p1;                // Copy Assignment wird genutzt\n\n    p1.anzeigen();          // Name: Kilian\n    p2.anzeigen();          // Name: Kilian\n    p3.anzeigen();          // Name: Kilian\n\n    p1 = p1;                // Selbstzuweisung ‚Üí gesch√ºtzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Move Constructor & Rvalue-Referenz",
  "content": {
    "text": [
      "### === Rvalue-Referenzen & Move Constructor (C++11+) ===\n",
      "Mit C++11 wurde die **Move-Semantik** eingef√ºhrt, um unn√∂tige Kopien zu vermeiden ‚Äì besonders bei tempor√§ren Objekten.\n",
      "\n",
      "### Was ist eine Rvalue-Referenz (`T&&`)?\n",
      "- `T&&` akzeptiert ein **tempor√§res Objekt** (z.‚ÄØB. R√ºckgabewert einer Funktion)\n",
      "- Erm√∂glicht das **√úbernehmen von Ressourcen**, statt sie zu kopieren\n",
      "\n",
      "### Move Constructor\n",
      "- Wird aufgerufen bei z.‚ÄØB. `Objekt b = std::move(a);`\n",
      "- **\"klaut\"** den Speicher von `a`, statt ihn zu kopieren\n",
      "\n",
      "### Move Assignment Operator\n",
      "- Wird bei `b = std::move(a);` aufgerufen (wenn `b` schon existiert)\n",
      "- Wie Zuweisung, aber mit √úbernahme statt Kopie\n",
      "\n",
      "### Wann sinnvoll?\n",
      "- Gro√üe Objekte (z.‚ÄØB. Strings, Container)\n",
      "- Tempor√§re R√ºckgaben (`return obj;`)\n",
      "\n",
      "### Wichtig:\n",
      "- Danach ist das Objekt im \"moved-from\"-Zustand ‚Üí es darf **nicht mehr normal verwendet**, aber **zerst√∂rt** werden\n",
      "- Rvalue-Referenz erkennt man meist mit `std::move(var)`\n",
      "\n",
      "üëâ Wer Copy Constructor, Copy Assignment, Destruktor UND Move-Funktionen schreibt, folgt der **Rule of 5**\n",
      "\n",
      "### ‚ùó Auch bei Move Assignment: `if (this != &andere)`\n",
      "Bei `obj = std::move(obj);` kann es zu **Selbst-Zuweisung** kommen!\n",
      "- Ohne Pr√ºfung: Speicher wird gel√∂scht **bevor** er √ºbertragen wird ‚Üí ‚ùå Absturz!\n",
      "- Mit Pr√ºfung: Zuweisung wird √ºbersprungen ‚Üí ‚úÖ korrekt\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) { // wichtig bei Selbst-Zuweisung!\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << (name ? name : \"[leer]\") << std::endl;\n    }\n};\n\nPerson erzeugePerson() {\n    return Person(\"Kilian\");\n}\n\nint main() {\n    Person p1 = erzeugePerson();    // Move Constructor\n    Person p2(\"Test\");\n    p2 = std::move(p1);             // Move Assignment\n\n    p2.anzeigen();                  // Name: Kilian\n    p1.anzeigen();                  // Name: [leer]\n\n    p2 = std::move(p2);             // Selbstzuweisung ‚Üí gesch√ºtzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Rule of 5",
  "content": {
    "text": [
      "### === Rule of 5 (C++11+) ===\n",
      "Die **Rule of 5** beschreibt, welche Funktionen du in einer Klasse mit Ressourcen (z.‚ÄØB. `new`) implementieren solltest.\n",
      "\n",
      "Sie erweitert die **Rule of 3** (Copy Constructor, Copy Assignment, Destruktor) um zwei neue Funktionen:\n",
      "\n",
      "### Die f√ºnf Funktionen:\n",
      "1. **Destruktor** (`~Klasse()`)\n",
      "2. **Copy Constructor** (`Klasse(const Klasse&)`)\n",
      "3. **Copy Assignment Operator** (`operator=(const Klasse&)`)\n",
      "4. **Move Constructor** (`Klasse(Klasse&&)`)\n",
      "5. **Move Assignment Operator** (`operator=(Klasse&&)`)\n",
      "\n",
      "### Warum das Ganze?\n",
      "- Wenn du eine Funktion manuell schreibst (z.‚ÄØB. Copy Constructor), deaktiviert C++ die automatische Generierung der anderen ‚Üí du musst sie selbst implementieren\n",
      "- Besonders bei dynamischem Speicher wichtig (deep copy & safe move)\n",
      "\n",
      "### Wann ist die Rule of 5 wichtig?\n",
      "- Wenn deine Klasse **Zeiger oder Ressourcen verwaltet** (z.‚ÄØB. mit `new`, `malloc`, Datei-Handles)\n",
      "- Wenn du **Kopie und Verschiebung erlauben oder verhindern** willst\n",
      "\n",
      "üëâ Alternativen: **Rule of 0** bei reinem Value-Semantik-Code (z.‚ÄØB. `std::vector`, keine `new`) oder Rule of 6 (mit `operator==()`)\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) {\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n};\n\nint main() {\n    Person a(\"Max\");\n    Person b = a;             // Copy Constructor\n    Person c(\"Test\");\n    c = a;                    // Copy Assignment\n    Person d = std::move(a);  // Move Constructor\n    b = std::move(c);         // Move Assignment\n    return 0;\n}"
    ]
  }
},
{
  "title": "Implizite Klassenbestandteile & = delete",
  "content": {
    "text": [
      "### === Implizite Klassenbestandteile in C++ ===\n",
      "C++ erzeugt f√ºr jede Klasse automatisch bestimmte Methoden, wenn du sie nicht selbst definierst:\n",
      "\n",
      "### Diese Methoden werden (standardm√§√üig) automatisch generiert:\n",
      "- Standard-Konstruktor (`MyClass()`)\n",
      "- Destruktor (`~MyClass()`)\n",
      "- Copy Constructor (`MyClass(const MyClass&)`)\n",
      "- Copy Assignment (`operator=(const MyClass&)`)\n",
      "- Move Constructor (`MyClass(MyClass&&)`) *(ab C++11)*\n",
      "- Move Assignment (`operator=(MyClass&&)`) *(ab C++11)*\n",
      "\n",
      "### Warum `= delete`?\n",
      "- Verhindert, dass eine bestimmte Methode automatisch generiert oder verwendet wird\n",
      "- Beispiel: Kopieren verhindern (z.‚ÄØB. bei Singleton- oder Handle-Klassen)\n",
      "```cpp\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n",
      "\n",
      "### Warum `= default`?\n",
      "- Erzwingt die automatische Standard-Erstellung (z.‚ÄØB. wenn du trotzdem was anderes schreibst)\n",
      "```cpp\nMyClass() = default;\n```\n",
      "\n",
      "### Wann ist das wichtig?\n",
      "- Wenn deine Klasse z.‚ÄØB. Zeiger enth√§lt und **tiefe Kopie n√∂tig** ist\n",
      "- Wenn du **kopieren bewusst verbieten** willst\n",
      "- Wenn du eine Methode **nur deklarieren willst, aber ohne eigene Logik** (z.‚ÄØB. bei APIs)\n",
      "\n",
      "üëâ Moderne Klassen (z.‚ÄØB. mit Ressourcenbesitz) sollten Copy/Move bewusst steuern\n",
      "üëâ In Pr√ºfungen wird oft gefragt: \"Was macht `= delete`?\" oder \"Was wird implizit generiert?\"\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Beispiel {\npublic:\n    Beispiel() = default; // Standard-Konstruktor explizit erlaubt\n\n    // Copy-Vorg√§nge deaktivieren\n    Beispiel(const Beispiel&) = delete;\n    Beispiel& operator=(const Beispiel&) = delete;\n\n    void hallo() {\n        std::cout << \"Hallo!\" << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b1;      // OK\n    b1.hallo();\n\n    // Beispiel b2 = b1;        // Fehler: Copy Constructor ist gel√∂scht\n    // Beispiel b3;\n    // b3 = b1;                  // Fehler: Copy Assignment ist gel√∂scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Struct vs. Class",
  "content": {
    "text": [
      "### === struct vs. class in C++ ===\n",
      "`struct` und `class` sind sich in C++ sehr √§hnlich ‚Äì beide k√∂nnen Memberfunktionen, Konstruktoren, Vererbung und vieles mehr enthalten.\n",
      "Der **einzige technische Unterschied** ist die **Standard-Sichtbarkeit**:\n",
      "\n",
      "| Merkmal                     | `struct` (Standard: public)   | `class` (Standard: private)   |\n",
      "| Standard-Sichtbarkeit       | `public`                      | `private`                    |\n",
      "| Wird verwendet f√ºr...       | Datencontainer, PODs          | OOP-Klassen, Kapselung       |\n",
      "| Methoden m√∂glich?           | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "| Vererbung m√∂glich?          | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "| Konstruktoren, Operatoren?  | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "\n",
      "### Beispiel: Unterschied in der Sichtbarkeit\n",
      "```cpp\nstruct A {\n    int x;       // automatisch public\n};\n\nclass B {\n    int x;       // automatisch private\n};\n\nint main() {\n    A a;\n    a.x = 10;    // ‚úÖ erlaubt\n\n    B b;\n    // b.x = 10; // ‚ùå Fehler: x ist private\n    return 0;\n}\n```\n",
      "\n",
      "### Merksatz:\n",
      "- Verwende `struct`, wenn du **nur Daten speichern willst** (wie bei C-Strukturen)\n",
      "- Verwende `class`, wenn du **Verhalten, Kapselung, Logik** einbauen willst\n",
      "\n",
      "üëâ Aber technisch gesehen sind beide fast identisch ‚Äì nur der Standardzugriff unterscheidet sich!"
    ],
    "code": [
      "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n\n    void anzeigen() {\n        std::cout << \"x: \" << x << \", y: \" << y << std::endl;\n    }\n};\n\nclass Person {\nprivate:\n    std::string name;\npublic:\n    Person(const std::string& n) : name(n) {}\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Punkt p = {3, 5};\n    p.anzeigen();   // x: 3, y: 5\n\n    Person pers(\"Kilian\");\n    pers.anzeigen(); // Name: Kilian\n\n    return 0;\n}"
    ]
  }
}

    ]
  },
  {
    "category": "√úberladung",
    "subtopics": [
      {
        "title": "Funktionen",
        "content": {
          "text": [
            "### === Funktions√ºberladung in C++ ===\n",
            "Funktions√ºberladung bedeutet, dass mehrere Funktionen **denselben Namen**, aber **unterschiedliche Parameterlisten** haben k√∂nnen.\n",
            "\n",
            "Der Compiler w√§hlt beim Aufruf die passende Funktion anhand der √ºbergebenen Argumente.\n",
            "\n",
            "### Regeln\n",
            "- Funktionen m√ºssen sich in der Anzahl oder dem Typ der Parameter unterscheiden\n",
            "- R√ºckgabewert allein reicht **nicht** zur Unterscheidung!\n",
            "\n",
            "### Vorteile\n",
            "- Lesbarkeit: Gleicher Funktionsname f√ºr √§hnliche Aufgaben\n",
            "- Flexibilit√§t: Funktion kann mit verschiedenen Datentypen arbeiten\n"
          ],
          "code": [
            "#include <iostream>\n\n// Funktions√ºberladungen\nvoid begruessung() {\n  std::cout << \"Hallo!\" << std::endl;\n}\n\nvoid begruessung(std::string name) {\n  std::cout << \"Hallo, \" << name << \"!\" << std::endl;\n}\n\nvoid begruessung(int stunde) {\n  if (stunde < 12)\n    std::cout << \"Guten Morgen!\" << std::endl;\n  else\n    std::cout << \"Guten Tag!\" << std::endl;\n}",
            "int main() {\n  begruessung();              // Ausgabe: Hallo!\n  begruessung(\"Kilian\");     // Ausgabe: Hallo, Kilian!\n  begruessung(9);             // Ausgabe: Guten Morgen!\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Operatoren",
        "content": {
          "text": [
            "### === Operator√ºberladung in C++ ===\n",
            "Operator√ºberladung erlaubt es, **eigene Klassen** so zu definieren, dass Standard-Operatoren (`+`, `==`, `<<`, usw.) auch mit diesen Klassen funktionieren.\n",
            "\n",
            "### Warum Operatoren √ºberladen?\n",
            "- Mehr Lesbarkeit: `a + b` statt `a.addiere(b)`\n",
            "- Nat√ºrlichere Verwendung eigener Typen\n",
            "\n",
            "### Syntax\n",
            "`R√ºckgabetyp operator<OPERATOR>(Parameter)`\n",
            "-> Wird innerhalb oder au√üerhalb der Klasse definiert\n",
            "-> Kann fast jeder Operator √ºberladen werden (au√üer z.‚ÄØB. `.` oder `::`)\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Punkt {\nprivate:\n  int x, y;\n\npublic:\n  Punkt(int x, int y) : x(x), y(y) {}\n\n  // Operator√ºberladung f√ºr +\n  Punkt operator+(const Punkt& other) {\n    return Punkt(x + other.x, y + other.y);\n  }\n\n  // Ausgabeoperator √ºberladen (als friend)\n  friend std::ostream& operator<<(std::ostream& os, const Punkt& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n  }\n};",
            "int main() {\n  Punkt a(2, 3);\n  Punkt b(4, 1);\n  Punkt c = a + b;\n\n  std::cout << \"a + b = \" << c << std::endl; // Ausgabe: a + b = (6, 4)\n\n  return 0;\n}"
          ]
        }
      }
    ]
  },
  {
    "category": "Extras",
    "subtopics": [
    {
  "title": "Casting",
  "content": {
    "text": [
      "### === Casting in C++ ===\n",
      "Casting ist die Umwandlung eines Ausdrucks von einem Datentyp in einen anderen.\n",
      "In C++ gibt es sowohl **C-Style Casts** als auch **C++-spezifische Casts**:\n",
      "\n",
      "### üü• C-Style Cast (unsicher!)\n",
      "```cpp\nint x = (int)3.14;   // Ergebnis: 3\n```\n",
      "- Alt, kompakt, aber **unsicher**\n",
      "- Kann **gef√§hrliche Typumwandlungen** stillschweigend zulassen\n",
      "\n",
      "### ‚úÖ C++ Casts (sicherer & spezifischer):\n",
      "\n",
      "#### üîπ static_cast<T>(expr)\n",
      "- F√ºr **sichere, logische Konvertierungen** (z.‚ÄØB. `double` ‚Üí `int`, `Base*` ‚Üí `Derived*` bei Vererbung ohne RTTI)\n",
      "```cpp\nint x = static_cast<int>(3.7);  // x = 3\n```\n",
      "\n",
      "#### üîπ dynamic_cast<T>(expr)\n",
      "- F√ºr **sichere Konvertierung bei Vererbung** mit `virtual`\n",
      "- Funktioniert nur mit **Polymorphie** (mind. eine `virtual`-Methode)\n",
      "- Gibt `nullptr` zur√ºck, wenn Cast fehlschl√§gt\n",
      "```cpp\nBase* b = new Derived();\nDerived* d = dynamic_cast<Derived*>(b);  // OK\n```\n",
      "\n",
      "#### üîπ reinterpret_cast<T>(expr)\n",
      "- F√ºr **rohe Speicherumwandlungen**, z.‚ÄØB. zwischen Zeigertypen\n",
      "- Sehr gef√§hrlich ‚Äì nur mit gro√üem Verst√§ndnis verwenden\n",
      "```cpp\nint* p = reinterpret_cast<int*>(0x1234);\n```\n",
      "\n",
      "#### üîπ const_cast<T>(expr)\n",
      "- Entfernt oder f√ºgt `const` hinzu (z.‚ÄØB. um schreibende Funktion auf `const`-Objekte anzuwenden)\n",
      "- Nur erlaubt, wenn Ursprungsobjekt nicht wirklich `const` war\n",
      "```cpp\nconst int* p = ...;\nint* mod = const_cast<int*>(p);\n```\n",
      "\n",
      "### üëá Empfehlung:\n",
      "- Verwende **`static_cast` f√ºr fast alles**, wenn du den Typ kennst\n",
      "- **Vermeide `reinterpret_cast` und `C-Style`-Casts**, wenn m√∂glich\n",
      "- **Nutze `dynamic_cast` nur bei Vererbung**, sonst bringt es nichts\n",
      "- **Vermeide `const_cast`**, au√üer in Spezialf√§llen\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\" << std::endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\" << std::endl; }\n};\n\nint main() {\n    double pi = 3.14;\n    int x = static_cast<int>(pi);               // static_cast: 3\n    std::cout << \"x: \" << x << std::endl;\n\n    Base* base = new Derived();\n    Derived* d = dynamic_cast<Derived*>(base);  // dynamic_cast: OK\n    if (d) d->show();                           // Ausgabe: Derived\n\n    const int a = 42;\n    int* b = const_cast<int*>(&a);              // const_cast: ‚ö†Ô∏è gef√§hrlich\n    std::cout << \"b: \" << *b << std::endl;\n\n    delete base;\n    return 0;\n}"
    ]
  }
},
      {
        "title": "Algorithmen",
        "content": {
          "text": [
            "### === STL-Algorithmen in C++ ===\n",
            "Die Standard Template Library (STL) bietet viele n√ºtzliche Algorithmen zur Bearbeitung von Containern wie `vector`, `set`, `map`, etc.\n",
            "\n",
            "### Wichtige Algorithmen:\n",
            "- `std::sort`: Sortiert Elemente (ben√∂tigt `<algorithm>`)\n",
            "- `std::reverse`: Dreht die Reihenfolge um\n",
            "- `std::find`: Sucht ein bestimmtes Element\n",
            "- `std::count`: Z√§hlt, wie oft ein bestimmter Wert vorkommt\n",
            "- `std::for_each`: F√ºhrt eine Funktion auf jedem Element aus\n",
            "- `std::remove`: Entfernt (logisch) ein Element ‚Äì mit `erase` kombinieren\n",
            "\n",
            "### Allgemein\n",
            "- Alle Algorithmen arbeiten mit **Iteratoren** (z.‚ÄØB. `begin()` / `end()`)\n",
            "- STL-Algorithmen ver√§ndern nicht den Container direkt (au√üer `sort`, `reverse`, etc.)\n",
            "- Viele Algorithmen nutzen **Lambdas** oder Funktionsobjekte\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr sort, find, etc.\n\nint main() {\n  std::vector<int> zahlen = {4, 2, 7, 2, 9};\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end());\n\n  // ausgeben\n  std::cout << \"Sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \";\n  std::cout << std::endl; // Ausgabe: 2 2 4 7 9\n\n  // z√§hlen\n  int anz = std::count(zahlen.begin(), zahlen.end(), 2);\n  std::cout << \"Die Zahl 2 kommt \" << anz << \" mal vor.\" << std::endl;\n\n  // suchen\n  auto it = std::find(zahlen.begin(), zahlen.end(), 7);\n  if (it != zahlen.end()) {\n    std::cout << \"7 gefunden an Position \" << (it - zahlen.begin()) << std::endl; //(it - zahlen.begin()) == Abstand im Container\n  }\n\n  // for_each mit Lambda\n  std::cout << \"Alle Werte verdoppelt: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x * 2 << \" \"; });\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Templates",
        "content": {
          "text": [
            "### === Templates in C++ ===\n",
            "Templates erm√∂glichen es, **generischen Code** zu schreiben, der mit beliebigen Datentypen funktioniert.\n",
            "\n",
            "### Warum Templates?\n",
            "- Wiederverwendbarkeit: gleiche Funktion/Klasse f√ºr viele Datentypen\n",
            "- Flexibilit√§t: z.‚ÄØB. `int`, `double`, `std::string`, eigene Typen\n",
            "- Kein mehrfacher Code n√∂tig f√ºr unterschiedliche Typen\n",
            "\n",
            "### Funktions-Template\n",
            "```cpp\n template <typename T>\n T max(T a, T b) {\n   return (a > b) ? a : b;\n }\n```\n",
            "`T` ist ein Platzhalter f√ºr einen beliebigen Typ.\n",
            "Beim Aufruf wird automatisch der passende Typ eingesetzt (Typinferenz).\n",
            "\n",
            "### Einschr√§nkung bei Operatoren\n",
            "Ein Funktions-Template wie `addiere(T a, T b)` funktioniert **nur, wenn f√ºr `T` der `+`-Operator definiert ist**.\n",
            "Beispiele, wo es funktioniert:\n",
            "- `int`, `double`, `std::string`\n",
            "Bei eigenen Typen (z.‚ÄØB. `struct Person`) musst du den `operator+` **selbst √ºberladen**, damit das Template funktioniert.\n",
            "\n",
            "### Klassen-Template\n",
            "```cpp\n template <typename T>\n class Box {\n   T inhalt;\n   // ...\n };\n```\n",
            "Auch Klassen lassen sich so f√ºr beliebige Typen definieren.\n"
          ],
          "code": [
            "#include <iostream>\n\n// Funktions-Template\ntemplate <typename T>\nT addiere(T a, T b) {\n  return a + b;\n}",
            "// Klassen-Template\ntemplate <typename T>\nclass Beh√§lter {\nprivate:\n  T wert;\n\npublic:\n  Beh√§lter(T w) : wert(w) {}\n\n  void anzeigen() {\n    std::cout << \"Wert: \" << wert << std::endl;\n  }\n};",
            "int main() {\n  std::cout << \"Summe: \" << addiere(3, 4) << std::endl;         // int\n  std::cout << \"Summe: \" << addiere(2.5, 1.2) << std::endl;     // double\n  std::cout << \"Summe: \" << addiere(std::string(\"Hi \"), \"Kilian\") << std::endl; // string\n\n  Beh√§lter<int> b1(42);\n  Beh√§lter<std::string> b2(\"Text\");\n\n  b1.anzeigen();  // Ausgabe: Wert: 42\n  b2.anzeigen();  // Ausgabe: Wert: Text\n\n  return 0;\n}"
          ]
        }
      },
            {
        "title": "Lambdas",
        "content": {
          "text": [
            "### === Lambda-Ausdr√ºcke in C++ ===\n",
            "Ein Lambda ist eine **anonyme Funktion**, die direkt im Code definiert und z.‚ÄØB. an Algorithmen √ºbergeben werden kann.\n",
            "\n",
            "### Warum Lambdas?\n",
            "- Wenn man **kleine Funktionen nur einmalig** braucht (z.‚ÄØB. in `sort`, `for_each`), ist es **unn√∂tig**, extra eine benannte Funktion zu schreiben.\n",
            "- Lambdas machen den Code **k√ºrzer, klarer und direkt an Ort und Stelle**.\n",
            "- Sie lassen sich auch mit lokalen Variablen verkn√ºpfen (√ºber `[]`-Capture).\n",
            "\n",
            "### Syntax\n",
            "`[capture](parameter) -> r√ºckgabetyp { body }`\n",
            "- `capture`: Welche Variablen von au√üen verwendet werden d√ºrfen (z.‚ÄØB. `[x]`, `[&]`, `[=]`, `[]`)\n",
            "- `parameter`: √úbergabeparameter wie bei normalen Funktionen\n",
            "- `r√ºckgabetyp` ist optional (oft automatisch erkannt)\n",
            "\n",
            "### Beispiel ‚Äì einfache Lambda-Funktion\n",
            "`auto quadrat = [](int x) { return x * x; };`\n",
            "`quadrat(5); // ergibt 25`\n",
            "\n",
            "### Lambdas mit Algorithmen\n",
            "Sehr praktisch in Verbindung mit `std::for_each`, `std::sort`, usw.\n",
            "```cpp\n std::for_each(v.begin(), v.end(), [](int x){ std::cout << x << \" \"; });\n```\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr for_each, sort\n\nint main() {\n  std::vector<int> zahlen = {5, 2, 8, 1};\n\n  // Lambda speichern und benutzen\n  auto quadrat = [](int x) { return x * x; };\n  std::cout << \"Quadrat von 4: \" << quadrat(4) << std::endl; // Ausgabe: 16\n\n  // for_each mit Lambda\n  std::cout << \"Zahlen: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x << \" \"; });\n  std::cout << std::endl;\n\n  // sortieren mit Lambda (absteigend)\n  std::sort(zahlen.begin(), zahlen.end(), [](int a, int b){ return a > b; });\n\n  std::cout << \"Absteigend sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \"; // Ausgabe: 8 5 2 1\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Exceptions",
        "content": {
          "text": [
            "### === Exceptions in C++ ===\n",
            "Exceptions (Ausnahmen) dienen der **kontrollierten Fehlerbehandlung** zur Laufzeit.\n",
            "Statt einen Fehler mit `if` zu pr√ºfen, kann ein Fehler als Exception ‚Äûgeworfen‚Äú werden und mit `try`/`catch` behandelt werden.\n",
            "\n",
            "### Warum Exceptions?\n",
            "- Trennen normalen Code von Fehlerbehandlung\n",
            "- Sorgen f√ºr sauberen und robusten Code\n",
            "- Besonders n√ºtzlich bei Funktionen, die fehlschlagen k√∂nnen (z.‚ÄØB. Datei √∂ffnen, Division durch 0, Eingabe pr√ºfen)\n",
            "\n",
            "### Grundstruktur\n",
            "```cpp\n try {\n   // Code, der eine Ausnahme werfen kann\n } catch (Typ der Ausnahme) {\n   // Fehlerbehandlung\n }\n```\n",
            "-> Mit `throw` wirft man eine Ausnahme\n",
            "-> Mit `catch` f√§ngt man sie ab\n",
            "\n",
            "### Typen\n",
            "- Beliebige Datentypen m√∂glich: `int`, `std::string`, eigene Klassen\n",
            "- Meist verwendet: `std::exception` (und Unterklassen wie `std::runtime_error`)\n",
            "\n",
            "### `ex.what()` erkl√§rt\n",
            "- Wenn du im `catch`-Block `std::exception& ex` abf√§ngst, kannst du `ex.what()` aufrufen\n",
            "- `what()` gibt eine **Fehlermeldung als Text (const char\\*)** zur√ºck\n",
            "- Beispiel:\n",
            "```cpp\n throw std::runtime_error(\"Fehler beim Laden der Datei\");\n // sp√§ter:\n catch (const std::exception& ex) {\n   std::cout << ex.what(); // Ausgabe: Fehler beim Laden der Datei\n }\n```\n",
            "- Eigene Klassen m√ºssen `what()` selbst definieren, wenn du diesen Mechanismus nutzen willst\n"
          ],
          "code": [
            "#include <iostream>\n#include <stdexcept> // f√ºr std::runtime_error\n\nint teile(int a, int b) {\n  if (b == 0) {\n    throw std::runtime_error(\"Division durch 0 nicht erlaubt\");\n  }\n  return a / b;\n}",
            "int main() {\n  try {\n    int ergebnis = teile(10, 0);\n    std::cout << \"Ergebnis: \" << ergebnis << std::endl;\n  } catch (const std::exception& ex) {\n    std::cerr << \"Fehler: \" << ex.what() << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
       {
        "title": "Doxygen",
        "content": {
          "text": [
      "### === Doxygen ‚Äì Automatische Dokumentation f√ºr C++ ===\n",
      "Doxygen ist ein Tool, mit dem man aus speziell kommentiertem C++-Code automatisch eine HTML- oder PDF-Dokumentation erzeugen kann ‚Äì √§hnlich wie Javadoc bei Java.\n",
      "\n",
      "### Vorteile von Doxygen:\n",
      "- √úbersichtliche Dokumentation f√ºr gro√üe Projekte\n",
      "- Besseres Verst√§ndnis f√ºr andere Entwickler (oder dich selbst sp√§ter)\n",
      "- Funktioniert direkt aus dem C++-Quellcode\n",
      "\n",
      "### Grundprinzip:\n",
      "- Man kommentiert Klassen, Funktionen, Variablen mit speziellen `/** ... */`- oder `///`-Bl√∂cken\n",
      "- Doxygen liest diese Kommentare und erzeugt daraus eine strukturierte Dokumentation\n",
      "\n",
      "### Wichtige Doxygen-Kommentare:\n",
      "- `@brief`: Kurzbeschreibung\n",
      "- `@param`: Beschreibung eines Parameters\n",
      "- `@return`: R√ºckgabewert\n",
      "- `@author`, `@version`, `@date`, ...\n",
      "\n",
      "### Beispiel f√ºr eine dokumentierte Funktion:\n",
      "```cpp\n/**\n * @brief Addiert zwei Zahlen\n * @param a Erste Zahl\n * @param b Zweite Zahl\n * @return Summe von a und b\n */\nint addiere(int a, int b) {\n    return a + b;\n}\n```\n",
      "\n",
      "### So benutzt du Doxygen:\n",
      "1. Lade dir Doxygen von https://www.doxygen.nl/download.html herunter\n",
      "2. Starte das Tool (`doxygen -g`) und bearbeite die `Doxyfile`\n",
      "3. F√ºge deinen Projektpfad ein\n",
      "4. F√ºhre Doxygen aus: `doxygen Doxyfile`\n",
      "5. Dokumentation wird im `html/` oder `latex/`-Ordner erstellt\n",
      "\n",
      "üëâ Doxygen wird besonders im Beruf, in Open-Source-Projekten oder bei Bibliotheken verwendet\n",
      "üëâ Du kannst es auch lokal nutzen, um dein Projekt ordentlich zu strukturieren"
    ],
          "code": []
        }
      }
    ]
  },

  {
    "category": "Struktur",
    "subtopics": [
                  {
   "title": "Namespaces",
   "content": {
   "text": [
      "### === Namespaces in C++ ===\n",
      "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
      "\n",
      "### Warum Namespaces?\n",
      "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
      "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
      "\n",
      "### Verwendung von Namespaces\n",
      "- Definition:\n",
      "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
      "- Aufruf:\n",
      "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
      "\n",
      "### `using namespace` (nicht immer empfohlen)\n",
      "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
      "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
      "- Besser: Nur gezielt importieren\n",
      "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
      "\n",
      "### Anonyme Namespaces (Datei-spezifisch)\n",
      "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
      "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
      "\n",
      "### Verschachtelte Namespaces (modernes C++)\n",
      "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
      "\n",
      "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
      "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n"
    ],
    "code": [
            "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
          ]
        }
      },
      {
      "title": "Namespace vs. Class",
      "content": {
      "text": [
            "### === Unterschied: Namespace vs. Class ===\n",
            "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
            "\n",
            "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
            "|----------------------|-----------------------------------------|-------------------------------------------|\n",
            "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
            "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
            "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
            "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
            "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
            "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
            "\n",
            "### Beispiel zur Verdeutlichung:\n",
            "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
            "\n",
            "üëâ Merksatz: `namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**."
          ],
          "code": []
        }
      },
      {
  "title": "Zeiger & this-Zeiger",
  "content": {
    "text": [
      "### === Zeiger in C++ ===\n",
      "Ein Zeiger ist eine Variable, die die Adresse eines anderen Objekts speichert.\n",
      "\n",
      "### Zeiger-Grundlagen:\n",
      "- `int* ptr;` ‚Üí zeigt auf eine `int`-Variable\n",
      "- `*ptr` ‚Üí greift auf den Wert zu\n",
      "- `&x` ‚Üí gibt die Adresse von `x` zur√ºck\n",
      "\n",
      "```cpp\nint x = 10;\nint* ptr = &x;\n*ptr = 20;  // x wird ge√§ndert\n```\n",
      "\n",
      "### Dynamischer Speicher:\n",
      "- Mit `new` wird Speicher auf dem Heap reserviert\n",
      "- Mit `delete` muss er wieder freigegeben werden\n",
      "```cpp\nint* p = new int(5);\ndelete p;\n```\n",
      "\n",
      "### Zeiger auf Objekte:\n",
      "- Klassenobjekte k√∂nnen ebenfalls per Zeiger angesprochen werden\n",
      "- Zugriff √ºber `->`\n",
      "```cpp\nPerson* p = new Person(\"Kilian\");\np->anzeigen();\ndelete p;\n```\n",
      "\n",
      "### === `this`-Zeiger ===\n",
      "- Jede Memberfunktion hat automatisch Zugriff auf `this`\n",
      "- `this` ist ein Zeiger auf das **aktuelle Objekt**\n",
      "- Wird z.‚ÄØB. f√ºr Vergleich, R√ºckgabe oder Methodenkette genutzt\n",
      "\n",
      "```cpp\nclass Test {\n    int wert;\npublic:\n    Test(int w) : wert(w) {}\n\n    Test& setWert(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n```\n",
      "\n",
      "üëâ So kann man z.‚ÄØB. Methoden verkettet aufrufen: `obj.setWert(5).setWert(10);`\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\nprivate:\n    int wert;\n\npublic:\n    Zahl(int w) : wert(w) {}\n\n    void verdoppeln() {\n        wert *= 2;\n        std::cout << \"[this: \" << this << \"] Wert: \" << wert << std::endl;\n    }\n\n    Zahl& setze(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n\nint main() {\n    int x = 5;\n    int* ptr = &x;\n    std::cout << \"Zeiger: \" << *ptr << std::endl;  // 5\n\n    *ptr = 10;\n    std::cout << \"x: \" << x << std::endl;           // 10\n\n    Zahl z(7);\n    z.verdoppeln();          // 14\n    z.setze(3).verdoppeln(); // 6\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Smart Pointer",
  "content": {
    "text": [
      "### === Smart Pointer in C++ ===\n",
      "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
      "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
      "\n",
      "### Warum Smart Pointer?\n",
      "- Kein manuelles `delete` n√∂tig\n",
      "- Klare Besitzverh√§ltnisse\n",
      "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
      "\n",
      "### üîπ `std::unique_ptr<T>`\n",
      "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
      "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
      "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
      "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
      "\n",
      "### üîπ `std::shared_ptr<T>`\n",
      "- **Mehrere Besitzer** teilen sich das Objekt\n",
      "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
      "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
      "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
      "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
      "\n",
      "### üîπ `std::weak_ptr<T>`\n",
      "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
      "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
      "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
      "\n",
      "### üîç Vergleichstabelle:\n",
      "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
      "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
      "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
      "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "const",
  "content": {
    "text": [
      "### === `const` in C++ ===\n",
      "`const` sch√ºtzt vor ungewollten √Ñnderungen ‚Äì je nach Position bedeutet es etwas anderes:\n",
      "\n",
      "### üîπ `const` bei Variablen:\n",
      "- Der Wert darf **nicht ver√§ndert** werden\n",
      "```cpp\nconst int x = 5;\n// x = 10; // ‚ùå Fehler\n```\n",
      "\n",
      "### üîπ `const` bei Funktionsparametern:\n",
      "- Verhindert √Ñnderungen am √úbergabewert\n",
      "```cpp\nvoid zeige(const std::string& text);\n```\n",
      "- spart **Kopieraufwand** + sch√ºtzt Daten\n",
      "\n",
      "### üîπ `const`-Methoden:\n",
      "- Garantie, dass innerhalb der Methode **nichts ver√§ndert wird**\n",
      "```cpp\nclass Person {\n    std::string name;\npublic:\n    std::string getName() const; // ‚ùå darf name nicht √§ndern\n};\n```\n",
      "\n",
      "### üîπ `const` bei Zeigern:\n",
      "| Schreibweise           | Bedeutung                               |\n",
      "| `const int* p`        | Zeiger auf **konstante Daten**           |\n",
      "| `int* const p`        | **Konstanter Zeiger** auf Daten          |\n",
      "| `const int* const p`  | **Beides konstant**                      |\n",
      "\n",
      "```cpp\nconst int* p = &x;   // *p darf nicht ge√§ndert werden\nint* const q = &x;   // q darf nicht woanders hinzeigen\n```\n",
      "\n",
      "### üîπ `const` bei R√ºckgabewerten:\n",
      "- Schutz vor Modifikation des R√ºckgabewerts\n",
      "```cpp\nconst std::string& getName() const;  // R√ºckgabe nicht modifizierbar\n```\n",
      "\n",
      "### Merksatz:\n",
      "- Lies `const` **von rechts nach links**:\n",
      "    - `int* const` = konstanter Zeiger auf int\n",
      "    - `const int*` = Zeiger auf konstantes int\n",
      "\n",
      "üëâ `const` hilft, **Bugs zu vermeiden**, **Lesbarkeit zu erh√∂hen** und ist **Best Practice** in modernem C++\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n    std::string name;\n\npublic:\n    Person(const std::string& n) : name(n) {}\n\n    // const-Methode: darf nichts ver√§ndern\n    std::string getName() const {\n        return name;\n    }\n\n    // const-R√ºckgabe + const-Parameter\n    void begruessung(const std::string& begrussung) const {\n        std::cout << begrussung << \", \" << name << \"!\" << std::endl;\n    }\n};\n\nint main() {\n    const int x = 5;\n    // x = 10; // ‚ùå nicht erlaubt\n\n    const int* ptr1 = &x;    // Zeiger auf konstanten Wert\n    // *ptr1 = 20; // ‚ùå nicht erlaubt\n\n    int y = 8;\n    int* const ptr2 = &y;    // Konstanter Zeiger\n    *ptr2 = 12;              // ‚úÖ erlaubt\n\n    Person p(\"Kilian\");\n    p.begruessung(\"Hallo\");\n    std::cout << \"Name: \" << p.getName() << std::endl;\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "static",
  "content": {
    "text": [
      "### === `static` in C++ ===\n",
      "`static` hat in C++ mehrere Bedeutungen ‚Äì je nachdem, **wo** es verwendet wird:\n",
      "\n",
      "### üîπ `static` innerhalb einer Funktion:\n",
      "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
      "- Bleibt zwischen Aufrufen **erhalten**\n",
      "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
      "\n",
      "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
      "- Mitglied geh√∂rt **zur Klasse, nicht zum Objekt**\n",
      "- Wird **au√üerhalb der Klasse** definiert\n",
      "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;  // Definition au√üerhalb\n```\n",
      "\n",
      "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
      "- Macht die Funktion **nur in dieser Datei sichtbar** (interne Verlinkung)\n",
      "- Wird bei Modularisierung genutzt\n",
      "\n",
      "### Unterschiede im Verhalten:\n",
      "| Kontext         | Bedeutung                                               |\n",
      "| In Funktion     | Lebensdauer √ºber Funktionsaufrufe hinaus                 |\n",
      "| In Klasse       | Gleicher Wert f√ºr **alle Objekte**                       |\n",
      "| Au√üerhalb       | Nur in derselben Datei sichtbar (file-scope)             |\n",
      "\n",
      "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Zugriff zu begrenzen**\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;  // Deklaration\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;   // Definition au√üerhalb der Klasse\n\nvoid funktionMitStatic() {\n    static int x = 0;    // bleibt erhalten √ºber mehrere Aufrufe\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl;  // 1, dann 2\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl;  // 2\n\n    funktionMitStatic();  // static in Funktion: 1\n    funktionMitStatic();  // static in Funktion: 2\n\n    return 0;\n}"
    ]
  }
}

    ]
  },

  {
    "category": "Speicherverwaltung",
    "subtopics": [
      {
  "title": "Heap (new / new[])",
  "content": {
    "text": [
      "### === Heap-Speicher in C++ (new / delete) ===\n",
      "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
      "\n",
      "### üîπ Warum Heap?\n",
      "- Stack ist nur f√ºr **kurzlebige, kleine** Daten\n",
      "- Heap erlaubt **dynamische Gr√∂√üe** und **l√§ngere Lebenszeit**\n",
      "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
      "\n",
      "### üî∏ `new` f√ºr EIN Objekt:\n",
      "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
      "- Speicher f√ºr genau **ein Objekt** wird angefordert\n",
      "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
      "\n",
      "### üî∏ `new[]` f√ºr MEHRERE Objekte (Array):\n",
      "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
      "- Reserviert **zusammenh√§ngenden Speicherplatz** f√ºr mehrere Objekte\n",
      "- Muss mit **`delete[]`** freigegeben werden!\n",
      "\n",
      "### ‚ùó Vorsicht bei falscher Kombination:\n",
      "- `new[]` ‚Üí `delete[]`\n",
      "- `new` ‚Üí `delete`\n",
      "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
      "\n",
      "### üîπ Klassen & Konstruktoren:\n",
      "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
      "\n",
      "### üîπ Wann `new[]` statt `new`?\n",
      "- Wenn du mehrere gleichartige Objekte brauchst ‚Üí `new[]`\n",
      "- Wenn du nur ein einzelnes Objekt brauchst ‚Üí `new`\n",
      "\n",
      "### ‚ùó Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
      "üëâ Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nint main() {\n    // new f√ºr EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] f√ºr MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt l√∂schen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gel√∂scht\n    delete[] pArr;  // 2x Punkt gel√∂scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Speicherverwaltung: Heap vs. Stack",
  "content": {
    "text": [
      "### === Speicherverwaltung in C++: Stack vs. Heap ===\n",
      "In C++ unterscheidet man bei der Speichervergabe zwischen **Stack** und **Heap**:\n",
      "\n",
      "### üîπ Stack-Speicher (automatisch)\n",
      "- Wird f√ºr **lokale Variablen** verwendet\n",
      "- Speicher wird **automatisch** freigegeben, wenn der Block verlassen wird\n",
      "- Sehr schnell & sicher, aber begrenzt (Stack Overflow bei gro√üen Arrays)\n",
      "\n",
      "```cpp\nvoid funktion() {\n    int a = 10;        // auf dem Stack\n} // a wird automatisch gel√∂scht\n```\n",
      "\n",
      "### üîπ Heap-Speicher (dynamisch)\n",
      "- Wird bei Bedarf mit `new` reserviert und mit `delete` freigegeben\n",
      "- Muss **manuell** verwaltet werden ‚Üí Gefahr von Speicherlecks\n",
      "- Gr√∂√üer, aber langsamer als der Stack\n",
      "\n",
      "```cpp\nint* ptr = new int(5);  // Speicher im Heap\n*ptr = 42;\ndelete ptr;             // Speicher freigeben\n```\n",
      "\n",
      "### üîπ Vergleich:\n",
      "| Merkmal     | Stack                     | Heap                          |\n",
      "| Geschwindigkeit | Sehr schnell              | Langsamer                    |\n",
      "| Lebensdauer | Block-lokal (automatisch) | Manuell, bis `delete`        |\n",
      "| Speichergr√∂√üe | Begrenzter Speicher       | Gr√∂√üerer Speicher verf√ºgbar  |\n",
      "| Fehlerquellen | Stack Overflow m√∂glich    | Speicherlecks, Dangling Ptr  |\n",
      "\n",
      "### üî∏ Modern C++ Tipp:\n",
      "- Statt `new` / `delete` ‚Üí besser `std::unique_ptr`, `std::shared_ptr`\n",
      "- Smart Pointer √ºbernehmen Speicherverwaltung automatisch\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory> // f√ºr Smart Pointer\n\nvoid stackBeispiel() {\n    int zahl = 10;                    // Stack-Speicher\n    std::cout << \"Stack: \" << zahl << std::endl;\n} // zahl wird automatisch gel√∂scht\n\nvoid heapBeispiel() {\n    int* ptr = new int(42);           // Heap-Speicher\n    std::cout << \"Heap: \" << *ptr << std::endl;\n    delete ptr;                       // manuell l√∂schen\n}\n\nvoid smartPointerBeispiel() {\n    std::unique_ptr<int> sp = std::make_unique<int>(100);\n    std::cout << \"SmartPointer: \" << *sp << std::endl;\n} // wird automatisch gel√∂scht\n\nint main() {\n    stackBeispiel();\n    heapBeispiel();\n    smartPointerBeispiel();\n    return 0;\n}"
    ]
  }
}

    ]
  }
  
]

