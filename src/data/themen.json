[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          {
          "title": "Namensgebung in C++",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Namensgebung",
              "text": "Namensgebung beschreibt die Regeln und Konventionen zur Benennung von Variablen, Funktionen, Klassen, Typen und anderen Bezeichnern in C++ mit dem Ziel, Code verst√§ndlich, wartbar und eindeutig zu machen."
            },
            {
              "type": "explanation",
              "title": "Warum Namensgebung wichtig ist",
              "text": [
                "C++ erlaubt sehr viele g√ºltige Bezeichner, aber nur ein kleiner Teil davon ist sinnvoll. Der Compiler pr√ºft nur die Syntax, nicht ob ein Name verst√§ndlich ist.",
                "Gute Namen transportieren Bedeutung, reduzieren Kommentare und helfen dabei, Fehler schneller zu erkennen. Schlechte Namen machen selbst korrekten Code schwer wartbar."
              ]
            },
            {
              "type": "list",
              "title": "Allgemeine Regeln f√ºr Bezeichner",
              "items": [
                "Bezeichner bestehen aus Buchstaben, Ziffern und Unterstrichen",
                "Ein Bezeichner darf nicht mit einer Ziffer beginnen",
                "Gro√ü und Kleinschreibung sind relevant",
                "Reservierte Schl√ºsselw√∂rter d√ºrfen nicht verwendet werden"
              ]
            },
            {
              "type": "comparison",
              "title": "Gro√ü und Kleinschreibung",
              "columns": ["Bezeichner", "Bedeutung"],
              "rows": [
                {
                  "aspect": "value vs Value",
                  "values": ["zwei verschiedene Namen", "Gro√üschreibung erzeugt einen anderen Bezeichner"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "√úbliche Namenskonventionen in C++",
              "text": [
                "C++ selbst erzwingt keine Namenskonventionen, aber in der Praxis haben sich feste Muster etabliert, um Code konsistent zu halten.",
                "Welche Konvention genutzt wird, h√§ngt oft vom Projekt, Team oder Styleguide ab, sollte aber innerhalb eines Projekts einheitlich sein."
              ]
            },
            {
              "type": "list",
              "title": "Typische Konventionen",
              "items": [
                "Variablen und Funktionen meist klein geschrieben",
                "Mehrteilige Namen werden oft mit Unterstrichen getrennt",
                "Klassen und Typen beginnen h√§ufig mit einem Gro√übuchstaben",
                "Konstanten werden oft komplett gro√ü geschrieben"
              ]
            },
            {
              "type": "code",
              "title": "Beispiele f√ºr g√ºltige Bezeichner",
              "language": "cpp",
              "code": "int age;\nint user_count;\nvoid calculateSum();\nclass PatientRecord {};\nconst int MAX_SIZE = 100;"
            },
            {
              "type": "example",
              "title": "Gute vs. schlechte Namen",
              "text": [
                "count ist besser als c",
                "calculateAverage ist besser als func1",
                "patient_age ist verst√§ndlicher als pa"
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrdeutige oder nichtssagende Namen",
              "text": "Kurze oder generische Namen wie x, tmp oder data sagen nichts √ºber ihre Bedeutung aus und f√ºhren schnell zu Verst√§ndnisproblemen."
            },
            {
              "type": "important",
              "text": "Ein guter Name erkl√§rt seine Bedeutung ohne zus√§tzlichen Kommentar."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Moderne C++ Projekte legen gro√üen Wert auf sprechende Namen, da Code h√§ufiger gelesen als geschrieben wird."
            },
            {
              "type": "note",
              "variant": "exam",
              "text": "In Pr√ºfungen wird oft erwartet, dass Bezeichner sinnvoll gew√§hlt sind, auch wenn die Syntax korrekt ist."
            },
            {
              "type": "summary",
              "points": [
                "C++ erlaubt viele Namen, aber nicht jeder ist sinnvoll",
                "Gro√ü und Kleinschreibung unterscheidet Bezeichner",
                "Einheitliche Konventionen erh√∂hen Lesbarkeit",
                "Sprechende Namen sind wichtiger als kurze Namen"
              ]
            }
          ]
        },
          {
            "title": "Wichtige Grundbegriffe in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Deklaration",
                "text": "Macht einen Namen und seinen Typ bekannt, ohne ihn zwingend vollst√§ndig festzulegen. (z.B. `int x;`)"
              },
              {
                "type": "definition",
                "term": "Definition",
                "text": "Legt Speicher oder die konkrete Implementierung eines Namens fest. (z.B. `int x = 5;`)"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Vergibt beim Erzeugen einer Variable direkt einen Startwert."
              },
              {
                "type": "definition",
                "term": "Zuweisung",
                "text": "√Ñndert den Wert einer bereits existierenden Variable."
              },
              {
                "type": "definition",
                "term": "Variable",
                "text": "Ein benannter Speicherbereich zur Ablage von Daten."
              },
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Legt fest, welche Art von Wert gespeichert wird und wie viel Speicher ben√∂tigt wird."
              },
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "definition",
                "term": "Funktion",
                "text": "Ein benannter Codeblock, der eine bestimmte Aufgabe ausf√ºhrt."
              },
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Platzhalter in der Funktionsdefinition f√ºr √ºbergebene Werte."
              },
              {
                "type": "definition",
                "term": "Argument",
                "text": "Konkreter Wert, der beim Funktionsaufruf √ºbergeben wird."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Scope",
                "text": "Der G√ºltigkeitsbereich, in dem ein Name verwendet werden darf."
              },
              {
                "type": "definition",
                "term": "Block",
                "text": "Ein zusammengeh√∂riger Codebereich, der durch geschweifte Klammern begrenzt ist."
              },
              {
                "type": "definition",
                "term": "Namespace",
                "text": "Ein Namensraum zur Strukturierung und Vermeidung von Namenskonflikten."
              },
              {
                "type": "definition",
                "term": "Klasse",
                "text": "Ein Bauplan f√ºr Objekte, der Daten und Funktionen zusammenfasst."
              },
              {
                "type": "definition",
                "term": "Objekt",
                "text": "Eine konkrete Instanz einer Klasse."
              },
              {
                "type": "definition",
                "term": "Konstruktor",
                "text": "Spezielle Funktion, die beim Erzeugen eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Destruktor",
                "text": "Spezielle Funktion, die beim Zerst√∂ren eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Header-Datei",
                "text": "Datei, die Deklarationen f√ºr andere √úbersetzungseinheiten bereitstellt."
              },
              {
                "type": "definition",
                "term": "Quell-Datei",
                "text": "Datei, die die eigentlichen Definitionen und Implementierungen enth√§lt."
              },
              {
                "type": "important",
                "text": "Diese Begriffe bilden das Fundament zum Verstehen von C++ Code und Compiler-Fehlern."
              },
              {
                "type": "summary",
                "points": [
                  "Deklaration und Definition sind nicht dasselbe",
                  "Parameter geh√∂ren zur Funktion, Argumente zum Aufruf",
                  "Referenzen und Zeiger arbeiten beide mit bestehenden Objekten",
                  "Klassen definieren Strukturen, Objekte sind ihre Instanzen"
                ]
              }
            ]
          },
          {
            "title": "Datentypen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Ein Datentyp legt fest, welche Art von Wert gespeichert wird und wie dieser interpretiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundlegende Datentypen",
                "text": [
                  "Grundlegende Datentypen sind fest in C++ eingebaut und bilden die Basis aller weiteren Typen.",
                  "Sie unterscheiden sich in Speicherbedarf, Wertebereich und Verwendungszweck."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige grundlegende Datentypen",
                "items": [
                  "int: Ganzzahltyp",
                  "double: Gleitkommazahl",
                  "char: Einzelnes Zeichen",
                  "bool: Wahrheitswert true oder false",
                  "void: Kein Wert"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Datentypen Beispiel",
                "language": "cpp",
                "code": "int a = 5;\ndouble b = 3.14;\nbool ok = true;"
              },
              {
                "type": "definition",
                "term": "size_t",
                "text": "Ein vorzeichenloser Ganzzahltyp zur Darstellung von Gr√∂√üen und Indizes."
              },
              {
                "type": "code",
                "title": "size_t Beispiel",
                "language": "cpp",
                "code": "size_t len = 10;"
              },
              {
                "type": "definition",
                "term": "std::string",
                "text": "Ein Standardtyp zur komfortablen Verarbeitung von Texten."
              },
              {
                "type": "code",
                "title": "std::string Beispiel",
                "language": "cpp",
                "code": "std::string name = \"C++\";"
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert f√ºr einen ung√ºltigen Zeiger."
              },
              {
                "type": "code",
                "title": "nullptr Beispiel",
                "language": "cpp",
                "code": "int* p = nullptr;"
              },
              {
                "type": "definition",
                "term": "auto",
                "text": "L√§sst den Compiler den Datentyp einer Variablen automatisch ableiten."
              },
              {
                "type": "code",
                "title": "auto Beispiel",
                "language": "cpp",
                "code": "auto x = 42;"
              },
              {
                "type": "definition",
                "term": "decltype",
                "text": "Ermittelt den Typ eines Ausdrucks, ohne ihn auszuwerten."
              },
              {
                "type": "code",
                "title": "decltype Beispiel",
                "language": "cpp",
                "code": "int a = 0;\ndecltype(a) b = 1;"
              },
              {
                "type": "definition",
                "term": "struct",
                "text": "Ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer Werte."
              },
              {
                "type": "definition",
                "term": "class",
                "text": "Ein benutzerdefinierter Datentyp mit Kapselung und Zugriffskontrolle."
              },
              {
                "type": "code",
                "title": "struct und class mit Funktionen",
                "language": "cpp",
                "code": "struct Point {\n    int x;\n    int y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n};\n\nclass Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n\n    int get() const {\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "enum",
                "text": "Ein Datentyp mit einer festen Menge benannter Ganzzahlwerte."
              },
              {
                "type": "code",
                "title": "enum Beispiel",
                "language": "cpp",
                "code": "enum Color { Red, Green, Blue };"
              },
              {
                "type": "definition",
                "term": "enum class",
                "text": "Stark typisierte Enumeration mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung zu int."
              },
              {
                "type": "code",
                "title": "enum class Beispiel",
                "language": "cpp",
                "code": "enum class Status { Ok, Error, Unknown };\n\nStatus s = Status::Ok;"
              },
              {
                "type": "definition",
                "term": "typedef",
                "text": "Erstellt einen Aliasnamen f√ºr einen bestehenden Datentyp."
              },
              {
                "type": "definition",
                "term": "using",
                "text": "Moderne Alternative zu typedef f√ºr Typaliasse."
              },
              {
                "type": "code",
                "title": "typedef und using Beispiel",
                "language": "cpp",
                "code": "typedef unsigned int uint;\nusing Index = size_t;"
              },
              {
                "type": "explanation",
                "title": "Typumwandlung in C++",
                "text": [
                  "Typumwandlungen werden verwendet, wenn ein Wert in einem anderen Datentyp weiterverarbeitet werden soll.",
                  "Explizite Casts wie static_cast sind sicherer und besser lesbar als implizite Umwandlungen."
                ]
              },
              {
                "type": "list",
                "title": "G√§ngige Cast-Arten",
                "items": [
                  "static_cast: normale, √ºberpr√ºfbare Umwandlungen",
                  "const_cast: Entfernen oder Hinzuf√ºgen von const",
                  "reinterpret_cast: bitweise Umdeutung, sehr gef√§hrlich",
                  "dynamic_cast: sichere Laufzeitpr√ºfung bei Vererbung"
                ]
              },
              {
                "type": "code",
                "title": "Typumwandlung Beispiel",
                "language": "cpp",
                "code": "double d = 4.9;\nint i = static_cast<int>(d);"
              },
              {
                "type": "important",
                "text": "Datentypen bestimmen Speicher, Verhalten und Sicherheit von C++ Programmen."
              },
              {
                "type": "summary",
                "points": [
                  "Grundlegende Typen bilden die Basis aller Programme",
                  "size_t, string und nullptr sind zentrale Standardtypen",
                  "auto und decltype vereinfachen typsicheren Code",
                  "struct, class und enum erlauben eigene Datentypen",
                  "using ersetzt typedef in modernem C++"
                ]
              }
            ]
          },
          {
            "title": "I/O Grundprinzipien in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "I/O",
                "text": "Input und Output bezeichnen das Einlesen von Daten in ein Programm und das Ausgeben von Daten nach au√üen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Ein und Ausgabe",
                "text": [
                  "C++ arbeitet bei Ein und Ausgabe mit sogenannten Streams. Ein Stream ist eine Abfolge von Zeichen oder Daten.",
                  "Programme lesen Daten aus einem Eingabestrom und schreiben Daten in einen Ausgabestrom."
                ]
              },
              {
                "type": "definition",
                "term": "Stream",
                "text": "Ein abstrakter Datenstrom, der Zeichen sequenziell transportiert."
              },
              {
                "type": "definition",
                "term": "Standard Input",
                "text": "Der voreingestellte Eingabestrom, meist die Tastatur."
              },
              {
                "type": "definition",
                "term": "Standard Output",
                "text": "Der voreingestellte Ausgabestrom, meist die Konsole."
              },
              {
                "type": "definition",
                "term": "Standard Error",
                "text": "Separater Ausgabestrom f√ºr Fehlermeldungen."
              },
              {
                "type": "list",
                "title": "Wichtige Standard-Streams",
                "items": [
                  "std::cin: Standardeingabe",
                  "std::cout: Standardausgabe",
                  "std::cerr: Fehlerausgabe",
                  "std::clog: Protokollausgabe"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe mit cout",
                "language": "cpp",
                "code": "std::cout << \"Hallo Welt\" << std::endl;"
              },
              {
                "type": "code",
                "title": "Einfache Eingabe mit cin",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;"
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Schreibt Daten in einen Ausgabestrom."
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Liest Daten aus einem Eingabestrom."
              },
              {
                "type": "explanation",
                "title": "Verkettung von Streams",
                "text": [
                  "Einf√ºge und Extraktionsoperatoren k√∂nnen verkettet werden.",
                  "Dadurch lassen sich mehrere Werte in einer Anweisung ein oder ausgeben."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Ein und Ausgabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b;\nstd::cout << a << \" \" << b;"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Zwischenspeicherung von Ausgaben, bevor sie tats√§chlich geschrieben werden."
              },
              {
                "type": "definition",
                "term": "Flush",
                "text": "Erzwingt das sofortige Schreiben des Ausgabepuffers."
              },
              {
                "type": "code",
                "title": "Flush Beispiel",
                "language": "cpp",
                "code": "std::cout << \"Text\" << std::flush;"
              },
              {
                "type": "pitfall",
                "title": "Eingabe ohne Pr√ºfung",
                "text": "Fehlerhafte Eingaben k√∂nnen Streams in einen Fehlerzustand versetzen und weitere Eingaben verhindern."
              },
              {
                "type": "important",
                "text": "I/O in C++ basiert auf Streams und Operatoren, nicht auf direkten Ger√§tezugriffen."
              },
              {
                "type": "summary",
                "points": [
                  "Ein und Ausgabe erfolgt √ºber Streams",
                  "cin, cout und cerr sind zentrale Standard-Streams",
                  "<< schreibt, >> liest",
                  "Streams k√∂nnen verkettet werden",
                  "Pufferung beeinflusst, wann Ausgaben sichtbar werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          {
            "title": "Arithmetische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Arithmetischer Operator",
                "text": "Ein Operator zur Durchf√ºhrung mathematischer Berechnungen auf numerischen Datentypen."
              },
              {
                "type": "list",
                "title": "Grundlegende arithmetische Operatoren",
                "items": [
                  "+: Addition",
                  "-: Subtraktion",
                  "*: Multiplikation",
                  "/: Division",
                  "%: Modulo Restbildung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Operatoren Beispiel",
                "language": "cpp",
                "code": "int a = 10;\nint b = 3;\nint sum = a + b;\nint diff = a - b;\nint prod = a * b;\nint quot = a / b;\nint rest = a % b;"
              },
              {
                "type": "definition",
                "term": "Ganzzahldivision",
                "text": "Division zweier Ganzzahlen, bei der der Nachkommateil verworfen wird."
              },
              {
                "type": "code",
                "title": "Ganzzahldivision Beispiel",
                "language": "cpp",
                "code": "int x = 7 / 2;"
              },
              {
                "type": "definition",
                "term": "Modulo",
                "text": "Berechnet den Rest einer Ganzzahldivision."
              },
              {
                "type": "explanation",
                "title": "Inkrement und Dekrement",
                "text": [
                  "Inkrement und Dekrement erh√∂hen oder verringern einen Wert um eins.",
                  "Es wird zwischen Pr√§fix und Postfix unterschieden."
                ]
              },
              {
                "type": "list",
                "title": "Inkrement und Dekrement Operatoren",
                "items": [
                  "++x: Pr√§fix Inkrement",
                  "x++: Postfix Inkrement",
                  "--x: Pr√§fix Dekrement",
                  "x--: Postfix Dekrement"
                ]
              },
              {
                "type": "code",
                "title": "Inkrement und Dekrement Beispiel",
                "language": "cpp",
                "code": "int i = 5;\nint a = ++i;\nint b = i++;"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Legt fest, in welcher Reihenfolge Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Operatorpriorit√§t und Klammern",
                "text": [
                  "Multiplikation und Division werden vor Addition und Subtraktion ausgewertet.",
                  "Klammern k√∂nnen verwendet werden, um die Auswertungsreihenfolge explizit festzulegen."
                ]
              },
              {
                "type": "code",
                "title": "Operatorpriorit√§t Beispiel",
                "language": "cpp",
                "code": "int r1 = 2 + 3 * 4;\nint r2 = (2 + 3) * 4;"
              },
              {
                "type": "pitfall",
                "title": "Unerwartete Ganzzahldivision",
                "text": "Division mit int liefert kein Kommaergebnis, auch wenn das mathematisch erwartet wird."
              },
              {
                "type": "important",
                "text": "Der Datentyp der Operanden beeinflusst das Ergebnis arithmetischer Operationen."
              },
              {
                "type": "summary",
                "points": [
                  "Arithmetische Operatoren f√ºhren grundlegende Berechnungen aus",
                  "Ganzzahldivision verwirft den Nachkommateil",
                  "Modulo liefert den Divisionsrest",
                  "Inkrement und Dekrement unterscheiden Pr√§fix und Postfix",
                  "Klammern steuern die Auswertungsreihenfolge"
                ]
              }
            ]
          },
          {
            "title": "Vergleichsoperatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Vergleichsoperator",
                "text": "Ein Operator, der zwei Werte vergleicht und einen booleschen Wert zur√ºckliefert."
              },
              {
                "type": "list",
                "title": "Grundlegende Vergleichsoperatoren",
                "items": [
                  "==: gleich",
                  "!=: ungleich",
                  "<: kleiner als",
                  ">: gr√∂√üer als",
                  "<=: kleiner oder gleich",
                  ">=: gr√∂√üer oder gleich"
                ]
              },
              {
                "type": "code",
                "title": "Vergleichsoperatoren Beispiel",
                "language": "cpp",
                "code": "int a = 5;\nint b = 7;\nbool r1 = (a == b);\nbool r2 = (a < b);"
              },
              {
                "type": "definition",
                "term": "bool",
                "text": "Ein Datentyp mit den m√∂glichen Werten true oder false."
              },
              {
                "type": "explanation",
                "title": "Vergleiche in Bedingungen",
                "text": [
                  "Vergleichsoperatoren werden h√§ufig in if Anweisungen und Schleifen verwendet.",
                  "Das Ergebnis entscheidet √ºber den weiteren Programmfluss."
                ]
              },
              {
                "type": "code",
                "title": "Vergleich in einer Bedingung",
                "language": "cpp",
                "code": "if (a >= 0)\n{\n    std::cout << \"positiv\";\n}"
              },
              {
                "type": "definition",
                "term": "Vergleich von Gleitkommazahlen",
                "text": "Der direkte Vergleich von Gleitkommazahlen kann wegen Rundungsfehlern problematisch sein."
              },
              {
                "type": "pitfall",
                "title": "== statt =",
                "text": "Das Verwechseln von Zuweisung und Vergleich f√ºhrt zu logischen Fehlern."
              },
              {
                "type": "important",
                "text": "Vergleichsoperatoren liefern immer einen booleschen Wert."
              },
              {
                "type": "summary",
                "points": [
                  "Vergleichsoperatoren pr√ºfen Beziehungen zwischen Werten",
                  "Das Ergebnis ist immer true oder false",
                  "Sie steuern Bedingungen und Schleifen",
                  "Besondere Vorsicht bei Gleitkommazahlen"
                ]
              }
            ]
          },
          {
            "title": "Logische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Logischer Operator",
                "text": "Ein Operator zur logischen Verkn√ºpfung oder Negation boolescher Ausdr√ºcke."
              },
              {
                "type": "list",
                "title": "Grundlegende logische Operatoren",
                "items": [
                  "&&: logisches UND",
                  "||: logisches ODER",
                  "!: logisches NICHT"
                ]
              },
              {
                "type": "code",
                "title": "Logische Operatoren Beispiel",
                "language": "cpp",
                "code": "bool a = true;\nbool b = false;\nbool r1 = a && b;\nbool r2 = a || b;\nbool r3 = !a;"
              },
              {
                "type": "definition",
                "term": "Kurzschlussauswertung",
                "text": "Der zweite Operand wird nur ausgewertet, wenn das Ergebnis noch beeinflusst werden kann."
              },
              {
                "type": "explanation",
                "title": "Kurzschlussverhalten",
                "text": [
                  "Bei && wird der zweite Ausdruck nur gepr√ºft, wenn der erste true ist.",
                  "Bei || wird der zweite Ausdruck nur gepr√ºft, wenn der erste false ist."
                ]
              },
              {
                "type": "code",
                "title": "Kurzschluss Beispiel",
                "language": "cpp",
                "code": "if (ptr != nullptr && ptr->value > 0)\n{\n}"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Bestimmt die Reihenfolge, in der logische Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Priorit√§t und Klammern",
                "text": [
                  "! wird vor && ausgewertet.",
                  "&& wird vor || ausgewertet. Klammern erh√∂hen die Lesbarkeit."
                ]
              },
              {
                "type": "code",
                "title": "Priorit√§t Beispiel",
                "language": "cpp",
                "code": "bool r = !a || b && a;\nbool r2 = (!a || b) && a;"
              },
              {
                "type": "pitfall",
                "title": "Bitweise mit logischen Operatoren verwechseln",
                "text": "& und | sind bitweise Operatoren und nicht gleichbedeutend mit && und ||."
              },
              {
                "type": "important",
                "text": "Logische Operatoren arbeiten mit booleschen Ausdr√ºcken und nutzen Kurzschlussauswertung."
              },
              {
                "type": "summary",
                "points": [
                  "&&, || und ! verkn√ºpfen boolesche Ausdr√ºcke",
                  "Kurzschlussauswertung verhindert unn√∂tige Auswertungen",
                  "Operatorpriorit√§t beachten oder Klammern setzen",
                  "Nicht mit bitweisen Operatoren verwechseln"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          {
            "title": "const Variablen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const",
                "text": "const kennzeichnet Werte oder Objekte, die nach ihrer Initialisierung nicht mehr ver√§ndert werden d√ºrfen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const",
                "text": [
                  "const dient dazu, unbeabsichtigte √Ñnderungen zu verhindern und Code verst√§ndlicher zu machen.",
                  "Der Compiler erzwingt die Unver√§nderlichkeit zur √úbersetzungszeit."
                ]
              },
              {
                "type": "code",
                "title": "const Variable",
                "language": "cpp",
                "code": "const int maxValue = 10;"
              },
              {
                "type": "definition",
                "term": "const Initialisierung",
                "text": "const Variablen m√ºssen beim Erzeugen initialisiert werden."
              },
              {
                "type": "pitfall",
                "title": "Fehlende Initialisierung",
                "text": "const Variablen ohne Initialisierung f√ºhren zu Compilerfehlern."
              },
              {
                "type": "definition",
                "term": "const Referenz",
                "text": "Eine Referenz, √ºber die das referenzierte Objekt nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenz Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nconst int& r = x;"
              },
              {
                "type": "definition",
                "term": "const Zeiger",
                "text": "Je nach Position von const kann der Zeiger selbst oder das Ziel unver√§nderlich sein."
              },
              {
                "type": "code",
                "title": "const und Zeiger",
                "language": "cpp",
                "code": "int x = 1;\nconst int* p1 = &x; // Zeiger auf konstante Daten\nint* const p2 = &x; // Konstanter Zeiger auf Daten\nconst int* const p3 = &x; // Beides konstant"
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die den Zustand des Objekts nicht ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "const Memberfunktion Beispiel",
                "language": "cpp",
                "code": "class A {\n    int v;\npublic:\n    int get() const { return v; }\n};"
              },
              {
                "type": "important",
                "text": "const ist ein zentrales Werkzeug f√ºr sicheren und gut wartbaren C++ Code."
              },
              {
                "type": "summary",
                "points": [
                  "const verhindert unbeabsichtigte √Ñnderungen",
                  "const Variablen m√ºssen initialisiert werden",
                  "const kann auf Objekte, Referenzen, Zeiger und Funktionen angewendet werden",
                  "const Memberfunktionen garantieren unver√§nderten Objektzustand"
                ]
              }
            ]
          },
          { "title": "const Parameter", "content": { "text": [], "code": [] } },
          { "title": "const Klassenmember", "content": { "text": [], "code": [] } },
          { "title": "const √úberladen", "content": { 
            "text": [
              "### === `const` √úberladen ===\n",
              "In C++ kann man Funktionen **√ºberladen**, indem man einmal eine `const`- und einmal eine **nicht-`const`-Version** erstellt.\n",
              "\n",
              "---\n",
              "### Warum?\n",
              "- `const`-Objekte d√ºrfen nur `const`-Funktionen aufrufen.\n",
              "- So kann dieselbe Funktion **unterschiedliches Verhalten** haben - je nach `const`-Zustand des Objekts.\n",
              "\n",
              "---\n",
              "### `const` am Ende einer Methode:\n",
              "- Bedeutet: Diese Funktion **ver√§ndert keine Membervariablen** (au√üer `mutable`)\n",
              "- Wichtig f√ºr **Zugriffsmethoden (Getter)** oder bei Funktionen, die nur lesen\n",
              "\n",
              "üëâ `const` ist Teil der Funktionssignatur und wird bei der √úberladung beachtet.\n",
              "---\n"
              ], 
              "code": [    
              "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n  std::string name;\n\npublic:\n  Person(std::string n) : name(n) {}\n\n  // Nicht-const-Version\n  std::string& getName() {\n    std::cout << \"Nicht-const Version\" << std::endl;\n    return name;\n  }\n\n  // Const-Version (f√ºr const Objekte)\n  const std::string& getName() const {\n    std::cout << \"Const-Version\" << std::endl;\n    return name;\n  }\n};\n\nint main() {\n  Person p1(\"Kilian\");\n  const Person p2(\"Lisa\");\n\n  std::cout << p1.getName() << std::endl;  // Ausgabe: Nicht-const Version\\nKilian\n  std::cout << p2.getName() << std::endl;  // Ausgabe: Const-Version\\nLisa\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "constexpr", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          { "title": "cout", "content": { "text": [], "code": [] } },
          { "title": "cin", "content": { "text": [], "code": [] } },
          { "title": "getline", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "ifstream", "content": { "text": [], "code": [] } },
          { "title": "ofstream", "content": { "text": [], "code": [] } },
          { "title": "fstream", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          { "title": "if / else", "content": { "text": [], "code": [] } },
          { "title": "switch", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          { "title": "for", "content": { "text": [], "code": [] } },
          { "title": "while", "content": { "text": [], "code": [] } },
          { "title": "do-while", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          { "title": "Funktionsdefinition", "content": { "text": [], "code": [] } },
          { "title": "Parameter & R√ºckgabe", "content": { "text": [], "code": [] } },
          { "title": "√úberladen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          { "title": "inline", "content": { "text": [], "code": [] } },
          { "title": "constexpr Funktionen", "content": { "text": [], "code": [] } },
          { "title": "Lambda-Funktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          { "title": "C-Arrays", "content": { "text": [], "code": [] } },
          { "title": "std::array", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          { "title": "C-Strings", "content": { "text": [], "code": [] } },
          { "title": "std::string", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          { "title": "Pointer Basics", "content": { "text": [], "code": [] } },
          { "title": "Pointer Arithmetik", "content": { "text": [], "code": [] } },
          { "title": "Nullpointer", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          { "title": "Referenzen Basics", "content": { "text": [], "code": [] } },
          { "title": "Referenzparameter", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          {
          "title": "Stack vs Heap",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Stack",
              "text": "Automatisch verwalteter Speicherbereich f√ºr lokale Variablen und Funktionsaufrufe."
            },
            {
              "type": "definition",
              "term": "Heap",
              "text": "Dynamischer Speicherbereich f√ºr Objekte, deren Lebensdauer manuell oder √ºber Smart Pointer gesteuert wird."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "C++ verwendet zwei zentrale Speicherbereiche: Stack und Heap.",
                "Beide unterscheiden sich stark in Lebensdauer, Geschwindigkeit und Fehleranf√§lligkeit."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften des Stack",
              "items": [
                "Speicher wird automatisch freigegeben",
                "Sehr schneller Zugriff",
                "Lebensdauer an Block oder Funktion gebunden",
                "Begrenzte Gr√∂√üe"
              ]
            },
            {
              "type": "code",
              "title": "Stack Beispiel",
              "language": "cpp",
              "code": "void f() {\n    int x = 10;\n} // x wird automatisch freigegeben"
            },
            {
              "type": "list",
              "title": "Eigenschaften des Heap",
              "items": [
                "Speicher wird dynamisch reserviert",
                "Manuelle oder automatische Freigabe n√∂tig",
                "Gr√∂√üerer Speicherbereich",
                "Langsamer als Stack"
              ]
            },
            {
              "type": "code",
              "title": "Heap Beispiel",
              "language": "cpp",
              "code": "int* p = new int(5);\n// ...\ndelete p;"
            },
            {
              "type": "comparison",
              "title": "Vergleich",
              "columns": ["Stack", "Heap"],
              "rows": [
                {
                  "aspect": "Geschwindigkeit",
                  "values": ["sehr schnell", "langsamer"]
                },
                {
                  "aspect": "Lebensdauer",
                  "values": ["automatisch", "manuell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Dangling Pointer",
              "text": "Ein Pointer zeigt auf Speicher, der bereits freigegeben wurde."
            },
            {
              "type": "important",
              "text": "Manuelle Speicherverwaltung mit new und delete ist fehleranf√§llig."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Verwende bevorzugt std::unique_ptr oder std::shared_ptr statt new und delete."
            },
            {
              "type": "example",
              "title": "Typische Verwendung",
              "text": [
                "Lokale Variablen und Schleifen ‚Üí Stack",
                "Gro√üe Datenstrukturen oder geteilte Objekte ‚Üí Heap"
              ]
            },
            {
              "type": "summary",
              "points": [
                "Stack ist schnell und automatisch",
                "Heap ist flexibel, aber fehleranf√§llig",
                "Modernes C++ vermeidet manuelle Speicherverwaltung"
              ]
            }
          ]
        },
          { "title": "new / delete", "content": { 
            "text": [
              "### === Heap-Speicher in C++ (new / delete) ===\n",
              "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
              "\n",
              "---\n",
              "### üîπ Warum Heap?\n",
              "- Stack ist nur f√ºr **kurzlebige, kleine** Daten\n",
              "- Heap erlaubt **dynamische Gr√∂√üe** und **l√§ngere Lebenszeit**\n",
              "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
              "\n",
              "---\n",
              "### üî∏ `new` f√ºr EIN Objekt:\n",
              "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
              "- Speicher f√ºr genau **ein Objekt** wird angefordert\n",
              "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
              "\n",
              "---\n",
              "### üî∏ `new[]` f√ºr MEHRERE Objekte (Array):\n",
              "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
              "- Reserviert **zusammenh√§ngenden Speicherplatz** f√ºr mehrere Objekte\n",
              "- Muss mit **`delete[]`** freigegeben werden!\n",
              "\n",
              "---\n",
              "### ‚ùó Vorsicht bei falscher Kombination:\n",
              "- `new[]` ‚Üí `delete[]`\n",
              "- `new` ‚Üí `delete`\n",
              "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
              "\n",
              "---\n",
              "### üîπ Klassen & Konstruktoren:\n",
              "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
              "\n",
              "---\n",
              "### üîπ Wann `new[]` statt `new`?\n",
              "- Wenn du mehrere gleichartige Objekte brauchst ‚Üí `new[]`\n",
              "- Wenn du nur ein einzelnes Objekt brauchst ‚Üí `new`\n",
              "\n",
              "---\n",
              "### ‚ùó Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
              "üëâ Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nint main() {\n    // new f√ºr EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] f√ºr MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt l√∂schen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gel√∂scht\n    delete[] pArr;  // 2x Punkt gel√∂scht\n\n    return 0;\n}"
              ] 
            } 
          }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          { "title": "RAII Prinzip", "content": { "text": [], "code": [] } },
          { "title": "Smart Pointer", "content": {
            "text": [
              "### === Smart Pointer in C++ ===\n",
              "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
              "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
              "\n",
              "---\n",
              "### Warum Smart Pointer?\n",
              "- Kein manuelles `delete` n√∂tig\n",
              "- Klare Besitzverh√§ltnisse\n",
              "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
              "\n",
              "---\n",
              "### üîπ `std::unique_ptr<T>`\n",
              "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
              "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
              "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
              "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
              "\n",
              "---\n",
              "### üîπ `std::shared_ptr<T>`\n",
              "- **Mehrere Besitzer** teilen sich das Objekt\n",
              "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
              "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
              "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
              "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
              "\n",
              "---\n",
              "### üîπ `std::weak_ptr<T>`\n",
              "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
              "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
              "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
              "\n",
              "---\n",
              "### üîç Vergleichstabelle:\n",
              "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
              "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
              "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
              "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        { "title": "<iostream>", "content": { "text": [], "code": [] } },
        { "title": "<fstream>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } },
        { "title": "<iomanip>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
        { "title": "<string>", "content": { "text": [], "code": [] } },
        { "title": "<string_view>", "content": { "text": [], "code": [] } },
        { "title": "<cstring>", "content": { "text": [], "code": [] } },
        { "title": "<cctype>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        { "title": "<cmath>", "content": { "text": [], "code": [] } },
        { "title": "<cstdlib>", "content": { "text": [], "code": [] } },
        { "title": "<random>", "content": { "text": [], "code": [] } },
        { "title": "<limits>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        { "title": "<chrono>", "content": { "text": [], "code": [] } },
        { "title": "<ctime>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        { "title": "<thread>", "content": { "text": [], "code": [] } },
        { "title": "<future>", "content": { "text": [], "code": [] } },
        { "title": "<typeinfo>", "content": { "text": [], "code": [] } },
        { "title": "<new>", "content": { "text": [], "code": [] } },
        { "title": "<memory>", "content": { "text": [], "code": [] } },
        { "title": "<cstdio>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
        { "title": "<algorithm>", "content": { "text": [], "code": [] } },
        { "title": "<iterator>", "content": { "text": [], "code": [] } },
        { "title": "<functional>", "content": { "text": [], "code": [] } },
        { "title": "<initializer_list>", "content": { "text": [], "code": [] } },
        { "title": "<tuple>", "content": { "text": [], "code": [] } },
        { "title": "<utility> (pair, swap)", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
          { "title": "Klassen Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren & Destruktoren", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
          { "title": "Basisklassen", "content": { "text": [], "code": [] } },
          { "title": "Polymorphie", "content": { "text": [], "code": [] } },
          { "title": "virtual / override", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
          { "title": "struct Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "struct vs class", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
          { "title": "enum Grundlagen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
          { "title": "enum class Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "enum class vs enum", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
          { "title": "namespace Grundlagen", "content": {
            "text": [
                "### === Namespaces in C++ ===\n",
                "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
                "\n",
                "---\n",
                "### Warum Namespaces?\n",
                "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
                "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
                "\n",
                "---\n",
                "### Verwendung von Namespaces\n",
                "- Definition:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
                "- Aufruf:\n",
                "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
                "\n",
                "---\n",
                "### Anonyme Namespaces (Datei-spezifisch)\n",
                "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
                "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
                "\n",
                "---\n",
                "### Verschachtelte Namespaces (modernes C++)\n",
                "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
                "\n",
                "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
                "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
                "---\n"
              ],
              "code": [
                "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
              ]
            } 
          },
          { "title": "using namespace", "content": { 
            "text": [
                "### `using namespace` (nicht immer empfohlen)\n",
                "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
                "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
                "- Besser: Nur gezielt importieren\n",
                "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
                "\n"
              ], 
            "code": [] } },
          { "title": "namespace vs. class", "content": { 
            "text": [ 
                "### === Unterschied: Namespace vs. Class ===\n",
                "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
                "\n",
                "---\n",
                "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
                "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
                "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
                "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
                "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
                "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
                "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
                "\n",
                "---\n",
                "### Beispiel zur Verdeutlichung:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
                "\n",
                "### üëâ Merksatz",
                "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
                "---\n"
            ], 
            "code": [] 
            } 
          }
        ]
      },
      {
        "name": "Klassenmember & Attribute",
        "icon": "üß©",
        "topics": [
          { "title": "static Member", "content": { 
            "text": [    
              "### === `static` in C++ ===\n",
              "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
              "\n",
              "---\n",
              "### üîπ `static` innerhalb einer Funktion:\n",
              "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
              "- Bleibt zwischen Aufrufen **erhalten**\n",
              "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
              "- Variable geh√∂rt **zur Klasse, nicht zum Objekt**\n",
              "- Wird **au√üerhalb der Klasse** definiert\n",
              "- Gleicher Wert f√ºr **alle Instanzen**\n",
              "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Klassenfunktionen:\n",
              "- Funktion geh√∂rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
              "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
              "- Wird √ºber `Klassenname::Funktion()` aufgerufen\n",
              "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
              "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
              "- N√ºtzlich zur Kapselung beim Modularisieren\n",
              "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
              "\n",
              "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschr√§nken**.\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion au√üerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
              ] 
            } 
          },
          { "title": "mutable Member", "content": { 
            "text": [  
              "### === `mutable` in C++ ===\n",
              "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu ver√§ndern**.\n",
              "\n",
              "---\n",
              "### Wann braucht man das?\n",
              "- Normalerweise d√ºrfen `const`-Funktionen **keine Membervariablen ver√§ndern**.\n",
              "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. f√ºr Logging, Caching oder Zugriffsz√§hler.\n",
              "\n",
              "---\n",
              "### Auch ohne `const` n√ºtzlich:\n",
              "- `mutable`-Member sind **immer unabh√§ngig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
              "- Sie k√∂nnen **immer ver√§ndert werden**, auch au√üerhalb von `const`-Kontexten - z.B. als interne Z√§hler oder Zust√§nde.\n",
              "\n",
              "---\n",
              "### Wichtig:\n",
              "- `mutable` funktioniert **nur bei Membervariablen**.\n",
              "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** f√ºr Klassenmitglieder.\n",
              "\n",
              "üëâ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZ√§hler = 0;  // darf auch in const-Funktion ver√§ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZ√§hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZ√§hler() const {\n    return leseZ√§hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZ√§hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "const Memberfunktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
          { "title": "Funktionstemplates", "content": { "text": [], "code": [] } },
          { "title": "Klassentemplates", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
          { "title": "vector", "content": { "text": [], "code": [] } },
          { "title": "array", "content": { "text": [], "code": [] } },
          { "title": "deque", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "map", "content": { "text": [], "code": [] } },
          { "title": "set", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
          { "title": "stack", "content": { "text": [], "code": [] } },
          { "title": "queue", "content": { "text": [], "code": [] } },
          { "title": "priority_queue", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Utility Types",
        "icon": "üß∞",
        "topics": [
          { "title": "pair", "content": { "text": [], "code": [] } },
          { "title": "tuple", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Fehlerbehandlung (try/catch)", "content": { "text": [], "code": [] } },
          { "title": "Pr√§prozessor (#define)", "content": { "text": [], "code": [] } },
          { "title": "CMake Basics", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Windows / Clion",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Console Ausgabe UTF-8 Windows", "content": {
            "text": [
              "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
              "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
              "---\n",
              "## üîπ FONT Einstellen:",
              "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
              "### üîπ Einstellung in CLion\n",
              "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
              "---\n",
              "### CODE in main.lua:"
              ],
            "code": [
              "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
              ]
            } 
          },
          { "title": "Working Directory in CLion", "content": {
            "text": [
              "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
              "Standardm√§√üig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen m√∂chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis (‚ÄûWorking Directory‚Äú) √§ndern.\n",
              "\n",
              "### üîπ Zielstruktur\n",
              "```",
              "Projektordner/\n",
              "‚îú‚îÄ‚îÄ CMakeLists.txt\n",
              "‚îú‚îÄ‚îÄ data/\n",
              "‚îî‚îÄ‚îÄ cmake-build-debug/",
              "```",
              "\n",
              "### üîπ Einstellung in CLion\n",
              "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
              "2. W√§hle **‚ÄûEdit Configurations‚Ä¶‚Äú**.\n",
              "3. W√§hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
              "4. Im Feld **‚ÄûWorking directory‚Äú** tr√§gst du ein: `$ProjectFileDir$`\n",
              "   ‚Üí Das sorgt daf√ºr, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
              "\n",
              "### üîπ Pr√ºfen im Code\n",
              "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
              "\n",
              "```cpp",
              "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
              "```",
              "\n",
              "---\n",
              "### üîπ Hinweis\n",
              "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
              "```cpp",
              "std::filesystem::create_directories(\"data\");",
              "```",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
          { "title": "main.cpp Grundger√ºst", "content": { "text": [], "code": [] } },
          { "title": "Hello World Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Input/Output Vorlage", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
          { "title": "Klasse mit Header & cpp", "content": { "text": [], "code": [] } },
          { "title": "Getter & Setter", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
          { "title": "vector Beispiel", "content": { "text": [], "code": [] } },
          { "title": "map Beispiel", "content": { "text": [], "code": [] } },
          { "title": "tuple / pair Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "CMakeLists.txt Minimal", "content": { "text": [], "code": [] } },
          { "title": "Ordnerstruktur Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Modulares Projekt Setup", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Datenbanken",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SQLite",
        "icon": "üß±",
        "topics": [
          { "title": "SQLite Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "prepare / bind / step / finalize", "content": { "text": [], "code": [] } },
          { "title": "CRUD Operationen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  }

]
