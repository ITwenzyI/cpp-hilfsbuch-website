[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          {
          "title": "Namensgebung in C++",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Namensgebung",
              "text": "Namensgebung beschreibt die Regeln und Konventionen zur Benennung von Variablen, Funktionen, Klassen, Typen und anderen Bezeichnern in C++ mit dem Ziel, Code verst√§ndlich, wartbar und eindeutig zu machen."
            },
            {
              "type": "explanation",
              "title": "Warum Namensgebung wichtig ist",
              "text": [
                "C++ erlaubt sehr viele g√ºltige Bezeichner, aber nur ein kleiner Teil davon ist sinnvoll. Der Compiler pr√ºft nur die Syntax, nicht ob ein Name verst√§ndlich ist.",
                "Gute Namen transportieren Bedeutung, reduzieren Kommentare und helfen dabei, Fehler schneller zu erkennen. Schlechte Namen machen selbst korrekten Code schwer wartbar."
              ]
            },
            {
              "type": "list",
              "title": "Allgemeine Regeln f√ºr Bezeichner",
              "items": [
                "Bezeichner bestehen aus Buchstaben, Ziffern und Unterstrichen",
                "Ein Bezeichner darf nicht mit einer Ziffer beginnen",
                "Gro√ü und Kleinschreibung sind relevant",
                "Reservierte Schl√ºsselw√∂rter d√ºrfen nicht verwendet werden"
              ]
            },
            {
              "type": "comparison",
              "title": "Gro√ü und Kleinschreibung",
              "columns": ["Bezeichner", "Bedeutung"],
              "rows": [
                {
                  "aspect": "value vs Value",
                  "values": ["zwei verschiedene Namen", "Gro√üschreibung erzeugt einen anderen Bezeichner"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "√úbliche Namenskonventionen in C++",
              "text": [
                "C++ selbst erzwingt keine Namenskonventionen, aber in der Praxis haben sich feste Muster etabliert, um Code konsistent zu halten.",
                "Welche Konvention genutzt wird, h√§ngt oft vom Projekt, Team oder Styleguide ab, sollte aber innerhalb eines Projekts einheitlich sein."
              ]
            },
            {
              "type": "list",
              "title": "Typische Konventionen",
              "items": [
                "Variablen und Funktionen meist klein geschrieben",
                "Mehrteilige Namen werden oft mit Unterstrichen getrennt",
                "Klassen und Typen beginnen h√§ufig mit einem Gro√übuchstaben",
                "Konstanten werden oft komplett gro√ü geschrieben"
              ]
            },
            {
              "type": "code",
              "title": "Beispiele f√ºr g√ºltige Bezeichner",
              "language": "cpp",
              "code": "int age;\nint user_count;\nvoid calculateSum();\nclass PatientRecord {};\nconst int MAX_SIZE = 100;"
            },
            {
              "type": "example",
              "title": "Gute vs. schlechte Namen",
              "text": [
                "count ist besser als c",
                "calculateAverage ist besser als func1",
                "patient_age ist verst√§ndlicher als pa"
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrdeutige oder nichtssagende Namen",
              "text": "Kurze oder generische Namen wie x, tmp oder data sagen nichts √ºber ihre Bedeutung aus und f√ºhren schnell zu Verst√§ndnisproblemen."
            },
            {
              "type": "important",
              "text": "Ein guter Name erkl√§rt seine Bedeutung ohne zus√§tzlichen Kommentar."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Moderne C++ Projekte legen gro√üen Wert auf sprechende Namen, da Code h√§ufiger gelesen als geschrieben wird."
            },
            {
              "type": "note",
              "variant": "exam",
              "text": "In Pr√ºfungen wird oft erwartet, dass Bezeichner sinnvoll gew√§hlt sind, auch wenn die Syntax korrekt ist."
            },
            {
              "type": "summary",
              "points": [
                "C++ erlaubt viele Namen, aber nicht jeder ist sinnvoll",
                "Gro√ü und Kleinschreibung unterscheidet Bezeichner",
                "Einheitliche Konventionen erh√∂hen Lesbarkeit",
                "Sprechende Namen sind wichtiger als kurze Namen"
              ]
            }
          ]
        },
          {
            "title": "Wichtige Grundbegriffe in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Deklaration",
                "text": "Macht einen Namen und seinen Typ bekannt, ohne ihn zwingend vollst√§ndig festzulegen. (z.B. `int x;`)"
              },
              {
                "type": "definition",
                "term": "Definition",
                "text": "Legt Speicher oder die konkrete Implementierung eines Namens fest. (z.B. `int x = 5;`)"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Vergibt beim Erzeugen einer Variable direkt einen Startwert."
              },
              {
                "type": "definition",
                "term": "Zuweisung",
                "text": "√Ñndert den Wert einer bereits existierenden Variable."
              },
              {
                "type": "definition",
                "term": "Variable",
                "text": "Ein benannter Speicherbereich zur Ablage von Daten."
              },
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Legt fest, welche Art von Wert gespeichert wird und wie viel Speicher ben√∂tigt wird."
              },
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "definition",
                "term": "Funktion",
                "text": "Ein benannter Codeblock, der eine bestimmte Aufgabe ausf√ºhrt."
              },
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Platzhalter in der Funktionsdefinition f√ºr √ºbergebene Werte."
              },
              {
                "type": "definition",
                "term": "Argument",
                "text": "Konkreter Wert, der beim Funktionsaufruf √ºbergeben wird."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Scope",
                "text": "Der G√ºltigkeitsbereich, in dem ein Name verwendet werden darf."
              },
              {
                "type": "definition",
                "term": "Block",
                "text": "Ein zusammengeh√∂riger Codebereich, der durch geschweifte Klammern begrenzt ist."
              },
              {
                "type": "definition",
                "term": "Namespace",
                "text": "Ein Namensraum zur Strukturierung und Vermeidung von Namenskonflikten."
              },
              {
                "type": "definition",
                "term": "Klasse",
                "text": "Ein Bauplan f√ºr Objekte, der Daten und Funktionen zusammenfasst."
              },
              {
                "type": "definition",
                "term": "Objekt",
                "text": "Eine konkrete Instanz einer Klasse."
              },
              {
                "type": "definition",
                "term": "Konstruktor",
                "text": "Spezielle Funktion, die beim Erzeugen eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Destruktor",
                "text": "Spezielle Funktion, die beim Zerst√∂ren eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Header-Datei",
                "text": "Datei, die Deklarationen f√ºr andere √úbersetzungseinheiten bereitstellt."
              },
              {
                "type": "definition",
                "term": "Quell-Datei",
                "text": "Datei, die die eigentlichen Definitionen und Implementierungen enth√§lt."
              },
              {
                "type": "important",
                "text": "Diese Begriffe bilden das Fundament zum Verstehen von C++ Code und Compiler-Fehlern."
              },
              {
                "type": "summary",
                "points": [
                  "Deklaration und Definition sind nicht dasselbe",
                  "Parameter geh√∂ren zur Funktion, Argumente zum Aufruf",
                  "Referenzen und Zeiger arbeiten beide mit bestehenden Objekten",
                  "Klassen definieren Strukturen, Objekte sind ihre Instanzen"
                ]
              }
            ]
          },
          {
            "title": "Datentypen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Ein Datentyp legt fest, welche Art von Wert gespeichert wird und wie dieser interpretiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundlegende Datentypen",
                "text": [
                  "Grundlegende Datentypen sind fest in C++ eingebaut und bilden die Basis aller weiteren Typen.",
                  "Sie unterscheiden sich in Speicherbedarf, Wertebereich und Verwendungszweck."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige grundlegende Datentypen",
                "items": [
                  "int: Ganzzahltyp",
                  "double: Gleitkommazahl",
                  "char: Einzelnes Zeichen",
                  "bool: Wahrheitswert true oder false",
                  "void: Kein Wert"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Datentypen Beispiel",
                "language": "cpp",
                "code": "int a = 5;\ndouble b = 3.14;\nbool ok = true;"
              },
              {
                "type": "definition",
                "term": "size_t",
                "text": "Ein vorzeichenloser Ganzzahltyp zur Darstellung von Gr√∂√üen und Indizes."
              },
              {
                "type": "code",
                "title": "size_t Beispiel",
                "language": "cpp",
                "code": "size_t len = 10;"
              },
              {
                "type": "definition",
                "term": "std::string",
                "text": "Ein Standardtyp zur komfortablen Verarbeitung von Texten."
              },
              {
                "type": "code",
                "title": "std::string Beispiel",
                "language": "cpp",
                "code": "std::string name = \"C++\";"
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert f√ºr einen ung√ºltigen Zeiger."
              },
              {
                "type": "code",
                "title": "nullptr Beispiel",
                "language": "cpp",
                "code": "int* p = nullptr;"
              },
              {
                "type": "definition",
                "term": "auto",
                "text": "L√§sst den Compiler den Datentyp einer Variablen automatisch ableiten."
              },
              {
                "type": "code",
                "title": "auto Beispiel",
                "language": "cpp",
                "code": "auto x = 42;"
              },
              {
                "type": "definition",
                "term": "decltype",
                "text": "Ermittelt den Typ eines Ausdrucks, ohne ihn auszuwerten."
              },
              {
                "type": "code",
                "title": "decltype Beispiel",
                "language": "cpp",
                "code": "int a = 0;\ndecltype(a) b = 1;"
              },
              {
                "type": "definition",
                "term": "struct",
                "text": "Ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer Werte."
              },
              {
                "type": "definition",
                "term": "class",
                "text": "Ein benutzerdefinierter Datentyp mit Kapselung und Zugriffskontrolle."
              },
              {
                "type": "code",
                "title": "struct und class mit Funktionen",
                "language": "cpp",
                "code": "struct Point {\n    int x;\n    int y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n};\n\nclass Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n\n    int get() const {\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "enum",
                "text": "Ein Datentyp mit einer festen Menge benannter Ganzzahlwerte."
              },
              {
                "type": "code",
                "title": "enum Beispiel",
                "language": "cpp",
                "code": "enum Color { Red, Green, Blue };"
              },
              {
                "type": "definition",
                "term": "enum class",
                "text": "Stark typisierte Enumeration mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung zu int."
              },
              {
                "type": "code",
                "title": "enum class Beispiel",
                "language": "cpp",
                "code": "enum class Status { Ok, Error, Unknown };\n\nStatus s = Status::Ok;"
              },
              {
                "type": "definition",
                "term": "typedef",
                "text": "Erstellt einen Aliasnamen f√ºr einen bestehenden Datentyp."
              },
              {
                "type": "definition",
                "term": "using",
                "text": "Moderne Alternative zu typedef f√ºr Typaliasse."
              },
              {
                "type": "code",
                "title": "typedef und using Beispiel",
                "language": "cpp",
                "code": "typedef unsigned int uint;\nusing Index = size_t;"
              },
              {
                "type": "explanation",
                "title": "Typumwandlung in C++",
                "text": [
                  "Typumwandlungen werden verwendet, wenn ein Wert in einem anderen Datentyp weiterverarbeitet werden soll.",
                  "Explizite Casts wie static_cast sind sicherer und besser lesbar als implizite Umwandlungen."
                ]
              },
              {
                "type": "list",
                "title": "G√§ngige Cast-Arten",
                "items": [
                  "static_cast: normale, √ºberpr√ºfbare Umwandlungen",
                  "const_cast: Entfernen oder Hinzuf√ºgen von const",
                  "reinterpret_cast: bitweise Umdeutung, sehr gef√§hrlich",
                  "dynamic_cast: sichere Laufzeitpr√ºfung bei Vererbung"
                ]
              },
              {
                "type": "code",
                "title": "Typumwandlung Beispiel",
                "language": "cpp",
                "code": "double d = 4.9;\nint i = static_cast<int>(d);"
              },
              {
                "type": "important",
                "text": "Datentypen bestimmen Speicher, Verhalten und Sicherheit von C++ Programmen."
              },
              {
                "type": "summary",
                "points": [
                  "Grundlegende Typen bilden die Basis aller Programme",
                  "size_t, string und nullptr sind zentrale Standardtypen",
                  "auto und decltype vereinfachen typsicheren Code",
                  "struct, class und enum erlauben eigene Datentypen",
                  "using ersetzt typedef in modernem C++"
                ]
              }
            ]
          },
          {
            "title": "I/O Grundprinzipien in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "I/O",
                "text": "Input und Output bezeichnen das Einlesen von Daten in ein Programm und das Ausgeben von Daten nach au√üen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Ein und Ausgabe",
                "text": [
                  "C++ arbeitet bei Ein und Ausgabe mit sogenannten Streams. Ein Stream ist eine Abfolge von Zeichen oder Daten.",
                  "Programme lesen Daten aus einem Eingabestrom und schreiben Daten in einen Ausgabestrom."
                ]
              },
              {
                "type": "definition",
                "term": "Stream",
                "text": "Ein abstrakter Datenstrom, der Zeichen sequenziell transportiert."
              },
              {
                "type": "definition",
                "term": "Standard Input",
                "text": "Der voreingestellte Eingabestrom, meist die Tastatur."
              },
              {
                "type": "definition",
                "term": "Standard Output",
                "text": "Der voreingestellte Ausgabestrom, meist die Konsole."
              },
              {
                "type": "definition",
                "term": "Standard Error",
                "text": "Separater Ausgabestrom f√ºr Fehlermeldungen."
              },
              {
                "type": "list",
                "title": "Wichtige Standard-Streams",
                "items": [
                  "std::cin: Standardeingabe",
                  "std::cout: Standardausgabe",
                  "std::cerr: Fehlerausgabe",
                  "std::clog: Protokollausgabe"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe mit cout",
                "language": "cpp",
                "code": "std::cout << \"Hallo Welt\" << std::endl;"
              },
              {
                "type": "code",
                "title": "Einfache Eingabe mit cin",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;"
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Schreibt Daten in einen Ausgabestrom."
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Liest Daten aus einem Eingabestrom."
              },
              {
                "type": "explanation",
                "title": "Verkettung von Streams",
                "text": [
                  "Einf√ºge und Extraktionsoperatoren k√∂nnen verkettet werden.",
                  "Dadurch lassen sich mehrere Werte in einer Anweisung ein oder ausgeben."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Ein und Ausgabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b;\nstd::cout << a << \" \" << b;"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Zwischenspeicherung von Ausgaben, bevor sie tats√§chlich geschrieben werden."
              },
              {
                "type": "definition",
                "term": "Flush",
                "text": "Erzwingt das sofortige Schreiben des Ausgabepuffers."
              },
              {
                "type": "code",
                "title": "Flush Beispiel",
                "language": "cpp",
                "code": "std::cout << \"Text\" << std::flush;"
              },
              {
                "type": "pitfall",
                "title": "Eingabe ohne Pr√ºfung",
                "text": "Fehlerhafte Eingaben k√∂nnen Streams in einen Fehlerzustand versetzen und weitere Eingaben verhindern."
              },
              {
                "type": "important",
                "text": "I/O in C++ basiert auf Streams und Operatoren, nicht auf direkten Ger√§tezugriffen."
              },
              {
                "type": "summary",
                "points": [
                  "Ein und Ausgabe erfolgt √ºber Streams",
                  "cin, cout und cerr sind zentrale Standard-Streams",
                  "<< schreibt, >> liest",
                  "Streams k√∂nnen verkettet werden",
                  "Pufferung beeinflusst, wann Ausgaben sichtbar werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          {
            "title": "Arithmetische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Arithmetischer Operator",
                "text": "Ein Operator zur Durchf√ºhrung mathematischer Berechnungen auf numerischen Datentypen."
              },
              {
                "type": "list",
                "title": "Grundlegende arithmetische Operatoren",
                "items": [
                  "+: Addition",
                  "-: Subtraktion",
                  "*: Multiplikation",
                  "/: Division",
                  "%: Modulo Restbildung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Operatoren Beispiel",
                "language": "cpp",
                "code": "int a = 10;\nint b = 3;\nint sum = a + b;\nint diff = a - b;\nint prod = a * b;\nint quot = a / b;\nint rest = a % b;"
              },
              {
                "type": "definition",
                "term": "Ganzzahldivision",
                "text": "Division zweier Ganzzahlen, bei der der Nachkommateil verworfen wird."
              },
              {
                "type": "code",
                "title": "Ganzzahldivision Beispiel",
                "language": "cpp",
                "code": "int x = 7 / 2;"
              },
              {
                "type": "definition",
                "term": "Modulo",
                "text": "Berechnet den Rest einer Ganzzahldivision."
              },
              {
                "type": "explanation",
                "title": "Inkrement und Dekrement",
                "text": [
                  "Inkrement und Dekrement erh√∂hen oder verringern einen Wert um eins.",
                  "Es wird zwischen Pr√§fix und Postfix unterschieden."
                ]
              },
              {
                "type": "list",
                "title": "Inkrement und Dekrement Operatoren",
                "items": [
                  "++x: Pr√§fix Inkrement",
                  "x++: Postfix Inkrement",
                  "--x: Pr√§fix Dekrement",
                  "x--: Postfix Dekrement"
                ]
              },
              {
                "type": "code",
                "title": "Inkrement und Dekrement Beispiel",
                "language": "cpp",
                "code": "int i = 5;\nint a = ++i;\nint b = i++;"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Legt fest, in welcher Reihenfolge Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Operatorpriorit√§t und Klammern",
                "text": [
                  "Multiplikation und Division werden vor Addition und Subtraktion ausgewertet.",
                  "Klammern k√∂nnen verwendet werden, um die Auswertungsreihenfolge explizit festzulegen."
                ]
              },
              {
                "type": "code",
                "title": "Operatorpriorit√§t Beispiel",
                "language": "cpp",
                "code": "int r1 = 2 + 3 * 4;\nint r2 = (2 + 3) * 4;"
              },
              {
                "type": "pitfall",
                "title": "Unerwartete Ganzzahldivision",
                "text": "Division mit int liefert kein Kommaergebnis, auch wenn das mathematisch erwartet wird."
              },
              {
                "type": "important",
                "text": "Der Datentyp der Operanden beeinflusst das Ergebnis arithmetischer Operationen."
              },
              {
                "type": "summary",
                "points": [
                  "Arithmetische Operatoren f√ºhren grundlegende Berechnungen aus",
                  "Ganzzahldivision verwirft den Nachkommateil",
                  "Modulo liefert den Divisionsrest",
                  "Inkrement und Dekrement unterscheiden Pr√§fix und Postfix",
                  "Klammern steuern die Auswertungsreihenfolge"
                ]
              }
            ]
          },
          {
            "title": "Vergleichsoperatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Vergleichsoperator",
                "text": "Ein Operator, der zwei Werte vergleicht und einen booleschen Wert zur√ºckliefert."
              },
              {
                "type": "list",
                "title": "Grundlegende Vergleichsoperatoren",
                "items": [
                  "==: gleich",
                  "!=: ungleich",
                  "<: kleiner als",
                  ">: gr√∂√üer als",
                  "<=: kleiner oder gleich",
                  ">=: gr√∂√üer oder gleich"
                ]
              },
              {
                "type": "code",
                "title": "Vergleichsoperatoren Beispiel",
                "language": "cpp",
                "code": "int a = 5;\nint b = 7;\nbool r1 = (a == b);\nbool r2 = (a < b);"
              },
              {
                "type": "definition",
                "term": "bool",
                "text": "Ein Datentyp mit den m√∂glichen Werten true oder false."
              },
              {
                "type": "explanation",
                "title": "Vergleiche in Bedingungen",
                "text": [
                  "Vergleichsoperatoren werden h√§ufig in if Anweisungen und Schleifen verwendet.",
                  "Das Ergebnis entscheidet √ºber den weiteren Programmfluss."
                ]
              },
              {
                "type": "code",
                "title": "Vergleich in einer Bedingung",
                "language": "cpp",
                "code": "if (a >= 0)\n{\n    std::cout << \"positiv\";\n}"
              },
              {
                "type": "definition",
                "term": "Vergleich von Gleitkommazahlen",
                "text": "Der direkte Vergleich von Gleitkommazahlen kann wegen Rundungsfehlern problematisch sein."
              },
              {
                "type": "pitfall",
                "title": "== statt =",
                "text": "Das Verwechseln von Zuweisung und Vergleich f√ºhrt zu logischen Fehlern."
              },
              {
                "type": "important",
                "text": "Vergleichsoperatoren liefern immer einen booleschen Wert."
              },
              {
                "type": "summary",
                "points": [
                  "Vergleichsoperatoren pr√ºfen Beziehungen zwischen Werten",
                  "Das Ergebnis ist immer true oder false",
                  "Sie steuern Bedingungen und Schleifen",
                  "Besondere Vorsicht bei Gleitkommazahlen"
                ]
              }
            ]
          },
          {
            "title": "Logische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Logischer Operator",
                "text": "Ein Operator zur logischen Verkn√ºpfung oder Negation boolescher Ausdr√ºcke."
              },
              {
                "type": "list",
                "title": "Grundlegende logische Operatoren",
                "items": [
                  "&&: logisches UND",
                  "||: logisches ODER",
                  "!: logisches NICHT"
                ]
              },
              {
                "type": "code",
                "title": "Logische Operatoren Beispiel",
                "language": "cpp",
                "code": "bool a = true;\nbool b = false;\nbool r1 = a && b;\nbool r2 = a || b;\nbool r3 = !a;"
              },
              {
                "type": "definition",
                "term": "Kurzschlussauswertung",
                "text": "Der zweite Operand wird nur ausgewertet, wenn das Ergebnis noch beeinflusst werden kann."
              },
              {
                "type": "explanation",
                "title": "Kurzschlussverhalten",
                "text": [
                  "Bei && wird der zweite Ausdruck nur gepr√ºft, wenn der erste true ist.",
                  "Bei || wird der zweite Ausdruck nur gepr√ºft, wenn der erste false ist."
                ]
              },
              {
                "type": "code",
                "title": "Kurzschluss Beispiel",
                "language": "cpp",
                "code": "if (ptr != nullptr && ptr->value > 0)\n{\n}"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Bestimmt die Reihenfolge, in der logische Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Priorit√§t und Klammern",
                "text": [
                  "! wird vor && ausgewertet.",
                  "&& wird vor || ausgewertet. Klammern erh√∂hen die Lesbarkeit."
                ]
              },
              {
                "type": "code",
                "title": "Priorit√§t Beispiel",
                "language": "cpp",
                "code": "bool r = !a || b && a;\nbool r2 = (!a || b) && a;"
              },
              {
                "type": "pitfall",
                "title": "Bitweise mit logischen Operatoren verwechseln",
                "text": "& und | sind bitweise Operatoren und nicht gleichbedeutend mit && und ||."
              },
              {
                "type": "important",
                "text": "Logische Operatoren arbeiten mit booleschen Ausdr√ºcken und nutzen Kurzschlussauswertung."
              },
              {
                "type": "summary",
                "points": [
                  "&&, || und ! verkn√ºpfen boolesche Ausdr√ºcke",
                  "Kurzschlussauswertung verhindert unn√∂tige Auswertungen",
                  "Operatorpriorit√§t beachten oder Klammern setzen",
                  "Nicht mit bitweisen Operatoren verwechseln"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          {
            "title": "const Variablen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const",
                "text": "const kennzeichnet Werte oder Objekte, die nach ihrer Initialisierung nicht mehr ver√§ndert werden d√ºrfen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const",
                "text": [
                  "const dient dazu, unbeabsichtigte √Ñnderungen zu verhindern und Code verst√§ndlicher zu machen.",
                  "Der Compiler erzwingt die Unver√§nderlichkeit zur √úbersetzungszeit."
                ]
              },
              {
                "type": "code",
                "title": "const Variable",
                "language": "cpp",
                "code": "const int maxValue = 10;"
              },
              {
                "type": "definition",
                "term": "const Initialisierung",
                "text": "const Variablen m√ºssen beim Erzeugen initialisiert werden."
              },
              {
                "type": "pitfall",
                "title": "Fehlende Initialisierung",
                "text": "const Variablen ohne Initialisierung f√ºhren zu Compilerfehlern."
              },
              {
                "type": "definition",
                "term": "const Referenz",
                "text": "Eine Referenz, √ºber die das referenzierte Objekt nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenz Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nconst int& r = x;"
              },
              {
                "type": "definition",
                "term": "const Zeiger",
                "text": "Je nach Position von const kann der Zeiger selbst oder das Ziel unver√§nderlich sein."
              },
              {
                "type": "code",
                "title": "const und Zeiger",
                "language": "cpp",
                "code": "int x = 1;\nconst int* p1 = &x; // Zeiger auf konstante Daten\nint* const p2 = &x; // Konstanter Zeiger auf Daten\nconst int* const p3 = &x; // Beides konstant"
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die den Zustand des Objekts nicht ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "const Memberfunktion Beispiel",
                "language": "cpp",
                "code": "class A {\n    int v;\npublic:\n    int get() const { return v; }\n};"
              },
              {
                "type": "important",
                "text": "const ist ein zentrales Werkzeug f√ºr sicheren und gut wartbaren C++ Code."
              },
              {
                "type": "summary",
                "points": [
                  "const verhindert unbeabsichtigte √Ñnderungen",
                  "const Variablen m√ºssen initialisiert werden",
                  "const kann auf Objekte, Referenzen, Zeiger und Funktionen angewendet werden",
                  "const Memberfunktionen garantieren unver√§nderten Objektzustand"
                ]
              }
            ]
          },
          {
            "title": "const Parameter in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Parameter",
                "text": "Ein Funktionsparameter, der innerhalb der Funktion nicht ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Warum const Parameter verwenden",
                "text": [
                  "const Parameter verhindern unbeabsichtigte √Ñnderungen an √ºbergebenen Werten.",
                  "Sie machen Funktionsschnittstellen klarer und sicherer, besonders bei Referenzen und Zeigern."
                ]
              },
              {
                "type": "code",
                "title": "const Wertparameter",
                "language": "cpp",
                "code": "void print(const int x)\n{\n    // x darf hier nicht ver√§ndert werden\n    // x = 5; // Compilerfehler\n}"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Parameter, der per Referenz √ºbergeben wird, aber nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter Beispiel",
                "language": "cpp",
                "code": "void print(const std::string& text)\n{\n    // text wird nicht kopiert\n    // text.clear(); // Compilerfehler\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Vorteile von const Referenzen",
                "text": [
                  "Vermeidet unn√∂tige Kopien gro√üer Objekte.",
                  "Garantiert, dass die Funktion das Objekt nicht ver√§ndert."
                ]
              },
              {
                "type": "definition",
                "term": "const Zeigerparameter",
                "text": "Bei Zeigerparametern kann entweder das Ziel oder der Zeiger selbst als const markiert werden."
              },
              {
                "type": "code",
                "title": "const Zeigerparameter Beispiel",
                "language": "cpp",
                "code": "void read(const int* ptr)\n{\n    // *ptr darf nicht ver√§ndert werden\n    // *ptr = 10; // Compilerfehler\n}\n\nvoid move(int* const ptr)\n{\n    // ptr darf nicht neu gesetzt werden\n    // ptr = nullptr; // Compilerfehler\n}"
              },
              {
                "type": "pitfall",
                "title": "const vergessen",
                "text": "Fehlendes const bei Parametern kann unn√∂tige Einschr√§nkungen f√ºr Aufrufer verursachen."
              },
              {
                "type": "important",
                "text": "const Parameter sind ein Versprechen der Funktion an den Aufrufer."
              },
              {
                "type": "summary",
                "points": [
                  "const Parameter verhindern √Ñnderungen innerhalb der Funktion",
                  "const Referenzen sind effizient und sicher",
                  "Bei Zeigern bestimmt die Position von const die Bedeutung",
                  "const verbessert Lesbarkeit und API Design"
                ]
              }
            ]
          },
          {
            "title": "const Klassenmember in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Klassenmember",
                "text": "Ein Datenmember einer Klasse, dessen Wert nach der Initialisierung nicht mehr ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const Membern",
                "text": [
                  "const Member repr√§sentieren feste Eigenschaften eines Objekts, die sich w√§hrend der Lebensdauer nicht √§ndern sollen.",
                  "Der Compiler erzwingt, dass diese Member nicht neu zugewiesen werden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierungsliste",
                "text": "Mechanismus zum Initialisieren von Klassenmembern beim Erzeugen eines Objekts."
              },
              {
                "type": "code",
                "title": "const Member und Initialisierungsliste",
                "language": "cpp",
                "code": "class User {\nprivate:\n    const int id; // darf nach Konstruktion nicht ge√§ndert werden\n\npublic:\n    User(int idValue) : id(idValue) {}\n\n    int getId() const {\n        return id; // Lesen erlaubt\n    }\n};"
              },
              {
                "type": "pitfall",
                "title": "Zuweisung im Konstruktor",
                "text": "const Member k√∂nnen nicht im Konstruktorrumpf zugewiesen werden, sondern nur in der Initialisierungsliste."
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die garantiert, dass sie keine nicht-const Member ver√§ndert."
              },
              {
                "type": "code",
                "title": "const Memberfunktion und Zugriff",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    int get() const {\n        // value++;\n        // nicht erlaubt, da Funktion const ist\n        return value;\n    }\n\n    void increment() {\n        value++; // erlaubt, Funktion ist nicht const\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Zusammenspiel von const Membern und Funktionen",
                "text": [
                  "const Memberfunktionen d√ºrfen nur const Member oder lesenden Zugriff verwenden.",
                  "Nicht-const Memberfunktionen d√ºrfen alle Member ver√§ndern."
                ]
              },
              {
                "type": "important",
                "text": "const Member m√ºssen immer √ºber die Initialisierungsliste gesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "const Klassenmember sind nach der Konstruktion unver√§nderlich",
                  "Sie m√ºssen in der Initialisierungsliste gesetzt werden",
                  "const Memberfunktionen d√ºrfen den Objektzustand nicht √§ndern",
                  "const verbessert Korrektheit und Objektmodellierung"
                ]
              }
            ]
          },
          {
            "title": "const √úberladung in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const √úberladung",
                "text": "Eine Form der Funktions√ºberladung, bei der sich Funktionen nur durch const unterscheiden."
              },
              {
                "type": "explanation",
                "title": "Grundidee der const √úberladung",
                "text": [
                  "const √úberladung wird fast ausschlie√ülich bei Memberfunktionen verwendet.",
                  "Je nach const Zustand des Objekts wird eine andere Funktionsversion aufgerufen."
                ]
              },
              {
                "type": "definition",
                "term": "const Objekt",
                "text": "Ein Objekt, das als const deklariert wurde und nur const Memberfunktionen aufrufen darf."
              },
              {
                "type": "code",
                "title": "const √úberladung bei Memberfunktionen",
                "language": "cpp",
                "code": "class Box {\nprivate:\n    int value;\n\npublic:\n    Box(int v) : value(v) {}\n\n    int& get() {\n        // wird bei nicht-const Objekten aufgerufen\n        return value;\n    }\n\n    const int& get() const {\n        // wird bei const Objekten aufgerufen\n        return value;\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Bei einem nicht-const Objekt wird die nicht-const Version bevorzugt.",
                  "Bei einem const Objekt ist nur die const Version erlaubt."
                ]
              },
              {
                "type": "code",
                "title": "Aufruf der √ºberladenen Funktionen",
                "language": "cpp",
                "code": "Box b(5);\nb.get() = 10; // erlaubt, nicht-const Version\n\nconst Box cb(7);\nint x = cb.get(); // nur const Version m√∂glich"
              },
              {
                "type": "pitfall",
                "title": "Fehlende const Version",
                "text": "Ohne const √ºberladene Memberfunktion k√∂nnen const Objekte wichtige Funktionen nicht nutzen."
              },
              {
                "type": "important",
                "text": "const √úberladung erh√∂ht Korrektheit und Flexibilit√§t von Klassen."
              },
              {
                "type": "summary",
                "points": [
                  "const √úberladung unterscheidet Funktionen nach const",
                  "Sie wird haupts√§chlich bei Memberfunktionen eingesetzt",
                  "const Objekte d√ºrfen nur const Funktionen aufrufen",
                  "Nicht-const Objekte nutzen bevorzugt nicht-const Versionen"
                ]
              }
            ]
          },
          {
            "title": "constexpr in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "constexpr",
                "text": "constexpr kennzeichnet Ausdr√ºcke, Variablen oder Funktionen, die zur Compilezeit ausgewertet werden k√∂nnen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von constexpr",
                "text": [
                  "constexpr erm√∂glicht es, Berechnungen bereits zur Compilezeit durchzuf√ºhren.",
                  "Dadurch werden Programme effizienter und sicherer, da Fehler fr√ºher erkannt werden."
                ]
              },
              {
                "type": "definition",
                "term": "constexpr Variable",
                "text": "Eine Variable, deren Wert zur Compilezeit bekannt sein muss."
              },
              {
                "type": "code",
                "title": "constexpr Variable Beispiel",
                "language": "cpp",
                "code": "constexpr int maxSize = 100; // Wert ist zur Compilezeit festgelegt"
              },
              {
                "type": "definition",
                "term": "constexpr Funktion",
                "text": "Eine Funktion, die bei konstanten Argumenten zur Compilezeit ausgewertet werden kann."
              },
              {
                "type": "code",
                "title": "constexpr Funktion Beispiel",
                "language": "cpp",
                "code": "constexpr int square(int x)\n{\n    return x * x;\n}\n\nconstexpr int value = square(5); // Compilezeit"
              },
              {
                "type": "explanation",
                "title": "Compilezeit vs. Laufzeit",
                "text": [
                  "constexpr Funktionen k√∂nnen sowohl zur Compilezeit als auch zur Laufzeit ausgef√ºhrt werden.",
                  "Ob Compilezeit oder Laufzeit entscheidet der Kontext der Verwendung."
                ]
              },
              {
                "type": "code",
                "title": "constexpr zur Laufzeit",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;\nint y = square(x); // Laufzeit, da x nicht konstant ist"
              },
              {
                "type": "comparison",
                "title": "const vs. constexpr",
                "columns": ["const", "constexpr"],
                "rows": [
                  {
                    "aspect": "Zeitpunkt der Auswertung",
                    "values": ["Laufzeit oder Compilezeit", "Immer Compilezeit m√∂glich"]
                  },
                  {
                    "aspect": "Einsatz",
                    "values": ["Unver√§nderlichkeit", "Konstante Ausdr√ºcke"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "constexpr mit nicht-konstanten Werten",
                "text": "constexpr erfordert zur Compilezeit bekannte Werte, sonst schl√§gt die √úbersetzung fehl."
              },
              {
                "type": "important",
                "text": "constexpr ist st√§rker als const und erm√∂glicht echte Compilezeit-Berechnungen."
              },
              {
                "type": "summary",
                "points": [
                  "constexpr erzwingt Compilezeit-Auswertbarkeit",
                  "constexpr Variablen sind echte Konstanten",
                  "constexpr Funktionen k√∂nnen auch zur Laufzeit genutzt werden",
                  "constexpr erh√∂ht Effizienz und Typsicherheit"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          {
            "title": "std::cout",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cout",
                "text": "std::cout ist der Standard-Ausgabestream in C++ zur Ausgabe von Text und Werten auf die Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cout",
                "text": [
                  "std::cout schreibt Daten in den Standard-Output, der in der Regel das Terminal ist.",
                  "Die Ausgabe erfolgt √ºber den Einf√ºgeoperator << und kann verkettet werden."
                ]
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Operator, mit dem Werte in einen Ausgabestream geschrieben werden."
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe",
                "language": "cpp",
                "code": "int x = 5;\nstd::cout << x; // gibt 5 auf der Konsole aus"
              },
              {
                "type": "explanation",
                "title": "Verkettete Ausgabe",
                "text": [
                  "Mehrere Werte k√∂nnen hintereinander ausgegeben werden.",
                  "Die Operatoren werden von links nach rechts ausgewertet."
                ]
              },
              {
                "type": "code",
                "title": "Verkettung mit Text",
                "language": "cpp",
                "code": "int a = 3;\nint b = 4;\nstd::cout << \"a = \" << a << \", b = \" << b; // kombinierte Ausgabe"
              },
              {
                "type": "definition",
                "term": "std::endl",
                "text": "Gibt einen Zeilenumbruch aus und leert zus√§tzlich den Ausgabepuffer."
              },
              {
                "type": "code",
                "title": "Zeilenumbruch",
                "language": "cpp",
                "code": "std::cout << \"Hallo\" << std::endl; // neue Zeile und flush"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Ausgaben werden zwischengespeichert und nicht sofort angezeigt."
              },
              {
                "type": "comparison",
                "title": "std::endl vs. '\\n'",
                "columns": ["std::endl", "\\n"],
                "rows": [
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Ja", "Ja"]
                  },
                  {
                    "aspect": "Flush",
                    "values": ["Ja", "Nein"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Unn√∂tiger Einsatz von std::endl",
                "text": "H√§ufiges std::endl kann Programme deutlich verlangsamen, da jedes Mal geflusht wird."
              },
              {
                "type": "important",
                "text": "std::cout ist ein gepufferter Stream und arbeitet mit dem Operator <<."
              },
              {
                "type": "summary",
                "points": [
                  "std::cout dient zur Standardausgabe",
                  "Ausgabe erfolgt mit dem Operator <<",
                  "Mehrere Ausgaben k√∂nnen verkettet werden",
                  "std::endl erzeugt Zeilenumbruch und Flush",
                  "\\n ist meist effizienter als std::endl"
                ]
              }
            ]
          },
          {
            "title": "std::cin",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cin",
                "text": "std::cin ist der Standard-Eingabestream in C++ zum Einlesen von Daten aus der Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cin",
                "text": [
                  "std::cin liest Daten aus dem Standard-Input, meist der Tastatur.",
                  "Das Einlesen erfolgt mit dem Extraktionsoperator >> und ist typabh√§ngig."
                ]
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Operator, mit dem Werte aus einem Eingabestream gelesen werden."
              },
              {
                "type": "code",
                "title": "Einfache Eingabe",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x; // liest eine Ganzzahl von der Konsole"
              },
              {
                "type": "explanation",
                "title": "Mehrere Werte einlesen",
                "text": [
                  "Mehrere Eingaben k√∂nnen in einer Anweisung verkettet werden.",
                  "Die Werte werden in der angegebenen Reihenfolge gelesen."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Eingabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b; // liest zwei Ganzzahlen"
              },
              {
                "type": "definition",
                "term": "Whitespace-Verhalten",
                "text": "std::cin √ºberspringt f√ºhrende Leerzeichen, Tabs und Zeilenumbr√ºche."
              },
              {
                "type": "code",
                "title": "Eingabe von Text",
                "language": "cpp",
                "code": "std::string name;\nstd::cin >> name; // liest bis zum n√§chsten Leerzeichen"
              },
              {
                "type": "definition",
                "term": "Stream-Zustand",
                "text": "Interner Status eines Streams, der angibt, ob die letzte Eingabe erfolgreich war."
              },
              {
                "type": "code",
                "title": "Eingabe pr√ºfen",
                "language": "cpp",
                "code": "int value;\nif (std::cin >> value) {\n    // Eingabe war erfolgreich\n}"
              },
              {
                "type": "pitfall",
                "title": "Fehlerhafte Eingaben",
                "text": "Ung√ºltige Eingaben setzen den Stream in einen Fehlerzustand und blockieren weitere Lesevorg√§nge."
              },
              {
                "type": "important",
                "text": "std::cin ist typabh√§ngig und nutzt den Operator >> zum Einlesen."
              },
              {
                "type": "summary",
                "points": [
                  "std::cin liest Daten von der Konsole",
                  "Eingabe erfolgt mit dem Operator >>",
                  "Whitespace wird automatisch √ºbersprungen",
                  "Der Stream-Zustand sollte gepr√ºft werden",
                  "Ung√ºltige Eingaben k√∂nnen weitere Eingaben verhindern"
                ]
              }
            ]
          },
          {
            "title": "std::getline",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::getline",
                "text": "std::getline liest eine komplette Zeile aus einem Eingabestream bis zum Zeilenumbruch."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::getline",
                "text": [
                  "std::getline eignet sich zum Einlesen von Texten mit Leerzeichen.",
                  "Der Zeilenumbruch wird gelesen, aber nicht im Ergebnis gespeichert."
                ]
              },
              {
                "type": "definition",
                "term": "Zeilenweises Einlesen",
                "text": "Einleseform, bei der der gesamte Inhalt bis zum Zeilenende √ºbernommen wird."
              },
              {
                "type": "code",
                "title": "Einfache Verwendung von std::getline",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(std::cin, line); // liest eine komplette Zeile"
              },
              {
                "type": "explanation",
                "title": "Unterschied zu std::cin >>",
                "text": [
                  "std::cin >> liest nur bis zum n√§chsten Leerzeichen.",
                  "std::getline liest die gesamte Zeile inklusive Leerzeichen."
                ]
              },
              {
                "type": "comparison",
                "title": "std::getline vs. std::cin >>",
                "columns": ["std::getline", "std::cin >>"],
                "rows": [
                  {
                    "aspect": "Leerzeichen",
                    "values": ["Werden mitgelesen", "Beenden die Eingabe"]
                  },
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Beendet das Lesen", "Wird √ºbersprungen"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "std::getline nach std::cin >>",
                "text": "Nach einer >> Eingabe bleibt der Zeilenumbruch im Stream und wird von getline sofort gelesen."
              },
              {
                "type": "code",
                "title": "Korrekte Kombination von cin und getline",
                "language": "cpp",
                "code": "int age;\nstd::cin >> age;\nstd::cin.ignore(); // entfernt den Zeilenumbruch\n\nstd::string name;\nstd::getline(std::cin, name); // liest den Namen korrekt"
              },
              {
                "type": "important",
                "text": "std::getline ist die richtige Wahl f√ºr ganze Textzeilen."
              },
              {
                "type": "summary",
                "points": [
                  "std::getline liest komplette Zeilen",
                  "Leerzeichen sind Teil der Eingabe",
                  "Unterschiedliches Verhalten zu std::cin >>",
                  "Nach >> muss oft ignore verwendet werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          {
            "title": "std::ifstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ifstream",
                "text": "std::ifstream ist ein Eingabestream zum Lesen von Daten aus Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ifstream",
                "text": [
                  "std::ifstream funktioniert √§hnlich wie std::cin, liest seine Daten aber aus einer Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Input verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Dateistream",
                "text": "Ein Stream, der Daten aus einer Datei liest oder in eine Datei schreibt."
              },
              {
                "type": "code",
                "title": "Datei √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ifstream file(\"data.txt\"); // √∂ffnet Datei zum Lesen"
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "√ñffnen pr√ºfen",
                "language": "cpp",
                "code": "std::ifstream file(\"data.txt\");\nif (!file) {\n    // Datei konnte nicht ge√∂ffnet werden\n}"
              },
              {
                "type": "explanation",
                "title": "Lesen aus einer Datei",
                "text": [
                  "Das Lesen aus ifstream erfolgt mit denselben Operatoren wie bei std::cin.",
                  "Auch std::getline kann f√ºr zeilenweises Lesen verwendet werden."
                ]
              },
              {
                "type": "code",
                "title": "Lesen mit >>",
                "language": "cpp",
                "code": "int x;\nfile >> x; // liest eine Ganzzahl aus der Datei"
              },
              {
                "type": "code",
                "title": "Zeilenweise lesen",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(file, line); // liest eine Zeile aus der Datei"
              },
              {
                "type": "definition",
                "term": "End of File",
                "text": "Zustand, der erreicht wird, wenn keine weiteren Daten in der Datei vorhanden sind."
              },
              {
                "type": "code",
                "title": "Lesen bis Dateiende",
                "language": "cpp",
                "code": "std::string line;\nwhile (std::getline(file, line)) {\n    // verarbeitet jede Zeile der Datei\n}"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der √ñffnungszustand nicht gepr√ºft, kann es zu undefiniertem Programmverhalten kommen."
              },
              {
                "type": "important",
                "text": "std::ifstream sollte immer auf erfolgreiches √ñffnen gepr√ºft werden."
              },
              {
                "type": "summary",
                "points": [
                  "std::ifstream liest Daten aus Dateien",
                  "Er wird √ºber <fstream> eingebunden",
                  "Lesen erfolgt wie bei std::cin",
                  "std::getline eignet sich f√ºr zeilenweises Lesen",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::ofstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ofstream",
                "text": "std::ofstream ist ein Ausgabestream zum Schreiben von Daten in Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ofstream",
                "text": [
                  "std::ofstream funktioniert √§hnlich wie std::cout, schreibt seine Ausgabe aber in eine Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Output verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei zum Schreiben mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "Datei zum Schreiben √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ofstream file(\"output.txt\"); // erstellt oder √ºberschreibt die Datei"
              },
              {
                "type": "definition",
                "term": "√úberschreiben",
                "text": "Standardverhalten von ofstream, bei dem vorhandene Dateiinhalte gel√∂scht werden."
              },
              {
                "type": "definition",
                "term": "Anh√§ngen",
                "text": "Schreiben neuer Daten ans Ende einer bestehenden Datei."
              },
              {
                "type": "code",
                "title": "Dateiinhalt anh√§ngen",
                "language": "cpp",
                "code": "std::ofstream file(\"output.txt\", std::ios::app); // schreibt ans Dateiende"
              },
              {
                "type": "explanation",
                "title": "Schreiben in eine Datei",
                "text": [
                  "Das Schreiben erfolgt mit dem Einf√ºgeoperator << wie bei std::cout.",
                  "Es k√∂nnen beliebige ausgabef√§hige Datentypen geschrieben werden."
                ]
              },
              {
                "type": "code",
                "title": "Schreiben mit <<",
                "language": "cpp",
                "code": "file << \"Ergebnis: \" << 42 << '\\n'; // schreibt Text und Zahl in die Datei"
              },
              {
                "type": "definition",
                "term": "Datei schlie√üen",
                "text": "Beendet die Verbindung zwischen Stream und Datei und schreibt den Puffer."
              },
              {
                "type": "code",
                "title": "Datei schlie√üen",
                "language": "cpp",
                "code": "file.close(); // optional, erfolgt auch automatisch"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der Stream nicht gepr√ºft, kann das Schreiben fehlschlagen, ohne dass es bemerkt wird."
              },
              {
                "type": "important",
                "text": "std::ofstream √ºberschreibt Dateien standardm√§√üig, wenn kein Modus angegeben wird."
              },
              {
                "type": "summary",
                "points": [
                  "std::ofstream schreibt Daten in Dateien",
                  "Standardm√§√üig wird die Datei √ºberschrieben",
                  "Anh√§ngen erfolgt mit std::ios::app",
                  "Schreiben erfolgt mit dem Operator <<",
                  "Streams sollten auf Fehler gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::fstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::fstream",
                "text": "std::fstream ist ein Dateistream, der sowohl Lesen als auch Schreiben in einer Datei erlaubt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::fstream",
                "text": [
                  "std::fstream kombiniert die Funktionalit√§t von std::ifstream und std::ofstream.",
                  "Er wird verwendet, wenn eine Datei sowohl gelesen als auch beschrieben werden soll."
                ]
              },
              {
                "type": "definition",
                "term": "√ñffnungsmodus",
                "text": "Ein Modus, der festlegt, wie eine Datei ge√∂ffnet wird, zum Beispiel zum Lesen oder Schreiben."
              },
              {
                "type": "list",
                "title": "H√§ufige √ñffnungsmodi",
                "items": [
                  "std::ios::in: Datei lesen",
                  "std::ios::out: Datei schreiben",
                  "std::ios::app: ans Dateiende schreiben",
                  "std::ios::trunc: Dateiinhalt l√∂schen",
                  "std::ios::binary: Bin√§rmodus"
                ]
              },
              {
                "type": "code",
                "title": "Datei mit fstream √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::fstream file(\"data.txt\", std::ios::in | std::ios::out);"
              },
              {
                "type": "definition",
                "term": "Lese- und Schreibzugriff",
                "text": "Die M√∂glichkeit, Daten aus derselben Datei zu lesen und in sie zu schreiben."
              },
              {
                "type": "code",
                "title": "Lesen und Schreiben",
                "language": "cpp",
                "code": "int x;\nfile >> x;          // liest aus der Datei\nfile << x * 2;      // schreibt in die Datei"
              },
              {
                "type": "definition",
                "term": "Dateiposition",
                "text": "Die aktuelle Lese- oder Schreibposition innerhalb der Datei."
              },
              {
                "type": "explanation",
                "title": "Dateiposition und Zeiger",
                "text": [
                  "fstream besitzt einen Lesezeiger und einen Schreibzeiger.",
                  "Diese k√∂nnen unabh√§ngig voneinander verschoben werden."
                ]
              },
              {
                "type": "explanation",
                "title": "Was ist die Dateiposition",
                "text": [
                  "Die Dateiposition beschreibt die aktuelle Stelle in der Datei, an der gelesen oder geschrieben wird.",
                  "Bei std::fstream gibt es getrennte Positionen f√ºr Lesen und Schreiben."
                ]
              },
              {
                "type": "definition",
                "term": "Lesezeiger",
                "text": "Interne Position, von der aus der n√§chste Lesevorgang beginnt."
              },
              {
                "type": "definition",
                "term": "Schreibzeiger",
                "text": "Interne Position, an der der n√§chste Schreibvorgang erfolgt."
              },
              {
                "type": "definition",
                "term": "tellg",
                "text": "Gibt die aktuelle Position des Lesezeigers zur√ºck."
              },
              {
                "type": "definition",
                "term": "tellp",
                "text": "Gibt die aktuelle Position des Schreibzeigers zur√ºck."
              },
              {
                "type": "code",
                "title": "Aktuelle Dateiposition abfragen",
                "language": "cpp",
                "code": "std::fstream file(\"data.txt\", std::ios::in | std::ios::out);\n\nstd::streampos readPos = file.tellg(); // aktuelle Leseposition\nstd::streampos writePos = file.tellp(); // aktuelle Schreibposition"
              },
              {
                "type": "definition",
                "term": "seekg",
                "text": "Setzt die Position des Lesezeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "definition",
                "term": "seekp",
                "text": "Setzt die Position des Schreibzeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "code",
                "title": "Dateiposition ver√§ndern",
                "language": "cpp",
                "code": "file.seekg(0);          // Lesezeiger an den Anfang der Datei\nfile.seekp(0);          // Schreibzeiger an den Anfang der Datei"
              },
              {
                "type": "explanation",
                "title": "Relative Positionierung",
                "text": [
                  "Die Dateiposition kann relativ zu bestimmten Referenzpunkten gesetzt werden.",
                  "Typische Referenzen sind Anfang, aktuelle Position und Dateiende."
                ]
              },
              {
                "type": "code",
                "title": "Relative Dateiposition",
                "language": "cpp",
                "code": "file.seekg(10, std::ios::beg); // 10 Bytes ab Dateianfang\nfile.seekg(0, std::ios::cur);  // aktuelle Position\nfile.seekg(-5, std::ios::end); // 5 Bytes vor Dateiende"
              },
              {
                "type": "pitfall",
                "title": "Lesen und Schreiben ohne Positionskontrolle",
                "text": "Ohne bewusstes Setzen der Dateiposition k√∂nnen Lese- und Schreibzugriffe an unerwarteten Stellen erfolgen."
              },
              {
                "type": "important",
                "text": "tellg und seekg steuern das Lesen, tellp und seekp das Schreiben."
              },
              {
                "type": "summary",
                "points": [
                  "Dateiposition bestimmt, wo gelesen oder geschrieben wird",
                  "fstream besitzt getrennte Lese- und Schreibzeiger",
                  "tellg und tellp fragen die aktuelle Position ab",
                  "seekg und seekp ver√§ndern die Position gezielt",
                  "Relative Positionierung ist mit beg, cur und end m√∂glich"
                ]
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger √ñffnungsmodus",
                "text": "Wird eine Datei ohne passenden Modus ge√∂ffnet, k√∂nnen Lese- oder Schreiboperationen fehlschlagen."
              },
              {
                "type": "important",
                "text": "std::fstream eignet sich f√ºr kombinierten Lese- und Schreibzugriff auf Dateien."
              },
              {
                "type": "summary",
                "points": [
                  "std::fstream vereint ifstream und ofstream",
                  "√ñffnungsmodi steuern das Dateiverhalten",
                  "Lesen und Schreiben sind in derselben Datei m√∂glich",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          {
            "title": "if / else",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "if Anweisung",
                "text": "Eine Kontrollstruktur, die Code nur dann ausf√ºhrt, wenn eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee von if und else",
                "text": [
                  "Mit if wird eine Bedingung gepr√ºft, die einen booleschen Wert liefert.",
                  "Mit else kann ein alternativer Codepfad definiert werden, falls die Bedingung false ist."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches if Beispiel",
                "language": "cpp",
                "code": "int x = 5;\n\nif (x > 0) {\n    // wird ausgef√ºhrt, wenn x gr√∂√üer als 0 ist\n}"
              },
              {
                "type": "definition",
                "term": "else",
                "text": "Erg√§nzt ein if um einen Codeblock, der ausgef√ºhrt wird, wenn die Bedingung false ist."
              },
              {
                "type": "code",
                "title": "if else Beispiel",
                "language": "cpp",
                "code": "int x = -3;\n\nif (x >= 0) {\n    // x ist nicht negativ\n} else {\n    // x ist negativ\n}"
              },
              {
                "type": "definition",
                "term": "else if",
                "text": "Erm√∂glicht das Pr√ºfen mehrerer Bedingungen nacheinander."
              },
              {
                "type": "code",
                "title": "else if Kette",
                "language": "cpp",
                "code": "int value = 10;\n\nif (value < 0) {\n    // negativ\n} else if (value == 0) {\n    // null\n} else {\n    // positiv\n}"
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Ein Ausdruck, der zu true oder false ausgewertet wird."
              },
              {
                "type": "explanation",
                "title": "Bedingungen formulieren",
                "text": [
                  "Bedingungen bestehen meist aus Vergleichs- und logischen Operatoren.",
                  "Komplexe Bedingungen k√∂nnen mit &&, || und ! kombiniert werden."
                ]
              },
              {
                "type": "code",
                "title": "Komplexe Bedingung",
                "language": "cpp",
                "code": "int age = 20;\nbool hasTicket = true;\n\nif (age >= 18 && hasTicket) {\n    // Zutritt erlaubt\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergleich mit = statt ==",
                "text": "Die Verwendung von = statt == in einer Bedingung f√ºhrt zu logischen Fehlern oder Warnungen."
              },
              {
                "type": "important",
                "text": "Die Bedingung in if muss immer einen booleschen Wert liefern."
              },
              {
                "type": "summary",
                "points": [
                  "if steuert bedingte Programmausf√ºhrung",
                  "else definiert einen alternativen Pfad",
                  "else if erlaubt mehrere Bedingungen",
                  "Bedingungen basieren auf Vergleichen und logischen Operatoren",
                  "Sorgf√§ltige Formulierung vermeidet logische Fehler"
                ]
              }
            ]
          },
          {
            "title": "switch",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "switch Anweisung",
                "text": "Eine Kontrollstruktur zur Auswahl eines Codepfads basierend auf dem Wert eines Ausdrucks."
              },
              {
                "type": "explanation",
                "title": "Grundidee von switch",
                "text": [
                  "switch vergleicht einen Ausdruck mit mehreren festen Werten.",
                  "Je nach Treffer wird der zugeh√∂rige Codeblock ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "case",
                "text": "Ein m√∂glicher Vergleichswert innerhalb einer switch Anweisung."
              },
              {
                "type": "definition",
                "term": "default",
                "text": "Ein optionaler Zweig, der ausgef√ºhrt wird, wenn kein case passt."
              },
              {
                "type": "code",
                "title": "Einfaches switch Beispiel",
                "language": "cpp",
                "code": "int day = 3;\n\nswitch (day) {\ncase 1:\n    // Montag\n    break;\ncase 2:\n    // Dienstag\n    break;\ncase 3:\n    // Mittwoch\n    break;\ndefault:\n    // Ung√ºltiger Tag\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "break",
                "text": "Beendet einen case Block und verhindert das Weiterlaufen in den n√§chsten case."
              },
              {
                "type": "explanation",
                "title": "Fallthrough",
                "text": [
                  "Ohne break wird der Code im n√§chsten case ebenfalls ausgef√ºhrt.",
                  "Dieses Verhalten nennt man Fallthrough."
                ]
              },
              {
                "type": "code",
                "title": "Fallthrough Beispiel",
                "language": "cpp",
                "code": "int x = 1;\n\nswitch (x) {\ncase 1:\n    // wird ausgef√ºhrt\ncase 2:\n    // wird ebenfalls ausgef√ºhrt\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "switch Ausdruck",
                "text": "Der Ausdruck in switch muss ein ganzzahliger oder enum Typ sein."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes break",
                "text": "Fehlende break Anweisungen f√ºhren oft zu unerwartetem Verhalten."
              },
              {
                "type": "important",
                "text": "switch ist geeignet f√ºr viele feste Vergleichswerte, nicht f√ºr komplexe Bedingungen."
              },
              {
                "type": "summary",
                "points": [
                  "switch w√§hlt Codepfade anhand eines Wertes",
                  "case definiert m√∂gliche Vergleichswerte",
                  "default deckt alle √ºbrigen F√§lle ab",
                  "break verhindert Fallthrough",
                  "switch funktioniert nur mit bestimmten Datentypen"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          {
            "title": "for Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "for Schleife",
                "text": "Eine Schleife, die einen Codeblock eine festgelegte Anzahl von Durchl√§ufen ausf√ºhrt."
              },
              {
                "type": "explanation",
                "title": "Grundidee der for Schleife",
                "text": [
                  "Die for Schleife besteht aus Initialisierung, Bedingung und Schritt.",
                  "Sie eignet sich besonders f√ºr z√§hlbasierte Wiederholungen."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Wird einmal vor dem ersten Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Wird vor jedem Durchlauf gepr√ºft und entscheidet √ºber das Weiterlaufen der Schleife."
              },
              {
                "type": "definition",
                "term": "Schritt",
                "text": "Wird nach jedem Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "code",
                "title": "Klassische for Schleife",
                "language": "cpp",
                "code": "for (int i = 0; i < 5; i++) {\n    // i l√§uft von 0 bis 4\n}"
              },
              {
                "type": "explanation",
                "title": "Ablauf einer for Schleife",
                "text": [
                  "Zuerst wird die Initialisierung ausgef√ºhrt.",
                  "Danach wird vor jedem Durchlauf die Bedingung gepr√ºft und am Ende der Schritt ausgef√ºhrt."
                ]
              },
              {
                "type": "code",
                "title": "for Schleife mit anderer Schrittweite",
                "language": "cpp",
                "code": "for (int i = 0; i <= 10; i += 2) {\n    // i nimmt die Werte 0, 2, 4, 6, 8, 10 an\n}"
              },
              {
                "type": "definition",
                "term": "Bereichsbasierte for Schleife",
                "text": "Moderne for Schleife zum Durchlaufen von Containern und Arrays."
              },
              {
                "type": "code",
                "title": "Bereichsbasierte for Schleife",
                "language": "cpp",
                "code": "int values[] = {1, 2, 3};\n\nfor (int v : values) {\n    // v nimmt nacheinander die Werte 1, 2, 3 an\n}"
              },
              {
                "type": "pitfall",
                "title": "Endlosschleife",
                "text": "Eine falsche Bedingung oder ein fehlender Schritt kann zu einer Endlosschleife f√ºhren."
              },
              {
                "type": "important",
                "text": "for Schleifen eignen sich besonders f√ºr bekannte oder z√§hlbare Wiederholungen."
              },
              {
                "type": "summary",
                "points": [
                  "for Schleifen bestehen aus Initialisierung, Bedingung und Schritt",
                  "Sie sind ideal f√ºr Z√§hlschleifen",
                  "Schrittweite kann frei gew√§hlt werden",
                  "Bereichsbasierte for Schleifen vereinfachen Containerzugriffe",
                  "Sorgf√§ltige Bedingungen verhindern Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "while Schleife",
                "text": "Eine Schleife, die einen Codeblock ausf√ºhrt, solange eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee der while Schleife",
                "text": [
                  "Die Bedingung wird vor jedem Durchlauf gepr√ºft.",
                  "Ist die Bedingung false, wird der Schleifenrumpf nicht ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Kopfgesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung vor dem ersten Durchlauf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\nwhile (i < 5) {\n    // wird ausgef√ºhrt, solange i kleiner als 5 ist\n    i++;\n}"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "while Schleifen werden genutzt, wenn die Anzahl der Durchl√§ufe vorher nicht bekannt ist.",
                  "H√§ufig wird die Schleife durch Benutzereingaben oder Dateiinhalte gesteuert."
                ]
              },
              {
                "type": "code",
                "title": "while mit Eingabe",
                "language": "cpp",
                "code": "int value;\n\nwhile (std::cin >> value) {\n    // l√§uft, solange die Eingabe g√ºltig ist\n}"
              },
              {
                "type": "definition",
                "term": "Endlosschleife",
                "text": "Eine Schleife, deren Bedingung niemals false wird."
              },
              {
                "type": "code",
                "title": "Bewusste Endlosschleife",
                "language": "cpp",
                "code": "while (true) {\n    // l√§uft unendlich\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergessene Zustands√§nderung",
                "text": "Wird die Schleifenbedingung im Rumpf nicht beeinflusst, entsteht unbeabsichtigt eine Endlosschleife."
              },
              {
                "type": "important",
                "text": "Die Schleifenbedingung muss irgendwann false werden, au√üer bei gewollten Endlosschleifen."
              },
              {
                "type": "summary",
                "points": [
                  "while Schleifen pr√ºfen die Bedingung vor jedem Durchlauf",
                  "Sie eignen sich f√ºr unbestimmte Wiederholungen",
                  "Die Bedingung steuert den Programmfluss",
                  "Fehlende Zustands√§nderungen f√ºhren zu Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "do-while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "do while Schleife",
                "text": "Eine Schleife, bei der der Codeblock mindestens einmal ausgef√ºhrt wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee der do while Schleife",
                "text": [
                  "Die Bedingung wird erst nach dem Schleifendurchlauf gepr√ºft.",
                  "Der Schleifenrumpf wird daher immer mindestens einmal ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Fu√ügesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung nach dem Schleifenrumpf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache do while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\ndo {\n    // wird mindestens einmal ausgef√ºhrt\n    i++;\n} while (i < 5);"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "do while wird genutzt, wenn eine Aktion mindestens einmal erfolgen muss.",
                  "H√§ufig bei Men√ºs oder wiederholten Benutzereingaben."
                ]
              },
              {
                "type": "code",
                "title": "do while mit Benutzereingabe",
                "language": "cpp",
                "code": "int choice;\n\ndo {\n    // Men√º anzeigen\n    std::cin >> choice;\n} while (choice != 0);"
              },
              {
                "type": "definition",
                "term": "Unterschied zu while",
                "text": "do while pr√ºft die Bedingung nach dem Durchlauf, while davor."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes Semikolon",
                "text": "Nach der while Bedingung der do while Schleife ist ein Semikolon Pflicht."
              },
              {
                "type": "important",
                "text": "do while garantiert mindestens einen Schleifendurchlauf."
              },
              {
                "type": "summary",
                "points": [
                  "do while ist eine fu√ügesteuerte Schleife",
                  "Der Schleifenrumpf l√§uft mindestens einmal",
                  "Die Bedingung wird am Ende gepr√ºft",
                  "Typisch f√ºr Men√ºs und Eingabeschleifen",
                  "Semikolon nach while nicht vergessen"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          {
            "title": "Funktionsdefinition",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktionsdefinition",
                "text": "Die vollst√§ndige Beschreibung einer Funktion inklusive R√ºckgabetyp, Name, Parameterliste und Funktionsrumpf."
              },
              {
                "type": "explanation",
                "title": "Bestandteile einer Funktionsdefinition",
                "text": [
                  "Eine Funktionsdefinition legt fest, was eine Funktion tut und wie sie implementiert ist.",
                  "Sie besteht aus R√ºckgabetyp, Funktionsname, Parametern und dem Codeblock."
                ]
              },
              {
                "type": "list",
                "title": "Bestandteile",
                "items": [
                  "R√ºckgabetyp",
                  "Funktionsname",
                  "Parameterliste",
                  "Funktionsrumpf"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Funktionsdefinition",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    // addiert zwei Zahlen\n    return a + b;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der Datentyp des Werts, den eine Funktion zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Funktionsname",
                "text": "Bezeichner, unter dem die Funktion aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Parameterliste",
                "text": "Liste von Variablen, √ºber die Werte an die Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "Funktionsrumpf",
                "text": "Der Codeblock, der beim Aufruf der Funktion ausgef√ºhrt wird."
              },
              {
                "type": "definition",
                "term": "void Funktion",
                "text": "Eine Funktion ohne R√ºckgabewert."
              },
              {
                "type": "code",
                "title": "void Funktionsdefinition",
                "language": "cpp",
                "code": "void printHello() {\n    // gibt eine Begr√º√üung aus\n    std::cout << \"Hallo\";\n}"
              },
              {
                "type": "definition",
                "term": "return",
                "text": "Anweisung zum Zur√ºckgeben eines Werts und Beenden der Funktion."
              },
              {
                "type": "pitfall",
                "title": "Fehlender return",
                "text": "Nicht-void Funktionen m√ºssen in allen F√§llen einen Wert zur√ºckgeben."
              },
              {
                "type": "important",
                "text": "Die Funktionsdefinition legt das Verhalten fest, die Deklaration nur die Schnittstelle."
              },
              {
                "type": "summary",
                "points": [
                  "Eine Funktionsdefinition beschreibt das Verhalten einer Funktion",
                  "Sie besteht aus R√ºckgabetyp, Name, Parametern und Rumpf",
                  "void Funktionen liefern keinen Wert zur√ºck",
                  "return beendet die Funktion und gibt einen Wert zur√ºck"
                ]
              }
            ]
          },
          {
            "title": "Parameter & R√ºckgabe",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Variablen in der Funktionsdefinition, √ºber die Werte an eine Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung an den Aufrufer zur√ºckliefert."
              },
              {
                "type": "explanation",
                "title": "√úbersicht der √úbergabearten",
                "text": [
                  "C++ unterscheidet zwischen √úbergabe per Wert, per Referenz und per Zeiger.",
                  "Die Wahl beeinflusst Performance, Sicherheit und √Ñnderbarkeit der Daten."
                ]
              },
              {
                "type": "definition",
                "term": "√úbergabe per Wert",
                "text": "Der Parameter erh√§lt eine Kopie des √ºbergebenen Werts."
              },
              {
                "type": "code",
                "title": "Parameter per Wert",
                "language": "cpp",
                "code": "void setToZero(int x) {\n    x = 0; // √§ndert nur die Kopie\n}\n\nint a = 5;\nsetToZero(a); // a bleibt 5"
              },
              {
                "type": "definition",
                "term": "√úbergabe per Referenz",
                "text": "Der Parameter ist ein Alias f√ºr die √ºbergebene Variable."
              },
              {
                "type": "code",
                "title": "Parameter per Referenz",
                "language": "cpp",
                "code": "void setToZero(int& x) {\n    x = 0; // √§ndert die Originalvariable\n}\n\nint a = 5;\nsetToZero(a); // a wird 0"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert und nicht ver√§ndert\n    std::cout << text;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Wert",
                "text": "Die Funktion gibt eine Kopie des Ergebnisses zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Wert",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b; // R√ºckgabe einer Kopie\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Referenz",
                "text": "Die Funktion gibt eine Referenz auf ein existierendes Objekt zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Referenz",
                "language": "cpp",
                "code": "int& access(int& x) {\n    return x; // Referenz auf bestehenden Wert\n}"
              },
              {
                "type": "pitfall",
                "title": "Referenz auf lokale Variable zur√ºckgeben",
                "text": "Das Zur√ºckgeben einer Referenz auf eine lokale Variable f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Typen per Wert, gro√üe Objekte per const Referenz √ºbergeben."
              },
              {
                "type": "summary",
                "points": [
                  "Parameter definieren die Eingaben einer Funktion",
                  "√úbergabe per Wert kopiert Daten",
                  "Referenzen erlauben direkten Zugriff auf Originaldaten",
                  "R√ºckgaben k√∂nnen per Wert oder Referenz erfolgen",
                  "Referenzen auf lokale Variablen d√ºrfen nie zur√ºckgegeben werden"
                ]
              }
            ]
          },
          {
            "title": "Funktions√ºberladung",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktions√ºberladung",
                "text": "Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Parameterliste."
              },
              {
                "type": "explanation",
                "title": "Grundidee der √úberladung",
                "text": [
                  "Funktionen k√∂nnen denselben Namen tragen, solange sich ihre Parameter unterscheiden.",
                  "Der Compiler entscheidet anhand der Argumente, welche Funktion aufgerufen wird."
                ]
              },
              {
                "type": "definition",
                "term": "Signatur",
                "text": "Kombination aus Funktionsname und Parametertypen."
              },
              {
                "type": "code",
                "title": "Einfache Funktions√ºberladung",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b;\n}\n\ndouble add(double a, double b) {\n    return a + b;\n}"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Die Auswahl erfolgt zur Compilezeit.",
                  "R√ºckgabetyp allein reicht nicht zur √úberladung aus."
                ]
              },
              {
                "type": "code",
                "title": "√úberladung mit unterschiedlicher Parameteranzahl",
                "language": "cpp",
                "code": "int sum(int a, int b) {\n    return a + b;\n}\n\nint sum(int a, int b, int c) {\n    return a + b + c;\n}"
              },
              {
                "type": "definition",
                "term": "√úberladung und const",
                "text": "const kann Teil der Funktionssignatur sein, insbesondere bei Memberfunktionen."
              },
              {
                "type": "pitfall",
                "title": "Mehrdeutige Aufrufe",
                "text": "Unklare Typumwandlungen k√∂nnen dazu f√ºhren, dass der Compiler keine passende √úberladung findet."
              },
              {
                "type": "important",
                "text": "Funktions√ºberladung verbessert Lesbarkeit, wenn gleiche Konzepte logisch zusammengeh√∂ren."
              },
              {
                "type": "summary",
                "points": [
                  "Mehrere Funktionen k√∂nnen denselben Namen haben",
                  "Die Parameterliste muss sich unterscheiden",
                  "Die Entscheidung erfolgt zur Compilezeit",
                  "Der R√ºckgabetyp allein gen√ºgt nicht",
                  "√úberladung sollte klar und eindeutig bleiben"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          {
            "title": "inline Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "inline Funktion",
                "text": "Eine Funktion, bei der der Compiler versucht, den Funktionsaufruf durch den Funktionscode zu ersetzen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von inline",
                "text": [
                  "inline soll den Overhead eines Funktionsaufrufs vermeiden.",
                  "Der Compiler darf inline ignorieren, es ist nur eine Empfehlung."
                ]
              },
              {
                "type": "definition",
                "term": "Funktionsaufruf Overhead",
                "text": "Zus√§tzlicher Aufwand durch Sprung, R√ºcksprung und Parameter√ºbergabe bei einem Funktionsaufruf."
              },
              {
                "type": "code",
                "title": "inline Funktionsdefinition",
                "language": "cpp",
                "code": "inline int square(int x) {\n    // einfacher, kurzer Code\n    return x * x;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann inline sinnvoll ist",
                "text": [
                  "Bei sehr kleinen, h√§ufig aufgerufenen Funktionen.",
                  "Typisch bei Getter und Setter Funktionen."
                ]
              },
              {
                "type": "code",
                "title": "Typischer Einsatz in Klassen",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    int get() const { // implizit inline\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "implizit inline",
                "text": "Funktionen, die innerhalb einer Klassendefinition definiert sind, gelten automatisch als inline."
              },
              {
                "type": "explanation",
                "title": "inline und Header Dateien",
                "text": [
                  "inline Funktionen d√ºrfen in Header Dateien definiert werden.",
                  "Mehrfache Definitionen sind erlaubt, solange sie identisch sind."
                ]
              },
              {
                "type": "pitfall",
                "title": "Zu gro√üe inline Funktionen",
                "text": "Gro√üe inline Funktionen k√∂nnen den Code aufbl√§hen und die Performance verschlechtern."
              },
              {
                "type": "important",
                "text": "inline ist kein Garant f√ºr Performance, die Entscheidung trifft der Compiler."
              },
              {
                "type": "summary",
                "points": [
                  "inline reduziert Funktionsaufruf Overhead",
                  "Der Compiler entscheidet, ob inline angewendet wird",
                  "Besonders sinnvoll f√ºr kleine Funktionen",
                  "Methoden in Klassen sind implizit inline",
                  "Zu viel inline kann schaden"
                ]
              }
            ]
          },
          {
            "title": "Lambda Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Lambda Funktion",
                "text": "Eine anonyme Funktion, die direkt an der Verwendungsstelle definiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Lambda Funktionen",
                "text": [
                  "Lambda Funktionen sind kurze Funktionsobjekte ohne eigenen Namen.",
                  "Sie werden h√§ufig f√ºr Callbacks, kurze Berechnungen und Standardalgorithmen genutzt."
                ]
              },
              {
                "type": "definition",
                "term": "Lambda Syntax",
                "text": "Besteht aus Capture Liste, Parameterliste, optionalem R√ºckgabetyp und Funktionsrumpf."
              },
              {
                "type": "code",
                "title": "Grundlegende Lambda Syntax",
                "language": "cpp",
                "code": "auto f = [](int x) {\n    return x * 2;\n};"
              },
              {
                "type": "definition",
                "term": "Capture Liste",
                "text": "Legt fest, welche √§u√üeren Variablen im Lambda verwendet werden d√ºrfen und wie sie √ºbergeben werden."
              },
              {
                "type": "list",
                "title": "Wichtige Capture Modi",
                "items": [
                  "[]: keine Variablen capturen",
                  "[x]: x per Wert capturen",
                  "[&x]: x per Referenz capturen",
                  "[=]: alle verwendeten Variablen per Wert capturen",
                  "[&]: alle verwendeten Variablen per Referenz capturen",
                  "[=, &x]: alle per Wert, x per Referenz",
                  "[&, x]: alle per Referenz, x per Wert"
                ]
              },
              {
                "type": "code",
                "title": "Capture Beispiele",
                "language": "cpp",
                "code": "int a = 1;\nint b = 2;\n\nauto l1 = [a]() { return a; };        // Wert-Capture\nauto l2 = [&b]() { b++; };            // Referenz-Capture\nauto l3 = [=]() { return a + b; };    // alle per Wert\nauto l4 = [=, &b]() { b += a; };      // Mischung"
              },
              {
                "type": "definition",
                "term": "mutable Lambda",
                "text": "Ein Lambda, das erlaubt, per Wert gecapturete Variablen zu ver√§ndern."
              },
              {
                "type": "code",
                "title": "mutable Lambda Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nauto l = [x]() mutable {\n    x++;            // erlaubt wegen mutable\n    return x;\n};"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der R√ºckgabetyp eines Lambdas wird meist automatisch bestimmt, kann aber explizit angegeben werden."
              },
              {
                "type": "code",
                "title": "Expliziter R√ºckgabetyp",
                "language": "cpp",
                "code": "auto div = [](int a, int b) -> double {\n    return static_cast<double>(a) / b;\n};"
              },
              {
                "type": "definition",
                "term": "std::function",
                "text": "Ein Typ, der beliebige aufrufbare Objekte mit einer festen Signatur speichern kann."
              },
              {
                "type": "explanation",
                "title": "Lambda mit std::function",
                "text": [
                  "Lambdas k√∂nnen in std::function gespeichert werden.",
                  "Dies ist flexibel, aber langsamer als direkte Nutzung eines Lambdas."
                ]
              },
              {
                "type": "code",
                "title": "Lambda in std::function",
                "language": "cpp",
                "code": "#include <functional>\n\nstd::function<int(int)> f = [](int x) {\n    return x * x;\n};"
              },
              {
                "type": "definition",
                "term": "Lambda in Algorithmen",
                "text": "Lambda Funktionen werden h√§ufig als Pr√§dikate oder Aktionen in Standardalgorithmen verwendet."
              },
              {
                "type": "code",
                "title": "Lambda mit std::algorithm",
                "language": "cpp",
                "code": "#include <algorithm>\n#include <vector>\n\nstd::vector<int> v = {1, 2, 3, 4};\n\nint count = std::count_if(v.begin(), v.end(), [](int x) {\n    return x % 2 == 0; // z√§hlt gerade Zahlen\n});"
              },
              {
                "type": "pitfall",
                "title": "Referenz Capture und Lebensdauer",
                "text": "Referenz-Captures sind gef√§hrlich, wenn das Lambda l√§nger lebt als die referenzierte Variable."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Logik direkt als Lambda, komplexe Logik als normale Funktion."
              },
              {
                "type": "summary",
                "points": [
                  "Lambda Funktionen sind anonyme Funktionsobjekte",
                  "Capture Listen steuern Zugriff auf √§u√üere Variablen",
                  "mutable erlaubt √Ñnderungen an Wert-Captures",
                  "Lambdas k√∂nnen in std::function gespeichert werden",
                  "Standardalgorithmen nutzen Lambdas intensiv"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          {
            "title": "C Arrays",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C Array",
                "text": "Ein C Array ist eine feste, zusammenh√§ngende Sequenz von Elementen gleichen Typs."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Arrays",
                "text": [
                  "C Arrays haben eine feste Gr√∂√üe, die zur Compilezeit bekannt sein muss.",
                  "Der Name des Arrays verweist implizit auf das erste Element."
                ]
              },
              {
                "type": "code",
                "title": "Deklaration eines C Arrays",
                "language": "cpp",
                "code": "int values[5]; // Array mit 5 int Elementen"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Beim Erzeugen eines Arrays k√∂nnen Startwerte angegeben werden."
              },
              {
                "type": "code",
                "title": "Initialisierung eines C Arrays",
                "language": "cpp",
                "code": "int numbers[3] = {1, 2, 3};"
              },
              {
                "type": "definition",
                "term": "Indexzugriff",
                "text": "Zugriff auf ein Element √ºber seinen Index, beginnend bei 0."
              },
              {
                "type": "code",
                "title": "Zugriff per Index",
                "language": "cpp",
                "code": "int x = numbers[0]; // erstes Element"
              },
              {
                "type": "definition",
                "term": "Arraygr√∂√üe",
                "text": "Die Anzahl der Elemente eines C Arrays."
              },
              {
                "type": "explanation",
                "title": "Arraygr√∂√üe ermitteln",
                "text": [
                  "C Arrays kennen ihre Gr√∂√üe nicht selbst.",
                  "Die Gr√∂√üe muss separat verwaltet oder berechnet werden."
                ]
              },
              {
                "type": "code",
                "title": "Arraygr√∂√üe berechnen",
                "language": "cpp",
                "code": "int size = sizeof(numbers) / sizeof(numbers[0]);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Arrays pr√ºfen nicht, ob ein Index g√ºltig ist, was zu undefiniertem Verhalten f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Arrays sind einfach, aber unsicher und unflexibel."
              },
              {
                "type": "summary",
                "points": [
                  "C Arrays haben feste Gr√∂√üe",
                  "Index beginnt bei 0",
                  "Keine automatische Gr√∂√üenverwaltung",
                  "Kein Bounds Check",
                  "In modernem C++ oft durch Container ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::array",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::array",
                "text": "std::array ist ein Container aus der Standardbibliothek mit fester Gr√∂√üe und sicherem Zugriff."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::array",
                "text": [
                  "std::array kapselt ein C Array in einer Klasse.",
                  "Es bietet zus√§tzliche Funktionen wie size und at."
                ]
              },
              {
                "type": "definition",
                "term": "Template Parameter",
                "text": "std::array ben√∂tigt einen Datentyp und eine feste Gr√∂√üe als Template Argumente."
              },
              {
                "type": "code",
                "title": "Deklaration von std::array",
                "language": "cpp",
                "code": "#include <array>\n\nstd::array<int, 3> values = {1, 2, 3};"
              },
              {
                "type": "explanation",
                "title": "Vorteile gegen√ºber C Arrays",
                "text": [
                  "std::array kennt seine eigene Gr√∂√üe.",
                  "Es unterst√ºtzt range based for Schleifen und Standardalgorithmen."
                ]
              },
              {
                "type": "code",
                "title": "std::array in einer for Schleife",
                "language": "cpp",
                "code": "for (int v : values) {\n    // Zugriff auf jedes Element\n}"
              },
              {
                "type": "pitfall",
                "title": "Feste Gr√∂√üe",
                "text": "Auch std::array hat eine feste Gr√∂√üe und kann nicht zur Laufzeit wachsen."
              },
              {
                "type": "important",
                "text": "std::array ist die sichere Alternative zu C Arrays bei fester Gr√∂√üe."
              },
              {
                "type": "summary",
                "points": [
                  "std::array ist ein Wrapper um C Arrays",
                  "Die Gr√∂√üe ist Teil des Typs",
                  "size liefert die Elementanzahl",
                  "at bietet Bounds Checking",
                  "Bevorzugt gegen√ºber rohen C Arrays"
                ]
              },
              {
                "type": "explanation",
                "title": "Wichtige Funktionen von std::array",
                "text": [
                  "std::array stellt im Vergleich zu C Arrays zus√§tzliche Memberfunktionen bereit.",
                  "Diese Funktionen erh√∂hen Sicherheit, Lesbarkeit und Integration mit der Standardbibliothek."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Elemente im Array."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> a = {1, 2, 3};\nstd::size_t n = a.size(); // n ist 3"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob das Array leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (a.empty()) {\n    // nur true bei Gr√∂√üe 0\n}"
              },
              {
                "type": "definition",
                "term": "operator[]",
                "text": "Greift ohne Indexpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Indexzugriff mit []",
                "language": "cpp",
                "code": "int x = a[0]; // kein Bounds Check"
              },
              {
                "type": "definition",
                "term": "at",
                "text": "Greift mit Laufzeitpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Sicherer Zugriff mit at",
                "language": "cpp",
                "code": "int x = a.at(1); // wirft Ausnahme bei ung√ºltigem Index"
              },
              {
                "type": "definition",
                "term": "front",
                "text": "Liefert das erste Element des Arrays."
              },
              {
                "type": "code",
                "title": "front Beispiel",
                "language": "cpp",
                "code": "int first = a.front();"
              },
              {
                "type": "definition",
                "term": "back",
                "text": "Liefert das letzte Element des Arrays."
              },
              {
                "type": "code",
                "title": "back Beispiel",
                "language": "cpp",
                "code": "int last = a.back();"
              },
              {
                "type": "definition",
                "term": "data",
                "text": "Gibt einen Zeiger auf das interne C Array zur√ºck."
              },
              {
                "type": "code",
                "title": "data Beispiel",
                "language": "cpp",
                "code": "int* ptr = a.data(); // kompatibel mit C APIs"
              },
              {
                "type": "definition",
                "term": "fill",
                "text": "Setzt alle Elemente des Arrays auf denselben Wert."
              },
              {
                "type": "code",
                "title": "fill Beispiel",
                "language": "cpp",
                "code": "a.fill(0); // alle Elemente werden 0"
              },
              {
                "type": "definition",
                "term": "swap",
                "text": "Tauscht den Inhalt zweier Arrays gleicher Gr√∂√üe und gleichen Typs."
              },
              {
                "type": "code",
                "title": "swap Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> b = {4, 5, 6};\na.swap(b); // Inhalte von a und b werden getauscht"
              },
              {
                "type": "important",
                "text": "at bietet Sicherheit, operator[] bietet Geschwindigkeit ohne Pr√ºfung."
              },
              {
                "type": "summary",
                "points": [
                  "std::array kennt seine eigene Gr√∂√üe",
                  "size und empty liefern Metainformationen",
                  "at pr√ºft Indizes zur Laufzeit",
                  "front und back erlauben direkten Randzugriff",
                  "data erm√∂glicht Interoperabilit√§t mit C Code"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          {
            "title": "C Strings",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C String",
                "text": "Ein C String ist ein Array von char, das mit einem Nullterminator '\\0' endet."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Strings",
                "text": [
                  "C Strings stammen aus der C Sprache und werden in C++ weiterhin unterst√ºtzt.",
                  "Das Ende des Strings wird durch das Zeichen '\\0' markiert."
                ]
              },
              {
                "type": "definition",
                "term": "Nullterminator",
                "text": "Ein spezielles Zeichen '\\0', das das Ende eines C Strings kennzeichnet."
              },
              {
                "type": "code",
                "title": "Deklaration eines C Strings",
                "language": "cpp",
                "code": "char text[6] = \"Hallo\"; // 'H','a','l','l','o','\\0'"
              },
              {
                "type": "definition",
                "term": "Stringliterale",
                "text": "Feste Zeichenketten, die im Programmcode definiert sind."
              },
              {
                "type": "code",
                "title": "Stringliteral",
                "language": "cpp",
                "code": "const char* msg = \"Hallo Welt\";"
              },
              {
                "type": "definition",
                "term": "cstring",
                "text": "Header mit Funktionen zur Arbeit mit C Strings."
              },
              {
                "type": "code",
                "title": "C String Funktionen",
                "language": "cpp",
                "code": "#include <cstring>\n\nsize_t len = std::strlen(text);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Strings pr√ºfen nicht, ob genug Speicher vorhanden ist, was zu Buffer Overflows f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Strings sind fehleranf√§llig und sollten in modernem C++ nur gezielt eingesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "C Strings sind char Arrays mit Nullterminator",
                  "Die L√§nge ist nicht im Typ gespeichert",
                  "Arbeiten mit C Strings ist unsicher",
                  "cstring stellt Hilfsfunktionen bereit",
                  "In modernem C++ meist durch std::string ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::string",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::string",
                "text": "std::string ist ein Standardcontainer zur sicheren und komfortablen Verarbeitung von Texten."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::string",
                "text": [
                  "std::string verwaltet Speicher automatisch.",
                  "Er kennt seine L√§nge und w√§chst dynamisch."
                ]
              },
              {
                "type": "definition",
                "term": "Dynamische L√§nge",
                "text": "Die L√§nge eines std::string kann sich zur Laufzeit √§ndern."
              },
              {
                "type": "code",
                "title": "Deklaration und Initialisierung",
                "language": "cpp",
                "code": "#include <string>\n\nstd::string name = \"Kilian\";"
              },
              {
                "type": "definition",
                "term": "Zugriff auf Zeichen",
                "text": "Einzelne Zeichen k√∂nnen √ºber einen Index gelesen oder ver√§ndert werden."
              },
              {
                "type": "code",
                "title": "Indexzugriff",
                "language": "cpp",
                "code": "char c = name[0]; // erstes Zeichen"
              },
              {
                "type": "definition",
                "term": "Konkatenation",
                "text": "Zusammenf√ºgen von Strings."
              },
              {
                "type": "code",
                "title": "Strings verketten",
                "language": "cpp",
                "code": "std::string a = \"Hallo\";\nstd::string b = \"Welt\";\nstd::string c = a + \" \" + b;"
              },
              {
                "type": "definition",
                "term": "c_str",
                "text": "Liefert einen C String Zeiger auf den internen Speicher."
              },
              {
                "type": "code",
                "title": "Umwandlung zu C String",
                "language": "cpp",
                "code": "const char* raw = name.c_str();"
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger Zeiger von c_str",
                "text": "Der von c_str gelieferte Zeiger wird ung√ºltig, wenn der String ver√§ndert wird."
              },
              {
                "type": "important",
                "text": "std::string ist der Standard f√ºr Textverarbeitung in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "std::string verwaltet Speicher automatisch",
                  "Die L√§nge ist jederzeit bekannt",
                  "Strings k√∂nnen sicher ver√§ndert und verkettet werden",
                  "c_str erm√∂glicht Interoperabilit√§t mit C APIs",
                  "std::string ist C Strings klar vorzuziehen"
                ]
              },
              {
                "type": "explanation",
                "title": "Funktionen von std::string",
                "text": [
                  "Der Header <string> liefert viele n√ºtzliche Funktionen f√ºr std::string Variablen."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Zeichen im String."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::size_t len = name.size();"
              },
              {
                "type": "definition",
                "term": "length",
                "text": "Liefert die Anzahl der Zeichen im String. Entspricht funktional size."
              },
              {
                "type": "code",
                "title": "length Beispiel",
                "language": "cpp",
                "code": "std::string s = \"Hallo\";\nstd::size_t n = s.length(); // n ist 5"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob der String leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (s.empty()) {\n    // String enth√§lt keine Zeichen\n}"
              },
              {
                "type": "definition",
                "term": "clear",
                "text": "Entfernt alle Zeichen aus dem String."
              },
              {
                "type": "code",
                "title": "clear Beispiel",
                "language": "cpp",
                "code": "s.clear(); // String ist danach leer"
              },
              {
                "type": "definition",
                "term": "append",
                "text": "H√§ngt Text an das Ende des Strings an."
              },
              {
                "type": "code",
                "title": "append Beispiel",
                "language": "cpp",
                "code": "s.append(\" Welt\"); // entspricht s += \" Welt\""
              },
              {
                "type": "definition",
                "term": "substr",
                "text": "Erzeugt einen Teilstring aus dem String."
              },
              {
                "type": "code",
                "title": "substr Beispiel",
                "language": "cpp",
                "code": "std::string sub = s.substr(0, 2); // erste zwei Zeichen"
              },
              {
                "type": "definition",
                "term": "find",
                "text": "Sucht nach einem Teilstring oder Zeichen und liefert die Position."
              },
              {
                "type": "code",
                "title": "find Beispiel",
                "language": "cpp",
                "code": "std::size_t pos = s.find(\"ll\");\nif (pos != std::string::npos) {\n    // Teilstring gefunden\n}"
              },
              {
                "type": "definition",
                "term": "replace",
                "text": "Ersetzt einen Teil des Strings durch einen anderen Text."
              },
              {
                "type": "code",
                "title": "replace Beispiel",
                "language": "cpp",
                "code": "s.replace(0, 5, \"Hi\"); // ersetzt die ersten 5 Zeichen"
              },
              {
                "type": "definition",
                "term": "compare",
                "text": "Vergleicht zwei Strings lexikografisch."
              },
              {
                "type": "code",
                "title": "compare Beispiel",
                "language": "cpp",
                "code": "int r = s.compare(\"Hallo\");\n// r == 0: gleich, <0: kleiner, >0: gr√∂√üer"
              },
              {
                "type": "important",
                "text": "size und length sind gleichwertig, size ist der bevorzugte Stil in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "size und length liefern die Stringl√§nge",
                  "empty pr√ºft auf leeren String",
                  "append und += h√§ngen Text an",
                  "substr erzeugt Teilstrings",
                  "find sucht Teilstrings sicher √ºber npos"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          {
            "title": "Pointer Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Ein Zeiger speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Zeigern",
                "text": [
                  "Zeiger erm√∂glichen den indirekten Zugriff auf Variablen √ºber ihre Adresse.",
                  "Sie werden h√§ufig f√ºr dynamischen Speicher, Arrays und Funktionsparameter verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Adresse",
                "text": "Die Speicherposition einer Variable im Arbeitsspeicher."
              },
              {
                "type": "definition",
                "term": "Dereferenzierung",
                "text": "Der Zugriff auf den Wert, auf den ein Zeiger zeigt."
              },
              {
                "type": "code",
                "title": "Pointer Deklaration und Nutzung",
                "language": "cpp",
                "code": "int x = 5;\nint* p = &x;     // p speichert die Adresse von x\nint y = *p;      // Dereferenzierung, y wird 5"
              },
              {
                "type": "definition",
                "term": "Zeigertyp",
                "text": "Der Typ eines Zeigers gibt an, auf welchen Datentyp er zeigt."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierter Zeiger",
                "text": "Ein nicht initialisierter Zeiger zeigt auf eine undefinierte Adresse."
              },
              {
                "type": "important",
                "text": "Ein Zeiger sollte immer initialisiert werden, idealerweise mit nullptr."
              },
              {
                "type": "summary",
                "points": [
                  "Zeiger speichern Adressen",
                  "Dereferenzierung erfolgt mit *",
                  "Der Zeigertyp bestimmt den Zieltyp",
                  "Uninitialisierte Zeiger sind gef√§hrlich"
                ]
              }
            ]
          },
          {
            "title": "Pointer Arithmetik",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Pointer Arithmetik",
                "text": "Rechenoperationen auf Zeigern, die sich an der Gr√∂√üe des Zieltyps orientieren."
              },
              {
                "type": "explanation",
                "title": "Grundidee der Pointer Arithmetik",
                "text": [
                  "Zeiger k√∂nnen vor und zur√ºck bewegt werden.",
                  "Die Schrittweite entspricht der Gr√∂√üe des Datentyps."
                ]
              },
              {
                "type": "definition",
                "term": "Inkrementieren eines Zeigers",
                "text": "Verschiebt den Zeiger auf das n√§chste Element desselben Typs."
              },
              {
                "type": "code",
                "title": "Pointer Arithmetik mit Arrays",
                "language": "cpp",
                "code": "int arr[3] = {10, 20, 30};\nint* p = arr;        // zeigt auf arr[0]\nint a = *p;          // 10\np++;                 // zeigt auf arr[1]\nint b = *p;          // 20"
              },
              {
                "type": "definition",
                "term": "Array und Pointer",
                "text": "Der Name eines Arrays zerf√§llt oft implizit zu einem Zeiger auf das erste Element."
              },
              {
                "type": "explanation",
                "title": "Erlaubte und unerlaubte Operationen",
                "text": [
                  "Addition und Subtraktion mit Ganzzahlen ist erlaubt.",
                  "Addition zweier Zeiger ist nicht erlaubt."
                ]
              },
              {
                "type": "pitfall",
                "title": "Au√üerhalb des Arrays",
                "text": "Pointer Arithmetik au√üerhalb der Arraygrenzen f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Pointer Arithmetik ist eng an Arrays gebunden und erfordert gro√üe Sorgfalt."
              },
              {
                "type": "summary",
                "points": [
                  "Pointer bewegen sich in Schritten der Typgr√∂√üe",
                  "Typischer Einsatz bei Arrays",
                  "Arrayname verh√§lt sich wie Zeiger",
                  "Grenzen d√ºrfen nicht √ºberschritten werden"
                ]
              }
            ]
          },
          {
            "title": "Nullpointer",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Nullpointer",
                "text": "Ein Zeiger, der auf kein g√ºltiges Objekt zeigt."
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert zur sicheren Darstellung eines Nullpointers."
              },
              {
                "type": "explanation",
                "title": "Grundidee von nullptr",
                "text": [
                  "nullptr ersetzt √§ltere Konzepte wie NULL oder 0.",
                  "Er ist eindeutig als Zeigerwert typisiert."
                ]
              },
              {
                "type": "code",
                "title": "nullptr verwenden",
                "language": "cpp",
                "code": "int* p = nullptr; // zeigt auf nichts\n\nif (p == nullptr) {\n    // Zeiger ist ung√ºltig\n}"
              },
              {
                "type": "definition",
                "term": "Nullpointer Dereferenzierung",
                "text": "Der Zugriff auf einen Nullpointer ist undefiniertes Verhalten."
              },
              {
                "type": "pitfall",
                "title": "Dereferenzierung von nullptr",
                "text": "Das Dereferenzieren eines Nullpointers f√ºhrt meist zu Programmabst√ºrzen."
              },
              {
                "type": "important",
                "text": "nullptr ist der einzige empfohlene Weg, einen leeren Zeiger darzustellen."
              },
              {
                "type": "summary",
                "points": [
                  "Nullpointer zeigen auf kein Objekt",
                  "nullptr ist typsicher",
                  "Vor Dereferenzierung immer pr√ºfen",
                  "NULL und 0 sollten vermieden werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          {
            "title": "Referenzen Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Eine Referenz ist ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzen",
                "text": [
                  "Referenzen erm√∂glichen den direkten Zugriff auf eine Variable, ohne deren Adresse explizit zu verwenden.",
                  "Sie verhalten sich wie Aliase und sind nach der Initialisierung fest gebunden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung einer Referenz",
                "text": "Eine Referenz muss beim Erzeugen an ein Objekt gebunden werden."
              },
              {
                "type": "code",
                "title": "Referenz deklarieren",
                "language": "cpp",
                "code": "int x = 10;\nint& ref = x; // ref ist ein Alias f√ºr x"
              },
              {
                "type": "definition",
                "term": "Alias Verhalten",
                "text": "√Ñnderungen √ºber die Referenz wirken sich direkt auf das referenzierte Objekt aus."
              },
              {
                "type": "code",
                "title": "Alias Beispiel",
                "language": "cpp",
                "code": "ref = 20;      // √§ndert x\nint y = x;     // y ist 20"
              },
              {
                "type": "definition",
                "term": "Neu binden",
                "text": "Referenzen k√∂nnen nach der Initialisierung nicht auf ein anderes Objekt zeigen."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierte Referenz",
                "text": "Referenzen m√ºssen immer initialisiert werden, sonst ist der Code ung√ºltig."
              },
              {
                "type": "important",
                "text": "Referenzen sind keine Zeiger und k√∂nnen nicht null sein."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzen sind Aliase f√ºr bestehende Objekte",
                  "Sie m√ºssen sofort initialisiert werden",
                  "Referenzen k√∂nnen nicht neu gebunden werden",
                  "Zugriff erfolgt ohne Dereferenzierung",
                  "Referenzen k√∂nnen nicht null sein"
                ]
              }
            ]
          },
          {
            "title": "Referenzparameter",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenzparameter",
                "text": "Ein Funktionsparameter, der per Referenz √ºbergeben wird und direkt auf das Argument zugreift."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzparametern",
                "text": [
                  "Referenzparameter erlauben es, Argumente innerhalb einer Funktion zu ver√§ndern.",
                  "Sie vermeiden Kopien und sind effizient f√ºr gro√üe Objekte."
                ]
              },
              {
                "type": "definition",
                "term": "√Ñnderbarer Referenzparameter",
                "text": "Ein Referenzparameter ohne const, der das √ºbergebene Objekt ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "Referenzparameter ver√§ndern Wert",
                "language": "cpp",
                "code": "void increment(int& x) {\n    x++; // √§ndert die Originalvariable\n}\n\nint a = 5;\nincrement(a); // a ist jetzt 6"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann const Referenzen verwenden",
                "text": [
                  "Bei gro√üen Objekten, die nicht ver√§ndert werden sollen.",
                  "Als Standard f√ºr Lesezugriff in Funktionsschnittstellen."
                ]
              },
              {
                "type": "pitfall",
                "title": "Unerwartete √Ñnderungen",
                "text": "Nicht-const Referenzparameter k√∂nnen Seiteneffekte verursachen."
              },
              {
                "type": "important",
                "text": "Standardregel: √úbergabe per Wert f√ºr kleine Typen, per const Referenz f√ºr gro√üe Typen."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzparameter greifen direkt auf Argumente zu",
                  "Sie vermeiden Kopien",
                  "Nicht-const Referenzen erlauben √Ñnderungen",
                  "const Referenzen verhindern Seiteneffekte",
                  "Referenzparameter sind sicherer als Zeiger"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          {
            "title": "Stack vs. Heap",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Speicherverwaltung",
                "text": "Mechanismen zur Reservierung und Freigabe von Speicher f√ºr Variablen und Objekte."
              },
              {
                "type": "definition",
                "term": "Stack",
                "text": "Automatischer Speicherbereich f√ºr lokale Variablen mit klar definierter Lebensdauer."
              },
              {
                "type": "definition",
                "term": "Heap",
                "text": "Dynamischer Speicherbereich f√ºr Objekte mit frei bestimmbarer Lebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Stack Speicher",
                "text": [
                  "Stack Speicher wird automatisch verwaltet.",
                  "Variablen werden beim Betreten eines G√ºltigkeitsbereichs angelegt und beim Verlassen automatisch freigegeben."
                ]
              },
              {
                "type": "code",
                "title": "Stack Beispiel",
                "language": "cpp",
                "code": "void foo() {\n    int x = 5;   // liegt auf dem Stack\n} // x wird hier automatisch zerst√∂rt"
              },
              {
                "type": "explanation",
                "title": "Grundidee von Heap Speicher",
                "text": [
                  "Heap Speicher wird manuell angefordert und freigegeben.",
                  "Objekte auf dem Heap leben so lange, bis sie explizit freigegeben werden.",
                  "Der Heap ist nicht an Blockgrenzen oder Funktionslebensdauer gebunden.",
                  "Heap Speicher ist flexibler, aber fehleranf√§lliger als Stack Speicher."
                ]
              },
              {
                "type": "code",
                "title": "Heap Grundprinzip",
                "language": "cpp",
                "code": "int* p = new int(5); // Speicher auf dem Heap\n// p zeigt auf ein Heap Objekt"
              },
              {
                "type": "comparison",
                "title": "Stack vs. Heap",
                "columns": ["Stack", "Heap"],
                "rows": [
                  {
                    "aspect": "Verwaltung",
                    "values": ["Automatisch", "Manuell"]
                  },
                  {
                    "aspect": "Lebensdauer",
                    "values": ["An G√ºltigkeitsbereich gebunden", "Beliebig steuerbar"]
                  },
                  {
                    "aspect": "Geschwindigkeit",
                    "values": ["Sehr schnell", "Langsamer"]
                  },
                  {
                    "aspect": "Fehleranf√§lligkeit",
                    "values": ["Gering", "Hoch"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Heap Speicher vergessen freizugeben",
                "text": "Nicht freigegebener Heap Speicher f√ºhrt zu Speicherlecks."
              },
              {
                "type": "important",
                "text": "Stack wann immer m√∂glich nutzen, Heap nur wenn n√∂tig."
              },
              {
                "type": "summary",
                "points": [
                  "Stack Speicher ist automatisch und sicher",
                  "Heap Speicher ist flexibel, aber manuell zu verwalten",
                  "Heap Objekte leben unabh√§ngig von Funktionen",
                  "Fehler im Heap f√ºhren oft zu schwer findbaren Bugs"
                ]
              }
            ]
          },
          {
            "title": "new & delete",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "new",
                "text": "Operator zum Anfordern von Speicher auf dem Heap und zum Erzeugen eines Objekts."
              },
              {
                "type": "definition",
                "term": "delete",
                "text": "Operator zum Freigeben von mit new reserviertem Heap Speicher."
              },
              {
                "type": "explanation",
                "title": "Grundprinzip von new und delete",
                "text": [
                  "new reserviert Speicher und ruft den Konstruktor auf.",
                  "delete ruft den Destruktor auf und gibt den Speicher frei."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches new und delete",
                "language": "cpp",
                "code": "int* p = new int(10); // Heap Speicher\n// Nutzung von *p\ndelete p;              // Speicher freigeben\np = nullptr;           // guter Stil"
              },
              {
                "type": "definition",
                "term": "Speicherleck",
                "text": "Nicht freigegebener Heap Speicher, der nicht mehr erreichbar ist."
              },
              {
                "type": "pitfall",
                "title": "delete vergessen",
                "text": "Wird delete nicht aufgerufen, bleibt der Speicher bis Programmende belegt."
              },
              {
                "type": "definition",
                "term": "new[]",
                "text": "Reserviert Speicher f√ºr ein Array auf dem Heap."
              },
              {
                "type": "definition",
                "term": "delete[]",
                "text": "Gibt Speicher frei, der mit new[] reserviert wurde."
              },
              {
                "type": "code",
                "title": "new[] und delete[]",
                "language": "cpp",
                "code": "int* arr = new int[3]; // Array auf dem Heap\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n\ndelete[] arr;          // korrektes Freigeben"
              },
              {
                "type": "pitfall",
                "title": "new[] mit delete",
                "text": "new[] und delete m√ºssen zusammen verwendet werden, genauso new und delete[]."
              },
              {
                "type": "code",
                "title": "Falsche Kombination",
                "language": "cpp",
                "code": "int* arr = new int[5];\n// delete arr; // falsch, f√ºhrt zu undefiniertem Verhalten"
              },
              {
                "type": "explanation",
                "title": "Warum new[] und delete[] zusammengeh√∂ren",
                "text": [
                  "Bei new[] m√ºssen mehrere Destruktoren aufgerufen werden.",
                  "delete[] wei√ü, wie viele Elemente zerst√∂rt werden m√ºssen."
                ]
              },
              {
                "type": "definition",
                "term": "Dangling Pointer",
                "text": "Ein Zeiger, der auf bereits freigegebenen Speicher zeigt."
              },
              {
                "type": "pitfall",
                "title": "Dangling Pointer",
                "text": "Zugriff auf freigegebenen Speicher f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "In modernem C++ sollten new und delete m√∂glichst durch Container und Smart Pointer ersetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "new reserviert Heap Speicher",
                  "delete gibt Heap Speicher frei",
                  "new[] erfordert delete[]",
                  "Vergessenes delete verursacht Speicherlecks",
                  "Dangling Pointer sind extrem gef√§hrlich"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          {
            "title": "RAII Prinzip",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "RAII",
                "text": "RAII steht f√ºr Resource Acquisition Is Initialization und koppelt Ressourcen an Objektlebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von RAII",
                "text": [
                  "Eine Ressource wird im Konstruktor eines Objekts erworben.",
                  "Die Freigabe erfolgt automatisch im Destruktor, wenn das Objekt den G√ºltigkeitsbereich verl√§sst."
                ]
              },
              {
                "type": "definition",
                "term": "Ressource",
                "text": "Alles, was explizit angefordert und freigegeben werden muss, zum Beispiel Speicher, Dateien oder Mutexes."
              },
              {
                "type": "code",
                "title": "RAII mit Speicher",
                "language": "cpp",
                "code": "class Buffer {\nprivate:\n    int* data;\n\npublic:\n    Buffer() {\n        data = new int[10]; // Ressource erwerben\n    }\n\n    ~Buffer() {\n        delete[] data;      // Ressource freigeben\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Vorteile von RAII",
                "text": [
                  "Automatische Freigabe auch bei return oder Exceptions.",
                  "Kein explizites Aufr√§umen im Code n√∂tig."
                ]
              },
              {
                "type": "pitfall",
                "title": "RAII umgehen",
                "text": "Manuelles new und delete au√üerhalb von RAII Klassen untergr√§bt das Prinzip."
              },
              {
                "type": "important",
                "text": "RAII ist das zentrale Speicherverwaltungsprinzip in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "Ressourcen sind an Objekte gebunden",
                  "Konstruktor erwirbt, Destruktor gibt frei",
                  "Sicher bei Exceptions",
                  "Grundlage f√ºr Smart Pointer"
                ]
              }
            ]
          },
          { "title": "Smart Pointer", "content": {
            "text": [
              "### === Smart Pointer in C++ ===\n",
              "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
              "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
              "\n",
              "---\n",
              "### Warum Smart Pointer?\n",
              "- Kein manuelles `delete` n√∂tig\n",
              "- Klare Besitzverh√§ltnisse\n",
              "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
              "\n",
              "---\n",
              "### üîπ `std::unique_ptr<T>`\n",
              "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
              "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
              "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
              "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
              "\n",
              "---\n",
              "### üîπ `std::shared_ptr<T>`\n",
              "- **Mehrere Besitzer** teilen sich das Objekt\n",
              "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
              "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
              "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
              "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
              "\n",
              "---\n",
              "### üîπ `std::weak_ptr<T>`\n",
              "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
              "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
              "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
              "\n",
              "---\n",
              "### üîç Vergleichstabelle:\n",
              "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
              "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
              "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
              "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        { "title": "<iostream>", "content": { "text": [], "code": [] } },
        { "title": "<fstream>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } },
        { "title": "<iomanip>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
        { "title": "<string>", "content": { "text": [], "code": [] } },
        { "title": "<string_view>", "content": { "text": [], "code": [] } },
        { "title": "<cstring>", "content": { "text": [], "code": [] } },
        { "title": "<cctype>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        { "title": "<cmath>", "content": { "text": [], "code": [] } },
        { "title": "<cstdlib>", "content": { "text": [], "code": [] } },
        { "title": "<random>", "content": { "text": [], "code": [] } },
        { "title": "<limits>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        { "title": "<chrono>", "content": { "text": [], "code": [] } },
        { "title": "<ctime>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        { "title": "<thread>", "content": { "text": [], "code": [] } },
        { "title": "<future>", "content": { "text": [], "code": [] } },
        { "title": "<typeinfo>", "content": { "text": [], "code": [] } },
        { "title": "<new>", "content": { "text": [], "code": [] } },
        { "title": "<memory>", "content": { "text": [], "code": [] } },
        { "title": "<cstdio>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
        { "title": "<algorithm>", "content": { "text": [], "code": [] } },
        { "title": "<iterator>", "content": { "text": [], "code": [] } },
        { "title": "<functional>", "content": { "text": [], "code": [] } },
        { "title": "<initializer_list>", "content": { "text": [], "code": [] } },
        { "title": "<tuple>", "content": { "text": [], "code": [] } },
        { "title": "<utility> (pair, swap)", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
          { "title": "Klassen Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren & Destruktoren", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
          { "title": "Basisklassen", "content": { "text": [], "code": [] } },
          { "title": "Polymorphie", "content": { "text": [], "code": [] } },
          { "title": "virtual / override", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
          { "title": "struct Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "struct vs class", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
          { "title": "enum Grundlagen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
          { "title": "enum class Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "enum class vs enum", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
          { "title": "namespace Grundlagen", "content": {
            "text": [
                "### === Namespaces in C++ ===\n",
                "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
                "\n",
                "---\n",
                "### Warum Namespaces?\n",
                "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
                "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
                "\n",
                "---\n",
                "### Verwendung von Namespaces\n",
                "- Definition:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
                "- Aufruf:\n",
                "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
                "\n",
                "---\n",
                "### Anonyme Namespaces (Datei-spezifisch)\n",
                "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
                "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
                "\n",
                "---\n",
                "### Verschachtelte Namespaces (modernes C++)\n",
                "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
                "\n",
                "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
                "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
                "---\n"
              ],
              "code": [
                "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
              ]
            } 
          },
          { "title": "using namespace", "content": { 
            "text": [
                "### `using namespace` (nicht immer empfohlen)\n",
                "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
                "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
                "- Besser: Nur gezielt importieren\n",
                "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
                "\n"
              ], 
            "code": [] } },
          { "title": "namespace vs. class", "content": { 
            "text": [ 
                "### === Unterschied: Namespace vs. Class ===\n",
                "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
                "\n",
                "---\n",
                "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
                "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
                "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
                "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
                "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
                "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
                "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
                "\n",
                "---\n",
                "### Beispiel zur Verdeutlichung:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
                "\n",
                "### üëâ Merksatz",
                "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
                "---\n"
            ], 
            "code": [] 
            } 
          }
        ]
      },
      {
        "name": "Klassenmember & Attribute",
        "icon": "üß©",
        "topics": [
          { "title": "static Member", "content": { 
            "text": [    
              "### === `static` in C++ ===\n",
              "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
              "\n",
              "---\n",
              "### üîπ `static` innerhalb einer Funktion:\n",
              "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
              "- Bleibt zwischen Aufrufen **erhalten**\n",
              "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
              "- Variable geh√∂rt **zur Klasse, nicht zum Objekt**\n",
              "- Wird **au√üerhalb der Klasse** definiert\n",
              "- Gleicher Wert f√ºr **alle Instanzen**\n",
              "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Klassenfunktionen:\n",
              "- Funktion geh√∂rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
              "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
              "- Wird √ºber `Klassenname::Funktion()` aufgerufen\n",
              "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
              "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
              "- N√ºtzlich zur Kapselung beim Modularisieren\n",
              "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
              "\n",
              "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschr√§nken**.\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion au√üerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
              ] 
            } 
          },
          { "title": "mutable Member", "content": { 
            "text": [  
              "### === `mutable` in C++ ===\n",
              "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu ver√§ndern**.\n",
              "\n",
              "---\n",
              "### Wann braucht man das?\n",
              "- Normalerweise d√ºrfen `const`-Funktionen **keine Membervariablen ver√§ndern**.\n",
              "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. f√ºr Logging, Caching oder Zugriffsz√§hler.\n",
              "\n",
              "---\n",
              "### Auch ohne `const` n√ºtzlich:\n",
              "- `mutable`-Member sind **immer unabh√§ngig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
              "- Sie k√∂nnen **immer ver√§ndert werden**, auch au√üerhalb von `const`-Kontexten - z.B. als interne Z√§hler oder Zust√§nde.\n",
              "\n",
              "---\n",
              "### Wichtig:\n",
              "- `mutable` funktioniert **nur bei Membervariablen**.\n",
              "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** f√ºr Klassenmitglieder.\n",
              "\n",
              "üëâ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZ√§hler = 0;  // darf auch in const-Funktion ver√§ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZ√§hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZ√§hler() const {\n    return leseZ√§hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZ√§hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "const Memberfunktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
          { "title": "Funktionstemplates", "content": { "text": [], "code": [] } },
          { "title": "Klassentemplates", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
          { "title": "vector", "content": { "text": [], "code": [] } },
          { "title": "array", "content": { "text": [], "code": [] } },
          { "title": "deque", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "map", "content": { "text": [], "code": [] } },
          { "title": "set", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
          { "title": "stack", "content": { "text": [], "code": [] } },
          { "title": "queue", "content": { "text": [], "code": [] } },
          { "title": "priority_queue", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Utility Types",
        "icon": "üß∞",
        "topics": [
          { "title": "pair", "content": { "text": [], "code": [] } },
          { "title": "tuple", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Fehlerbehandlung (try/catch)", "content": { "text": [], "code": [] } },
          { "title": "Pr√§prozessor (#define)", "content": { "text": [], "code": [] } },
          { "title": "CMake Basics", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Windows / Clion",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Console Ausgabe UTF-8 Windows", "content": {
            "text": [
              "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
              "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
              "---\n",
              "## üîπ FONT Einstellen:",
              "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
              "### üîπ Einstellung in CLion\n",
              "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
              "---\n",
              "### CODE in main.lua:"
              ],
            "code": [
              "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
              ]
            } 
          },
          { "title": "Working Directory in CLion", "content": {
            "text": [
              "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
              "Standardm√§√üig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen m√∂chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis (‚ÄûWorking Directory‚Äú) √§ndern.\n",
              "\n",
              "### üîπ Zielstruktur\n",
              "```",
              "Projektordner/\n",
              "‚îú‚îÄ‚îÄ CMakeLists.txt\n",
              "‚îú‚îÄ‚îÄ data/\n",
              "‚îî‚îÄ‚îÄ cmake-build-debug/",
              "```",
              "\n",
              "### üîπ Einstellung in CLion\n",
              "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
              "2. W√§hle **‚ÄûEdit Configurations‚Ä¶‚Äú**.\n",
              "3. W√§hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
              "4. Im Feld **‚ÄûWorking directory‚Äú** tr√§gst du ein: `$ProjectFileDir$`\n",
              "   ‚Üí Das sorgt daf√ºr, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
              "\n",
              "### üîπ Pr√ºfen im Code\n",
              "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
              "\n",
              "```cpp",
              "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
              "```",
              "\n",
              "---\n",
              "### üîπ Hinweis\n",
              "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
              "```cpp",
              "std::filesystem::create_directories(\"data\");",
              "```",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
          { "title": "main.cpp Grundger√ºst", "content": { "text": [], "code": [] } },
          { "title": "Hello World Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Input/Output Vorlage", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
          { "title": "Klasse mit Header & cpp", "content": { "text": [], "code": [] } },
          { "title": "Getter & Setter", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
          { "title": "vector Beispiel", "content": { "text": [], "code": [] } },
          { "title": "map Beispiel", "content": { "text": [], "code": [] } },
          { "title": "tuple / pair Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "CMakeLists.txt Minimal", "content": { "text": [], "code": [] } },
          { "title": "Ordnerstruktur Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Modulares Projekt Setup", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Datenbanken",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SQLite",
        "icon": "üß±",
        "topics": [
          { "title": "SQLite Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "prepare / bind / step / finalize", "content": { "text": [], "code": [] } },
          { "title": "CRUD Operationen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  }

]
