[
  {
    "category": "Grundlagen",
    "subtopics": [
      {
        "title": "Console Ausgabe UTF-8 Windows",
        "content": {
          "text": [
            "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
            "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
            "---\n",
            "## üîπ FONT Einstellen:",
            "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
            "### üîπ Einstellung in CLion\n",
            "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
            "---\n",
            "### CODE in main.lua:"
          ],
          "code": [
            "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
          ]
        }
      },
      {
  "title": "Working Directory in CLion",
  "content": {
    "text": [
      "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
      "Standardm√§√üig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen m√∂chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis (‚ÄûWorking Directory‚Äú) √§ndern.\n",
      "\n",
      "### üîπ Zielstruktur\n",
      "```",
      "Projektordner/\n",
      "‚îú‚îÄ‚îÄ CMakeLists.txt\n",
      "‚îú‚îÄ‚îÄ data/\n",
      "‚îî‚îÄ‚îÄ cmake-build-debug/",
      "```",
      "\n",
      "### üîπ Einstellung in CLion\n",
      "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
      "2. W√§hle **‚ÄûEdit Configurations‚Ä¶‚Äú**.\n",
      "3. W√§hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
      "4. Im Feld **‚ÄûWorking directory‚Äú** tr√§gst du ein: `$ProjectFileDir$`\n",
      "   ‚Üí Das sorgt daf√ºr, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
      "\n",
      "### üîπ Pr√ºfen im Code\n",
      "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
      "\n",
      "```cpp",
      "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
      "```",
      "\n",
      "---\n",
      "### üîπ Hinweis\n",
      "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
      "```cpp",
      "std::filesystem::create_directories(\"data\");",
      "```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Begriffe",
        "content": {
          "text": [
          "### === Wichtige Begriffe in C++ erkl√§rt ===\n",
          "Hier findest du eine √úbersicht zentraler Begriffe in der C++-Programmierung, kompakt erkl√§rt.\n",
          "\n",
          "#### Compiler\n",
          "- √úbersetzt C++-Code in Maschinenprogramm, das dein Computer ausf√ºhren kann\n",
          "\n",
          "#### Pr√§prozessor\n",
          "- F√ºhrt Anweisungen wie `#include` und `#define` vor dem Kompilieren aus\n",
          "\n",
          "#### Header-Datei\n",
          "- Datei mit Deklarationen von Funktionen, Klassen oder Konstanten (`.hpp`)\n",
          "\n",
          "#### Deklaration vs. Definition\n",
          "- Deklaration: Nur Ank√ºndigung (z.B. `int x;`)\n",
          "- Definition: Speicher wird wirklich zugewiesen (z.B. `int x = 5;`)\n",
          "\n",
          "#### Variable\n",
          "- Speicherstelle mit Namen, die Daten aufnehmen kann (z.B. `int zahl = 10;`)\n",
          "\n",
          "#### Funktion\n",
          "- Codeblock, der mehrfach ausf√ºhrbar ist - mit `return`-Wert und Parametern\n",
          "\n",
          "#### R√ºckgabewert\n",
          "- Der Wert, den eine Funktion mit `return` zur√ºckliefert\n",
          "\n",
          "#### Parameter vs. Argument\n",
          "- Parameter: Platzhalter in der Funktionsdefinition (`int add(int a, int b)`)\n",
          "- Argument: Konkreter Wert beim Aufruf (`add(5, 7)` ‚Üí 5 und 7)\n",
          "\n",
          "#### Block / Scope\n",
          "- Bereich mit `{}` - darin gelten lokale Variablen\n",
          "\n",
          "#### G√ºltigkeitsbereich (Scope)\n",
          "- Gibt an, wo im Code eine Variable sichtbar/nutzbar ist (z.B. lokal vs. global)\n",
          "\n",
          "#### Initialisierung\n",
          "- Erstmalige Zuweisung eines Werts an eine Variable (`int x = 5;`)\n",
          "\n",
          "#### Operatoren\n",
          "- Rechenzeichen oder Symbole zur Verarbeitung (`+`, `-`, `==`, `&&`, `++`, `<<`)\n",
          "\n",
          "#### Kontrollstrukturen\n",
          "- Anweisungen zur Ablaufsteuerung: `if`, `while`, `for`, `switch`\n",
          "\n",
          "#### Schleife\n",
          "- Wiederholt Anweisungen: `while`, `for`, `do-while`\n",
          "\n",
          "#### Bedingung\n",
          "- Ausdruck, der `true` oder `false` ergibt (z.B. `x > 5`)\n",
          "\n",
          "#### Klasse / Objekt\n",
          "- Klasse: Bauplan f√ºr Objekte (enth√§lt Daten + Funktionen)\n",
          "- Objekt: Konkrete Instanz einer Klasse\n",
          "\n",
          "#### Konstruktor / Destruktor\n",
          "- Konstruktor: Wird beim Erzeugen eines Objekts automatisch aufgerufen\n",
          "- Destruktor: Wird beim L√∂schen automatisch aufgerufen (`~Klassenname()`)\n",
          "\n",
          "#### this-Zeiger\n",
          "- Zeigt innerhalb einer Klasse auf das aktuelle Objekt (`this->variable`)\n",
          "\n",
          "#### new / delete\n",
          "- `new`: Reserviert Speicher auf dem Heap (`int* p = new int;`)\n",
          "- `delete`: Gibt diesen Speicher wieder frei\n",
          "\n",
          "#### Referenz (&)\n",
          "- Alias auf eine bestehende Variable (z.B. `int& r = x;`)\n",
          "\n",
          "#### Zeiger (*)\n",
          "- Variable, die eine Speicheradresse speichert (`int* p = &x;`)\n",
          "\n",
          "#### nullptr\n",
          "- Null-Zeiger, zeigt auf ‚Äûnichts‚Äú (`int* p = nullptr;`)\n",
          "\n",
          "#### √úberladung\n",
          "- Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Signatur\n",
          "\n",
          "#### Vererbung\n",
          "- Eine Klasse √ºbernimmt Eigenschaften einer anderen Klasse\n",
          "\n",
          "#### Polymorphie\n",
          "- F√§higkeit, Objekte √ºber gemeinsame Schnittstellen unterschiedlich zu behandeln\n",
          "\n",
          "#### Template\n",
          "- Erm√∂glicht generischen Code (z.B. Funktionen f√ºr beliebige Typen)\n",
          "\n",
          "#### Lambda\n",
          "- Anonyme Funktion, oft f√ºr kurze Aktionen in `std::for_each`, `sort`, ...\n",
          "\n",
          "#### Iterator\n",
          "- Zeiger-√§hnliches Objekt zum Durchlaufen von Containern (`v.begin()`, `v.end()`)\n",
          "---\n"
        ],
          "code": []
        }
      },
      {
        "title": "Typen",
        "content": {
          "text": [
            "### === Datentypen in C++ ===\n",
            "C++ kennt viele eingebaute Typen und erlaubt die Definition eigener Typen.\n",
            "\n",
            "---\n",
            "### Standard-Datentypen\n",
            "- `int`: Ganzzahl (z.B. `int x = 5;`)\n",
            "- `float`: Flie√ükommazahl mit einfacher Genauigkeit\n",
            "- `double`: Flie√ükommazahl mit doppelter Genauigkeit\n",
            "- `char`: Einzelnes Zeichen (z.B. `'A'`)\n",
            "- `bool`: Wahrheitswert (`true` / `false`)\n",
            "- `void`: Kein R√ºckgabewert (z.B. bei `void funktion()`)\n",
            "\n",
            "---\n",
            "### Erweiterte Grundtypen\n",
            "- `long`, `long long`, `unsigned`, `short`: Varianten von `int`\n",
            "- `wchar_t`, `char16_t`, `char32_t`: Unicode-Zeichentypen\n",
            "- `std::string`: String-Klasse (aus `<string>`)\n",
            "- `std::size_t`: Unsigned Ganzzahl f√ºr Gr√∂√üen (z.B. `v.size()`)\n",
            "- `nullptr_t`: Typ des Literals `nullptr`\n",
            "\n",
            "---\n",
            "### Automatische Typableitung\n",
            "- `auto`: Typ wird automatisch aus dem Ausdruck ermittelt\n",
            "- `decltype(...)`: Liefert den Typ eines Ausdrucks\n",
            "- Beispiel:\n",
            "```cpp\nint x = 5;\nauto y = x * 2;         // y ist int\ndecltype(y) z = 10;      // z ist auch int\n```\n",
            "\n",
            "---\n",
            "### Eigene Typen\n",
            "- `struct`: F√ºr einfache Strukturen mit mehreren Feldern\n",
            "- `class`: F√ºr Klassen mit Methoden und Zugriffskontrolle (public/private)\n",
            "- `enum`: F√ºr aufz√§hlbare Werte\n",
            "\n",
            "#### `enum` Erkl√§rung:\n",
            "- `enum` erstellt eigene ganzzahlige Werte (standardm√§√üig beginnend bei 0)\n",
            "- Beispiel:\n",
            "```cpp\nenum Farbe { Rot, Gruen, Blau };  // Rot = 0, Gruen = 1, Blau = 2\n```\n",
            "- Man kann Werte auch selbst zuweisen:\n",
            "```cpp\nenum Status { OK = 1, FEHLER = 404, NICHT_GEFUNDEN = 4040 };\n```\n",
            "- Zugriff auf Zahlwert mit `static_cast<int>(enumWert)`:\n",
            "```cpp\nStatus s = FEHLER;\nstd::cout << static_cast<int>(s);  // Ausgabe: 404\n```\n",
            "- `enum class` (modernes C++): Streng typisiert, Zugriff nur mit `Status::FEHLER`\n",
            "\n",
            "---\n",
            "### `using/typedef` Erkl√§rung:\n",
            "- `typedef` (alt) und `using` (modern): Eigene Namen f√ºr bestehende Typen\n",
            "- Beispiel:\n",
            "```cpp\ntypedef unsigned int uint;\nusing Score = double;\n```",
            "\n",
            "---\n",
            "### Typumwandlung (Casting)\n",
            "- `static_cast<T>(wert)`: Sicherer Cast zwischen kompatiblen Typen\n",
            "- `const_cast<T>`: Entfernt `const`\n",
            "\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <typeinfo>\n\n// Eigene Struktur\nstruct Person {\n    std::string name;\n    int alter;\n};\n\n// Typalias\nusing Zahl = unsigned int;\n\nenum Farbe { Rot, Gruen, Blau };           // Rot = 0, Gruen = 1, Blau = 2\nenum Status { OK = 1, FEHLER = 404 };      // eigene Werte\n\nint main() {\n    int a = 10;\n    auto b = 3.14;                          // automatisch double\n    decltype(a) c = 5;                      // ebenfalls int\n\n    Person p = {\"Kilian\", 21};\n    Zahl punkte = 150;\n\n    Farbe f = Gruen;\n    Status s = FEHLER;\n\n    std::cout << \"Name: \" << p.name << \", Alter: \" << p.alter << std::endl;         // Ausgabe: Name: Kilian, Alter: 21\n    std::cout << \"Punkte: \" << punkte << std::endl;                                  // Ausgabe: Punkte: 150\n    std::cout << \"Typ von b: \" << typeid(b).name() << std::endl;                     // Ausgabe: Typ von b: double (compilerabh√§ngig)\n    std::cout << \"Fehlercode: \" << static_cast<int>(s) << std::endl;                // Ausgabe: Fehlercode: 404\n\n    return 0;\n}"
          ]
        }
      },
      {
        "title": "Header",
        "content": {
          "text": [
            "### === Wichtige Header-Dateien in C++ ===\n",
            "Header-Dateien enthalten Deklarationen von Funktionen, Klassen und Datentypen. Standard-Header kommen aus der C++-Standardbibliothek, eigene erstellt man selbst.\n",
            "\n",
            "---\n",
            "### Arten von `#include`\n",
            "- `#include <...>`: F√ºr Standardbibliothek (z.B. `<iostream>`, `<vector>`, ...)\n",
            "- `#include \"...\"`: F√ºr eigene Dateien (z.B. `\"meinmodul.hpp\"`)\n",
            "\n",
            "---\n",
            "### Eigene Header-Dateien\n",
            "- Eigene Header enden mit `.hpp`\n",
            "- Sie enthalten **Deklarationen**, keine Implementierungen\n",
            "- Die zugeh√∂rige `.cpp`-Datei enth√§lt dann die **Definitionen**\n",
            "\n",
            "#### Beispiel - Header-Datei: `meinmodul.hpp`\n",
            "```cpp\n#ifndef MEINMODUL_HPP\n#define MEINMODUL_HPP\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n```\n",
            "\n",
            "#### Beispiel - Implementierung: `meinmodul.cpp`\n",
            "```cpp\n#include <iostream>\n#include \"meinmodul.hpp\"\n\nvoid begruessung() {\n    std::cout << \"Hallo!\";\n}\n```\n",
            "\n",
            "#### In `main.cpp` verwenden:\n",
            "```cpp\n#include \"meinmodul.hpp\"\n\nint main() {\n    begruessung();\n    return 0;\n}\n```\n",
            "\n",
            "üëâ Vorteil: strukturierter Code, Wiederverwendbarkeit und Trennung von Schnittstelle & Implementierung\n",
            "\n",
            "---\n",
            "### Include Guards (Schutz vor Mehrfacheinbindung)\n",
            "- Jeder eigene Header sollte mit einem **Include Guard** versehen werden:\n",
            "```cpp\n#ifndef MEIN_HEADER_HPP\n#define MEIN_HEADER_HPP\n\n// Inhalte des Headers\n\n#endif\n```\n",
            "- Verhindert doppelte Definitionen beim mehrfachen Einbinden. In CLion automatisch!\n",
            "\n",
            "---\n",
            "### √úbersicht wichtiger Standard-Header:\n",
            "\n",
            "#### Ein- und Ausgabe\n",
            "- `<iostream>`: `std::cin`, `std::cout`, `std::cerr`\n",
            "- `<iomanip>`: `std::setw`, `std::setprecision`, `std::fixed`, `std::put_time`\n",
            "- `<fstream>`: Datei-I/O mit `ifstream`, `ofstream`, `fstream`\n",
            "\n",
            "#### Strings und Streams\n",
            "- `<string>`: `std::string`\n",
            "- `<sstream>`: `std::stringstream` f√ºr String-Parsing und Umwandlungen\n",
            "\n",
            "#### Mathematisches\n",
            "- `<cmath>`: `sqrt`, `pow`, `abs`, `round`, `sin`, `log`\n",
            "- `<cstdlib>`: `rand`, `srand`, `atoi`, `atof`\n",
            "- `<limits>`: `numeric_limits<T>::max()` / `min()`\n",
            "\n",
            "#### Zeit und Threads\n",
            "- `<ctime>`: `std::time`, `std::localtime`\n",
            "- `<chrono>`: Zeitmessung (z.B. `high_resolution_clock`)\n",
            "- `<thread>`: `std::this_thread::sleep_for()`\n",
            "\n",
            "#### Container & Algorithmen\n",
            "- `<vector>`, `<array>`, `<set>`, `<map>`\n",
            "- `<stack>`, `<queue>`\n",
            "- `<algorithm>`: `sort`, `find`, `remove`, `for_each`, ...\n",
            "- `<iterator>`: Iteratorfunktionen wie `begin()`/`end()`\n",
            "\n",
            "#### Weitere n√ºtzliche Header\n",
            "- `<exception>`: `std::exception`, `std::runtime_error`\n",
            "- `<typeinfo>`: Laufzeittypinfo (`typeid`)\n",
            "- `<utility>`: `std::pair`, `std::swap`, `std::move`\n",
            "- `<memory>`: Smart Pointers wie `unique_ptr`, `shared_ptr`\n",
            "---\n"
          ],
          "code": [
            "#ifndef MEINMODUL_HPP\n#define MEINMODUL_HPP\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n\n// -----------------------------\n#include <iostream>\n#include \"meinmodul.hpp\"\n\nvoid begruessung() {\n  std::cout << \"Hallo!\";\n}\n\nint main() {\n  begruessung(); // Ausgabe: Hallo!\n  return 0;\n}"

          ]
        }
      },
      {
  "title": "Initialisierung  : vs. {}",
  "content": {
    "text": [
      "### === Initialisierung mit `:` vs. `{}` in C++ ===\n",
      "C++ bietet verschiedene M√∂glichkeiten, wie Variablen und Klassenmitglieder initialisiert werden k√∂nnen. Besonders wichtig sind:\n",
      "---\n",
      "- `:` ‚Üí Initialisierungsliste bei Konstruktoren\n",
      "- `{}` ‚Üí Einheitliche Initialisierung (Brace-Initialization / Uniform Initialization)\n",
      "\n",
      "---\n",
      "### Initialisierungsliste mit `:`\n",
      "- Wird in Konstruktoren verwendet, um Member **direkt zu initialisieren**, bevor der Body ausgef√ºhrt wird\n",
      "- **Effizienter** als Zuweisung im Konstruktorblock (insbesondere bei `const`- oder Referenz-Membern)\n",
      "\n",
      "```cpp\nclass Auto {\nprivate:\n    int ps;\npublic:\n    Auto(int p) : ps(p) {}   // Initialisierung mit Doppelpunkten\n};\n```\n",
      "\n",
      "---\n",
      "### Warum `:` statt `=` im Body?\n",
      "- `:` initialisiert direkt beim Erzeugen ‚Üí **vermeidet unn√∂tige Standardinitialisierung + sp√§tere Zuweisung**\n",
      "- Pflicht bei `const` oder Referenzen:\n",
      "```cpp\nclass Test {\n    const int wert;\npublic:\n    Test(int w) : wert(w) {}  // Muss so gemacht werden\n};\n```\n",
      "\n",
      "---\n",
      "### Einheitliche Initialisierung mit `{}`\n",
      "- Eingef√ºhrt mit C++11\n",
      "- Kann **Konstruktoren**, **Arrays**, **STL-Container** und **structs** initialisieren\n",
      "- **Vermeidet Verwechslungen** mit Funktionsdeklarationen (Most Vexing Parse)\n",
      "\n",
      "```cpp\nint a{5};                  // Direktinitialisierung\nstd::vector<int> zahlen{1, 2, 3};\nAuto b{150};                // ruft Konstruktor mit `int` auf\n```\n",
      "\n",
      "---\n",
      "### Kombination\n",
      "- Beides l√§sst sich kombinieren:\n",
      "```cpp\nclass Zahl {\n    int wert;\npublic:\n    Zahl(int w) : wert{w} {}  // Doppelt sicher: Initialisierungsliste + {}\n};\n```\n",
      "\n",
      "üëâ Faustregel:\n",
      "- **Konstruktoren mit `:` initialisieren Member**\n",
      "- **`{}` ist sicherer, universeller Stil ab C++11**\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Beispiel {\nprivate:\n    const int wert;\n    std::vector<int> zahlen;\n\npublic:\n    // Initialisierung mit : und {}\n    Beispiel(int w) : wert(w), zahlen{1, 2, 3} {}\n\n    void anzeigen() {\n        std::cout << \"Wert: \" << wert << \" | Erster Wert: \" << zahlen[0] << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b{42};      // Konstruktor-Aufruf mit {} Initialisierung\n    b.anzeigen();         // Ausgabe: Wert: 42 | Erster Wert: 1\n\n    int x{10};            // Brace-Initialisierung einer einfachen Variable\n    std::cout << \"x: \" << x << std::endl;\n\n    return 0;\n}"
    ]
        }
      }
    ]
  },







  {
    "category": "Ein-/Ausgabe",
    "subtopics": [
      {
        "title": "Eingabe",
        "content": {
          "text": [
            "### === Benutzereingabe in C++ ===\n",
            "F√ºr die Eingabe in C++ wird meist `std::cin` verwendet. Dabei wird direkt aus der Konsole gelesen.\n",
            "\n",
            "---\n",
            "### `std::cin`\n",
            "- Liest eine Eingabe **bis zum ersten Leerzeichen**\n",
            "- Nur f√ºr einzelne W√∂rter oder Zahlen geeignet\n",
            "\n",
            "---\n",
            "### `std::getline`\n",
            "- Liest eine ganze **Zeile** (inklusive Leerzeichen)\n",
            "- Ideal f√ºr Namen, Adressen, ganze S√§tze usw.\n",
            "- Wichtig: vorher `std::cin.ignore()` nutzen, wenn zuvor `cin` verwendet wurde\n",
            "\n",
            "---\n",
            "### `std::cin.ignore()`\n",
            "- Leert den Eingabepuffer, z.B. nach `cin` vor `getline`\n",
            "- Typisch: `std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');`\n",
            "\n",
            "---\n",
            "### `std::stringstream`\n",
            "- Konvertiert zwischen Strings und Zahlen\n",
            "- N√ºtzlich f√ºr Eingaben mit vielen Werten in einer Zeile\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <limits> // f√ºr std::numeric_limits\n\nint main() {\n  std::string name;\n  int alter;\n\n  // Eingabe eines einzelnen Werts\n  std::cout << \"Wie alt bist du? \";\n  std::cin >> alter;\n\n  // Eingabepuffer leeren (wichtig vor getline)\n  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n  // Eingabe einer ganzen Zeile\n  std::cout << \"Wie hei√üt du? \";\n  std::getline(std::cin, name);\n\n  std::cout << \"Hallo \" << name << \", du bist \" << alter << \" Jahre alt.\" << std::endl;\n\n  // Stringstream Beispiel\n  std::string eingabe = \"23 42 99\";\n  std::stringstream ss(eingabe);\n  int zahl1, zahl2, zahl3;\n  ss >> zahl1 >> zahl2 >> zahl3;\n  std::cout << \"Zahlen aus dem String: \" << zahl1 << \", \" << zahl2 << \", \" << zahl3 << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Ausgabe",
        "content": {
          "text": [
            "### === Ausgabe mit `std::cout` in C++ ===\n",
            "`std::cout` ist die Standardausgabe in C++ und wird f√ºr Konsolenausgaben verwendet.\n",
            "\n",
            "---\n",
            "### Grundlegende Ausgabe\n",
            "`std::cout << \"Text\" << variable;`\n",
            "- Die `<<`-Operatoren h√§ngen Inhalte aneinander\n",
            "- Mit `\\n` oder `std::endl` wird eine Zeile beendet\n",
            "\n",
            "---\n",
            "### Formatierung mit `<iomanip>`\n",
            "- `std::setw(n)`: Feldbreite setzen\n",
            "- `std::setprecision(n)`: Genauigkeit f√ºr Nachkommastellen\n",
            "- `std::fixed`: Kommazahlen mit fester Nachkommastellenzahl\n",
            "- `std::left` / `std::right`: Ausrichtung\n",
            "\n",
            "---\n",
            "### Fehlerausgabe mit `std::cerr` und `std::clog`\n",
            "- `std::cerr`: Wird f√ºr **Fehlermeldungen** verwendet (ungespeichert)\n",
            "- `std::clog`: Wird f√ºr **Logmeldungen** verwendet (gepuffert)\n",
            "- Beide gehen wie `std::cout` in die Konsole, k√∂nnen aber **umgeleitet** werden\n",
            "\n",
            "---\n",
            "### F√ºhrende Nullen bei Zahlen\n",
            "- Mit `std::setw(n)` und `std::setfill('0')` lassen sich Zahlen mit f√ºhrenden Nullen formatieren:\n",
            "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // Ausgabe: 00017\n```\n",
            "- Mit `std::string`: Umwandlung und manuelles Auff√ºllen:\n",
            "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17); // \"00017\"\n```\n",
            "- Ab C++20: `std::format` macht es besonders einfach:\n",
            "```cpp\nstd::cout << std::format(\"{:05}\", 17); // Ausgabe: 00017\n```\n",
            "\n",
            "---\n",
            "### Zahlenformat: `dec`, `hex`, `oct`\n",
            "- `std::dec`: Ausgabe als Dezimalzahl (Standard)\n",
            "- `std::hex`: Ausgabe als Hexadezimalzahl\n",
            "- `std::oct`: Ausgabe als Oktalzahl\n",
            "- Wichtig bei Bin√§rformaten, Flags oder Speicheradressen\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int alter = 21;\n  double kontostand = 1234.56789;\n\n  // Einfache Begr√º√üung\n  std::cout << \"Hallo, \" << name << \"!\\n\"; // Ausgabe: Hallo, Kilian!\n\n  // Formatierte Tabelle\n  std::cout << std::left << std::setw(10) << \"Name\"\n            << std::right << std::setw(10) << \"Alter\"\n            << std::setw(15) << \"Kontostand\" << std::endl;\n\n  std::cout << std::left << std::setw(10) << name\n            << std::right << std::setw(10) << alter\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl;\n\n  // Zahlenformat\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;\n\n  // F√ºhrende Nullen mit iomanip\n  int nummer = 17;\n  std::cout << \"F√ºhrende Nullen (iomanip): \" << std::setw(5) << std::setfill('0') << nummer << std::endl; // Ausgabe: 00017\n\n  // Mit std::string auff√ºllen\n  std::string gepolstert = std::string(5 - std::to_string(nummer).length(), '0') + std::to_string(nummer);\n  std::cout << \"Mit std::string: \" << gepolstert << std::endl; // Ausgabe: 00017\n\n#if __cpp_lib_format\n  // C++20: std::format\n  std::cout << \"Mit std::format: \" << std::format(\"{:05}\", nummer) << std::endl; // Ausgabe: 00017\n#endif\n\n  // Fehlermeldung und Logausgabe\n  std::cerr << \"Dies ist eine Fehlermeldung!\" << std::endl;\n  std::clog << \"Dies ist eine Logmeldung.\" << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
  "title": "Datei",
  "content": {
    "text": [
      "### === Datei-Ein-/Ausgabe in C++ ===\n",
      "`<fstream>` wird f√ºr klassische Dateiarbeit verwendet, `<filesystem>` f√ºr moderne Pfad- und Existenzpr√ºfungen.\n",
      "\n",
      "---\n",
      "### üîπ Typen aus `<fstream>`\n",
      "- `std::ofstream`: Schreiben (`output file stream`)\n",
      "- `std::ifstream`: Lesen (`input file stream`)\n",
      "- `std::fstream`: Beides\n",
      "\n",
      "---\n",
      "### üîπ Datei √∂ffnen\n",
      "- `std::ofstream f(\"name.txt\");` - zum Schreiben (√ºberschreibt!)\n",
      "- `std::ofstream f(\"name.txt\", std::ios::app);` - **zum Anh√§ngen**\n",
      "- `std::ifstream f(\"name.txt\");` - zum Lesen\n",
      "\n",
      "---\n",
      "### üîπ Datei pr√ºfen\n",
      "- Mit `.is_open()` oder √ºber `if (stream)`\n",
      "- Mit `std::filesystem::exists(pfad)` pr√ºft man, ob eine Datei/Ordner **existiert**\n",
      "- `std::filesystem::is_regular_file(pfad)`: pr√ºft auf **normale Datei**\n",
      "- `std::filesystem::is_directory(pfad)`: pr√ºft auf **Verzeichnis**\n",
      "\n",
      "---\n",
      "### üîπ Zeilenweise lesen und ver√§ndern\n",
      "- Mit `std::getline()` Zeilen einlesen\n",
      "- In `std::vector<std::string>` zwischenspeichern\n",
      "- √Ñnderungen durchf√ºhren und danach Datei neu schreiben\n",
      "\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <filesystem>\n\nint main() {\n  std::string dateiname = \"daten.txt\";\n\n  // Pr√ºfen, ob Datei bereits existiert\n  if (std::filesystem::exists(dateiname)) {\n    std::cout << \"Datei existiert bereits.\" << std::endl;\n  } else {\n    std::cout << \"Datei existiert NICHT. Wird erstellt...\" << std::endl;\n  }\n\n  // Neue Datei anlegen\n  std::ofstream out(dateiname);\n  if (out) {\n    out << \"Zeile 1\\n\" << \"Zeile 2\\n\" << \"Zeile 3\\n\";\n    out.close();\n  }\n\n  // Zeile anh√§ngen\n  std::ofstream append(dateiname, std::ios::app);\n  append << \"Neue Zeile am Ende\\n\";\n  append.close();\n\n  // Datei einlesen\n  std::ifstream in(dateiname);\n  std::vector<std::string> inhalt;\n  std::string zeile;\n  while (std::getline(in, zeile)) {\n    inhalt.push_back(zeile);\n  }\n  in.close();\n\n  // Zeile 2 bearbeiten (Index 1)\n  if (inhalt.size() >= 2) {\n    inhalt[1] = \"[GE√ÑNDERT] \" + inhalt[1];\n  }\n\n  // Datei √ºberschreiben\n  std::ofstream out2(dateiname);\n  for (const std::string& z : inhalt) {\n    out2 << z << \"\\n\";\n  }\n  out2.close();\n\n  // Pr√ºfung auf Verzeichnis\n  if (std::filesystem::is_directory(\".\")) {\n    std::cout << \"Aktuelles Verzeichnis ist g√ºltig.\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Date/Time",
        "content": {
          "text": [
            "### === Datum und Uhrzeit in C++ ===\n",
            "C++ bietet mehrere M√∂glichkeiten, um mit Datum und Zeit zu arbeiten.\n",
            "\n",
            "---\n",
            "### `std::time` & `std::localtime`\n",
            "- `std::time(nullptr)` liefert aktuelle Zeit (Sekunden seit 01.01.1970)\n",
            "- `std::localtime()` wandelt sie in eine `tm`-Struktur f√ºr lesbares Datum um\n",
            "\n",
            "---\n",
            "### `std::put_time()` (aus `<iomanip>`) f√ºr Formatierung\n",
            "- `std::put_time()` funktioniert wie `strftime`\n",
            "- Beispiel-Formate: `%d.%m.%Y`, `%H:%M:%S`, `%Y-%m-%d_%H-%M`\n",
            "- Mit `std::ostringstream` kann man Datum/Zeit auch als `std::string` speichern\n",
            "\n",
            "---\n",
            "### Zeitmessung mit `<chrono>`\n",
            "- Nutze `std::chrono::high_resolution_clock` f√ºr pr√§zise Messungen\n",
            "- `std::this_thread::sleep_for(...)` pausiert das Programm gezielt\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <ctime>        // time, localtime\n#include <iomanip>      // put_time\n#include <sstream>      // ostringstream f√ºr string-Formate\n#include <chrono>       // chrono f√ºr Zeitmessung\n#include <thread>       // sleep_for\n\nint main() {\n  // 1. Aktuelle Uhrzeit formatieren und anzeigen\n  std::time_t jetzt = std::time(nullptr);               // Sekunden seit 1970\n  std::tm* lokal = std::localtime(&jetzt);              // lokale Zeitstruktur\n\n  std::cout << \"Aktuelle Uhrzeit: \"\n            << std::put_time(lokal, \"%d.%m.%Y %H:%M:%S\") << std::endl; // Ausgabe: 28.05.2025 19:45:12\n\n  // 2. Zeit als String speichern\n  std::ostringstream oss;\n  oss << std::put_time(lokal, \"%Y-%m-%d_%H-%M-%S\");\n  std::string zeitString = oss.str();\n  std::cout << \"Als String gespeichert: \" << zeitString << std::endl; // Ausgabe: 2025-05-28_19-45-12\n\n  // 3. Kurze Pause (Thread schlafen lassen)\n  std::cout << \"Warte 1 Sekunde...\" << std::endl;\n  std::this_thread::sleep_for(std::chrono::seconds(1)); // Pause f√ºr 1 Sekunde\n  std::cout << \"Weiter!\" << std::endl; // Ausgabe: Weiter!\n\n  // 4. Zeitmessung mit chrono\n  auto start = std::chrono::high_resolution_clock::now();\n\n  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 0,5 Sek warten\n\n  auto ende = std::chrono::high_resolution_clock::now();\n  auto dauer = std::chrono::duration_cast<std::chrono::milliseconds>(ende - start);\n\n  std::cout << \"Verstrichene Zeit: \" << dauer.count() << \" ms\" << std::endl; // Ausgabe: Verstrichene Zeit: 500 ms\n\n  return 0;\n}"
          ]
        }
      }
    ]
  },









  


  {
    "category": "Struktur",
    "subtopics": [
    {
   "title": "Schleifen / Loops",
   "content": {
    "text": [
      "### === Schleifen in C++ ===\n",
      "Schleifen erm√∂glichen **wiederholte Ausf√ºhrung** von Code, solange eine Bedingung erf√ºllt ist.\n",
      "\n",
      "---\n",
      "### üîÅ `while`-Schleife\n",
      "- F√ºhrt Code **solange** aus, wie die Bedingung **wahr** ist\n",
      "- **Kopfgesteuert** (Bedingung wird **vorher** gepr√ºft)\n",
      "```cpp\nint i = 0;\nwhile (i < 3) {\n  std::cout << i << std::endl;\n  i++;\n}\n```\n",
      "\n",
      "---\n",
      "### üîÅ `do-while`-Schleife\n",
      "- F√ºhrt den Block **mindestens einmal** aus\n",
      "- **Fu√ügesteuert** (Bedingung wird **nachher** gepr√ºft)\n",
      "```cpp\nint j = 0;\ndo {\n  std::cout << j << std::endl;\n  j++;\n} while (j < 3);\n```\n",
      "\n",
      "---\n",
      "### üîÅ `for`-Schleife\n",
      "- Ideal f√ºr Schleifen mit **Z√§hler**\n",
      "- Besteht aus Initialisierung, Bedingung, Inkrement\n",
      "```cpp\nfor (int k = 0; k < 3; ++k) {\n  std::cout << k << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### üîÅ `range-based for` (seit C++11)\n",
      "- F√ºr **Container, Arrays** oder **Strings**\n",
      "```cpp\nstd::string text = \"Hi\";\nfor (char c : text) {\n  std::cout << c << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### üîÅ Schleifensteuerung:\n",
      "- `break;` ‚Üí Schleife **sofort beenden**\n",
      "- `continue;` ‚Üí N√§chste Iteration √ºberspringen\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n  // while-Schleife\n  int i = 0;\n  while (i < 3) {\n    std::cout << \"while: \" << i << std::endl; // Ausgabe: 0, 1, 2\n    i++;\n  }\n\n  // do-while-Schleife\n  int j = 0;\n  do {\n    std::cout << \"do-while: \" << j << std::endl; // Ausgabe: 0, 1, 2\n    j++;\n  } while (j < 3);\n\n  // for-Schleife\n  for (int k = 0; k < 3; ++k) {\n    std::cout << \"for: \" << k << std::endl; // Ausgabe: 0, 1, 2\n  }\n\n  // range-based for\n  std::vector<std::string> namen = {\"Anna\", \"Bob\", \"Clara\"};\n  for (const std::string& name : namen) {\n    std::cout << \"range-for: \" << name << std::endl; // Ausgabe: Anna, Bob, Clara\n  }\n\n  // break und continue\n  for (int x = 0; x < 5; ++x) {\n    if (x == 2) continue; // √ºberspringt 2\n    if (x == 4) break;    // bricht bei 4 ab\n    std::cout << \"x: \" << x << std::endl; // Ausgabe: 0, 1, 3\n  }\n\n  return 0;\n}"
    ]
        }
      },
      {
  "title": "if / else und switch",
  "content": {
    "text": [
      "### === Bedingungen mit `if` / `else` und `switch` ===\n",
      "In C++ werden Bedingungen mit `if`, `else if`, `else` und `switch` verwendet, um **Entscheidungen** im Programmablauf zu treffen.\n",
      "\n",
      "---\n",
      "### üî∏ `if` / `else if` / `else`\n",
      "- F√ºhrt Code aus, wenn eine **Bedingung erf√ºllt** ist\n",
      "- `else if` f√ºr weitere Alternativen, `else` f√ºr den Standardfall\n",
      "```cpp\nif (x > 0) {\n  std::cout << \"Positiv\";\n} else if (x == 0) {\n  std::cout << \"Null\";\n} else {\n  std::cout << \"Negativ\";\n}\n```\n",
      "\n",
      "---\n",
      "### üî∏ Vergleichsoperatoren\n",
      "- `==`, `!=`, `<`, `>`, `<=`, `>=`\n",
      "- Kombinieren mit `&&`, `||`, `!` f√ºr UND/ODER/NICHT\n",
      "\n",
      "---\n",
      "### üî∏ `switch`-Anweisung\n",
      "- Pr√ºft **einen konkreten Wert** (ganzzahlig oder `enum`)\n",
      "- Jeder `case` ist ein m√∂glicher Wert; `default` ist der Standardfall\n",
      "- `break;` beendet den jeweiligen Fall - sonst wird weiter ausgef√ºhrt (**Fallthrough**!)\n",
      "```cpp\nswitch (auswahl) {\n  case 1: std::cout << \"Eins\"; break;\n  case 2: std::cout << \"Zwei\"; break;\n  default: std::cout << \"Unbekannt\";\n}\n```\n",
      "\n",
      "---\n",
      "### üí° Tipp\n",
      "Bei mehreren Optionen, die das gleiche tun, kann man **Fallthrough** bewusst einsetzen:\n",
      "```cpp\ncase 1:\ncase 2: std::cout << \"Eins oder Zwei\"; break;\n```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nint main() {\n  int x = -3;\n\n  // if / else if / else\n  if (x > 0) {\n    std::cout << \"x ist positiv\" << std::endl; // (nicht ausgef√ºhrt)\n  } else if (x == 0) {\n    std::cout << \"x ist Null\" << std::endl; // (nicht ausgef√ºhrt)\n  } else {\n    std::cout << \"x ist negativ\" << std::endl; // Ausgabe: x ist negativ\n  }\n\n  // Vergleich mit logischen Operatoren\n  int a = 10, b = 20;\n  if (a < b && b < 30) {\n    std::cout << \"a ist kleiner als b und b < 30\" << std::endl; // Ausgabe\n  }\n\n  // switch-Anweisung\n  int wahl = 2;\n  switch (wahl) {\n    case 1:\n      std::cout << \"Du hast Eins gew√§hlt.\" << std::endl;\n      break;\n    case 2:\n      std::cout << \"Du hast Zwei gew√§hlt.\" << std::endl; // Ausgabe\n      break;\n    case 3:\n      std::cout << \"Du hast Drei gew√§hlt.\" << std::endl;\n      break;\n    default:\n      std::cout << \"Ung√ºltige Auswahl.\" << std::endl;\n  }\n\n  // Fallthrough bewusst\n  int note = 1;\n  switch (note) {\n    case 1:\n    case 2:\n      std::cout << \"Sehr gut oder gut!\" << std::endl; // Ausgabe bei 1 oder 2\n      break;\n    case 3:\n      std::cout << \"Befriedigend\" << std::endl;\n      break;\n    default:\n      std::cout << \"Andere Note\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
  "title": "Zeiger & this-Zeiger / Pointer",
  "content": {
    "text": [
      "### === Zeiger in C++ ===\n",
      "Ein Zeiger ist eine Variable, die die Adresse eines anderen Objekts speichert.\n",
      "\n",
      "---\n",
      "### Zeiger-Grundlagen:\n",
      "- `int* ptr;` ‚Üí zeigt auf eine `int`-Variable\n",
      "- `*ptr` ‚Üí greift auf den Wert zu\n",
      "- `&x` ‚Üí gibt die Adresse von `x` zur√ºck\n",
      "\n",
      "```cpp\nint x = 10;\nint* ptr = &x;\n*ptr = 20;  // x wird ge√§ndert\n```\n",
      "\n",
      "---\n",
      "### Dynamischer Speicher:\n",
      "- Mit `new` wird Speicher auf dem Heap reserviert\n",
      "- Mit `delete` muss er wieder freigegeben werden\n",
      "```cpp\nint* p = new int(5);\ndelete p;\n```\n",
      "\n",
      "---\n",
      "### Zeiger auf Objekte:\n",
      "- Klassenobjekte k√∂nnen ebenfalls per Zeiger angesprochen werden\n",
      "- Zugriff √ºber `->`\n",
      "```cpp\nPerson* p = new Person(\"Kilian\");\np->anzeigen();\ndelete p;\n```\n",
      "\n",
      "---\n",
      "### === `this`-Zeiger ===\n",
      "- Jede Memberfunktion hat automatisch Zugriff auf `this`\n",
      "- `this` ist ein Zeiger auf das **aktuelle Objekt**\n",
      "- Wird z.B. f√ºr Vergleich, R√ºckgabe oder Methodenkette genutzt\n",
      "\n",
      "```cpp\nclass Test {\n    int wert;\npublic:\n    Test(int w) : wert(w) {}\n\n    Test& setWert(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n```\n",
      "\n",
      "üëâ So kann man z.B. Methoden verkettet aufrufen: `obj.setWert(5).setWert(10);`\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\nprivate:\n    int wert;\n\npublic:\n    Zahl(int w) : wert(w) {}\n\n    void verdoppeln() {\n        wert *= 2;\n        std::cout << \"[this: \" << this << \"] Wert: \" << wert << std::endl;\n    }\n\n    Zahl& setze(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n\nint main() {\n    int x = 5;\n    int* ptr = &x;\n    std::cout << \"Zeiger: \" << *ptr << std::endl;  // 5\n\n    *ptr = 10;\n    std::cout << \"x: \" << x << std::endl;           // 10\n\n    Zahl z(7);\n    z.verdoppeln();          // 14\n    z.setze(3).verdoppeln(); // 6\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Smart Pointer",
  "content": {
    "text": [
      "### === Smart Pointer in C++ ===\n",
      "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
      "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
      "\n",
      "---\n",
      "### Warum Smart Pointer?\n",
      "- Kein manuelles `delete` n√∂tig\n",
      "- Klare Besitzverh√§ltnisse\n",
      "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
      "\n",
      "---\n",
      "### üîπ `std::unique_ptr<T>`\n",
      "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
      "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
      "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
      "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
      "\n",
      "---\n",
      "### üîπ `std::shared_ptr<T>`\n",
      "- **Mehrere Besitzer** teilen sich das Objekt\n",
      "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
      "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
      "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
      "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
      "\n",
      "---\n",
      "### üîπ `std::weak_ptr<T>`\n",
      "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
      "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
      "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
      "\n",
      "---\n",
      "### üîç Vergleichstabelle:\n",
      "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
      "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
      "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
      "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
    ]
  }
},
   {
   "title": "Namespaces",
   "content": {
   "text": [
      "### === Namespaces in C++ ===\n",
      "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
      "\n",
      "---\n",
      "### Warum Namespaces?\n",
      "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
      "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
      "\n",
      "---\n",
      "### Verwendung von Namespaces\n",
      "- Definition:\n",
      "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
      "- Aufruf:\n",
      "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
      "\n",
      "---\n",
      "### `using namespace` (nicht immer empfohlen)\n",
      "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
      "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
      "- Besser: Nur gezielt importieren\n",
      "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
      "\n",
      "---\n",
      "### Anonyme Namespaces (Datei-spezifisch)\n",
      "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
      "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
      "\n",
      "---\n",
      "### Verschachtelte Namespaces (modernes C++)\n",
      "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
      "\n",
      "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
      "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
      "---\n"
    ],
    "code": [
            "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
          ]
        }
      },
      {
      "title": "Namespace vs. Class",
      "content": {
      "text": [
            "### === Unterschied: Namespace vs. Class ===\n",
            "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
            "\n",
            "---\n",
            "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
            "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
            "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
            "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
            "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
            "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
            "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
            "\n",
            "---\n",
            "### Beispiel zur Verdeutlichung:\n",
            "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
            "\n",
            "### üëâ Merksatz",
            "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
            "---\n"
          ],
          "code": []
        }
      },
{
  "title": "Const",
  "content": {
    "text": [
      "### === `const` in C++ ===\n",
      "`const` sch√ºtzt vor ungewollten √Ñnderungen und je nach Position bedeutet es etwas anderes:\n",
      "\n",
      "---\n",
      "### üîπ `const` bei Variablen:\n",
      "- Der Wert darf **nicht ver√§ndert** werden\n",
      "```cpp\nconst int x = 5;\n// x = 10; // ‚ùå Fehler\n```\n",
      "\n",
      "---\n",
      "### üîπ `const` bei Funktionsparametern:\n",
      "- Verhindert √Ñnderungen am √úbergabewert\n",
      "```cpp\nvoid zeige(const std::string& text);\n```\n",
      "- spart **Kopieraufwand** + sch√ºtzt Daten\n",
      "\n",
      "---\n",
      "### üîπ `const`-Methoden:\n",
      "- Garantie, dass innerhalb der Methode **nichts ver√§ndert wird**\n",
      "```cpp\nclass Person {\n    std::string name;\npublic:\n    std::string getName() const; // ‚ùå darf name nicht √§ndern\n};\n```\n",
      "\n",
      "---\n",
      "### üîπ `const` bei Zeigern:\n",
      "| Schreibweise           | Bedeutung                               |\n",
      "| `const int* p`        | Zeiger auf **konstante Daten**           |\n",
      "| `int* const p`        | **Konstanter Zeiger** auf Daten          |\n",
      "| `const int* const p`  | **Beides konstant**                      |\n",
      "\n",
      "```cpp\nconst int* p = &x;   // *p darf nicht ge√§ndert werden\nint* const q = &x;   // q darf nicht woanders hinzeigen\n```\n",
      "\n",
      "---\n",
      "### üîπ `const` bei R√ºckgabewerten:\n",
      "- Schutz vor Modifikation des R√ºckgabewerts\n",
      "```cpp\nconst std::string& getName() const;  // R√ºckgabe nicht modifizierbar\n```\n",
      "\n",
      "---\n",
      "### Merksatz:\n",
      "- Lies `const` **von rechts nach links**:\n",
      "    - `int* const` = konstanter Zeiger auf int\n",
      "    - `const int*` = Zeiger auf konstantes int\n",
      "\n",
      "üëâ `const` hilft, **Bugs zu vermeiden**, **Lesbarkeit zu erh√∂hen** und ist **Best Practice** in modernem C++\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n    std::string name;\n\npublic:\n    Person(const std::string& n) : name(n) {}\n\n    // const-Methode: darf nichts ver√§ndern\n    std::string getName() const {\n        return name;\n    }\n\n    // const-R√ºckgabe + const-Parameter\n    void begruessung(const std::string& begrussung) const {\n        std::cout << begrussung << \", \" << name << \"!\" << std::endl;\n    }\n};\n\nint main() {\n    const int x = 5;\n    // x = 10; // ‚ùå nicht erlaubt\n\n    const int* ptr1 = &x;    // Zeiger auf konstanten Wert\n    // *ptr1 = 20; // ‚ùå nicht erlaubt\n\n    int y = 8;\n    int* const ptr2 = &y;    // Konstanter Zeiger\n    *ptr2 = 12;              // ‚úÖ erlaubt\n\n    Person p(\"Kilian\");\n    p.begruessung(\"Hallo\");\n    std::cout << \"Name: \" << p.getName() << std::endl;\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Const Overloading",
  "content": {
    "text": [
      "### === `const` Overloading ===\n",
      "In C++ kann man Funktionen **√ºberladen**, indem man einmal eine `const`- und einmal eine **nicht-`const`-Version** erstellt.\n",
      "\n",
      "---\n",
      "### Warum?\n",
      "- `const`-Objekte d√ºrfen nur `const`-Funktionen aufrufen.\n",
      "- So kann dieselbe Funktion **unterschiedliches Verhalten** haben - je nach `const`-Zustand des Objekts.\n",
      "\n",
      "---\n",
      "### `const` am Ende einer Methode:\n",
      "- Bedeutet: Diese Funktion **ver√§ndert keine Membervariablen** (au√üer `mutable`)\n",
      "- Wichtig f√ºr **Zugriffsmethoden (Getter)** oder bei Funktionen, die nur lesen\n",
      "\n",
      "üëâ `const` ist Teil der Funktionssignatur und wird bei der √úberladung beachtet.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n  std::string name;\n\npublic:\n  Person(std::string n) : name(n) {}\n\n  // Nicht-const-Version\n  std::string& getName() {\n    std::cout << \"Nicht-const Version\" << std::endl;\n    return name;\n  }\n\n  // Const-Version (f√ºr const Objekte)\n  const std::string& getName() const {\n    std::cout << \"Const-Version\" << std::endl;\n    return name;\n  }\n};\n\nint main() {\n  Person p1(\"Kilian\");\n  const Person p2(\"Lisa\");\n\n  std::cout << p1.getName() << std::endl;  // Ausgabe: Nicht-const Version\\nKilian\n  std::cout << p2.getName() << std::endl;  // Ausgabe: Const-Version\\nLisa\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Mutable",
  "content": {
    "text": [
      "### === `mutable` in C++ ===\n",
      "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu ver√§ndern**.\n",
      "\n",
      "---\n",
      "### Wann braucht man das?\n",
      "- Normalerweise d√ºrfen `const`-Funktionen **keine Membervariablen ver√§ndern**.\n",
      "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. f√ºr Logging, Caching oder Zugriffsz√§hler.\n",
      "\n",
      "---\n",
      "### Auch ohne `const` n√ºtzlich:\n",
      "- `mutable`-Member sind **immer unabh√§ngig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
      "- Sie k√∂nnen **immer ver√§ndert werden**, auch au√üerhalb von `const`-Kontexten - z.B. als interne Z√§hler oder Zust√§nde.\n",
      "\n",
      "---\n",
      "### Wichtig:\n",
      "- `mutable` funktioniert **nur bei Membervariablen**.\n",
      "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** f√ºr Klassenmitglieder.\n",
      "\n",
      "üëâ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZ√§hler = 0;  // darf auch in const-Funktion ver√§ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZ√§hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZ√§hler() const {\n    return leseZ√§hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZ√§hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Static",
  "content": {
    "text": [
      "### === `static` in C++ ===\n",
      "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
      "\n",
      "---\n",
      "### üîπ `static` innerhalb einer Funktion:\n",
      "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
      "- Bleibt zwischen Aufrufen **erhalten**\n",
      "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
      "- Variable geh√∂rt **zur Klasse, nicht zum Objekt**\n",
      "- Wird **au√üerhalb der Klasse** definiert\n",
      "- Gleicher Wert f√ºr **alle Instanzen**\n",
      "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
      "\n",
      "---\n",
      "### üîπ `static` bei Klassenfunktionen:\n",
      "- Funktion geh√∂rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
      "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
      "- Wird √ºber `Klassenname::Funktion()` aufgerufen\n",
      "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
      "\n",
      "---\n",
      "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
      "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
      "- N√ºtzlich zur Kapselung beim Modularisieren\n",
      "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
      "\n",
      "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschr√§nken**.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion au√üerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
    ]
  }
}
    ]
  },







  {
    "category": "Speicherverwaltung",
    "subtopics": [
      {
  "title": "Heap (new / new[])",
  "content": {
    "text": [
      "### === Heap-Speicher in C++ (new / delete) ===\n",
      "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
      "\n",
      "---\n",
      "### üîπ Warum Heap?\n",
      "- Stack ist nur f√ºr **kurzlebige, kleine** Daten\n",
      "- Heap erlaubt **dynamische Gr√∂√üe** und **l√§ngere Lebenszeit**\n",
      "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
      "\n",
      "---\n",
      "### üî∏ `new` f√ºr EIN Objekt:\n",
      "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
      "- Speicher f√ºr genau **ein Objekt** wird angefordert\n",
      "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
      "\n",
      "---\n",
      "### üî∏ `new[]` f√ºr MEHRERE Objekte (Array):\n",
      "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
      "- Reserviert **zusammenh√§ngenden Speicherplatz** f√ºr mehrere Objekte\n",
      "- Muss mit **`delete[]`** freigegeben werden!\n",
      "\n",
      "---\n",
      "### ‚ùó Vorsicht bei falscher Kombination:\n",
      "- `new[]` ‚Üí `delete[]`\n",
      "- `new` ‚Üí `delete`\n",
      "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
      "\n",
      "---\n",
      "### üîπ Klassen & Konstruktoren:\n",
      "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
      "\n",
      "---\n",
      "### üîπ Wann `new[]` statt `new`?\n",
      "- Wenn du mehrere gleichartige Objekte brauchst ‚Üí `new[]`\n",
      "- Wenn du nur ein einzelnes Objekt brauchst ‚Üí `new`\n",
      "\n",
      "---\n",
      "### ‚ùó Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
      "üëâ Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nint main() {\n    // new f√ºr EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] f√ºr MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt l√∂schen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gel√∂scht\n    delete[] pArr;  // 2x Punkt gel√∂scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Heap vs. Stack",
  "content": {
    "text": [
      "### === Speicherverwaltung in C++: Stack vs. Heap ===\n",
      "In C++ unterscheidet man bei der Speichervergabe zwischen **Stack** und **Heap**:\n",
      "\n",
      "---\n",
      "### üîπ Stack-Speicher (automatisch)\n",
      "- Wird f√ºr **lokale Variablen** verwendet\n",
      "- Speicher wird **automatisch** freigegeben, wenn der Block verlassen wird\n",
      "- Sehr schnell & sicher, aber begrenzt (Stack Overflow bei gro√üen Arrays)\n",
      "\n",
      "```cpp\nvoid funktion() {\n    int a = 10;        // auf dem Stack\n} // a wird automatisch gel√∂scht\n```\n",
      "\n",
      "---\n",
      "### üîπ Heap-Speicher (dynamisch)\n",
      "- Wird bei Bedarf mit `new` reserviert und mit `delete` freigegeben\n",
      "- Muss **manuell** verwaltet werden ‚Üí Gefahr von Speicherlecks\n",
      "- Gr√∂√üer, aber langsamer als der Stack\n",
      "\n",
      "```cpp\nint* ptr = new int(5);  // Speicher im Heap\n*ptr = 42;\ndelete ptr;             // Speicher freigeben\n```\n",
      "\n",
      "---\n",
      "### üîπ Vergleich:\n",
      "| Merkmal     | Stack                     | Heap                          |\n",
      "| Geschwindigkeit | Sehr schnell              | Langsamer                    |\n",
      "| Lebensdauer | Block-lokal (automatisch) | Manuell, bis `delete`        |\n",
      "| Speichergr√∂√üe | Begrenzter Speicher       | Gr√∂√üerer Speicher verf√ºgbar  |\n",
      "| Fehlerquellen | Stack Overflow m√∂glich    | Speicherlecks, Dangling Ptr  |\n",
      "\n",
      "---\n",
      "### üî∏ Modern C++ Tipp:\n",
      "- Statt `new` / `delete` ‚Üí besser `std::unique_ptr`, `std::shared_ptr`\n",
      "- Smart Pointer √ºbernehmen Speicherverwaltung automatisch\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory> // f√ºr Smart Pointer\n\nvoid stackBeispiel() {\n    int zahl = 10;                    // Stack-Speicher\n    std::cout << \"Stack: \" << zahl << std::endl;\n} // zahl wird automatisch gel√∂scht\n\nvoid heapBeispiel() {\n    int* ptr = new int(42);           // Heap-Speicher\n    std::cout << \"Heap: \" << *ptr << std::endl;\n    delete ptr;                       // manuell l√∂schen\n}\n\nvoid smartPointerBeispiel() {\n    std::unique_ptr<int> sp = std::make_unique<int>(100);\n    std::cout << \"SmartPointer: \" << *sp << std::endl;\n} // wird automatisch gel√∂scht\n\nint main() {\n    stackBeispiel();\n    heapBeispiel();\n    smartPointerBeispiel();\n    return 0;\n}"
    ]
  }
}

    ]
  },



  {
    "category": "Container",
    "subtopics": [
      {
        "title": "Strings",
        "content": {
          "text": [
            "### === String-Funktionen in C++ ===\n",
            "",
            "```cpp",
            "std::string example = \"Hello, World\";\n",
            "std::string number = \"42\";",
            "```\n",
            "---\n",
            "",
            "-> `.size()` - Gibt die L√§nge des Strings zur√ºck\n",
            "```cpp",
            "example.size(); // 12",
            "```\n",
            "---\n",
            "",
            "-> `.substr(start, length)` - Teilstring ab Startindex\n",
            "```cpp",
            "example.substr(3, 5); // \"lo, W\"",
            "```\n",
            "---\n",
            "",
            "-> `.replace(start, count, string)` - Ersetzt einen Teil des Strings\n",
            "```cpp",
            "example.replace(7, 5, \"Universe\"); // Hello, Universe",
            "```\n",
            "---\n",
            "",
            "-> `.empty()` - Pr√ºft ob der String leer ist\n",
            "-> `example[1]` - Zugriff auf Zeichen an Position\n",
            "-> `.find(\"text\")` - Sucht ein Teilwort im String\n",
            "",
            "---\n",
            "### === String <-> Zahl ===\n",
            "",
            "```cpp",
            "int i = std::stoi(\"42\");     // ‚Üí 42\n",
            "double d = std::stod(\"3.14\"); // ‚Üí 3.14\n",
            "std::string s = std::to_string(100); // ‚Üí \"100\"",
            "```\n",
            "",
            "---\n",
            "### === String-Konkatenation & Vergleich ===\n",
            "",
            "```cpp",
            "std::string s1 = \"Hello\";\n",
            "std::string s2 = \"World\";\n",
            "std::string s3 = s1 + \" \" + s2; // \"Hello World\"\n",
            "s1.compare(s2); // < 0 ‚Üí s1 < s2",
            "```\n",
            "",
            "---\n",
            "### === Gro√ü- und Kleinschreibung ===\n",
            "",
            "-> `#include <cctype>`, `#include <algorithm>` f√ºr toupper/tolower\n",
            "",
            "```cpp",
            "std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n",
            "std::transform(str.begin(), str.end(), str.begin(), ::tolower);",
            "```\n",
            "",
            "#### -> Einzelzeichen:\n",
            "```cpp",
            "std::toupper('a'); // ‚Üí 'A'\n",
            "std::islower('B'); // ‚Üí false\n",
            "std::isalpha('x'); // ‚Üí true\n",
            "std::isdigit('9'); // ‚Üí true",
            "```\n",
            "",
            "---\n",
            "### === istringstream: String analysieren ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::string zeile = \"3 Apfel 1.99\";\n",
            "std::istringstream iss(zeile);\n",
            "int menge; std::string produkt; double preis;\n",
            "iss >> menge >> produkt >> preis;\n",
            "// menge = 3, produkt = Apfel, preis = 1.99",
            "```\n",
            "",
            "---\n",
            "### === ostringstream: String zusammensetzen ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::ostringstream oss;\n",
            "oss << menge << \" \" << produkt << \" kosten \" << (menge * preis);\n",
            "std::string ausgabe = oss.str();",
            "```",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n\nint main() {\n  std::string text = \"C++ macht Spa√ü!\";\n\n  // L√§nge\n  std::cout << \"L√§nge: \" << text.length() << std::endl; // Ausgabe: 15\n\n  // Teilstring\n  std::string teil = text.substr(4, 5);\n  std::cout << \"Teilstring: \" << teil << std::endl; // Ausgabe: macht\n\n  // finden\n  size_t pos = text.find(\"Spa√ü\");\n  if (pos != std::string::npos)\n    std::cout << \"\\\"Spa√ü\\\" gefunden an Position: \" << pos << std::endl; // Ausgabe: 11\n\n  // ersetzen\n  text.replace(4, 5, \"ist cool\");\n  std::cout << \"Nach replace: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü!\n\n  // anh√§ngen\n  text += \" :)\";\n  std::cout << \"Nach Anf√ºgen: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü! :)\n\n  // einf√ºgen\n  text.insert(0, \"[INFO] \");\n  std::cout << \"Mit Prefix: \" << text << std::endl; // Ausgabe: [INFO] C++ ist cool Spa√ü! :)\n\n  // l√∂schen\n  text.erase(0, 7);\n  std::cout << \"Ohne Prefix: \" << text << std::endl; // Ausgabe: C++ ist cool Spa√ü! :)\n\n  // vergleichen\n  std::string a = \"Apfel\", b = \"Banane\";\n  if (a.compare(b) < 0)\n    std::cout << a << \" kommt vor \" << b << std::endl; // Ausgabe: Apfel kommt vor Banane\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Vektor",
        "content": {
          "text": [
            "### === Vector-Funktionen in C++ ===\n",
            "-> `std::vector<int> zahlen = {5, 3, 8, 1};` // Initialisierung eines Vektors\n",
            "-> `zahlen.push_back(element);` // F√ºgt ein Element hinten an (kopiert oder verschiebt es)\n",
            "-> `zahlen.emplace_back(argumente);` // Baut das Element direkt im Vektor (konstruiert es vor Ort)\n",
            "---\n",
            "### Unterschied `push_back` und `emplace_back`",
            "`push_back` erwartet ein fertiges Objekt,\n",
            "`emplace_back` √ºbernimmt die Konstruktion direkt im Speicher des Vektors.\n",
            "Besonders n√ºtzlich bei komplexen Typen wie `std::pair` oder eigenen Klassen.\n",
            "```cpp",
            "Beispiel: v.emplace_back(\"Text\", 42); statt: v.push_back(std::make_pair(\"Text\", 42));",
            "```\n",
            "---\n",
            "-> `zahlen.size();` // Gibt die Anzahl der Elemente im Vektor zur√ºck\n",
            "-> `zahlen[2];` // Greift direkt auf das Element mit Index 2 zu (kein Bounds-Check)\n",
            "-> `zahlen.at(1);` // Greift sicher auf Index 1 zu (mit Bounds-Check)\n",
            "-> `zahlen.front();` // Gibt das erste Element im Vektor zur√ºck\n",
            "-> `zahlen.back();` // Gibt das letzte Element im Vektor zur√ºck\n",
            "-> `zahlen.empty();` // Pr√ºft, ob der Vektor leer ist (true/false)\n",
            "-> `std::find(zahlen.begin(), zahlen.end(), 3);` // Sucht nach Wert 3 im Vektor\n",
            "-> `zahlen.insert(zahlen.begin() + 1, 42);` // F√ºgt 42 an Position 1 ein\n",
            "-> `std::sort(zahlen.begin(), zahlen.end());` // Sortiert den Vektor aufsteigend\n",
            "-> `std::reverse(zahlen.begin(), zahlen.end());` // Dreht die Reihenfolge um\n",
            "\n",
            "---\n",
            "-> `zahlen.erase(zahlen.begin());` // L√∂scht das erste Element\n",
            "-> `zahlen.erase(zahlen.begin(), zahlen.begin() + 2);` // L√∂scht die ersten zwei Elemente\n",
            "-> `zahlen.erase(zahlen.begin() + 2);` // L√∂scht das Element an Index 2\n",
            "-> `zahlen.clear();` // L√∂scht alle Elemente aus dem Vektor\n",
            "-> `zahlen.pop_back();` // Entfernt das letzte Element im Vektor\n",
            "\n",
            "---\n",
            "-> `zahlen.assign(5, 7);` // Setzt den Vektor auf 5 Elemente mit dem Wert 7\n",
            "-> `std::remove(zahlen.begin(), zahlen.end(), 5);` // Entfernt alle Vorkommen von 5 (nutzt erase danach!)\n",
            "-> `std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x; });` // Wendet eine Funktion auf alle Elemente an\n",
            "\n",
            "---\n",
            "### === 2D Vektor in C++ ===\n",
            "-> `std::vector<std::vector<int>> v3 = {{1}, {2, 3}, {4, 5, 6}};` // 2D vector\n",
            "Erstellt 2D-Vektor (Vektoren von Vektoren)\n",
            "`v3` hat drei Zeilen: `v3[0] = {1}; v3[1] = {2, 3}; v3[2] = {4, 5, 6}`\n",
            "`v3[2][2]` gibt `6` zur√ºck (Zeile 3, Spalte 3)\n",
            "---\n",
            "### === Unterschied: std::vector vs. std::tuple ===\n",
            "-> `std::vector<T>` speichert **beliebig viele Werte vom gleichen Typ** (z.B. `int`). Die Gr√∂√üe ist dynamisch und zur Laufzeit ver√§nderbar.\n",
            "-> `std::tuple<T1, T2, ...>` speichert **eine feste Anzahl unterschiedlich typisierter Werte**. Die Gr√∂√üe ist zur Compile-Zeit festgelegt.\n",
            "\n",
            "---\n",
            "### Beispiel:\n",
            "- `std::vector<int> v = {1, 2, 3};` ‚Üí Liste von Zahlen\n",
            "- `std::tuple<int, std::string> t = {42, \"Text\"};` ‚Üí Kombination aus Zahl & Text\n",
            "\n",
            "**Merksatz:** `vector = Liste gleicher Typen`, `tuple = Paket verschiedener Typen`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr sort()\n\nint main() {\n  // Vektor mit Werten initialisieren\n  std::vector<int> zahlen = {4, 2, 7};\n\n  // Element hinzuf√ºgen\n  zahlen.push_back(5); // Vektor = {4, 2, 7, 5}\n\n  // Gr√∂√üe des Vektors\n  std::cout << \"Anzahl Elemente: \" << zahlen.size() << std::endl; // Ausgabe: 4\n\n  // Zugriff auf Elemente\n  std::cout << \"Erstes Element: \" << zahlen[0] << std::endl; // Ausgabe: 4\n  std::cout << \"Zweites Element: \" << zahlen.at(1) << std::endl; // Ausgabe: 2\n  std::cout << \"Letztes Element: \" << zahlen.back() << std::endl; // Ausgabe: 5\n\n  // Ausgabe mit Schleife\n  std::cout << \"Alle Elemente: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 4 2 7 5\n  std::cout << std::endl;\n\n  // Element entfernen (letztes)\n  zahlen.pop_back(); // entfernt 5\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end()); // Vektor = {2, 4, 7}\n\n  // Ausgabe nach Sortierung\n  std::cout << \"Sortiert: \";\n  for (size_t i = 0; i < zahlen.size(); ++i) {\n    std::cout << zahlen[i] << \" \";\n  } // Ausgabe: 2 4 7\n  std::cout << std::endl;\n\n  // leeren Vektor pr√ºfen\n  if (!zahlen.empty()) {\n    std::cout << \"Vektor ist NICHT leer\" << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Sets",
        "content": {
          "text": [
            "### === Sets in C++ ===\n",
            "-> `#include <set>`       // F√ºr std::set\n",
            "\n",
            "---\n",
            "### --- Grundlagen ---\n",
            "-> `std::set<char> s1 = {'H', 'E', 'L', 'L', 'O'};`\n",
            "   Ein Set speichert nur eindeutige Elemente - doppelte 'L' werden entfernt\n",
            "   Ergebnis: `{ 'E', 'H', 'L', 'O' }` (automatisch sortiert nach ASCII)\n",
            "-> `s1.size()` Gibt die Anzahl der eindeutigen Elemente zur√ºck ‚Üí 4\n",
            "-> `s1.contains('E')` Pr√ºft, ob 'E' im Set enthalten ist ‚Üí true (1)\n",
            "-> `s1.contains('X')` Pr√ºft, ob 'X' im Set enthalten ist ‚Üí false (0)\n",
            "\n",
            "---\n",
            "### --- Elemente hinzuf√ºgen/entfernen ---\n",
            "-> `s1.insert('!')` F√ºgt ein neues Element hinzu ‚Üí `{ '!', 'E', 'H', 'L', 'O' }`\n",
            "-> `s1.erase('O')` Entfernt das Element 'O' aus dem Set\n",
            "-> `s1.clear()` Entfernt alle Elemente aus dem Set\n",
            "-> `s1.empty()` Pr√ºft, ob das Set leer ist ‚Üí true (1)\n",
            "\n",
            "---\n",
            "### --- Vergleich von Sets ---\n",
            "-> `std::set<int> a = {1, 2};`\n",
            "-> `std::set<int> b = {2, 1};`\n",
            "-> `a == b` ‚Üí true (1), Reihenfolge ist egal, nur Inhalte z√§hlen\n",
            "\n",
            "-> `std::set<int> c = {1, 2, 2};`\n",
            "-> `std::set<int> d = {1, 1, 2};`\n",
            "-> `c == d` ‚Üí true (1), da doppelte Eintr√§ge ignoriert werden\n",
            "\n",
            "_Hinweis: `std::set` speichert die Elemente automatisch sortiert,_\n",
            "_Erlaubt keine Duplikate und bietet schnellen Zugriff._\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  // Set mit Ganzzahlen\n  std::set<int> zahlen;\n\n  // Elemente einf√ºgen (werden automatisch sortiert)\n  zahlen.insert(5);\n  zahlen.insert(2);\n  zahlen.insert(8);\n  zahlen.insert(2); // Duplikat - wird ignoriert\n\n  // Ausgabe der Elemente\n  std::cout << \"Inhalt des Sets: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 2 5 8\n  std::cout << std::endl;\n\n  // Pr√ºfen, ob ein Element enthalten ist\n  if (zahlen.count(5) > 0) {\n    std::cout << \"5 ist enthalten\" << std::endl;\n  }\n\n  // Alternative mit find()\n  if (zahlen.find(3) == zahlen.end()) {\n    std::cout << \"3 ist NICHT enthalten\" << std::endl;\n  }\n\n  // Anzahl der Elemente\n  std::cout << \"Set-Gr√∂√üe: \" << zahlen.size() << std::endl; // Ausgabe: 3\n\n  // Element l√∂schen\n  zahlen.erase(2);\n  std::cout << \"Nach L√∂schen von 2: \";\n  for (int x : zahlen) std::cout << x << \" \"; // Ausgabe: 5 8\n  std::cout << std::endl;\n\n  // Set leeren\n  zahlen.clear();\n  std::cout << \"Nach clear(): Gr√∂√üe = \" << zahlen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Maps",
        "content": {
          "text": [
            "### === Maps in C++ ===\n",
            "-> `#include <map>`       // F√ºr std::map\n",
            "-> `#include <string>`    // F√ºr std::string als Schl√ºssel/Wert\n",
            "\n",
            "---\n",
            "### --- Grundlagen ---\n",
            "-> `std::map<std::string, int> m1;` Leere Map von string ‚Üí int\n",
            "-> `m1[\"C++\"] = 100;` F√ºgt Schl√ºssel \"C++\" mit Wert 100 ein\n",
            "-> `m1[\"Java\"] = 90; m1[\"Python\"] = 85;` Weitere Eintr√§ge\n",
            "   Map speichert Schl√ºssel-Wert-Paare, automatisch sortiert nach Schl√ºssel\n",
            "\n",
            "---\n",
            "### --- Zugriff & Erstellung ---\n",
            "-> `std::map<std::string, std::string> m2 = {{\"de\", \"Berlin\"}, {\"fr\", \"Paris\"}, {\"opf\", \"Regensburg\"}};`\n",
            "-> `m2.size()` ‚Üí Anzahl der Paare in der Map ‚Üí 3\n",
            "-> `m2[\"de\"]` ‚Üí Zugriff auf den Wert zu \"de\" ‚Üí \"Berlin\"\n",
            "-> `m2[\"en\"]` ‚Üí Nicht vorhanden ‚Üí erstellt Eintrag mit leerem String als Wert\n",
            "\n",
            "---\n",
            "### --- Sichere Abfrage mit at() ---\n",
            "-> `m1.at(\"C++\")` ‚Üí Gibt den Wert zu \"C++\" zur√ºck ‚Üí 100\n",
            "`// m1.at(\"C\")` w√ºrde abst√ºrzen (throw std::out_of_range), wenn Schl√ºssel nicht existiert!\n",
            "\n",
            "---\n",
            "### --- Existenz pr√ºfen mit count() ---\n",
            "-> `m1.count(\"Java\")` ‚Üí Gibt 1 zur√ºck, wenn vorhanden\n",
            "-> `m1.count(\"Cobol\")` ‚Üí Gibt 0 zur√ºck, wenn nicht vorhanden\n",
            "\n",
            "---\n",
            "### --- Entfernen & Pr√ºfen ---\n",
            "-> `m1.clear()` ‚Üí Entfernt alle Schl√ºssel-Wert-Paare\n",
            "-> `m1.empty()` ‚Üí Pr√ºft, ob Map leer ist ‚Üí true (1)\n",
            "\n",
            "---\n",
            "### --- Vergleich von Maps ---\n",
            "-> `std::map<int, char> mA = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mB = {{1, 'x'}, {2, 'z'}};`\n",
            "-> `mA == mB` ‚Üí false, da Werte unterschiedlich\n",
            "\n",
            "-> `std::map<int, char> mC = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mD = {{2, 'y'}, {1, 'x'}};`\n",
            "-> `mC == mD` ‚Üí true, Reihenfolge ist egal, Inhalte gleich\n",
            "\n",
            "-> `std::map<int, char> mE = {{2, 'y'}, {1, 'x'}, {1, 'x'}};`\n",
            "-> `mC == mE` ‚Üí true, mehrfacher identischer Eintrag z√§hlt nicht doppelt\n",
            "\n",
            "_Hinweis: `std::map` speichert die Schl√ºssel automatisch sortiert ‚Äî bei `int` aufsteigend (1, 2, 3, ...), bei `string` alphabetisch (a, b, c, ...) und erlaubt keine Duplikate._\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  // Map von Namen zu Alter\n  std::map<std::string, int> personen;\n\n  // Eintr√§ge hinzuf√ºgen\n  personen[\"Anna\"] = 23;\n  personen[\"Bob\"] = 30;\n  personen.insert({\"Clara\", 27});\n\n  // Werte lesen\n  std::cout << \"Anna ist \" << personen[\"Anna\"] << \" Jahre alt.\" << std::endl; // Ausgabe: Anna ist 23 Jahre alt.\n\n  // Map durchgehen (automatisch sortiert nach Schl√ºssel)\n  std::cout << \"Alle Eintr√§ge:\\n\";\n  for (const auto& eintrag : personen) {\n    std::cout << eintrag.first << \": \" << eintrag.second << std::endl;\n  } // Ausgabe: Anna: 23 / Bob: 30 / Clara: 27 (alphabetisch)\n\n  // Existenz pr√ºfen\n  if (personen.count(\"Bob\") > 0) {\n    std::cout << \"Bob ist vorhanden.\" << std::endl; // Ausgabe: Bob ist vorhanden.\n  }\n\n  // Mit find() pr√ºfen und Zugriff\n  auto it = personen.find(\"Dora\");\n  if (it == personen.end()) {\n    std::cout << \"Dora ist NICHT vorhanden.\" << std::endl;\n  }\n\n  // Wert √§ndern\n  personen[\"Anna\"] = 24; // Anna hat jetzt Geburtstag\n\n  // Eintrag l√∂schen\n  personen.erase(\"Bob\");\n\n  // Ausgabe nach √Ñnderungen\n  std::cout << \"Nach √Ñnderungen:\\n\";\n  for (const auto& p : personen) {\n    std::cout << p.first << \": \" << p.second << std::endl;\n  } // Ausgabe: Anna: 24 / Clara: 27\n\n  // Gr√∂√üe der Map\n  std::cout << \"Anzahl Personen: \" << personen.size() << std::endl; // Ausgabe: 2\n\n  // Map leeren\n  personen.clear();\n  std::cout << \"Nach clear(): \" << personen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Stack/Queue",
        "content": {
          "text": [
            "### === Stack/Queue in C++ ===\n",
            "-> `#include <stack>`   // F√ºr std::stack\n",
            "-> `#include <queue>`   // F√ºr std::queue\n",
            "-> `#include <string>`  // F√ºr std::string\n",
            "\n",
            "---\n",
            "### --- STACK (LIFO - Last In, First Out) ---\n",
            "-> `std::stack<std::string> s1;` Erstellt einen leeren Stack vom Typ std::string\n",
            "-> `s1.push(\"Hello\");` F√ºgt 'Hello' oben auf den Stack\n",
            "-> `s1.push(\"World\");` F√ºgt 'World' oben auf den Stack\n",
            "   Stack-Inhalt (von unten nach oben): [`Hello`, `World`]\n",
            "-> `s1.top();` Gibt das oberste Element zur√ºck ‚Üí \"World\"\n",
            "-> `s1.pop();` Entfernt das oberste Element (\"World\")\n",
            "-> `s1.size();` Gibt die Anzahl der Elemente im Stack zur√ºck ‚Üí 1\n",
            "-> `s1.empty();` Pr√ºft, ob der Stack leer ist (true/false)\n",
            "\n",
            "---\n",
            "### --- QUEUE (FIFO - First In, First Out) ---\n",
            "-> `std::queue<std::string> q1;` Erstellt eine leere Queue f√ºr std::string\n",
            "-> `q1.push(\"Hello\");` F√ºgt 'Hello' hinten in die Queue ein\n",
            "-> `q1.push(\"World\");` F√ºgt 'World' hinten in die Queue ein\n",
            "   Reihenfolge: front ‚Üí back = [`Hello`, `World`]\n",
            "-> `q1.front();` Gibt das erste (√§lteste) Element zur√ºck ‚Üí \"Hello\"\n",
            "-> `q1.back();` Gibt das letzte (neueste) Element zur√ºck ‚Üí \"World\"\n",
            "-> `q1.pop();` Entfernt das erste Element (\"Hello\")\n",
            "-> `q1.size();` Gibt die Anzahl der Elemente in der Queue zur√ºck ‚Üí 1\n",
            "-> `q1.empty();` Pr√ºft, ob die Queue leer ist (true/false)\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n\nint main() {\n  // -------- STACK (LIFO) --------\n  std::stack<int> stapel;\n  stapel.push(10);\n  stapel.push(20);\n  stapel.push(30); // Stapel: 10, 20, 30 (oben)\n\n  std::cout << \"[STACK] Oberstes Element: \" << stapel.top() << std::endl; // Ausgabe: 30\n  stapel.pop();\n  std::cout << \"[STACK] Nach pop(): \" << stapel.top() << std::endl; // Ausgabe: 20\n\n  std::cout << \"[STACK] Gr√∂√üe: \" << stapel.size() << std::endl; // Ausgabe: 2\n  if (!stapel.empty()) {\n    std::cout << \"[STACK] Nicht leer.\" << std::endl;\n  }\n\n  // -------- QUEUE (FIFO) --------\n  std::queue<std::string> warteschlange;\n  warteschlange.push(\"Anna\");\n  warteschlange.push(\"Bob\");\n  warteschlange.push(\"Clara\"); // Reihenfolge: Anna, Bob, Clara\n\n  std::cout << \"[QUEUE] Vorne: \" << warteschlange.front() << std::endl; // Ausgabe: Anna\n  std::cout << \"[QUEUE] Hinten: \" << warteschlange.back() << std::endl; // Ausgabe: Clara\n\n  warteschlange.pop();\n  std::cout << \"[QUEUE] Nach pop(): Vorne ist jetzt \" << warteschlange.front() << std::endl; // Ausgabe: Bob\n\n  std::cout << \"[QUEUE] Gr√∂√üe: \" << warteschlange.size() << std::endl; // Ausgabe: 2\n  if (!warteschlange.empty()) {\n    std::cout << \"[QUEUE] Nicht leer.\" << std::endl;\n  }\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Pairs/Tuples",
        "content": {
          "text": [
            "### === Pairs & Tuples in C++ ===\n",
            "-> `#include <utility>`   // F√ºr std::pair\n",
            "-> `#include <tuple>`     // F√ºr std::tuple\n",
            "-> `#include <string>`    // F√ºr std::string\n",
            "-> `#include <vector>`    // F√ºr std::vector\n",
            "\n",
            "---\n",
            "### std::pair\n",
            "-> `std::pair<std::string, int> p1 = std::make_pair(\"Regensburg\", 199000);`\n",
            "-> `std::pair<std::string, int> p2 = std::make_pair(\"Weiden\", 43000);`\n",
            "-> `std::pair<std::string, int> p3 = std::make_pair(\"Amberg\", 42000);`\n",
            "####   Ein Pair enth√§lt genau zwei Werte unterschiedlichen Typs\n",
            "-> `p1.first` ‚Üí Gibt das erste Element zur√ºck ‚Üí \"Regensburg\"\n",
            "-> `p1.second` ‚Üí Gibt das zweite Element zur√ºck ‚Üí 199000\n",
            "-> `std::vector<std::pair<std::string, int>> cities = {p1, p2, p3};` // Liste von St√§dten mit Einwohnern\n",
            "-> `cities[1].first` ‚Üí Zugriff auf den Namen der zweiten Stadt ‚Üí \"Weiden\"\n",
            "\n",
            "---\n",
            "### std::tuple\n",
            "-> `std::tuple<std::string, int, double> t1 = std::make_tuple(\"Lisa\", 123, 1.0);`\n",
            "-> `std::tuple<std::string, int, double> t2 = std::make_tuple(\"Bart\", 456, 3.7);`\n",
            "-> `std::tuple<std::string, int, double> t3 = std::make_tuple(\"Nelson\", 666, 5.0);`\n",
            "####   Ein Tuple kann beliebig viele Werte enthalten\n",
            "-> `std::get<0>(t1)` ‚Üí Zugriff auf das erste Element ‚Üí \"Lisa\"\n",
            "-> `std::get<1>(t2)` ‚Üí Zugriff auf das zweite Element ‚Üí 456\n",
            "-> `std::get<2>(t3)` ‚Üí Zugriff auf das dritte Element ‚Üí 5.0\n",
            "\n",
            "`std::tuple<T1, T2, T3>`: Bei Tuples muss der Index zur Compilezeit bekannt sein ‚Üí `std::get<1>(...)`\n",
            "   Das bedeutet: `std::get<0>(...)` gibt das erste Element vom Typ `T1` zur√ºck\n",
            "---\n",
            "### === Unterschied: std::vector vs. std::tuple ===\n",
            "-> `std::vector<T>` speichert **beliebig viele Werte vom gleichen Typ** (z.B. `int`). Die Gr√∂√üe ist dynamisch und zur Laufzeit ver√§nderbar.\n",
            "-> `std::tuple<T1, T2, ...>` speichert **eine feste Anzahl unterschiedlich typisierter Werte**. Die Gr√∂√üe ist zur Compile-Zeit festgelegt.\n",
            "\n",
            "---\n",
            "**Beispiel:**\n",
            "- `std::vector<int> v = {1, 2, 3};` ‚Üí Liste von Zahlen\n",
            "- `std::tuple<int, std::string> t = {42, \"Text\"};` ‚Üí Kombination aus Zahl & Text\n",
            "\n",
            "**Merksatz:** `vector = Liste gleicher Typen`, `tuple = Paket verschiedener Typen`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <utility>  // f√ºr pair, make_pair\n#include <tuple>    // f√ºr tuple, make_tuple, get, tie\n\nint main() {\n  // -------- PAIR --------\n  std::pair<std::string, int> person = {\"Anna\", 25};\n  std::cout << \"[PAIR] Name: \" << person.first << \", Alter: \" << person.second << std::endl; // Ausgabe: Anna, 25\n\n  // Alternative mit make_pair\n  auto student = std::make_pair(\"Bob\", 30);\n  std::cout << \"[PAIR] Student: \" << student.first << \" - \" << student.second << std::endl;\n\n  // Vergleich\n  std::pair<int, int> a = {1, 2};\n  std::pair<int, int> b = {1, 3};\n  if (a < b) {\n    std::cout << \"[PAIR] a < b (lexikografisch)\" << std::endl;\n  }\n\n  // -------- TUPLE --------\n  std::tuple<std::string, int, double> daten = {\"Clara\", 28, 1.65};\n  std::cout << \"\\n[TUPLE] Name: \" << std::get<0>(daten)\n            << \", Alter: \" << std::get<1>(daten)\n            << \", Gr√∂√üe: \" << std::get<2>(daten) << std::endl; // Ausgabe: Clara, 28, 1.65\n\n  // Alternative mit make_tuple\n  auto eintrag = std::make_tuple(\"David\", 32, 1.80);\n\n  // Entpacken mit tie\n  std::string name;\n  int alter;\n  double groesse;\n  std::tie(name, alter, groesse) = eintrag;\n  std::cout << \"[TUPLE] Entpackt: \" << name << \", \" << alter << \", \" << groesse << std::endl;\n\n  // Gr√∂√üe des Tupels\n  std::cout << \"[TUPLE] Anzahl Elemente: \" << std::tuple_size<decltype(eintrag)>::value << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Iteratoren",
        "content": {
          "text": [
            "### === Iteratoren in C++ ===\n",
            "-> `#include <vector>`   // F√ºr std::vector\n",
            "-> `#include <list>`     // F√ºr std::list\n",
            "-> `#include <set>`      // F√ºr std::set\n",
            "-> `#include <algorithm>`// F√ºr std::copy, std::sort, std::merge\n",
            "-> `#include <iterator>` // F√ºr std::back_inserter\n",
            "\n",
            "---\n",
            "### === Iteratoren - Grundlagen in C++ ===\n",
            "-> Iteratoren sind bewegliche Zeiger, die auf ein Element eines Containers zeigen.\n",
            "-> Typbeispiel: `std::vector<std::string>::iterator`\n",
            "\n",
            "---\n",
            "### --- Iterator-Zugriff & Navigation ---\n",
            "-> `container.begin()` ‚Üí Iterator auf das erste Element\n",
            "-> `container.end()` ‚Üí Iterator auf das Element *nach* dem letzten\n",
            "-> `*it` ‚Üí aktuelles Element\n",
            "-> `it->member` entspricht `(*it).member`\n",
            "-> `++it`, `--it` ‚Üí n√§chstes/vorheriges Element (nur r√ºckw√§rts bei bidirektional)\n",
            "-> `it += x` ‚Üí x Schritte vor (nur Random-Access, z.B. bei `std::vector`)\n",
            "\n",
            "---\n",
            "### --- Iterator-Vergleich ---\n",
            "-> `it == it2`, `it != it2` ‚Üí Vergleich\n",
            "-> `it < it2` ‚Üí Nur bei Random-Access m√∂glich\n",
            "\n",
            "---\n",
            "### --- Iterator-Arten nach Container ---\n",
            "`std::vector`, `std::array` ‚Üí Random-Access\n",
            "`std::list`, `std::set`, `std::map` ‚Üí Bidirektional\n",
            "`std::forward_list` ‚Üí Forward-only\n",
            "\n",
            "---\n",
            "### --- Klassischer Iterator-Loop ---\n",
            "```cpp\nstd::vector<int> v = {1, 2, 3};\nfor (auto it = v.begin(); it != v.end(); ++it)\n  std::cout << *it << std::endl;\n```\n",
            "\n",
            "---\n",
            "### --- Laufindex (C-Style) ---\n",
            "```cpp\nfor (int i = 0; i < v.size(); i++) std::cout << v[i];\n```\n",
            "\n",
            "---\n",
            "### --- Range-based for loop ---\n",
            "```cpp\nfor (int vi : v) std::cout << vi;\n```\n",
            "\n",
            "---\n",
            "### --- Iterator f√ºr jedes 2. Element ---\n",
            "```cpp\nfor (auto it = v.begin() + 1; it < v.end(); it += 2)\n  std::cout << *it;\n```\n",
            "\n",
            "---\n",
            "### --- Iterator f√ºr Kopieren, Sortieren ---\n",
            "```cpp\nstd::copy(v.begin(), v.end(), std::back_inserter(l));\nv.erase(v.begin() + 3);\nstd::sort(v.begin() + 1, v.end() - 1);\n```\n",
            "\n",
            "---\n",
            "### --- Iterator bei set: find() ---\n",
            "```cpp\nstd::set<int> s = {2, 4, 6};\nauto it = s.find(4);\nif (it != s.end()) std::cout << *it;\n```\n",
            "-> `find()` gibt `end()` zur√ºck, wenn das Element nicht vorhanden ist\n",
            "-> Sets haben keine Indexe, nur Iteratoren\n",
            "\n",
            "---\n",
            "### --- std::merge (zwei Container zusammenf√ºhren) ---\n",
            "```cpp\nstd::merge(s.begin(), s.end(), v.begin(), v.end(), std::back_inserter(l));\n```\n",
            "-> F√ºgt sortiert alle Elemente aus `s` und `v` in `l` ein\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <iterator>  // f√ºr advance, distance\n#include <algorithm>\n\nint main() {\n  std::vector<int> zahlen = {10, 20, 30, 40, 50};\n\n  // Iteration mit explizitem Iterator\n  std::cout << \"Normale Iteration: \";\n  for (std::vector<int>::iterator it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  } // Ausgabe: 10 20 30 40 50\n  std::cout << std::endl;\n\n  // Iteration mit auto\n  std::cout << \"Mit auto: \";\n  for (auto it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\n  // R√ºckw√§rts iterieren\n  std::cout << \"R√ºckw√§rts: \";\n  for (auto rit = zahlen.rbegin(); rit != zahlen.rend(); ++rit) {\n    std::cout << *rit << \" \";\n  } // Ausgabe: 50 40 30 20 10\n  std::cout << std::endl;\n\n  // Zugriff & √Ñnderung √ºber Iterator\n  auto it = zahlen.begin();\n  *it = 100; // √Ñndert erstes Element\n  std::cout << \"Nach √Ñnderung: \" << zahlen[0] << std::endl; // Ausgabe: 100\n\n  // std::advance: verschiebe Iterator um 3 Positionen\n  std::advance(it, 3);\n  std::cout << \"Iterator +3: \" << *it << std::endl; // Ausgabe: 40\n\n  // std::distance: Abstand zwischen zwei Iteratoren\n  int abstand = std::distance(zahlen.begin(), it);\n  std::cout << \"Abstand: \" << abstand << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Allgemeine Funktionen f√ºr STL-Container ===\n",
            "#### -> `begin()`: Gibt Iterator zum ersten Element zur√ºck.\n",
            "   Beispiel: `auto it = container.begin();`\n",
            "#### -> `end()`: Iterator hinter dem letzten Element.\n",
            "   Beispiel: `for (auto it = c.begin(); it != c.end(); ++it)`\n",
            "#### -> `size()`: Gibt Anzahl der Elemente zur√ºck.\n",
            "   Beispiel: `std::cout << v.size();`\n",
            "#### -> `empty()`: Pr√ºft, ob Container leer ist.\n",
            "   Beispiel: `if (v.empty()) std::cout << \"leer\";`\n",
            "#### -> `clear()`: L√∂scht alle Elemente.\n",
            "   Beispiel: `v.clear();`\n",
            "#### -> `erase()`: Entfernt ein Element (Iterator oder Wert).\n",
            "   Beispiel: `v.erase(v.begin());`\n",
            "#### -> `insert()`: F√ºgt Element(e) hinzu.\n",
            "   Beispiel: `s.insert(42);`\n",
            "#### -> `find()`: Sucht Element (bei set/map).\n",
            "   Beispiel: `if (s.find(3) != s.end()) { ... }`\n",
            "#### -> `front()`: Erstes Element (z.B. bei vector, queue).\n",
            "   Beispiel: `std::cout << v.front();`\n",
            "#### -> `back()`: Letztes Element (z.B. bei vector).\n",
            "   Beispiel: `std::cout << v.back();`\n",
            "#### -> `at()`: Zugriff mit Bounds-Check.\n",
            "   Beispiel: `v.at(2);`\n",
            "#### -> `operator[]`: Zugriff ohne Check (nur bei vector, string, map).\n",
            "   Beispiel: `v[0] = 42;`\n",
            "#### -> `swap()`: Tauscht Inhalt zweier Container.\n",
            "   Beispiel: `v1.swap(v2);`\n",
            "#### -> `assign()`: Ersetzt Inhalt (z.B. bei vector oder string).\n",
            "   Beispiel: `v.assign(5, 0); // 5 Nullen`\n",
            "#### -> `resize()`: Gr√∂√üe √§ndern (nur bei Sequenzcontainern).\n",
            "   Beispiel: `v.resize(10);`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  std::set<int> s = {1, 2, 3};\n\n  // empty()\n  if (!s.empty()) {\n    std::cout << \"Set ist NICHT leer\" << std::endl; // Ausgabe: Set ist NICHT leer\n  }\n\n  // size()\n  std::cout << \"Anzahl Elemente: \" << s.size() << std::endl; // Ausgabe: 3\n\n  // insert()\n  s.insert(4);\n  s.insert(2); // 2 ist bereits enthalten, wird ignoriert\n\n  // erase()\n  s.erase(3); // entfernt 3, falls vorhanden\n\n  // find()\n  auto it = s.find(2);\n  if (it != s.end()) {\n    std::cout << \"2 gefunden\" << std::endl;\n  }\n\n  // count()\n  if (s.count(5) == 0) {\n    std::cout << \"5 ist NICHT enthalten\" << std::endl;\n  }\n\n  // swap()\n  std::set<int> s2 = {10, 20};\n  s.swap(s2); // jetzt enth√§lt s die Elemente von s2\n\n  std::cout << \"Nach swap(): Set enth√§lt: \";\n  for (int x : s) std::cout << x << \" \"; // Ausgabe: 10 20\n  std::cout << std::endl;\n\n  // clear()\n  s.clear();\n  std::cout << \"Nach clear(): Gr√∂√üe = \" << s.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      }
    ]
  },








  {
    "category": "Klassen",
    "subtopics": [
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Klassen in C++ ===\n",
            "Eine Klasse ist ein Bauplan f√ºr Objekte. Sie definiert Eigenschaften (Attribute) und F√§higkeiten (Methoden), die ein Objekt haben kann.\n",
            "-> Mit einer Klasse kann man eigene Datentypen erstellen, die sowohl Daten als auch Funktionen enthalten.\n",
            "-> Klassen helfen beim Strukturieren von Code und sind ein zentrales Konzept der objektorientierten Programmierung.\n",
            "\n",
            "---\n",
            "### Aufbau einer Klasse\n",
            "`class Klassenname { ... };` definiert eine Klasse. Darin legt man Member-Variablen (Attribute) und Member-Funktionen (Methoden) fest.\n",
            "Die Sichtbarkeit wird mit `public`, `private` oder `protected` gesteuert:\n",
            "- `private`: Nur innerhalb der Klasse sichtbar (Standard)\n",
            "- `public`: Von au√üen sichtbar\n",
            "- `protected`: Kein Zugriff von z.B main. Zugriff aus abgeleiteten Klassen und aus eigener Klasse ist erlaubt.\n",
            "\n",
            "---\n",
            "### Objekt-Erzeugung\n",
            "Mit `Klassenname objektname;` wird ein Objekt erstellt. Danach kann man mit `objektname.funktion()` Methoden aufrufen.\n",
            "\n",
            "---\n",
            "### Konstruktor\n",
            "Ein Konstruktor ist eine spezielle Methode, die automatisch beim Erzeugen eines Objekts aufgerufen wird. Er tr√§gt den Namen der Klasse.\n",
            "\n",
            "---\n",
            "### this-Zeiger\n",
            "`this` ist ein Zeiger auf das aktuelle Objekt. Wird oft in Methoden verwendet, wenn man auf die eigene Instanz zugreifen m√∂chte.\n",
            "---\n"
          ],
            "code": [
            "#include <iostream>\n\n// Definition einer Klasse\nclass Auto {\nprivate:\n  std::string marke;\n  int baujahr;\n\npublic:\n  // Konstruktor\n  Auto(std::string m, int bj) {\n    marke = m;\n    baujahr = bj;\n  }\n\n  // Methode zur Ausgabe\n  void anzeigen() {\n    std::cout << \"Marke: \" << marke << \", Baujahr: \" << baujahr << std::endl;\n  }\n};",
            "int main() {\n  // Objekt erzeugen\n  Auto meinAuto(\"BMW\", 2020);\n  meinAuto.anzeigen(); // Ausgabe: Marke: BMW, Baujahr: 2020\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Public / Private / Protected",
  "content": {
    "text": [
      "### === Zugriffsmodifizierer: `public`, `private`, `protected` ===\n",
      "In C++ bestimmt man mit Zugriffsmodifizierern, welche Teile einer Klasse **von au√üen sichtbar** oder **gesch√ºtzt** sind.\n",
      "\n",
      "-> **Standard in `class`** ist: `private` (bei `struct` dagegen `public`)\n",
      "\n",
      "---\n",
      "### üîí `private:` (Standard)\n",
      "- Nur innerhalb der Klasse sichtbar\n",
      "- Gut f√ºr: Datenkapselung, interne Logik\n",
      "- Nicht sichtbar in Unterklassen\n",
      "\n",
      "---\n",
      "### üîì `public:`\n",
      "- Frei von √ºberall zug√§nglich\n",
      "- Wird verwendet f√ºr Schnittstellen (z.B. Methoden wie `anzeigen()`)\n",
      "\n",
      "---\n",
      "### üü® `protected:`\n",
      "- Wie `private`, aber auch **in Unterklassen sichtbar**\n",
      "- Von **au√üen weiterhin nicht zugreifbar**\n",
      "- Gut, wenn **abgeleitete Klassen** auf interne Daten zugreifen sollen\n",
      "\n",
      "---\n",
      "### ‚ûï Vergleich:\n",
      "| Modifizierer | Sichtbar in Klasse | Sichtbar in Unterklasse | Sichtbar au√üerhalb |\n",
      "| private      | ‚úÖ                 | ‚ùå                       | ‚ùå                  |\n",
      "| protected    | ‚úÖ                 | ‚úÖ                       | ‚ùå                  |\n",
      "| public       | ‚úÖ                 | ‚úÖ                       | ‚úÖ                  |\n",
      "\n",
      "üëâ `protected` wird v.‚ÄØa. bei Vererbung verwendet, wenn man Unterklassen erweiterten, aber kontrollierten Zugriff geben m√∂chte.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Konto {\nprivate:\n  int kontoNummer = 12345;        // Nur innerhalb der Klasse sichtbar\n\nprotected:\n  double kontostand = 100.0;      // F√ºr Unterklassen sichtbar\n\npublic:\n  void einzahlen(double betrag) {\n    kontostand += betrag;\n  }\n\n  void anzeigen() {\n    std::cout << \"Kontostand: \" << kontostand << \" EUR\" << std::endl;\n  }\n};\n\nclass KinderKonto : public Konto {\npublic:\n  void abheben(double betrag) {\n    kontostand -= betrag; // Zugriff auf protected-Mitglied erlaubt\n  }\n\n  void kontoInfo() {\n    // std::cout << kontoNummer; // ‚ùå Fehler: private in Basisklasse\n    std::cout << \"Zugriff auf gesch√ºtzten Kontostand m√∂glich: \" << kontostand << std::endl;\n  }\n};\n\nint main() {\n  KinderKonto k;\n  k.einzahlen(50);\n  k.abheben(30);\n  k.anzeigen(); // Ausgabe: Kontostand: 120 EUR\n\n  // k.kontostand = 999;      // ‚ùå Fehler: protected von au√üen nicht sichtbar\n  // k.kontoNummer = 11111;   // ‚ùå Fehler: private von au√üen nicht sichtbar\n\n  k.kontoInfo(); // Zugriff auf protected innerhalb der Unterklasse\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Konstruktor / Destruktor",
        "content": {
          "text": [
            "### === Konstruktoren & Destruktoren in C++ ===\n",
            "Konstruktoren und Destruktoren sind spezielle Methoden, die automatisch beim Erzeugen bzw. Zerst√∂ren eines Objekts aufgerufen werden.\n",
            "\n",
            "---\n",
            "### Konstruktor\n",
            "-> Wird beim Erzeugen eines Objekts aufgerufen\n",
            "-> Hat den **gleichen Namen wie die Klasse**, kein R√ºckgabewert (auch kein `void`)\n",
            "-> Wird oft verwendet, um Startwerte zu setzen oder Ressourcen zu reservieren\n",
            "\n",
            "---\n",
            "### Destruktor\n",
            "-> Wird beim L√∂schen eines Objekts aufgerufen (z.B. am Ende des G√ºltigkeitsbereichs)\n",
            "-> Hat den gleichen Namen wie die Klasse, aber mit einem **Tilde-Zeichen `~`** davor\n",
            "-> Wird genutzt, um Ressourcen wie Speicher oder Dateien freizugeben\n",
            "\n",
            "---\n",
            "### Wichtig\n",
            "- Es kann mehrere Konstruktoren geben (√úberladung), aber **nur einen Destruktor** pro Klasse\n",
            "- In modernen C++-Projekten ist der Destruktor vor allem bei dynamischem Speicher wichtig\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Tier {\nprivate:\n  std::string name;\n\npublic:\n  // Konstruktor\n  Tier(std::string n) {\n    name = n;\n    std::cout << \"Tier erstellt: \" << name << std::endl;\n  }\n\n  // Destruktor\n  ~Tier() {\n    std::cout << \"Tier gel√∂scht: \" << name << std::endl;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht Ger√§usche.\" << std::endl;\n  }\n};",
            "int main() {\n  Tier katze(\"Miezi\");\n  katze.sprich();\n\n  // Am Ende von main wird automatisch der Destruktor aufgerufen\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Friend",
        "content": {
          "text": [
            "### === `friend` in C++ ===\n",
            "Ein `friend` erlaubt einer Funktion oder einer anderen Klasse den **Zugriff auf private oder protected Member** einer Klasse.\n",
            "Damit kann gezielt und kontrolliert eine Ausnahme von der Kapselung gemacht werden.\n",
            "\n",
            "---\n",
            "### friend-Funktion\n",
            "-> Wird **au√üerhalb** der Klasse definiert,\n",
            "-> hat aber Zugriff auf private Member,\n",
            "-> muss **innerhalb** der Klasse mit `friend` deklariert werden.\n",
            "\n",
            "---\n",
            "### friend-Klasse\n",
            "-> Eine ganze Klasse kann als `friend` einer anderen Klasse deklariert werden,\n",
            "-> Sie bekommt vollen Zugriff auf alle privaten Elemente der Klasse.\n",
            "\n",
            "---\n",
            "### Wann verwendet man `friend`?\n",
            "- Wenn bestimmte Funktionen eng mit der Klasse zusammenarbeiten m√ºssen,\n",
            "- z.B. f√ºr Vergleichsfunktionen oder externe Operator√ºberladungen.\n",
            "- Sollte **sparsam und gezielt** verwendet werden, da es die Kapselung aufbricht.\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Geheimnis {\nprivate:\n  int geheimerWert = 42;\n\n  // friend-Funktion erlauben\n  friend void zeigeGeheimnis(const Geheimnis& g);\n};\n\n// Definition der friend-Funktion\nvoid zeigeGeheimnis(const Geheimnis& g) {\n  std::cout << \"Geheimer Wert: \" << g.geheimerWert << std::endl;\n}",
            "int main() {\n  Geheimnis objekt;\n  zeigeGeheimnis(objekt); // Ausgabe: Geheimer Wert: 42\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Copy Constructor & Assignment",
  "content": {
    "text": [
      "### === Copy Constructor & Copy Assignment ===\n",
      "Wenn Objekte kopiert oder zugewiesen werden, kommen spezielle Funktionen ins Spiel:\n",
      "\n",
      "- **Copy Constructor**: Wird aufgerufen bei z.B. `Objekt b = a;`\n",
      "- **Copy Assignment Operator**: Wird aufgerufen bei `b = a;`, wenn `b` schon existiert\n",
      "\n",
      "---\n",
      "### Warum ist das wichtig?\n",
      "Standardm√§√üig macht C++ eine **flache Kopie** (Shallow Copy):\n",
      "- Zeiger werden 1:1 √ºbernommen\n",
      "- F√ºhrt bei `delete` oft zu Abst√ºrzen oder doppelt gel√∂schtem Speicher\n",
      "\n",
      "Daher sollte man bei dynamischem Speicher (z.B. `new`) eine **tiefe Kopie (Deep Copy)** schreiben:\n",
      "- Es wird ein **neuer Speicher** erstellt und der Inhalt kopiert\n",
      "\n",
      "---\n",
      "### Die Rule of 3:\n",
      "Wenn du eins dieser 3 selbst schreibst, solltest du alle schreiben:\n",
      "- Destruktor (`~Klasse()`)\n",
      "- Copy Constructor\n",
      "- Copy Assignment Operator\n",
      "\n",
      "üëâ Ab C++11 gibt es auch die Rule of 5 (inkl. Move Constructor und Move Assignment)\n",
      "\n",
      "---\n",
      "### ‚ùó `if (this != &other)` - warum?\n",
      "Beim Zuweisungsoperator **kann es passieren**, dass ein Objekt sich selbst zugewiesen wird:\n",
      "```cpp\nobj = obj;\n```\n",
      "Ohne `if (this != &other)` w√ºrde man:\n",
      "- Speicher **l√∂schen**, der gleich danach **benutzt** wird ‚Üí ‚ùå Absturz!\n",
      "- Oder unn√∂tig neu kopieren\n",
      "‚úÖ Mit dem Vergleich wird sichergestellt, dass bei **Selbstzuweisung** nichts passiert.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n    }\n\n    // Copy Constructor (tiefe Kopie)\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n    }\n\n    // Copy Assignment Operator (tiefe Kopie)\n    Person& operator=(const Person& andere) {\n        if (this != &andere) { // wichtig bei Selbstzuweisung!\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Person p1(\"Kilian\");\n    Person p2 = p1;         // Copy Constructor wird genutzt\n    Person p3(\"Test\");\n    p3 = p1;                // Copy Assignment wird genutzt\n\n    p1.anzeigen();          // Name: Kilian\n    p2.anzeigen();          // Name: Kilian\n    p3.anzeigen();          // Name: Kilian\n\n    p1 = p1;                // Selbstzuweisung ‚Üí gesch√ºtzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Move Constructor & Rvalue-Referenz",
  "content": {
    "text": [
  "### === Rvalue-Referenzen & Move-Semantik (C++11+) ===\n",
  "Mit C++11 kamen Rvalue-Referenzen (`T&&`) und die Move-Semantik. Damit kannst du **gro√üe Objekte effizient √ºbertragen**, ohne sie teuer zu kopieren.\n",
  "\n",
  "---\n",
  "### ‚ùì Warum √ºberhaupt \"move\"?\n",
  "- Normale Kopien (`obj2 = obj1;`) machen **teuren Speicheraufwand**: neuer Speicher, Daten kopieren.\n",
  "- Viele Kopien sind **unn√∂tig**, z.‚ÄØB. bei tempor√§ren R√ºckgaben (`return ...`).\n",
  "- Der Move-Konstruktor **klaut** einfach den Speicher ‚Üí schneller & effizienter.\n",
  "\n",
  "---\n",
  "### üß± Move Constructor\n",
  "- Hat die Signatur: `ClassName(ClassName&& other)`\n",
  "- Wird aufgerufen bei z.‚ÄØB. `Objekt b = std::move(a);`\n",
  "- **√úbernimmt Ressourcen** von `a`, ohne Kopie\n",
  "- `a` wird danach in einen \"leeren\" Zustand versetzt (z.‚ÄØB. `pointer = nullptr`)\n",
  "\n",
  "---\n",
  "### üì§ Move Assignment Operator\n",
  "- Hat die Signatur: `ClassName& operator=(ClassName&& other)`\n",
  "- Wird aufgerufen bei z.‚ÄØB. `b = std::move(a);` (wenn `b` schon existiert)\n",
  "- **L√∂scht eigene Ressourcen** und √ºbernimmt die von `a`\n",
  "\n",
  "---\n",
  "### ‚ùó Wichtig bei Move Assignment!\n",
  "Wenn du schreibst: `obj = std::move(obj);` ‚Üí ist das eine **Selbst-Zuweisung**!\n",
  "- Ohne Pr√ºfung: Objekt zerst√∂rt sich selbst ‚Üí ‚ùå Absturz\n",
  "- Mit Pr√ºfung: \n",
  "```cpp\nif (this != &other) {\n  // sicher verschieben\n}\n```\n",
  "‚úÖ Damit wird Move korrekt √ºbersprungen, wenn `this` und `other` identisch sind.\n",
  "\n",
  "---\n",
  "### üÜö Copy vs. Move ‚Äì Was passiert wann?\n",
  "| Ausdruck                   | Ergebnis                   |\n",
  "| `Person p = p2;`           | Copy Constructor            |\n",
  "| `Person p = std::move(p2);`| ‚úÖ Move Constructor         |\n",
  "| `p = p2;`                  | Copy Assignment             |\n",
  "| `p = std::move(p2);`       | ‚úÖ Move Assignment          |\n",
  "\n",
  "---\n",
  "### üîç Was ist ein Rvalue?\n",
  "- Ein **tempor√§res, namenloses Objekt**.\n",
  "- Beispiele: `Person(\"Max\")`, `return Person(...)`, `std::move(p)`\n",
  "- Nur solche d√ºrfen an `T&&` √ºbergeben werden.\n",
  "\n",
  "---\n",
  "### üîß `std::move`\n",
  "- `std::move(obj)` **verschiebt nicht direkt** ‚Äì es markiert das Objekt als \"Rvalue\".\n",
  "- Nur damit erkennt der Compiler: Jetzt darf der Move-Konstruktor benutzt werden.\n",
  "\n",
  "---\n",
  "### üìå Wann braucht man Move?\n",
  "- Bei **gro√üen Klassen mit dynamischem Speicher** (z.‚ÄØB. `char*`, `std::vector`)\n",
  "- Wenn du Objekte **zur√ºckgibst** (`return`) oder weitergibst\n",
  "- Wenn du wei√üt: *\"Das alte Objekt brauche ich nicht mehr ‚Äì das neue darf alles √ºbernehmen\"*\n",
  "\n",
  "---\n",
  "### üß† Merksatz:\n",
  "> **Kopieren:** Ich brauche beide Objekte.\n",
  "> **Verschieben:** Ich brauche nur noch eins ‚Äì das andere darf leer sein.\n",
  "---\n"
],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) { // wichtig bei Selbst-Zuweisung!\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << (name ? name : \"[leer]\") << std::endl;\n    }\n};\n\nPerson erzeugePerson() {\n    return Person(\"Kilian\");\n}\n\nint main() {\n    Person p1 = erzeugePerson();    // Move Constructor\n    Person p2(\"Test\");\n    p2 = std::move(p1);             // Move Assignment\n\n    p2.anzeigen();                  // Name: Kilian\n    p1.anzeigen();                  // Name: [leer]\n\n    p2 = std::move(p2);             // Selbstzuweisung ‚Üí gesch√ºtzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Rule of 5",
  "content": {
    "text": [
      "### === Rule of 5 (C++11+) ===\n",
      "Die **Rule of 5** beschreibt, welche Funktionen du in einer Klasse mit Ressourcen (z.B. `new`) implementieren solltest.\n",
      "\n",
      "Sie erweitert die **Rule of 3** (Copy Constructor, Copy Assignment, Destruktor) um zwei neue Funktionen:\n",
      "\n",
      "---\n",
      "### Die f√ºnf Funktionen:\n",
      "1. **Destruktor** (`~Klasse()`)\n",
      "2. **Copy Constructor** (`Klasse(const Klasse&)`)\n",
      "3. **Copy Assignment Operator** (`operator=(const Klasse&)`)\n",
      "4. **Move Constructor** (`Klasse(Klasse&&)`)\n",
      "5. **Move Assignment Operator** (`operator=(Klasse&&)`)\n",
      "\n",
      "---\n",
      "### Warum das Ganze?\n",
      "- Wenn du eine Funktion manuell schreibst (z.B. Copy Constructor), deaktiviert C++ die automatische Generierung der anderen ‚Üí du musst sie selbst implementieren\n",
      "- Besonders bei dynamischem Speicher wichtig (deep copy & safe move)\n",
      "\n",
      "---\n",
      "### Wann ist die Rule of 5 wichtig?\n",
      "- Wenn deine Klasse **Zeiger oder Ressourcen verwaltet** (z.B. mit `new`, `malloc`, Datei-Handles)\n",
      "- Wenn du **Kopie und Verschiebung erlauben oder verhindern** willst\n",
      "\n",
      "üëâ Alternativen: **Rule of 0** bei reinem Value-Semantik-Code (z.B. `std::vector`, keine `new`) oder Rule of 6 (mit `operator==()`)\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) {\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n};\n\nint main() {\n    Person a(\"Max\");\n    Person b = a;             // Copy Constructor\n    Person c(\"Test\");\n    c = a;                    // Copy Assignment\n    Person d = std::move(a);  // Move Constructor\n    b = std::move(c);         // Move Assignment\n    return 0;\n}"
    ]
  }
},
{
  "title": "Implizite Klassenbestandteile & = delete",
  "content": {
    "text": [
      "### === Implizite Klassenbestandteile in C++ ===\n",
      "C++ erzeugt f√ºr jede Klasse automatisch bestimmte Methoden, wenn du sie nicht selbst definierst:\n",
      "\n",
      "---\n",
      "### Diese Methoden werden (standardm√§√üig) automatisch generiert:\n",
      "- Standard-Konstruktor (`MyClass()`)\n",
      "- Destruktor (`~MyClass()`)\n",
      "- Copy Constructor (`MyClass(const MyClass&)`)\n",
      "- Copy Assignment (`operator=(const MyClass&)`)\n",
      "- Move Constructor (`MyClass(MyClass&&)`) *(ab C++11)*\n",
      "- Move Assignment (`operator=(MyClass&&)`) *(ab C++11)*\n",
      "\n",
      "---\n",
      "### Warum `= delete`?\n",
      "- Verhindert, dass eine bestimmte Methode automatisch generiert oder verwendet wird\n",
      "- Beispiel: Kopieren verhindern (z.B. bei Singleton- oder Handle-Klassen)\n",
      "```cpp\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n",
      "\n",
      "---\n",
      "### Warum `= default`?\n",
      "- Erzwingt die automatische Standard-Erstellung (z.B. wenn du trotzdem was anderes schreibst)\n",
      "```cpp\nMyClass() = default;\n```\n",
      "\n",
      "---\n",
      "### Wann ist das wichtig?\n",
      "- Wenn deine Klasse z.B. Zeiger enth√§lt und **tiefe Kopie n√∂tig** ist\n",
      "- Wenn du **kopieren bewusst verbieten** willst\n",
      "- Wenn du eine Methode **nur deklarieren willst, aber ohne eigene Logik** (z.B. bei APIs)\n",
      "\n",
      "---\n",
      "üëâ Moderne Klassen (z.B. mit Ressourcenbesitz) sollten Copy/Move bewusst steuern\n",
      "üëâ In Pr√ºfungen wird oft gefragt: \"Was macht `= delete`?\" oder \"Was wird implizit generiert?\"\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Beispiel {\npublic:\n    Beispiel() = default; // Standard-Konstruktor explizit erlaubt\n\n    // Copy-Vorg√§nge deaktivieren\n    Beispiel(const Beispiel&) = delete;\n    Beispiel& operator=(const Beispiel&) = delete;\n\n    void hallo() {\n        std::cout << \"Hallo!\" << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b1;      // OK\n    b1.hallo();\n\n    // Beispiel b2 = b1;        // Fehler: Copy Constructor ist gel√∂scht\n    // Beispiel b3;\n    // b3 = b1;                  // Fehler: Copy Assignment ist gel√∂scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Struct vs. Class",
  "content": {
    "text": [
      "### === struct vs. class in C++ ===\n",
      "`struct` und `class` sind sich in C++ sehr √§hnlich - beide k√∂nnen Memberfunktionen, Konstruktoren, Vererbung und vieles mehr enthalten.\n",
      "---\n",
      "#### Der einzige technische Unterschied ist die Standard-Sichtbarkeit:\n",
      "\n",
      "| Merkmal                     | `struct` (Standard: public)   | `class` (Standard: private)   |\n",
      "| Standard-Sichtbarkeit       | `public`                      | `private`                    |\n",
      "| Wird verwendet f√ºr...       | Datencontainer, PODs          | OOP-Klassen, Kapselung       |\n",
      "| Methoden m√∂glich?           | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "| Vererbung m√∂glich?          | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "| Konstruktoren, Operatoren?  | ‚úÖ Ja                          | ‚úÖ Ja                         |\n",
      "\n",
      "---\n",
      "### Beispiel: Unterschied in der Sichtbarkeit\n",
      "```cpp\nstruct A {\n    int x;       // automatisch public\n};\n\nclass B {\n    int x;       // automatisch private\n};\n\nint main() {\n    A a;\n    a.x = 10;    // ‚úÖ erlaubt\n\n    B b;\n    // b.x = 10; // ‚ùå Fehler: x ist private\n    return 0;\n}\n```\n",
      "\n",
      "---\n",
      "### Merksatz:\n",
      "- Verwende `struct`, wenn du **nur Daten speichern willst** (wie bei C-Strukturen)\n",
      "- Verwende `class`, wenn du **Verhalten, Kapselung, Logik** einbauen willst\n",
      "\n",
      "üëâ Aber technisch gesehen sind beide fast identisch - nur der Standardzugriff unterscheidet sich!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n\n    void anzeigen() {\n        std::cout << \"x: \" << x << \", y: \" << y << std::endl;\n    }\n};\n\nclass Person {\nprivate:\n    std::string name;\npublic:\n    Person(const std::string& n) : name(n) {}\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Punkt p = {3, 5};\n    p.anzeigen();   // x: 3, y: 5\n\n    Person pers(\"Kilian\");\n    pers.anzeigen(); // Name: Kilian\n\n    return 0;\n}"
    ]
        }
      },
    {
  "title": "explicit",
  "content": {
    "text": [
        "### === `explicit` in C++ ===\n",
        "Das Schl√ºsselwort `explicit` wird verwendet, um **automatische (implizite) Typumwandlungen** zu verhindern ‚Äì vor allem bei **einparametrigen Konstruktoren**.\n",
        "\n",
        "---\n",
        "### ‚ùó Problem ohne `explicit`\n",
        "Ein Konstruktor mit nur einem Argument kann **automatisch aufgerufen werden**, wenn ein Wert vom passenden Typ √ºbergeben wird. Das f√ºhrt oft zu **unerwartetem Verhalten**:\n",
        "```cpp\nclass Zahl {\npublic:\n  Zahl(int wert); // kein explicit!\n};\n\nZahl z = 5;  // OK: int wird implizit zu Zahl\n```\n",
        "Auch bei Funktionsaufrufen ist das problematisch:\n",
        "```cpp\nvoid verarbeite(Zahl z);\nverarbeite(5); // ‚ö†Ô∏è int wird still zu Zahl\n```\n",
        "‚û°Ô∏è Die Konvertierung passiert im Hintergrund, obwohl du sie nie bewusst im Code angegeben hast.\n",
        "\n",
        "---\n",
        "### ‚úÖ L√∂sung mit `explicit`\n",
        "Durch `explicit` wird der Konstruktor **nur dann aufgerufen**, wenn du ihn **direkt und bewusst** verwendest:\n",
        "```cpp\nclass Zahl {\npublic:\n  explicit Zahl(int wert);\n};\n\nZahl z(5);        // ‚úÖ OK: direkte Initialisierung\nverarbeite(z);     // ‚úÖ erlaubt\nverarbeite(5);     // ‚ùå Fehler: keine implizite Umwandlung\n```\n",
        "\n",
        "---\n",
        "### üìå Auch n√ºtzlich bei `operator`-Funktionen\n",
        "`explicit` kann z.‚ÄØB. auch vor `operator bool()` stehen, damit ein Objekt **nicht automatisch in `bool` umgewandelt** wird ‚Äì etwa in `if`-Bedingungen:\n",
        "```cpp\nexplicit operator bool() const;\n```\n",
        "\n",
        "---\n",
        "### üß† Merksatz:\n",
        "> Hast du einen **Konstruktor mit genau einem Argument**?\n",
        "> Dann verwende **immer `explicit`**, au√üer du willst die automatische Konvertierung **wirklich ganz bewusst zulassen**.\n",
        "---\n"
      ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\npublic:\n  explicit Zahl(int wert) {\n    std::cout << \"Konstruktor aufgerufen mit: \" << wert << std::endl;\n  }\n};\n\nvoid printZahl(Zahl z) {\n  std::cout << \"printZahl() aufgerufen\" << std::endl;\n}\n\nint main() {\n  Zahl z(42);      // ‚úÖ erlaubt: direkte Initialisierung\n  printZahl(z);    // ‚úÖ erlaubt\n\n  // printZahl(42); // ‚ùå Fehler: implizite Konvertierung verboten durch 'explicit'\n  return 0;\n}\n\n// Beispielausgabe:\n// Konstruktor aufgerufen mit: 42\n// printZahl() aufgerufen"
    ]
  }
},
{
  "title": "Getter- und Setter-Funktionen",
  "content": {
    "text": [
      "### === Getter- und Setter-Funktionen ===\n",
      "Getter und Setter sind spezielle Funktionen, die den **Zugriff auf private Membervariablen** einer Klasse erm√∂glichen.\n",
      "\n",
      "üëâ Sie sind ein Teil des **Kapselungskonzepts** in der objektorientierten Programmierung.\n",
      "\n",
      "---\n",
      "### Getter:\n",
      "- Lesen den Wert eines privaten Members.\n",
      "- Haben oft den Namen `getXYZ()`.\n",
      "- R√ºckgabetyp entspricht dem Membertyp.\n",
      "\n",
      "---\n",
      "### Setter:\n",
      "- Setzen oder √§ndern den Wert eines privaten Members.\n",
      "- Haben oft den Namen `setXYZ()`.\n",
      "- K√∂nnen zus√§tzliche Pr√ºfungen enthalten (z.B. Wertebereich).\n",
      "\n",
      "---\n",
      "### Warum verwenden?\n",
      "- Direkter Zugriff auf `private` Variablen ist nicht erlaubt.\n",
      "- Getter/Setter erm√∂glichen **kontrollierten Zugriff**.\n",
      "- So bleibt die **Datenintegrit√§t** erhalten.\n",
      "\n",
      "---\n",
      "üìå In modernen C++-Projekten ist es √ºblich, nur dann Getter/Setter zu schreiben, wenn sie **wirklich gebraucht werden**\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Person {\nprivate:\n  int alter;\n\npublic:\n  // Getter\n  int getAlter() const {\n    return alter;\n  }\n\n  // Setter mit Pr√ºfung\n  void setAlter(int a) {\n    if (a >= 0)\n      alter = a;\n  }\n};\n\nint main() {\n  Person p;\n  p.setAlter(25); // setzt Alter auf 25\n  std::cout << \"Alter: \" << p.getAlter() << std::endl;\n  return 0;\n}\n\n// Beispielausgabe:\n// Alter: 25"
    ]
  }
}



    ]
  },








{
    "category": "Klassen Vererbung",
    "subtopics": [
{
  "title": "Allgemein",
  "content": {
    "text": [
      "### === Vererbung in C++ ===\n",
      "Vererbung ist ein zentrales Konzept der objektorientierten Programmierung.\n",
      "Damit kann eine neue Klasse (`Kindklasse`) die Eigenschaften und Methoden einer bestehenden Klasse (`Basisklasse`) √ºbernehmen.\n",
      "\n",
      "---\n",
      "### Vorteile\n",
      "- Code-Wiederverwendung\n",
      "- Erweiterbarkeit\n",
      "- Strukturierte Hierarchien\n",
      "\n",
      "---\n",
      "### Syntax\n",
      "`class Kindklasse : public Basisklasse { ... };`\n",
      "-> `public` bedeutet: √∂ffentliche Mitglieder der Basisklasse bleiben auch in der Kindklasse √∂ffentlich.\n",
      "-> `protected` bedeutet: √∂ffentliche Mitglieder der Basisklasse werden in der Kindklasse protected.\n",
      "-> `private` bedeutet: √∂ffentliche Mitglieder der Basisklasse werden in der Kindklasse private.\n",
      "\n",
      "---\n",
      "### Konstruktoren in Vererbung\n",
      "-> Konstruktor der Basisklasse wird **automatisch zuerst** aufgerufen.\n",
      "-> Kann im Initialisierungsbereich der Kindklasse explizit aufgerufen werden.\n",
      "\n",
      "---\n",
      "### Vererbungsmodi in C++\n",
      "C++ kennt drei Vererbungsmodi: `public`, `protected` und `private`.\n",
      "- Sie bestimmen, wie sich die Sichtbarkeit von geerbten Attributen und Methoden in der abgeleiteten Klasse ver√§ndert.\n",
      "- Der Modus ist eine **obere Schranke**: `public` l√§sst alles wie es ist, `private` versteckt fast alles.\n",
      "\n",
      "---\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n",
      "---\n"
    ],
"code": [
  "#include <iostream>\n\n// Basisklasse\nclass Tier {\nprotected:\n  std::string name;\n\npublic:\n  Tier(std::string n) {\n    name = n;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht ein Ger√§usch.\" << std::endl;\n  }\n};\n\n// Abgeleitete Klasse\nclass Hund : public Tier {\npublic:\n  Hund(std::string n) : Tier(n) {}\n\n  void bell() {\n    std::cout << name << \" bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  rex.sprich(); // Ausgabe: Rex macht ein Ger√§usch.\n  rex.bell();   // Ausgabe: Rex bellt.\n\n  return 0;\n}",
  "// Zus√§tzliche Beispiele zur Vererbungsart:\n\nclass base {\npublic:\n  void f() {}\nprotected:\n  void g() {}\nprivate:\n  int x;\n};\n\nclass derived_1 : public base {\n  // f() bleibt public\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_2 : protected base {\n  // f() wird protected\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_3 : private base {\n  // f() wird private\n  // g() wird private\n  // x ist nicht zugreifbar\n};"
]
        }
      },
{
  "title": "Vererbungsmodi",
  "content": {
    "text": [
      "### === Vererbungsmodi in C++ ===\n",
      "Wenn eine Klasse von einer anderen Klasse erbt, kannst du den **Vererbungsmodus** festlegen:\n",
      "- `public`\n",
      "- `protected`\n",
      "- `private`\n",
      "\n",
      "Der Modus bestimmt, **wie die Zugriffsrechte** (`public` / `protected` / `private`) der Basisklasse in der abgeleiteten Klasse weitervererbt werden.\n",
      "\n",
      "---\n",
      "### Vergleichstabelle:\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n",
      "üëâ **private Mitglieder werden nie vererbt**, egal welcher Modus.\n",
      "\n",
      "---\n",
      "### Wann welchen Modus?\n",
      "- `public`: Die abgeleitete Klasse ist eine vollwertige ‚Äûist-ein‚Äú-Variante (z.B. `Hund ist ein Tier`)\n",
      "- `protected`: Meist intern genutzt, selten in Praxis\n",
      "- `private`: Wenn Vererbung nur als Implementierungshilfe dient und von au√üen verborgen bleiben soll\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass base {\npublic:\n  void f() { std::cout << \"f()\\n\"; }\nprotected:\n  void g() { std::cout << \"g()\\n\"; }\nprivate:\n  int x = 42; // nicht vererbbar\n};\n\nclass derived_public : public base {\npublic:\n  void test() {\n    f(); // OK (public bleibt public)\n    g(); // OK (protected bleibt protected)\n    // x; ‚ùå nicht zugreifbar\n  }\n};\n\nclass derived_protected : protected base {\npublic:\n  void test() {\n    f(); // OK (public wird protected)\n    g(); // OK (protected bleibt protected)\n  }\n};\n\nclass derived_private : private base {\npublic:\n  void test() {\n    f(); // OK (public wird private)\n    g(); // OK (protected wird private)\n  }\n};\n\nint main() {\n  derived_public dp;\n  dp.f(); // OK\n  // dp.g(); ‚ùå nicht erlaubt (gesch√ºtzt)\n\n  derived_protected dpr;\n  // dpr.f(); ‚ùå nicht erlaubt (gesch√ºtzt)\n\n  derived_private dpi;\n  // dpi.f(); ‚ùå nicht erlaubt (privat)\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Konstruktorvererbung & -√ºbernahme",
  "content": {
    "text": [
      "### === Konstruktorvererbung & -weitergabe in C++ ===\n",
      "Normalerweise werden Konstruktoren **nicht automatisch** an abgeleitete Klassen vererbt.\n",
      "Das bedeutet: Die Unterklasse muss eigene Konstruktoren definieren und dabei die Konstruktoren der Basisklasse explizit aufrufen.\n",
      "\n",
      "---\n",
      "### üîß Konstruktorweitergabe mit Initialisierungsliste\n",
      "- Ein Konstruktor der Unterklasse kann per `: Basisklasse(...)` den Konstruktor der Oberklasse aufrufen.\n",
      "\n",
      "```cpp\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  Hund(std::string name) : Tier(name) {}\n};\n```\n",
      "\n",
      "---\n",
      "### üîÅ Konstruktorvererbung mit `using` (ab C++11)\n",
      "- Mit `using Basisklasse::Basisklasse;` k√∂nnen Konstruktoren **automatisch √ºbernommen** werden.\n",
      "- Spart Schreibaufwand, wenn man nichts zus√§tzlich initialisieren muss.\n",
      "\n",
      "üëâ Achtung: Funktioniert **nicht**, wenn die Unterklasse zus√§tzliche Member/Attribute initialisieren muss oder andere Logik enth√§lt.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  // Weitergabe an Basiskonstruktor\n  Hund(std::string name) : Tier(name) {\n    std::cout << \"Hund-Konstruktor l√§uft.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  // Konstruktorvererbung ab C++11\n  using Tier::Tier;\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  // Ausgabe:\n  // Rex wird erschaffen.\n  // Hund-Konstruktor l√§uft.\n\n  Katze mimi(\"Mimi\");\n  // Ausgabe:\n  // Mimi wird erschaffen.\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Destruktorvererbung",
  "content": {
    "text": [
      "### === Destruktorvererbung ===\n",
      "Wenn Klassen **vererbt** werden und √ºber Zeiger auf die **Basisklasse** gel√∂scht wird, ist es wichtig, den Destruktor **virtuell** zu machen.\n",
      "\n",
      "üëâ Nur dann wird der Destruktor der **abgeleiteten Klasse korrekt aufgerufen**.\n",
      "\n",
      "---\n",
      "### Warum `virtual` beim Destruktor?\n",
      "- Ohne `virtual` wird beim L√∂schen √ºber einen Basisklassenzeiger **nur der Basisklassen-Destruktor** aufgerufen.\n",
      "- Das f√ºhrt zu **undefiniertem Verhalten** oder **Speicherlecks**, wenn die abgeleitete Klasse Ressourcen verwaltet.\n",
      "\n",
      "---\n",
      "### Best Practice:\n",
      "- In jeder Klasse mit virtuellen Funktionen sollte der Destruktor ebenfalls `virtual` sein.\n",
      "- Auch Interfaceklassen (mit `= 0`) sollten **einen virtuellen Destruktor** haben.\n",
      "\n",
      "üìå Ein `virtual`-Destruktor sorgt daf√ºr, dass beim L√∂schen √ºber einen Zeiger auf die Basisklasse **alle Destruktoren korrekt und vollst√§ndig** ausgef√ºhrt werden.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual ~Tier() {\n    std::cout << \"Tier-Destruktor\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  ~Hund() {\n    std::cout << \"Hund-Destruktor\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  ~Katze() {\n    std::cout << \"Katze-Destruktor\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  delete t1; // Ausgabe: Hund-Destruktor, Tier-Destruktor\n  delete t2; // Ausgabe: Katze-Destruktor, Tier-Destruktor\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Redefinition von Memberfunktionen",
  "content": {
    "text": [
      "### === Redefinition von Memberfunktionen ===\n",
      "In der objektorientierten Programmierung mit C++ ist es m√∂glich, **Funktionen in Unterklassen neu zu definieren**.\n",
      "Dabei √ºberschreibt die Unterklasse die gleichnamige Funktion der Oberklasse. Das nennt man auch **‚ÄûRedefinition‚Äú** oder **‚Äû√úberschreiben‚Äú** (nicht zu verwechseln mit √úberladung).\n",
      "\n",
      "---\n",
      "### Wann macht man das?\n",
      "- Wenn eine abgeleitete Klasse ein **eigenes Verhalten** f√ºr eine Methode braucht\n",
      "- Beispiel: `Tier` hat `sprich()`, aber `Hund` bellt und `Katze` miaut\n",
      "\n",
      "---\n",
      "### Ohne `virtual` = statisch gebunden\n",
      "- Wenn die Methode **nicht** als `virtual` deklariert ist, entscheidet sich beim **Compilieren**, welche Funktion verwendet wird (statisch)\n",
      "\n",
      "---\n",
      "### Mit `virtual` = dynamisch gebunden\n",
      "- Nur wenn die Methode in der Basisklasse als `virtual` markiert ist, wird sie **zur Laufzeit** (dynamisch) aufgel√∂st - wichtig f√ºr **Polymorphie**\n",
      "\n",
      "üëâ `virtual` sollte bei der Basisklasse verwendet werden, wenn man m√∂chte, dass Unterklassen eigene Versionen implementieren\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void sprich() {\n    std::cout << \"Ein Tier macht ein Ger√§usch.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() { // √ºberschreibt, aber nicht virtuell\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund h;\n  h.sprich(); // Ausgabe: Ein Hund bellt.\n\n  Tier* t = new Hund();\n  t->sprich(); // Ausgabe: Ein Tier macht ein Ger√§usch. (weil kein virtual!)\n\n  delete t;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Virtuelle Funktionen",
  "content": {
    "text": [
      "### === Virtuelle Funktionen ===\n",
      "Virtuelle Funktionen erm√∂glichen es in C++, dass die **richtige Funktion zur Laufzeit aufgerufen wird**, wenn mit Zeigern oder Referenzen auf Basisklassen gearbeitet wird.\n",
      "\n",
      "üëâ Dieses Verhalten nennt man **dynamisches Binden** oder **Laufzeit-Polymorphie**.\n",
      "\n",
      "---\n",
      "### Was passiert ohne `virtual`?\n",
      "- Es wird immer die Funktion der **Basisklasse** aufgerufen, selbst wenn das Objekt eigentlich zur Unterklasse geh√∂rt.\n",
      "\n",
      "---\n",
      "### Mit `virtual`:\n",
      "- Die Entscheidung, **welche Funktion** aufgerufen wird, erfolgt **zur Laufzeit** (dynamisch), basierend auf dem tats√§chlichen Objekttyp.\n",
      "- Ideal f√ºr Oberklassen mit gemeinsamem Interface, das von Unterklassen **spezialisiert** wird.\n",
      "\n",
      "---\n",
      "### Wichtig:\n",
      "- Wird in einer Klasse `virtual` verwendet, sollte in abgeleiteten Klassen `override` verwendet werden (seit C++11).\n",
      "- Der Destruktor einer Basisklasse sollte fast immer `virtual` sein, wenn Vererbung verwendet wird!\n",
      "\n",
      "---\n",
      "### üîí Pur-virtuelle Funktionen (`= 0`)\n",
      "- Eine Funktion kann als **rein virtuell** deklariert werden:\n",
      "```cpp\nvirtual void sprich() = 0;\n```\n",
      "- Die Klasse wird dadurch **abstrakt** - es k√∂nnen **keine Objekte davon erstellt** werden.\n",
      "- Jede abgeleitete Klasse **muss** diese Funktion implementieren, sonst ist auch sie abstrakt.\n",
      "- Wird oft f√ºr **Interfaces** genutzt (z.B. gemeinsame Schnittstelle f√ºr viele Untertypen).\n",
      "\n",
      "#### üö´ Nicht erlaubt:\n",
      "- Es ist **nicht erlaubt**, direkt ein Objekt einer abstrakten Klasse zu erzeugen:\n",
      "```cpp\nLebewesen l; // ‚ùå Fehler: Objekt von abstrakter Klasse\n```\n",
      "- Auch das Erzeugen eines Zeigers oder einer Referenz ist **nur erlaubt**, wenn kein Konstruktor direkt aufgerufen wird:\n",
      "```cpp\nLebewesen* ptr; // ‚úÖ erlaubt, solange kein Objekt erstellt wird\n```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein Ger√§usch.\" << std::endl;\n  }\n\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  t1->sprich(); // Ausgabe: Ein Hund bellt.\n  t2->sprich(); // Ausgabe: Eine Katze miaut.\n\n  delete t1;\n  delete t2;\n  return 0;\n}",
      "\n// Beispiel mit rein virtueller Funktion:\n#include <iostream>\n\nclass Lebewesen {\npublic:\n  virtual void bewegung() = 0; // rein virtuelle Funktion\n  virtual ~Lebewesen() {}\n};\n\nclass Fisch : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Fisch schwimmt.\" << std::endl;\n  }\n};\n\nclass Vogel : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Vogel fliegt.\" << std::endl;\n  }\n};\n\nint main() {\n  // Lebewesen l; // ‚ùå Fehler: Kann nicht instanziiert werden (abstrakte Klasse)\n\n  Lebewesen* l1 = new Fisch();\n  Lebewesen* l2 = new Vogel();\n\n  l1->bewegung(); // Ausgabe: Ein Fisch schwimmt.\n  l2->bewegung(); // Ausgabe: Ein Vogel fliegt.\n\n  delete l1;\n  delete l2;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Statisches vs. dynamisches Binden",
  "content": {
    "text": [
      "### === Statisches vs. dynamisches Binden ===\n",
      "**Binden** bedeutet, dass der Compiler entscheidet, **welche Funktion** bei einem Funktionsaufruf verwendet wird.\n",
      "---\n",
      "## In C++ gibt es zwei Arten:\n",
      "\n",
      "### üîí Statisches Binden (Compile-Time Binding)\n",
      "- Der **Compiler** entscheidet zur **√úbersetzungszeit**, welche Funktion aufgerufen wird.\n",
      "- Gilt f√ºr **nicht-virtuelle Funktionen**.\n",
      "- Schneller, aber **nicht polymorph**.\n",
      "\n",
      "---\n",
      "### üîì Dynamisches Binden (Run-Time Binding)\n",
      "- Die Entscheidung erfolgt zur **Laufzeit**.\n",
      "- Nur m√∂glich bei **virtuellen Funktionen** √ºber **Zeiger oder Referenzen** auf die Basisklasse.\n",
      "- Erm√∂glicht **Polymorphie**.\n",
      "\n",
      "---\n",
      "### Vergleich:\n",
      "| Merkmal              | Statisch (`default`)    | Dynamisch (`virtual`)      |\n",
      "| Zeitpunkt der Bindung| Kompilierzeit          | Laufzeit                    |\n",
      "| Geschwindigkeit      | Schnell                | Etwas langsamer             |\n",
      "| Polymorphie m√∂glich? | ‚ùå                     | ‚úÖ                          |\n",
      "| Anwendbar auf        | normale Funktionen     | virtuelle Funktionen        |\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Tier\" << std::endl;\n  }\n\n  virtual void sprich() {\n    std::cout << \"[dynamisch] Tier macht ein Ger√§usch\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Hund\" << std::endl;\n  }\n\n  void sprich() override {\n    std::cout << \"[dynamisch] Hund bellt\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* tierPtr = new Hund();\n\n  tierPtr->info();   // Ausgabe: [statisch] Tier (keine virtuelle Methode)\n  tierPtr->sprich(); // Ausgabe: [dynamisch] Hund bellt (virtuell)\n\n  delete tierPtr;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Polymorphie",
  "content": {
    "text": [
      "### === Polymorphie in C++ ===\n",
      "Polymorphie bedeutet, dass ein Objekt **unterschiedliche Formen annehmen** kann - also dass **eine Schnittstelle viele Implementierungen** zul√§sst.\n",
      "\n",
      "üëâ In C++ tritt Polymorphie oft in Verbindung mit **Vererbung und virtuellen Funktionen** auf.\n",
      "\n",
      "---\n",
      "### Vorteile der Polymorphie:\n",
      "- Erm√∂glicht flexiblen und erweiterbaren Code\n",
      "- Funktionen k√∂nnen auf **Basisklassen zeigen**, aber das Verhalten **von Unterklassen ausf√ºhren**\n",
      "- Wichtig f√ºr Designmuster wie Strategy, Factory, etc.\n",
      "\n",
      "---\n",
      "### Voraussetzungen f√ºr Polymorphie:\n",
      "- Eine **Basisklasse** mit mindestens einer `virtual`-Funktion\n",
      "- Funktionen werden √ºber **Zeiger oder Referenzen** aufgerufen\n",
      "\n",
      "üëâ Polymorphie funktioniert **nicht bei Werten**, sondern nur √ºber Zeiger oder Referenz!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein Ger√§usch.\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Tier*> tiere;\n  tiere.push_back(new Hund());\n  tiere.push_back(new Katze());\n  tiere.push_back(new Hund());\n\n  for (Tier* t : tiere) {\n    t->sprich();\n    // Ausgabe:\n    // Ein Hund bellt.\n    // Eine Katze miaut.\n    // Ein Hund bellt.\n  }\n\n  for (Tier* t : tiere) {\n    delete t;\n  }\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Abstrakte Klassen und Schnittstellenklassen",
  "content": {
    "text": [
      "### === Abstrakte Klassen und Schnittstellenklassen ===\n",
      "Abstrakte Klassen dienen als **Basisklassen**, von denen **kein direktes Objekt erstellt** werden kann.\n",
      "\n",
      "üëâ Sie enthalten mindestens **eine rein virtuelle Funktion** (`= 0`).\n",
      "\n",
      "---\n",
      "### Eigenschaften abstrakter Klassen:\n",
      "- K√∂nnen normale Memberfunktionen und Membervariablen enthalten.\n",
      "- K√∂nnen **teilweise implementiert** sein (z.B. gemeinsames Verhalten).\n",
      "- K√∂nnen als **Basisklasse** f√ºr konkrete Unterklassen dienen.\n",
      "\n",
      "---\n",
      "### Schnittstellenklassen (Interfaces):\n",
      "- Eine Sonderform der abstrakten Klasse.\n",
      "- Enthalten **nur rein virtuelle Funktionen** (und evtl. einen virtuellen Destruktor).\n",
      "- Dienen nur als **Vertrag**, was eine Klasse k√∂nnen muss.\n",
      "- Kein Zustand, keine Implementierung - nur Methoden ohne K√∂rper.\n",
      "\n",
      "üß© In C++ gibt es keine eigene `interface`-Syntax wie in Java oder C#, stattdessen nutzt man reine virtuelle Funktionen.\n",
      "\n",
      "---\n",
      "### Beispiel f√ºr eine Interfaceklasse:\n",
      "```cpp\nclass Druckbar {\npublic:\n  virtual void drucke() = 0;\n  virtual ~Druckbar() {}\n};\n```\n",
      "\n",
      "---\n",
      "### Warum verwenden?\n",
      "- Um **Verhalten festzulegen**, das von mehreren Klassen auf **unterschiedliche Weise** umgesetzt wird.\n",
      "- Um **Polymorphie** zu erm√∂glichen.\n",
      "- Um **Abh√§ngigkeiten zu entkoppeln** (z.B. bei Plugins, Testbarkeit usw.).\n",
      "---\n"
    ],
    "code": [
  "// Abstrakte Klasse mit gemeinsamer Logik\n#include <iostream>\n#include <vector>\n\nclass Form {\npublic:\n  virtual double flaeche() = 0; // rein virtuelle Funktion\n  void zeige() {\n    std::cout << \"Fl√§che: \" << flaeche() << std::endl;\n  }\n  virtual ~Form() {}\n};\n\nclass Kreis : public Form {\n  double radius;\npublic:\n  Kreis(double r) : radius(r) {}\n  double flaeche() override {\n    return 3.14159 * radius * radius;\n  }\n};\n\nclass Quadrat : public Form {\n  double seite;\npublic:\n  Quadrat(double s) : seite(s) {}\n  double flaeche() override {\n    return seite * seite;\n  }\n};\n\nint main() {\n  std::vector<Form*> formen;\n  formen.push_back(new Kreis(2));     // Kreis mit Radius 2 ‚Üí Fl√§che ‚âà 12.56636\n  formen.push_back(new Quadrat(3));   // Quadrat mit Seite 3 ‚Üí Fl√§che = 9\n\n  for (Form* f : formen) {\n    f->zeige();                        // Ausgabe:\n                                      // Fl√§che: 12.56636\n                                      // Fl√§che: 9\n  }\n\n  for (Form* f : formen) {\n    delete f;\n  }\n  return 0;\n}"
]

  }
},
{
  "title": "Finale Klassen und Memberfunktionen",
  "content": {
    "text": [
      "### === Finale Klassen und Memberfunktionen ===\n",
      "Mit dem Schl√ºsselwort `final` kann man in C++ **Vererbung oder √úberschreiben verhindern**.\n",
      "\n",
      "üëâ Das ist n√ºtzlich, wenn du sicherstellen willst, dass bestimmte Funktionen oder Klassen **nicht mehr ver√§ndert** werden d√ºrfen.\n",
      "\n",
      "---\n",
      "### Finale Memberfunktionen:\n",
      "- Eine `virtual`-Funktion kann mit `final` markiert werden:\n",
      "```cpp\nvirtual void machEtwas() final;\n```\n",
      "- Dadurch **kann sie in abgeleiteten Klassen nicht mehr √ºberschrieben** werden.\n",
      "- Wird oft verwendet, um bestimmte Methoden **festzulegen und abzusichern**.\n",
      "\n",
      "---\n",
      "### Finale Klassen:\n",
      "- Eine ganze Klasse kann mit `final` markiert werden:\n",
      "```cpp\nclass A final { ... };\n```\n",
      "- Dadurch **kann von dieser Klasse nicht mehr geerbt** werden.\n",
      "- Ideal, wenn die Klasse **vollst√§ndig abgeschlossen** ist oder keine weitere Spezialisierung erw√ºnscht ist.\n",
      "\n",
      "üìå `final` wurde mit **C++11** eingef√ºhrt. Es erh√∂ht die **Lesbarkeit**, verbessert die **Fehlersicherheit** und kann dem Compiler sogar **Optimierungen** erm√∂glichen.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Basis {\npublic:\n  virtual void begruessung() {\n    std::cout << \"Hallo aus Basis\" << std::endl;\n  }\n  virtual void fixMethode() final {\n    std::cout << \"Diese Methode ist final und kann nicht √ºberschrieben werden.\" << std::endl;\n  }\n  virtual ~Basis() {}\n};\n\nclass Abgeleitet : public Basis {\npublic:\n  void begruessung() override {\n    std::cout << \"Hallo aus Abgeleitet\" << std::endl;\n  }\n  // void fixMethode() override {} // ‚ùå Fehler: Methode ist final in der Basisklasse\n};\n\n// === Finale Klasse ===\nclass Endklasse final {\npublic:\n  void info() {\n    std::cout << \"Dies ist eine finale Klasse.\" << std::endl;\n  }\n};\n\n// class Versuch : public Endklasse {}; // ‚ùå Fehler: Endklasse ist final, kann nicht geerbt werden\n\nint main() {\n  Basis* b = new Abgeleitet();\n  b->begruessung(); // Ausgabe: Hallo aus Abgeleitet\n  b->fixMethode();  // Ausgabe: Diese Methode ist final und kann nicht √ºberschrieben werden.\n\n  Endklasse e;\n  e.info(); // Ausgabe: Dies ist eine finale Klasse.\n\n  delete b;\n  return 0;\n"
    ]
  }
},
{
  "title": "Kovariante R√ºckgabetypen",
  "content": {
    "text": [
      "### === Kovariante R√ºckgabetypen ===\n",
      "Kovariante R√ºckgabetypen erm√∂glichen es in C++, dass eine **√ºberschriebene virtuelle Funktion** in einer abgeleiteten Klasse **einen spezielleren R√ºckgabetyp** liefert.\n",
      "\n",
      "üëâ Der R√ºckgabetyp darf sich √§ndern, **wenn er ein Zeiger oder eine Referenz auf einen abgeleiteten Typ** ist.\n",
      "\n",
      "---\n",
      "### Beispiel:\n",
      "- In der Basisklasse wird eine Funktion deklariert, die `Basis*` zur√ºckgibt.\n",
      "- In der abgeleiteten Klasse kann dieselbe Funktion dann `Abgeleitet*` zur√ºckgeben.\n",
      "\n",
      "‚úÖ Das ist erlaubt, **solange die R√ºckgabetypen kompatibel vererbt** sind (also `Abgeleitet*` ist ein Spezialfall von `Basis*`).\n",
      "\n",
      "---\n",
      "### Vorteile:\n",
      "- Erm√∂glicht **pr√§zisere Typen** bei polymorphem Verhalten.\n",
      "- Spart **unn√∂tige Casts** im Code.\n",
      "\n",
      "üìå Achtung: Kovarianz gilt **nur** f√ºr R√ºckgabetypen bei **virtuellen Funktionen**, nicht bei Parametern.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Tier {\npublic:\n  virtual Tier* klonen() const {\n    std::cout << \"Tier wird geklont\" << std::endl;\n    return new Tier(*this); // Kopiert das aktuelle Objekt (Kopierkonstruktor)\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  Hund* klonen() const override { // ‚úÖ kovarianter R√ºckgabetyp: Hund* statt Tier*\n    std::cout << \"Hund wird geklont\" << std::endl;\n    return new Hund(*this); // ‚úÖ korrekt: erstellt Kopie des aktuellen Hund-Objekts\n    // return *(new Hund()); // ‚ùå Fehler: ergibt Objekt (Hund), kein Zeiger (Hund*)\n  }\n\n  // int klonen() const override { return 1; } // ‚ùå Fehler: inkompatibler R√ºckgabetyp (int ‚â† Tier*)\n};\n\n// === Beispiel f√ºr R√ºckgabe als Referenz ===\nclass Fog {\npublic:\n  std::string name = \"Fog\";\n};\n\nclass DemoRef {\npublic:\n  Fog& getFog() const {\n    return *(new Fog()); // ‚úÖ erlaubt: R√ºckgabe als Referenz (&), Objekt lebt auf dem Heap\n  }\n};\n\nint main() {\n  Tier* t = new Hund();\n  Tier* neu = t->klonen(); // Ausgabe: Hund wird geklont\n\n  DemoRef d;\n  Fog& f = d.getFog();\n  std::cout << f.name << std::endl; // Ausgabe: Fog\n\n  delete t;\n  delete neu;\n  delete &f; // ‚ùóÔ∏èmanuell l√∂schen, da mit new erzeugt\n  return 0;\n"
    ]
  }
},
{
  "title": "Object Slicing",
  "content": {
    "text": [
      "### === Object Slicing ===\n",
      "Beim **Object Slicing** (Objektabschneiden) geht Information **verloren**, wenn ein Objekt einer abgeleiteten Klasse in ein Objekt einer Basisklasse **kopiert** wird - **ohne Zeiger oder Referenz**.\n",
      "\n",
      "üëâ Dabei werden **nur die Mitglieder der Basisklasse** √ºbernommen - alles, was zur Unterklasse geh√∂rt, **geht verloren**.\n",
      "\n",
      "---\n",
      "### Wann passiert Slicing?\n",
      "- Wenn ein Objekt **per Wert** (also nicht per Zeiger oder Referenz) √ºbergeben oder zugewiesen wird.\n",
      "- Typisch bei: `Base b = Derived();`\n",
      "\n",
      "---\n",
      "### Warum ist das ein Problem?\n",
      "- Virtuelle Funktionen verhalten sich dann **nicht mehr polymorph**.\n",
      "- Das Objekt \"vergisst\", dass es eigentlich ein Unterklassen-Objekt war.\n",
      "\n",
      "---\n",
      "### Wie vermeidet man Slicing?\n",
      "- Arbeite immer mit **Zeigern (`*`) oder Referenzen (`&`)**, nicht mit Objekten per Wert.\n",
      "- √úbergib Objekte polymorph:\n",
      "```cpp\nvoid verarbeite(const Base& b);\n```\n",
      "\n",
      "üìå C++ selbst erkennt Slicing **nicht als Fehler** - du musst es **bewusst vermeiden**!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  std::string name = \"Tier\";\n\n  virtual void sprich() const {\n    std::cout << name << \" spricht\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  std::string rasse = \"Sch√§ferhund\";\n\n  void sprich() const override {\n    std::cout << name << \" bellt. Rasse: \" << rasse << std::endl;\n  }\n};\n\nvoid machGer√§usch(Tier t) { // ‚ùå Slicing: Hund wird zu Tier kopiert\n  std::cout << \"[Slicing] Name: \" << t.name << std::endl;\n  t.sprich(); // Ausgabe: Tier spricht\n}\n\nvoid machGer√§uschRichtig(const Tier& t) { // ‚úÖ korrekt per Referenz\n  std::cout << \"[Kein Slicing] Name bleibt erhalten\" << std::endl;\n  t.sprich(); // Ausgabe: Hund bellt. Rasse: Sch√§ferhund\n}\n\nint main() {\n  Hund h;\n  h.name = \"Bello\";\n  h.rasse = \"Labrador\";\n\n  machGer√§usch(h);        // ‚ùå slicing: nur Tier-Teil bleibt √ºbrig\n  machGer√§uschRichtig(h); // ‚úÖ korrekt: vollst√§ndiges Objekt erhalten\n\n  return 0;\n"
    ]
  }
},
{
  "title": "Mehrfachvererbung",
  "content": {
    "text": [
      "### === Mehrfachvererbung ===\n",
      "In C++ ist es m√∂glich, dass eine Klasse **von mehreren Basisklassen gleichzeitig erbt**.\n",
      "\n",
      "üëâ Das nennt man **Mehrfachvererbung** und sie kann n√ºtzlich sein - aber auch schnell zu Problemen f√ºhren.\n",
      "\n",
      "---\n",
      "### Syntax:\n",
      "- Eine Klasse kann mehrere Basisklassen angeben:\n",
      "```cpp\nclass C : public A, public B { ... };\n```\n",
      "\n",
      "---\n",
      "### Vorteile:\n",
      "- Kombinieren von Funktionalit√§t aus verschiedenen Klassen.\n",
      "- Kann helfen, **Code zu teilen**, z.B. bei Interfaceklassen.\n",
      "\n",
      "---\n",
      "### Probleme (Diamond Problem):\n",
      "- Wenn **mehrere Basisklassen** von **derselben Oberklasse** erben, kann es zu **Mehrdeutigkeiten** kommen.\n",
      "- Beispiel: Beide Elternklassen erben von `Grundklasse`, Kindklasse erbt von beiden ‚Üí `Grundklasse` ist **zweimal** vorhanden!\n",
      "\n",
      "---\n",
      "### L√∂sung: `virtual`-Vererbung\n",
      "- Mit `virtual` wird sichergestellt, dass es **nur eine gemeinsame Instanz** der Basisklasse gibt:\n",
      "```cpp\nclass A : virtual public Grundklasse { };\n```\n",
      "- Wird auch **virtuelle Vererbung** genannt.\n",
      "\n",
      "---\n",
      "### Reihenfolge: Konstruktoren & Destruktoren\n",
      "- Die Konstruktoren der **Basisklassen** werden in der Reihenfolge aufgerufen, wie sie **in der Klassendeklaration** erscheinen - **nicht nach Reihenfolge im Initialisierungslisten-Code**.\n",
      "- Destruktoren laufen **in umgekehrter Reihenfolge** (von abgeleitet nach oben).\n",
      "- Bei **virtueller Vererbung** wird der virtuelle Basisklassenkonstruktor **nur einmal** aufgerufen - von der **untersten Klasse** im Hierarchiebaum.\n",
      "\n",
      "üìå Mehrfachvererbung ist m√§chtig, sollte aber **mit Bedacht eingesetzt** werden. Oft sind Komposition oder Interfaces die bessere Wahl.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Lebewesen {\npublic:\n  Lebewesen() { std::cout << \"[Konstruktor] Lebewesen\" << std::endl; }\n  ~Lebewesen() { std::cout << \"[Destruktor] Lebewesen\" << std::endl; }\n  void atme() { std::cout << \"Lebewesen atmet\" << std::endl; }\n};\n\nclass Schwimmer : virtual public Lebewesen {\npublic:\n  Schwimmer() { std::cout << \"[Konstruktor] Schwimmer\" << std::endl; }\n  ~Schwimmer() { std::cout << \"[Destruktor] Schwimmer\" << std::endl; }\n  void schwimme() { std::cout << \"Ich schwimme\" << std::endl; }\n};\n\nclass L√§ufer : virtual public Lebewesen {\npublic:\n  L√§ufer() { std::cout << \"[Konstruktor] L√§ufer\" << std::endl; }\n  ~L√§ufer() { std::cout << \"[Destruktor] L√§ufer\" << std::endl; }\n  void laufe() { std::cout << \"Ich laufe\" << std::endl; }\n};\n\nclass Triathlet : public Schwimmer, public L√§ufer {\npublic:\n  Triathlet() { std::cout << \"[Konstruktor] Triathlet\" << std::endl; }\n  ~Triathlet() { std::cout << \"[Destruktor] Triathlet\" << std::endl; }\n  void wettkampf() {\n    atme();\n    schwimme();\n    laufe();\n  }\n};\n\nint main() {\n  Triathlet t;\n  t.wettkampf();\n  return 0;\n}\n\n// Beispielausgabe:\n// [Konstruktor] Lebewesen\n// [Konstruktor] Schwimmer\n// [Konstruktor] L√§ufer\n// [Konstruktor] Triathlet\n// Lebewesen atmet\n// Ich schwimme\n// Ich laufe\n// [Destruktor] Triathlet\n// [Destruktor] L√§ufer\n// [Destruktor] Schwimmer\n// [Destruktor] Lebewesen"
    ]
  }
}






      
    ]
  },







  {
    "category": "√úberladung",
    "subtopics": [
      {
        "title": "Funktionen",
        "content": {
          "text": [
            "### === Funktions√ºberladung in C++ ===\n",
            "Funktions√ºberladung bedeutet, dass mehrere Funktionen **denselben Namen**, aber **unterschiedliche Parameterlisten** haben k√∂nnen.\n",
            "\n",
            "Der Compiler w√§hlt beim Aufruf die passende Funktion anhand der √ºbergebenen Argumente.\n",
            "\n",
            "---\n",
            "### Regeln\n",
            "- Funktionen m√ºssen sich in der Anzahl oder dem Typ der Parameter unterscheiden\n",
            "- R√ºckgabewert allein reicht **nicht** zur Unterscheidung!\n",
            "\n",
            "---\n",
            "### Vorteile\n",
            "- Lesbarkeit: Gleicher Funktionsname f√ºr √§hnliche Aufgaben\n",
            "- Flexibilit√§t: Funktion kann mit verschiedenen Datentypen arbeiten\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\n// Funktions√ºberladungen\nvoid begruessung() {\n  std::cout << \"Hallo!\" << std::endl;\n}\n\nvoid begruessung(std::string name) {\n  std::cout << \"Hallo, \" << name << \"!\" << std::endl;\n}\n\nvoid begruessung(int stunde) {\n  if (stunde < 12)\n    std::cout << \"Guten Morgen!\" << std::endl;\n  else\n    std::cout << \"Guten Tag!\" << std::endl;\n}\n\nint main() {\n  begruessung();              // Ausgabe: Hallo!\n  begruessung(\"Kilian\");     // Ausgabe: Hallo, Kilian!\n  begruessung(9);             // Ausgabe: Guten Morgen!\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Operatoren",
        "content": {
          "text": [
            "### === Operator√ºberladung in C++ ===\n",
            "Operator√ºberladung erlaubt es, **eigene Klassen** so zu definieren, dass Standard-Operatoren (`+`, `==`, `<<`, usw.) auch mit diesen Klassen funktionieren.\n",
            "\n",
            "---\n",
            "### Warum Operatoren √ºberladen?\n",
            "- Mehr Lesbarkeit: `a + b` statt `a.addiere(b)`\n",
            "- Nat√ºrlichere Verwendung eigener Typen\n",
            "\n",
            "---\n",
            "### Syntax\n",
            "`R√ºckgabetyp operator<OPERATOR>(Parameter)`\n",
            "-> Wird innerhalb oder au√üerhalb der Klasse definiert\n",
            "-> Kann fast jeder Operator √ºberladen werden (au√üer z.B. `.` oder `::`)\n",
            "---\n"
          ],
          "code": [
  "#include <iostream>\n\nclass Punkt {\nprivate:\n  int x, y;\n\npublic:\n  Punkt(int x, int y) : x(x), y(y) {}\n\n  // Operator√ºberladung f√ºr +\n  Punkt operator+(const Punkt& other) {\n    return Punkt(x + other.x, y + other.y);\n  }\n\n  // Operator√ºberladung f√ºr -\n  Punkt operator-(const Punkt& other) {\n    return Punkt(x - other.x, y - other.y);\n  }\n\n  // Gleichheitsoperator ==\n  bool operator==(const Punkt& other) const {\n    return x == other.x && y == other.y;\n  }\n\n  // Ausgabeoperator √ºberladen (als friend)\n  friend std::ostream& operator<<(std::ostream& os, const Punkt& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n  }\n};\n\nclass Z√§hler {\nprivate:\n  int wert;\n\npublic:\n  Z√§hler(int w) : wert(w) {}\n\n  // Pr√§fix-Inkrement ++z\n  Z√§hler& operator++() {\n    ++wert;\n    return *this;\n  }\n\n  // Postfix-Inkrement z++\n  Z√§hler operator++(int) {\n    Z√§hler temp = *this;\n    ++wert;\n    return temp;\n  }\n\n  // Ausgabeoperator\n  friend std::ostream& operator<<(std::ostream& os, const Z√§hler& z) {\n    os << z.wert;\n    return os;\n  }\n};\n\nint main() {\n  Punkt a(2, 3);\n  Punkt b(4, 1);\n  Punkt c = a + b;\n  Punkt d = a - b;\n\n  std::cout << \"a + b = \" << c << std::endl;  // (6, 4)\n  std::cout << \"a - b = \" << d << std::endl;  // (-2, 2)\n\n  std::cout << std::boolalpha;\n  std::cout << \"a == b: \" << (a == b) << std::endl; // false\n\n  Z√§hler z(10);\n  std::cout << \"z: \" << z << std::endl;      // 10\n  std::cout << \"++z: \" << ++z << std::endl;   // 11\n  std::cout << \"z++: \" << z++ << std::endl;   // 11 (zeigt alten Wert)\n  std::cout << \"nach z++: \" << z << std::endl; // 12\n\n  return 0;\n}"
]
        }
      }
    ]
  },







  {
    "category": "Extras",
    "subtopics": [
      {
  "title": "Formatierung",
  "content": {
    "text": [
      "### === Formatierung in C++ ===\n",
      "In C++ gibt es verschiedene M√∂glichkeiten, Ausgaben optisch zu formatieren - z.B. f√ºr Tabellen, Zahlen, Texte und Spezialformate.\n",
      "\n",
      "---\n",
      "### üìè Feldbreite und Ausrichtung (`<iomanip>`)\n",
      "- `std::setw(n)`: Legt die Breite eines Felds fest\n",
      "- `std::left`, `std::right`: Textausrichtung (nur in Verbindung mit `std::setw()`)\n",
      "- `std::setfill(c)`: Zeichen zum Auff√ºllen (z.B. `0` oder `-`)\n",
      "\n",
      "---\n",
      "### üî¢ Nachkommastellen und Gleitkommaformat\n",
      "- `std::fixed`: Feste Anzahl Nachkommastellen\n",
      "- `std::setprecision(n)`: Anzahl Nachkommastellen\n",
      "- `std::scientific`: Wissenschaftliche Notation\n",
      "\n",
      "---\n",
      "### üî£ Zahlenformate\n",
      "- `std::dec` ‚Üí dezimal (Standard)\n",
      "- `std::hex` ‚Üí hexadezimal\n",
      "- `std::oct` ‚Üí oktal\n",
      "- Praktisch f√ºr Debug-Ausgaben oder Speicheradressen\n",
      "\n",
      "---\n",
      "### üîê F√ºhrende Nullen\n",
      "- Mit `std::setw()` und `std::setfill('0')`:\n",
      "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // 00017\n```\n",
      "- Mit `std::string` manuell:\n",
      "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17);\n```\n",
      "- Ab C++20 mit `std::format`:\n",
      "```cpp\nstd::format(\"{:05}\", 17); // 00017\n```\n",
      "\n",
      "---\n",
      "### üÜï `std::format` (C++20)\n",
      "- Moderner, leistungsf√§higer Formatter\n",
      "- Nutzt Python-√§hnliche Syntax\n",
      "- Beispiele:\n",
      "```cpp\nstd::format(\"{} hat {} Punkte\", name, punkte);\nstd::format(\"{:>10}\", \"rechts\"); // rechtsb√ºndig\n```\n",
      "- Erfordert Compiler mit C++20 + Format-Unterst√ºtzung (`<format>`)\n",
      "---\n"
    ],
    "code": [
  "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int punkte = 42;\n  double kontostand = 1234.56789;\n\n  // Feldbreite und Ausrichtung\n  std::cout << std::left << std::setw(12) << \"Name\"\n            << std::right << std::setw(8) << \"Punkte\"\n            << std::setw(15) << \"Kontostand\" << std::endl; // Ausgabe: Name            Punkte     Kontostand\n  std::cout << std::left << std::setw(12) << name\n            << std::right << std::setw(8) << punkte\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl; // Ausgabe: Kilian             42         1234.57\n\n  // Zahlenformate\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;        // Ausgabe: Dezimal: 42\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;   // Ausgabe: Hexadezimal: 2a\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;          // Ausgabe: Oktal: 52\n\n  // F√ºhrende Nullen mit iomanip\n  std::cout << \"F√ºhrende Nullen: \" << std::setw(5) << std::setfill('0') << zahl << std::endl; // Ausgabe: F√ºhrende Nullen: 00042\n\n  // Mit std::string\n  std::string gepolstert = std::string(5 - std::to_string(zahl).length(), '0') + std::to_string(zahl);\n  std::cout << \"Manuell gepolstert: \" << gepolstert << std::endl; // Ausgabe: Manuell gepolstert: 00042\n\n#if __cpp_lib_format\n  // Mit std::format (C++20)\n  std::cout << std::format(\"std::format f√ºhrend: {:05}\\n\", zahl); // Ausgabe: std::format f√ºhrend: 00042\n  std::cout << std::format(\"Name: {}, Punkte: {}\\n\", name, punkte); // Ausgabe: Name: Kilian, Punkte: 42\n  std::cout << std::format(\"{:>10}\\n\", \"rechts\"); // Ausgabe:     rechts\n#endif\n\n  return 0;\n"
]

  }
},
    {
  "title": "Casting",
  "content": {
    "text": [
      "### === Casting in C++ ===\n",
      "Casting ist die Umwandlung eines Ausdrucks von einem Datentyp in einen anderen.\n",
      "In C++ gibt es sowohl **C-Style Casts** als auch **C++-spezifische Casts**:\n",
      "\n",
      "---\n",
      "### üü• C-Style Cast (unsicher!)\n",
      "```cpp\nint x = (int)3.14;   // Ergebnis: 3\n```\n",
      "- Alt, kompakt, aber **unsicher**\n",
      "- Kann **gef√§hrliche Typumwandlungen** stillschweigend zulassen\n",
      "\n",
      "---\n",
      "### ‚úÖ C++ Casts (sicherer & spezifischer):\n",
      "\n",
      "#### üîπ static_cast<T>(expr)\n",
      "- F√ºr **sichere, logische Konvertierungen** (z.B. `double` ‚Üí `int`, `Base*` ‚Üí `Derived*` bei Vererbung ohne RTTI)\n",
      "```cpp\nint x = static_cast<int>(3.7);  // x = 3\n```\n",
      "\n",
      "---\n",
      "#### üîπ dynamic_cast<T>(expr)\n",
      "- F√ºr **sichere Konvertierung bei Vererbung** mit `virtual`\n",
      "- Funktioniert nur mit **Polymorphie** (mind. eine `virtual`-Methode)\n",
      "- Gibt `nullptr` zur√ºck, wenn Cast fehlschl√§gt\n",
      "```cpp\nBase* b = new Derived();\nDerived* d = dynamic_cast<Derived*>(b);  // OK\n```\n",
      "\n",
      "---\n",
      "#### üîπ const_cast<T>(expr)\n",
      "- Entfernt oder f√ºgt `const` hinzu (z.B. um schreibende Funktion auf `const`-Objekte anzuwenden)\n",
      "- Nur erlaubt, wenn Ursprungsobjekt nicht wirklich `const` war\n",
      "```cpp\nconst int* p = ...;\nint* mod = const_cast<int*>(p);\n```\n",
      "\n",
      "---\n",
      "### üëá Empfehlung:\n",
      "- Verwende **`static_cast` f√ºr fast alles**, wenn du den Typ kennst\n",
      "- **Vermeide `C-Style`-Casts**, wenn m√∂glich\n",
      "- **Nutze `dynamic_cast` nur bei Vererbung**, sonst bringt es nichts\n",
      "- **Vermeide `const_cast`**, au√üer in Spezialf√§llen\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\" << std::endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\" << std::endl; }\n};\n\nint main() {\n    double pi = 3.14;\n    int x = static_cast<int>(pi);               // static_cast: 3\n    std::cout << \"x: \" << x << std::endl;\n\n    Base* base = new Derived();\n    Derived* d = dynamic_cast<Derived*>(base);  // dynamic_cast: OK\n    if (d) d->show();                           // Ausgabe: Derived\n\n    const int a = 42;\n    int* b = const_cast<int*>(&a);              // const_cast: ‚ö†Ô∏è gef√§hrlich\n    std::cout << \"b: \" << *b << std::endl;\n\n    delete base;\n    return 0;\n}"
    ]
  }
},
      {
        "title": "Algorithmen",
        "content": {
          "text": [
            "### === STL-Algorithmen in C++ ===\n",
            "Die Standard Template Library (STL) bietet viele n√ºtzliche Algorithmen zur Bearbeitung von Containern wie `vector`, `set`, `map`, etc.\n",
            "\n",
            "---\n",
            "### Wichtige Algorithmen:\n",
            "- `std::sort`: Sortiert Elemente (ben√∂tigt `<algorithm>`)\n",
            "- `std::reverse`: Dreht die Reihenfolge um\n",
            "- `std::find`: Sucht ein bestimmtes Element\n",
            "- `std::count`: Z√§hlt, wie oft ein bestimmter Wert vorkommt\n",
            "- `std::for_each`: F√ºhrt eine Funktion auf jedem Element aus\n",
            "- `std::remove`: Entfernt (logisch) ein Element - mit `erase` kombinieren\n",
            "\n",
            "---\n",
            "### Allgemein\n",
            "- Alle Algorithmen arbeiten mit **Iteratoren** (z.B. `begin()` / `end()`)\n",
            "- STL-Algorithmen ver√§ndern nicht den Container direkt (au√üer `sort`, `reverse`, etc.)\n",
            "- Viele Algorithmen nutzen **Lambdas** oder Funktionsobjekte\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr sort, find, etc.\n\nint main() {\n  std::vector<int> zahlen = {4, 2, 7, 2, 9};\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end());\n\n  // ausgeben\n  std::cout << \"Sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \";\n  std::cout << std::endl; // Ausgabe: 2 2 4 7 9\n\n  // z√§hlen\n  int anz = std::count(zahlen.begin(), zahlen.end(), 2);\n  std::cout << \"Die Zahl 2 kommt \" << anz << \" mal vor.\" << std::endl;\n\n  // suchen\n  auto it = std::find(zahlen.begin(), zahlen.end(), 7);\n  if (it != zahlen.end()) {\n    std::cout << \"7 gefunden an Position \" << (it - zahlen.begin()) << std::endl; //(it - zahlen.begin()) == Abstand im Container\n  }\n\n  // for_each mit Lambda\n  std::cout << \"Alle Werte verdoppelt: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x * 2 << \" \"; });\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Templates",
        "content": {
          "text": [
            "### === Templates in C++ ===\n",
            "Templates erm√∂glichen es, **generischen Code** zu schreiben, der mit beliebigen Datentypen funktioniert.\n",
            "\n",
            "---\n",
            "### Warum Templates?\n",
            "- Wiederverwendbarkeit: gleiche Funktion/Klasse f√ºr viele Datentypen\n",
            "- Flexibilit√§t: z.B. `int`, `double`, `std::string`, eigene Typen\n",
            "- Kein mehrfacher Code n√∂tig f√ºr unterschiedliche Typen\n",
            "\n",
            "---\n",
            "### Funktions-Template\n",
            "```cpp\n template <typename T>\n T max(T a, T b) {\n   return (a > b) ? a : b;\n }\n```\n",
            "`T` ist ein Platzhalter f√ºr einen beliebigen Typ.\n",
            "Beim Aufruf wird automatisch der passende Typ eingesetzt (Typinferenz).\n",
            "\n",
            "---\n",
            "### Einschr√§nkung bei Operatoren\n",
            "Ein Funktions-Template wie `addiere(T a, T b)` funktioniert **nur, wenn f√ºr `T` der `+`-Operator definiert ist**.\n",
            "Beispiele, wo es funktioniert:\n",
            "- `int`, `double`, `std::string`\n",
            "Bei eigenen Typen (z.B. `struct Person`) musst du den `operator+` **selbst √ºberladen**, damit das Template funktioniert.\n",
            "\n",
            "---\n",
            "### Klassen-Template\n",
            "```cpp\n template <typename T>\n class Box {\n   T inhalt;\n   // ...\n };\n```\n",
            "Auch Klassen lassen sich so f√ºr beliebige Typen definieren.\n",
            "---\n",
            "\n### Typ muss bei Klassen-Templates immer angegeben werden\n",
            "Im Gegensatz zu Funktions-Templates kann der Compiler bei Klassen **nicht automatisch den Typ ableiten**.\n",
            "Du musst beim Erstellen eines Objekts **immer den gew√ºnschten Typ explizit angeben**:\n",
            "```cpp\nBeh√§lter<int> b(10);   // ‚úÖ korrekt\nBeh√§lter b(10);        // ‚ùå Fehler - Typ fehlt\n```\n",
            "Der Compiler kann aus den Konstruktorargumenten **nicht selbst schlie√üen**, welchen Typ `T` annehmen soll.\n",
            "\n",
            "---\n",
            "### `typename` oder `class`?\n",
            "Beide Varianten sind bei Templates **gleichwertig** und funktionieren identisch:\n",
            "```cpp\ntemplate <typename T>   // bevorzugt in moderner C++-Schreibweise\ntemplate <class T>      // historisch h√§ufiger verwendet\n```\n",
            "Du kannst die Variante frei w√§hlen - in modernen Projekten ist `typename` oft √ºblicher, weil es semantisch klarer ist.\n",
            "---\n",
            "\n### Methoden au√üerhalb von Template-Klassen definieren\n",
            "Wenn eine Methode **au√üerhalb** einer Template-Klasse definiert wird, muss der Compiler genau wissen, dass auch die Methode ein Template ist.\n",
            "Dazu muss man:\n",
            "- die `template <typename T>`-Zeile **vor jeder Methode** wiederholen\n",
            "- beim Klassennamen den **Typparameter mit angeben**\n",
            "```cpp\n// Klassendeklaration\ntemplate <typename T>\nclass Complex {\n  T re();\n};\n\n// Methodendefinition au√üerhalb\ntemplate <typename T>\nT Complex<T>::re() {\n  // ...\n}\n```\n",
            "Ohne diese Angaben kann der Compiler die Funktion nicht korrekt zuordnen und meldet einen Fehler.\n",
            "---\n",    
            "\n### Templates und Dateiaufteilung\n",
            "Bei normalen Klassen ist es √ºblich, Deklaration und Definition auf `.hpp` und `.cpp` aufzuteilen.\n",
            "‚Üí Bei Template-Klassen funktioniert das **nicht**, weil der Compiler beim Verwenden (z.B. `Complex<int>`) **alle Methoden kennen muss**.\n",
            "\n",
            "---\n",
            "### L√∂sung: `.tpp`-Datei\n",
            "Um den Code trotzdem √ºbersichtlich zu halten, wird die Implementierung oft in eine `.tpp`-Datei ausgelagert.\n",
            "Diese wird **ausnahmsweise in der Header-Datei eingebunden**:\n",
            "```cpp\n// complex.hpp\n#ifndef COMPLEX_HPP\n#define COMPLEX_HPP\n\ntemplate <typename T>\nclass Complex {\n  // ...\n  T re();\n  T im();\n};\n\n#include \"complex.tpp\"  // Wichtig: im Header einbinden!\n\n#endif\n```\n",
            "```cpp\n// complex.tpp\ntemplate <typename T>\nT Complex<T>::re() { return re_; }\n\ntemplate <typename T>\nT Complex<T>::im() { return im_; }\n```\n",
            "So bleibt der Code sauber getrennt, aber der Compiler kann beim Instanziieren alle Definitionen sehen.\n",
            "---\n",
            "\n### Statische Member in Template-Klassen\n",
            "Statische Variablen in Template-Klassen werden **f√ºr jede Typ-Instanziierung separat erzeugt**.\n",
            "Das bedeutet: `complex<int>` und `complex<long>` haben **unabh√§ngige** eigene `counter_`-Werte.\n",
            "Will man statisch **typ√ºbergreifend** z√§hlen, muss man eine **globale Variable au√üerhalb** der Klasse verwenden.\n",
            "---\n",
            "\n### Templates mit Wertparametern\n",
            "Templates k√∂nnen neben Typen auch **konstante Werte als Parameter** annehmen - sogenannte **Nicht-Typ-Template-Parameter**.\n",
            "Diese werden wie normale Parameter in der Template-Liste angegeben, z.B. `int offset`:\n",
            "```cpp\ntemplate <typename T, int offset = 42>\nT shiftedMax(T x, T y) {\n  return offset + (x > y ? x : y);\n}\n```\n",
            "Aufrufbeispiele:\n",
            "- `shiftedMax<int, 10>(2, 3)` ‚Üí ergibt `13`\n",
            "- `shiftedMax<double>(2.0, 3.0)` ‚Üí ergibt `45.0` (Default-Offset 42)\n",
            "- `shiftedMax(2, 3)` ‚Üí ergibt `45` (Typ und Offset abgeleitet)\n",
            "\n",
            "üìå Zul√§ssig sind nur **integrale Datentypen** wie `int`, `char`, `bool` oder `enum`.\n",
            "üëâ Integrale Datentypen sind alle **ganzzahligen Typen**, also ohne Nachkommastellen.\n",
            "F√ºr **jede Kombination von Typ und Wert** wird beim Kompilieren **neuer Code generiert**.\n",
            "---\n",
            "\n### Template-Klassen mit Wert- und Typ-Defaults\n",
            "Auch Klassen-Templates k√∂nnen **konstante Wertparameter** enthalten - z.B. zur Festlegung von Array-Gr√∂√üen.\n",
            "Zus√§tzlich k√∂nnen **Standardwerte f√ºr Typen und Werte** angegeben werden:\n",
            "```cpp\ntemplate <class T = int, unsigned int size = 2>\nstruct my_array {\n  T data[size];\n};\n```\n",
            "Verwendung:\n",
            "- `my_array<> a;` ‚Üí ergibt `my_array<int, 2>`\n",
            "- `my_array<double> b;` ‚Üí ergibt `my_array<double, 2>`\n",
            "- `my_array<double, 10> c;` ‚Üí ergibt `my_array<double, 10>`\n",
            "\n",
            "üìå Der Wertparameter `size` muss ein **konstanter Ausdruck** sein, z.B. `unsigned int`.\n",
            "So lassen sich Klassen flexibel anpassen, ohne jedes Detail beim Aufruf anzugeben.\n",
            "---\n",
            "\n### Template-Template-Parameter\n",
            "Templates k√∂nnen auch **andere Templates als Parameter** annehmen. Das nennt man **Template-Template-Parameter** oder kurz: **Template-Templates**.\n",
            "\n",
            "Ein typisches Beispiel ist ein generischer Container-Wrapper:\n",
            "```cpp\ntemplate <class T,\n          template<typename, typename> class C,\n          template<typename> class A = std::allocator>\nclass container_wrapper {\n  C<T, A<T>> container;\npublic:\n  void insert(const T& t) { container.push_back(t); }\n  const T& get(unsigned int i) { return container[i]; }\n};\n```\n",
            "\n",
            "#### üîç Was passiert hier?\n",
            "- `T` ist der Typ der Elemente, z.B. `int` oder `std::string`\n",
            "- `C` ist ein Container-Template wie `std::vector` oder `std::list`, das **zwei Typen erwartet** (`T`, `Allocator<T>`) ‚Üí deshalb `template<typename, typename>`\n",
            "- `A` ist der **Allocator**, also eine Speicherverwaltungsklasse, z.B. `std::allocator` (Standardwert)\n",
            "\n",
            "‚û°Ô∏è Der Ausdruck `C<T, A<T>> container;` wird z.B. zu `std::vector<int, std::allocator<int>>`.\n",
            "\n",
            "---\n",
            "#### ‚úÖ Beispiel:\n",
            "```cpp\ncontainer_wrapper<std::string, std::vector> cw;\ncw.insert(\"Hello\");\nstd::cout << cw.get(0);  // Ausgabe: Hello\n```\n",
            "\n",
            "#### üìå Warum ist das so aufgebaut?\n",
            "- Container wie `std::vector` ben√∂tigen zwei Parameter: den Datentyp und den Allocator\n",
            "- Deshalb muss `C` so definiert sein: `template<typename, typename>`\n",
            "- Der extra `A`-Parameter erlaubt es, den Allocator gezielt zu setzen oder den Standard zu verwenden\n",
            "\n",
            "üí° Ein **Allocator** k√ºmmert sich intern um die Speicherverwaltung - in der Praxis brauchst du ihn meist nicht aktiv zu benutzen.\n",
            "\n",
            "**Template-Template-Parameter** sind ein m√§chtiges Werkzeug f√ºr sehr flexible, generische Konstrukte - aber sie k√∂nnen schnell komplex wirken.\n",
            "---\n",
            "\n### Abh√§ngige Typen und `typename`\n",
            "In Template-Klassen k√∂nnen auch **Typen auftreten, die vom Typparameter abh√§ngen** - z.B. `T*` oder `std::vector<T>::iterator`.\n",
            "Solche Typen nennt man **abh√§ngige Typen** (*dependent types*), weil sie erst beim Instantiieren des Templates eindeutig sind.\n",
            "\n",
            "üìå Wichtig: Wenn du innerhalb eines Templates auf einen solchen abh√§ngigen Typ zugreifst, **musst du `typename` davor schreiben**, damit der Compiler wei√ü, dass es sich um einen Typ handelt:\n",
            "```cpp\ntypename std::vector<T>::iterator iter;\n```\n",
            "Ohne `typename` denkt der Compiler eventuell, es handelt sich um ein Datenmitglied oder eine Funktion - und gibt einen Fehler aus.\n",
            "---\n",    
            "\n### Vererbung mit Template-Klassen\n",
            "Template-Klassen k√∂nnen als **Basisklassen** in Vererbungshierarchien dienen.\n",
            "Sie eignen sich z.B. f√ºr generische Schnittstellen mit Memberfunktionen, die verschiedene Typen verarbeiten sollen.\n",
            "Wenn eine **nicht-template Unterklasse** davon ableitet, muss sie den **Typparameter festlegen**:\n",
            "```cpp\nclass add_double : invertible_operation<double> { ... };\n```\n",
            "So kann man z.B. mit einer Basisklasse `operation<T>` die Methode `T apply(T, T)` vorschreiben - unabh√§ngig vom konkreten Typ.\n",
            "Mit virtuellen oder rein virtuellen Methoden lassen sich dabei flexible, generische Interfaces bauen.\n",
            "---\n",
            "\n### Template-Metaprogrammierung\n",
            "Templates k√∂nnen in C++ nicht nur f√ºr generischen Code verwendet werden - man kann damit auch **Werte zur Compile-Zeit berechnen**. Das nennt man **Template-Metaprogrammierung**.\n",
            "\n",
            "Ein klassisches Beispiel ist die Fakult√§t (n!) als rekursive Template-Variable:\n",
            "```cpp\ntemplate<unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\n\ntemplate<>\nconstexpr unsigned long long factorial<0> = 1;\n```\n",
            "Diese Definition berechnet z.B. `factorial<5>` schon beim √úbersetzen als `120`.\n",
            "\n",
            "√úberpr√ºfen l√§sst sich das mit `static_assert`, das bei einem falschen Ergebnis einen Compilerfehler ausl√∂st:\n",
            "```cpp\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n```\n",
            "Das Programm f√ºhrt diese Berechnung **nicht zur Laufzeit aus**, sondern ersetzt `factorial<5>` direkt mit dem Wert.\n",
            "---\n",    
            "\n### SFINAE mit `std::enable_if` (Typabh√§ngige Spezialisierung)\n",
            "Mithilfe von `std::enable_if` und `type_traits` wie `std::is_integral` oder `std::is_floating_point` lassen sich **Funktionen gezielt nur f√ºr bestimmte Typen definieren**.\n",
            "Das funktioniert √ºber das Prinzip **SFINAE** (Substitution Failure Is Not An Error): Wenn eine Typbedingung nicht zutrifft, wird die Funktion einfach ignoriert - ohne Compilerfehler.\n",
            "\n",
            "Beispiel: Eine Funktion, die einen Wert mit 2‚Åø multipliziert - einmal f√ºr Ganzzahlen mit Bitshift, einmal f√ºr Flie√ükommazahlen mit `std::pow`:\n",
            "```cpp\n// f√ºr Ganzzahlen (schnell via Bitshift)\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\n\n// f√ºr Gleitkommazahlen\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n```\n",
            "Je nach √ºbergebenem Typ (`int` oder `double`) wird die passende Version der Funktion instanziiert.\n",
            "---\n",    
            "\n### Concepts (ab C++20)\n",
            "Templates k√∂nnen fehlschlagen, wenn bestimmte Operationen mit einem Typ nicht erlaubt sind - z.B. wenn ein Typ nicht durchlaufbar ist oder kein `+=` unterst√ºtzt.\n",
            "Mit **Concepts** kann man diese Voraussetzungen **explizit machen**.\n",
            "\n",
            "Beispiel: Das Concept `Sequence` pr√ºft, ob ein Typ `.begin()` und `.end()` besitzt:\n",
            "```cpp\ntemplate<typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\n```\n",
            "Damit kann man eine Funktion nur f√ºr passende Typen zulassen:\n",
            "```cpp\ntemplate<Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n```\n",
            "Wenn ein ungeeigneter Typ √ºbergeben wird (z.B. ein String-Literal), gibt der Compiler eine **klare Fehlermeldung** - z.B.:\n",
            "- `ERROR: constraints not satisfied: the required expression 's.begin()' is invalid`\n",
            "\n",
            "üìå Concepts helfen dabei, Templates **zu beschr√§nken**, **Fehler verst√§ndlicher zu machen** und sind eine moderne Alternative zu `std::enable_if` und `type_traits`.\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <array>\n#include <type_traits>\n#include <cmath>\n#include <string>\n#include <memory>\n#include <concepts>\n\n// === Funktions-Template ===\ntemplate <typename T>\nT maxValue(T a, T b) {\n  return (a > b) ? a : b;\n}\n\n// === Klassen-Template mit statischem Member ===\ntemplate <typename T>\nclass CounterBox {\npublic:\n  static int count;\n  T value;\n  CounterBox(T v) : value(v) { ++count; }\n};\ntemplate <typename T>\nint CounterBox<T>::count = 0;\n\n// === Template mit Wertparameter ===\ntemplate <typename T, int offset = 0>\nT shiftedMax(T a, T b) {\n  return offset + ((a > b) ? a : b);\n}\n\n// === Template-Klasse mit Typ- und Wert-Default ===\ntemplate <typename T = int, size_t N = 3>\nstruct MyArray {\n  T data[N];\n};\n\n// === Template-Template-Parameter ===\ntemplate <typename T, template<typename, typename> class Container, template<typename> class Alloc = std::allocator>\nclass ContainerWrapper {\n  Container<T, Alloc<T>> items;\npublic:\n  void add(const T& t) { items.push_back(t); }\n  const T& get(size_t i) { return items[i]; }\n};\n\n// === Abh√§ngiger Typ mit typename ===\ntemplate <typename T>\nclass WithIterator {\npublic:\n  typename std::vector<T>::iterator it;\n};\n\n// === Vererbung mit Templates ===\ntemplate <typename T>\nclass Operation {\npublic:\n  virtual T apply(T, T) const = 0;\n};\ntemplate <typename T>\nclass InvertibleOperation : public Operation<T> {\npublic:\n  virtual T apply_inverse(T, T) const = 0;\n};\nclass AddDouble : public InvertibleOperation<double> {\npublic:\n  double apply(double a, double b) const override { return a + b; }\n  double apply_inverse(double a, double b) const override { return a - b; }\n};\n\n// === Template-Metaprogrammierung ===\ntemplate <unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\ntemplate <>\nconstexpr unsigned long long factorial<0> = 1;\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n\n// === SFINAE mit enable_if ===\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n\n// === Concepts ===\ntemplate <typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\ntemplate <Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n\nint main() {\n  std::cout << maxValue(4, 7) << std::endl;\n  CounterBox<int> a(1), b(2);\n  std::cout << \"Anzahl CounterBox<int>: \" << CounterBox<int>::count << std::endl;\n  std::cout << shiftedMax<int, 10>(3, 5) << std::endl;\n  MyArray<> arr1;\n  MyArray<double, 5> arr2;\n  ContainerWrapper<std::string, std::vector> cw;\n  cw.add(\"Hello\");\n  std::cout << cw.get(0) << std::endl;\n  AddDouble ad;\n  std::cout << ad.apply(3.5, 2.5) << \", \" << ad.apply_inverse(3.5, 2.5) << std::endl;\n  std::cout << multByPow2(2, 3) << \" | \" << multByPow2(0.5, 4) << std::endl;\n  std::vector<int> v = {1, 2, 3};\n  std::cout << accum(v, 0) << std::endl;\n  return 0;\n}"
          ]
        }
      },
            {
        "title": "Lambdas",
        "content": {
          "text": [
            "### === Lambda-Ausdr√ºcke in C++ ===\n",
            "Ein Lambda ist eine **anonyme Funktion**, die direkt im Code definiert und z.B. an Algorithmen √ºbergeben werden kann.\n",
            "\n",
            "---\n",
            "### Warum Lambdas?\n",
            "- Wenn man **kleine Funktionen nur einmalig** braucht (z.B. in `sort`, `for_each`), ist es **unn√∂tig**, extra eine benannte Funktion zu schreiben.\n",
            "- Lambdas machen den Code **k√ºrzer, klarer und direkt an Ort und Stelle**.\n",
            "- Sie lassen sich auch mit lokalen Variablen verkn√ºpfen (√ºber `[]`-Capture).\n",
            "\n",
            "---\n",
            "### Syntax\n",
            "`[capture](parameter) -> r√ºckgabetyp { body }`\n",
            "- `capture`: Welche Variablen von au√üen verwendet werden d√ºrfen (z.B. `[x]`, `[&]`, `[=]`, `[]`)\n",
            "- `parameter`: √úbergabeparameter wie bei normalen Funktionen\n",
            "- `r√ºckgabetyp` ist optional (oft automatisch erkannt)\n",
            "\n",
            "---\n",
            "### Beispiel - einfache Lambda-Funktion\n",
            "```cpp\n auto quadrat = [](int x) { return x * x; };\n quadrat(5); // ergibt 25\n```\n",
            "\n",
            "---\n",
            "### Lambdas mit Algorithmen\n",
            "Sehr praktisch in Verbindung mit `std::for_each`, `std::sort`, usw.\n",
            "```cpp\n std::for_each(v.begin(), v.end(), [](int x){ std::cout << x << \" \"; });\n```\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // f√ºr for_each, sort\n\nint main() {\n  std::vector<int> zahlen = {5, 2, 8, 1};\n\n  // Lambda speichern und benutzen\n  auto quadrat = [](int x) { return x * x; };\n  std::cout << \"Quadrat von 4: \" << quadrat(4) << std::endl; // Ausgabe: 16\n\n  // for_each mit Lambda\n  std::cout << \"Zahlen: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x << \" \"; });\n  std::cout << std::endl;\n\n  // sortieren mit Lambda (absteigend)\n  std::sort(zahlen.begin(), zahlen.end(), [](int a, int b){ return a > b; });\n\n  std::cout << \"Absteigend sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \"; // Ausgabe: 8 5 2 1\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Exceptions",
  "content": {
    "text": [
      "### === Exceptions in C++ - Fehler sauber behandeln ===\n",
      "**Exceptions** (Ausnahmen) sind das C++-System, um **Fehler zu erkennen** und **sauber darauf zu reagieren**, ohne den gesamten Code mit `if`-Abfragen vollzustopfen.\n",
      "\n",
      "---\n",
      "### üß† Grundidee\n",
      "- Du pr√ºfst, ob etwas schief l√§uft ‚Üí mit `if`\n",
      "- Du meldest den Fehler ‚Üí mit `throw`\n",
      "- Du behandelst ihn **zentral** ‚Üí mit `catch`\n",
      "\n",
      "---\n",
      "### ‚úÖ Warum Exceptions verwenden?\n",
      "- Dein **Hauptcode bleibt √ºbersichtlich**\n",
      "- Du hast die **Fehlerbehandlung zentral an einem Ort** (z.B. in `main()`)\n",
      "- Lokale Objekte werden bei Fehlern **automatisch gel√∂scht** (Stack-Unwinding)\n",
      "\n",
      "---\n",
      "### üîß Grundstruktur\n",
      "```cpp\ntry {\n  // Problematischer Code, z.B. Funktion, die throw verwendet\n} catch (const std::exception& e) {\n  // Hier behandelst du den Fehler zentral\n}\n```\n",
      "\n",
      "---\n",
      "### üìå Beispiel: Funktion wirft Fehler, `main` f√§ngt ihn\n",
      "```cpp\n#include <iostream>\n#include <stdexcept>\nint teile(int a, int b) {\n  if (b == 0) throw std::runtime_error(\"Division durch 0 nicht erlaubt\");\n  return a / b;\n}\nint main() {\n  try {\n    int x = teile(10, 0);\n    std::cout << \"Ergebnis: \" << x << \"\\n\";\n  } catch (const std::exception& e) {\n    std::cerr << \"Fehler aufgetreten: \" << e.what() << \"\\n\";\n  }\n  return 0;\n}\n```\n",
      "\n",
      "---\n",
      "### üîç Was passiert im `catch`-Block?\n",
      "**Hier kommt dein Plan B.** Du kannst z.B.:\n",
      "- Eine **Fehlermeldung ausgeben** (`std::cerr`)\n",
      "- Das **Programm beenden** (`return` oder `exit`)\n",
      "- **Benutzereingaben nochmal abfragen**\n",
      "- Eine **Ersatzdatei √∂ffnen** oder **Alternativweg** gehen\n",
      "- Etwas **aufr√§umen** (z.B. Speicher, Datei schlie√üen)\n",
      "\n",
      "---\n",
      "### üì¶ H√§ufige Exception-Typen (aus `<stdexcept>`)\n",
      "**`std::logic_error`** (Fehler durch falschen Code):\n",
      "- `std::invalid_argument` - ung√ºltiger Parameter\n",
      "- `std::domain_error` - mathematisch unsinniger Wert\n",
      "- `std::length_error` - Datenstruktur zu gro√ü\n",
      "- `std::out_of_range` - Index zu gro√ü\n",
      "\n",
      "**`std::runtime_error`** (Fehler zur Laufzeit):\n",
      "- `std::overflow_error` - √úberlauf (z.B. Zahl zu gro√ü)\n",
      "- `std::underflow_error` - Unterlauf\n",
      "- `std::range_error` - Bereichsproblem\n",
      "- `std::system_error` - Betriebssystemfehler (Dateien, Threads)\n",
      "- `std::bad_alloc` - kein Speicher verf√ºgbar\n",
      "- `std::bad_cast` - falscher Cast\n",
      "\n",
      "---\n",
      "### üí° Merksatz\n",
      "> `if` erkennt den Fehler, `throw` wirft ihn weiter, `catch` reagiert darauf.\n",
      "\n",
      "---\n",
      "### üéØ Tipp f√ºr deinen Code-Stil\n",
      "- Schreibe **`throw` in deinen Funktionen**, z.B. `throw std::invalid_argument(...)`\n",
      "- Schreibe **`try` und `catch` in `main()`**, um die Fehler an einer Stelle zu behandeln\n",
      "\n",
      "---\n",
      "### üéÅ Bonus: RAII sch√ºtzt vor Speicherlecks\n",
      "- Bei Exceptions werden automatisch **alle lokalen Objekte** gel√∂scht\n",
      "- Aber: **manuell mit `new` erstellte Objekte nicht!**\n",
      "- L√∂sung: Verwende **Smart Pointer** oder RAII-Klassen (z.B. `std::unique_ptr`)\n",
      "---\n"
    ],
    "code": [
  "#include <iostream> // Ein- und Ausgabe\n#include <memory>    // F√ºr smart pointer\n#include <stdexcept>  // F√ºr Exception-Typen\n\nint main() {\n    try {\n        // Speicher dynamisch anfordern, aber mit RAII sicher verwalten\n        std::unique_ptr<int[]> daten(new int[100]);\n\n        // Stell dir vor, hier passiert ein Problem zur Laufzeit\n        throw std::runtime_error(\"Ein Fehler ist aufgetreten!\");\n\n        // Dieser Code wird nie erreicht - w√§re aber sicher\n        std::cout << \"Berechnung abgeschlossen.\" << std::endl;\n\n    } catch (const std::runtime_error& e) {\n        // Exception behandeln und Fehlermeldung anzeigen\n        std::cerr << \"Fehler: \" << e.what() << std::endl;\n    }\n\n    // Programmende, Speicher wurde automatisch durch unique_ptr freigegeben\n    return 0;\n}"
    ]
  }
},
       {
        "title": "Doxygen",
        "content": {
          "text": [
      "### === Doxygen - Automatische Dokumentation f√ºr C++ ===\n",
      "Doxygen ist ein Tool, mit dem man aus speziell kommentiertem C++-Code automatisch eine HTML- oder PDF-Dokumentation erzeugen kann - √§hnlich wie Javadoc bei Java.\n",
      "\n",
      "---\n",
      "### Vorteile von Doxygen:\n",
      "- √úbersichtliche Dokumentation f√ºr gro√üe Projekte\n",
      "- Besseres Verst√§ndnis f√ºr andere Entwickler (oder dich selbst sp√§ter)\n",
      "- Funktioniert direkt aus dem C++-Quellcode\n",
      "\n",
      "---\n",
      "### Grundprinzip:\n",
      "- Man kommentiert Klassen, Funktionen, Variablen mit speziellen `/** ... */`- oder `///`-Bl√∂cken\n",
      "- Doxygen liest diese Kommentare und erzeugt daraus eine strukturierte Dokumentation\n",
      "\n",
      "---\n",
      "### Wichtige Doxygen-Kommentare:\n",
      "- `@brief`: Kurzbeschreibung\n",
      "- `@param`: Beschreibung eines Parameters\n",
      "- `@return`: R√ºckgabewert\n",
      "- `@author`, `@version`, `@date`, ...\n",
      "\n",
      "---\n",
      "### Beispiel f√ºr eine dokumentierte Funktion:\n",
      "```cpp\n/**\n * @brief Addiert zwei Zahlen\n * @param a Erste Zahl\n * @param b Zweite Zahl\n * @return Summe von a und b\n */\nint addiere(int a, int b) {\n    return a + b;\n}\n```\n",
      "\n",
      "---\n",
      "### So benutzt du Doxygen:\n",
      "1. Lade dir Doxygen von https://www.doxygen.nl/download.html herunter\n",
      "2. Starte das Tool (`doxygen -g`) und bearbeite die `Doxyfile`\n",
      "3. F√ºge deinen Projektpfad ein\n",
      "4. F√ºhre Doxygen aus: `doxygen Doxyfile`\n",
      "5. Dokumentation wird im `html/` oder `latex/`-Ordner erstellt\n",
      "\n",
      "---\n",
      "üëâ Doxygen wird besonders im Beruf, in Open-Source-Projekten oder bei Bibliotheken verwendet\n",
      "üëâ Du kannst es auch lokal nutzen, um dein Projekt ordentlich zu strukturieren\n",
      "---\n"
    ],
          "code": []
  }
}

    ]
  }
  
]

