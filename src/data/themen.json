[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          {
          "title": "Namensgebung in C++",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Namensgebung",
              "text": "Namensgebung beschreibt die Regeln und Konventionen zur Benennung von Variablen, Funktionen, Klassen, Typen und anderen Bezeichnern in C++ mit dem Ziel, Code verst√§ndlich, wartbar und eindeutig zu machen."
            },
            {
              "type": "explanation",
              "title": "Warum Namensgebung wichtig ist",
              "text": [
                "C++ erlaubt sehr viele g√ºltige Bezeichner, aber nur ein kleiner Teil davon ist sinnvoll. Der Compiler pr√ºft nur die Syntax, nicht ob ein Name verst√§ndlich ist.",
                "Gute Namen transportieren Bedeutung, reduzieren Kommentare und helfen dabei, Fehler schneller zu erkennen. Schlechte Namen machen selbst korrekten Code schwer wartbar."
              ]
            },
            {
              "type": "list",
              "title": "Allgemeine Regeln f√ºr Bezeichner",
              "items": [
                "Bezeichner bestehen aus Buchstaben, Ziffern und Unterstrichen",
                "Ein Bezeichner darf nicht mit einer Ziffer beginnen",
                "Gro√ü und Kleinschreibung sind relevant",
                "Reservierte Schl√ºsselw√∂rter d√ºrfen nicht verwendet werden"
              ]
            },
            {
              "type": "comparison",
              "title": "Gro√ü und Kleinschreibung",
              "columns": ["Bezeichner", "Bedeutung"],
              "rows": [
                {
                  "aspect": "value vs Value",
                  "values": ["zwei verschiedene Namen", "Gro√üschreibung erzeugt einen anderen Bezeichner"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "√úbliche Namenskonventionen in C++",
              "text": [
                "C++ selbst erzwingt keine Namenskonventionen, aber in der Praxis haben sich feste Muster etabliert, um Code konsistent zu halten.",
                "Welche Konvention genutzt wird, h√§ngt oft vom Projekt, Team oder Styleguide ab, sollte aber innerhalb eines Projekts einheitlich sein."
              ]
            },
            {
              "type": "list",
              "title": "Typische Konventionen",
              "items": [
                "Variablen und Funktionen meist klein geschrieben",
                "Mehrteilige Namen werden oft mit Unterstrichen getrennt",
                "Klassen und Typen beginnen h√§ufig mit einem Gro√übuchstaben",
                "Konstanten werden oft komplett gro√ü geschrieben"
              ]
            },
            {
              "type": "code",
              "title": "Beispiele f√ºr g√ºltige Bezeichner",
              "language": "cpp",
              "code": "int age;\nint user_count;\nvoid calculateSum();\nclass PatientRecord {};\nconst int MAX_SIZE = 100;"
            },
            {
              "type": "example",
              "title": "Gute vs. schlechte Namen",
              "text": [
                "count ist besser als c",
                "calculateAverage ist besser als func1",
                "patient_age ist verst√§ndlicher als pa"
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrdeutige oder nichtssagende Namen",
              "text": "Kurze oder generische Namen wie x, tmp oder data sagen nichts √ºber ihre Bedeutung aus und f√ºhren schnell zu Verst√§ndnisproblemen."
            },
            {
              "type": "important",
              "text": "Ein guter Name erkl√§rt seine Bedeutung ohne zus√§tzlichen Kommentar."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Moderne C++ Projekte legen gro√üen Wert auf sprechende Namen, da Code h√§ufiger gelesen als geschrieben wird."
            },
            {
              "type": "note",
              "variant": "exam",
              "text": "In Pr√ºfungen wird oft erwartet, dass Bezeichner sinnvoll gew√§hlt sind, auch wenn die Syntax korrekt ist."
            },
            {
              "type": "summary",
              "points": [
                "C++ erlaubt viele Namen, aber nicht jeder ist sinnvoll",
                "Gro√ü und Kleinschreibung unterscheidet Bezeichner",
                "Einheitliche Konventionen erh√∂hen Lesbarkeit",
                "Sprechende Namen sind wichtiger als kurze Namen"
              ]
            }
          ]
        },
          {
            "title": "Wichtige Grundbegriffe in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Deklaration",
                "text": "Macht einen Namen und seinen Typ bekannt, ohne ihn zwingend vollst√§ndig festzulegen. (z.B. `int x;`)"
              },
              {
                "type": "definition",
                "term": "Definition",
                "text": "Legt Speicher oder die konkrete Implementierung eines Namens fest. (z.B. `int x = 5;`)"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Vergibt beim Erzeugen einer Variable direkt einen Startwert."
              },
              {
                "type": "definition",
                "term": "Zuweisung",
                "text": "√Ñndert den Wert einer bereits existierenden Variable."
              },
              {
                "type": "definition",
                "term": "Variable",
                "text": "Ein benannter Speicherbereich zur Ablage von Daten."
              },
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Legt fest, welche Art von Wert gespeichert wird und wie viel Speicher ben√∂tigt wird."
              },
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "definition",
                "term": "Funktion",
                "text": "Ein benannter Codeblock, der eine bestimmte Aufgabe ausf√ºhrt."
              },
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Platzhalter in der Funktionsdefinition f√ºr √ºbergebene Werte."
              },
              {
                "type": "definition",
                "term": "Argument",
                "text": "Konkreter Wert, der beim Funktionsaufruf √ºbergeben wird."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Scope",
                "text": "Der G√ºltigkeitsbereich, in dem ein Name verwendet werden darf."
              },
              {
                "type": "definition",
                "term": "Block",
                "text": "Ein zusammengeh√∂riger Codebereich, der durch geschweifte Klammern begrenzt ist."
              },
              {
                "type": "definition",
                "term": "Namespace",
                "text": "Ein Namensraum zur Strukturierung und Vermeidung von Namenskonflikten."
              },
              {
                "type": "definition",
                "term": "Klasse",
                "text": "Ein Bauplan f√ºr Objekte, der Daten und Funktionen zusammenfasst."
              },
              {
                "type": "definition",
                "term": "Objekt",
                "text": "Eine konkrete Instanz einer Klasse."
              },
              {
                "type": "definition",
                "term": "Konstruktor",
                "text": "Spezielle Funktion, die beim Erzeugen eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Destruktor",
                "text": "Spezielle Funktion, die beim Zerst√∂ren eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Header-Datei",
                "text": "Datei, die Deklarationen f√ºr andere √úbersetzungseinheiten bereitstellt."
              },
              {
                "type": "definition",
                "term": "Quell-Datei",
                "text": "Datei, die die eigentlichen Definitionen und Implementierungen enth√§lt."
              },
              {
                "type": "important",
                "text": "Diese Begriffe bilden das Fundament zum Verstehen von C++ Code und Compiler-Fehlern."
              },
              {
                "type": "summary",
                "points": [
                  "Deklaration und Definition sind nicht dasselbe",
                  "Parameter geh√∂ren zur Funktion, Argumente zum Aufruf",
                  "Referenzen und Zeiger arbeiten beide mit bestehenden Objekten",
                  "Klassen definieren Strukturen, Objekte sind ihre Instanzen"
                ]
              }
            ]
          },
          {
            "title": "Datentypen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Ein Datentyp legt fest, welche Art von Wert gespeichert wird und wie dieser interpretiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundlegende Datentypen",
                "text": [
                  "Grundlegende Datentypen sind fest in C++ eingebaut und bilden die Basis aller weiteren Typen.",
                  "Sie unterscheiden sich in Speicherbedarf, Wertebereich und Verwendungszweck."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige grundlegende Datentypen",
                "items": [
                  "int: Ganzzahltyp",
                  "double: Gleitkommazahl",
                  "char: Einzelnes Zeichen",
                  "bool: Wahrheitswert true oder false",
                  "void: Kein Wert"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Datentypen Beispiel",
                "language": "cpp",
                "code": "int a = 5;\ndouble b = 3.14;\nbool ok = true;"
              },
              {
                "type": "definition",
                "term": "size_t",
                "text": "Ein vorzeichenloser Ganzzahltyp zur Darstellung von Gr√∂√üen und Indizes."
              },
              {
                "type": "code",
                "title": "size_t Beispiel",
                "language": "cpp",
                "code": "size_t len = 10;"
              },
              {
                "type": "definition",
                "term": "std::string",
                "text": "Ein Standardtyp zur komfortablen Verarbeitung von Texten."
              },
              {
                "type": "code",
                "title": "std::string Beispiel",
                "language": "cpp",
                "code": "std::string name = \"C++\";"
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert f√ºr einen ung√ºltigen Zeiger."
              },
              {
                "type": "code",
                "title": "nullptr Beispiel",
                "language": "cpp",
                "code": "int* p = nullptr;"
              },
              {
                "type": "definition",
                "term": "auto",
                "text": "L√§sst den Compiler den Datentyp einer Variablen automatisch ableiten."
              },
              {
                "type": "code",
                "title": "auto Beispiel",
                "language": "cpp",
                "code": "auto x = 42;"
              },
              {
                "type": "definition",
                "term": "decltype",
                "text": "Ermittelt den Typ eines Ausdrucks, ohne ihn auszuwerten."
              },
              {
                "type": "code",
                "title": "decltype Beispiel",
                "language": "cpp",
                "code": "int a = 0;\ndecltype(a) b = 1;"
              },
              {
                "type": "definition",
                "term": "struct",
                "text": "Ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer Werte."
              },
              {
                "type": "definition",
                "term": "class",
                "text": "Ein benutzerdefinierter Datentyp mit Kapselung und Zugriffskontrolle."
              },
              {
                "type": "code",
                "title": "struct und class mit Funktionen",
                "language": "cpp",
                "code": "struct Point {\n    int x;\n    int y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n};\n\nclass Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n\n    int get() const {\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "enum",
                "text": "Ein Datentyp mit einer festen Menge benannter Ganzzahlwerte."
              },
              {
                "type": "code",
                "title": "enum Beispiel",
                "language": "cpp",
                "code": "enum Color { Red, Green, Blue };"
              },
              {
                "type": "definition",
                "term": "enum class",
                "text": "Stark typisierte Enumeration mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung zu int."
              },
              {
                "type": "code",
                "title": "enum class Beispiel",
                "language": "cpp",
                "code": "enum class Status { Ok, Error, Unknown };\n\nStatus s = Status::Ok;"
              },
              {
                "type": "definition",
                "term": "typedef",
                "text": "Erstellt einen Aliasnamen f√ºr einen bestehenden Datentyp."
              },
              {
                "type": "definition",
                "term": "using",
                "text": "Moderne Alternative zu typedef f√ºr Typaliasse."
              },
              {
                "type": "code",
                "title": "typedef und using Beispiel",
                "language": "cpp",
                "code": "typedef unsigned int uint;\nusing Index = size_t;"
              },
              {
                "type": "explanation",
                "title": "Typumwandlung in C++",
                "text": [
                  "Typumwandlungen werden verwendet, wenn ein Wert in einem anderen Datentyp weiterverarbeitet werden soll.",
                  "Explizite Casts wie static_cast sind sicherer und besser lesbar als implizite Umwandlungen."
                ]
              },
              {
                "type": "list",
                "title": "G√§ngige Cast-Arten",
                "items": [
                  "static_cast: normale, √ºberpr√ºfbare Umwandlungen",
                  "const_cast: Entfernen oder Hinzuf√ºgen von const",
                  "reinterpret_cast: bitweise Umdeutung, sehr gef√§hrlich",
                  "dynamic_cast: sichere Laufzeitpr√ºfung bei Vererbung"
                ]
              },
              {
                "type": "code",
                "title": "Typumwandlung Beispiel",
                "language": "cpp",
                "code": "double d = 4.9;\nint i = static_cast<int>(d);"
              },
              {
                "type": "important",
                "text": "Datentypen bestimmen Speicher, Verhalten und Sicherheit von C++ Programmen."
              },
              {
                "type": "summary",
                "points": [
                  "Grundlegende Typen bilden die Basis aller Programme",
                  "size_t, string und nullptr sind zentrale Standardtypen",
                  "auto und decltype vereinfachen typsicheren Code",
                  "struct, class und enum erlauben eigene Datentypen",
                  "using ersetzt typedef in modernem C++"
                ]
              }
            ]
          },
          {
            "title": "I/O Grundprinzipien in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "I/O",
                "text": "Input und Output bezeichnen das Einlesen von Daten in ein Programm und das Ausgeben von Daten nach au√üen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Ein und Ausgabe",
                "text": [
                  "C++ arbeitet bei Ein und Ausgabe mit sogenannten Streams. Ein Stream ist eine Abfolge von Zeichen oder Daten.",
                  "Programme lesen Daten aus einem Eingabestrom und schreiben Daten in einen Ausgabestrom."
                ]
              },
              {
                "type": "definition",
                "term": "Stream",
                "text": "Ein abstrakter Datenstrom, der Zeichen sequenziell transportiert."
              },
              {
                "type": "definition",
                "term": "Standard Input",
                "text": "Der voreingestellte Eingabestrom, meist die Tastatur."
              },
              {
                "type": "definition",
                "term": "Standard Output",
                "text": "Der voreingestellte Ausgabestrom, meist die Konsole."
              },
              {
                "type": "definition",
                "term": "Standard Error",
                "text": "Separater Ausgabestrom f√ºr Fehlermeldungen."
              },
              {
                "type": "list",
                "title": "Wichtige Standard-Streams",
                "items": [
                  "std::cin: Standardeingabe",
                  "std::cout: Standardausgabe",
                  "std::cerr: Fehlerausgabe",
                  "std::clog: Protokollausgabe"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe mit cout",
                "language": "cpp",
                "code": "std::cout << \"Hallo Welt\" << std::endl;"
              },
              {
                "type": "code",
                "title": "Einfache Eingabe mit cin",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;"
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Schreibt Daten in einen Ausgabestrom."
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Liest Daten aus einem Eingabestrom."
              },
              {
                "type": "explanation",
                "title": "Verkettung von Streams",
                "text": [
                  "Einf√ºge und Extraktionsoperatoren k√∂nnen verkettet werden.",
                  "Dadurch lassen sich mehrere Werte in einer Anweisung ein oder ausgeben."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Ein und Ausgabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b;\nstd::cout << a << \" \" << b;"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Zwischenspeicherung von Ausgaben, bevor sie tats√§chlich geschrieben werden."
              },
              {
                "type": "definition",
                "term": "Flush",
                "text": "Erzwingt das sofortige Schreiben des Ausgabepuffers."
              },
              {
                "type": "code",
                "title": "Flush Beispiel",
                "language": "cpp",
                "code": "std::cout << \"Text\" << std::flush;"
              },
              {
                "type": "pitfall",
                "title": "Eingabe ohne Pr√ºfung",
                "text": "Fehlerhafte Eingaben k√∂nnen Streams in einen Fehlerzustand versetzen und weitere Eingaben verhindern."
              },
              {
                "type": "important",
                "text": "I/O in C++ basiert auf Streams und Operatoren, nicht auf direkten Ger√§tezugriffen."
              },
              {
                "type": "summary",
                "points": [
                  "Ein und Ausgabe erfolgt √ºber Streams",
                  "cin, cout und cerr sind zentrale Standard-Streams",
                  "<< schreibt, >> liest",
                  "Streams k√∂nnen verkettet werden",
                  "Pufferung beeinflusst, wann Ausgaben sichtbar werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          {
            "title": "Arithmetische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Arithmetischer Operator",
                "text": "Ein Operator zur Durchf√ºhrung mathematischer Berechnungen auf numerischen Datentypen."
              },
              {
                "type": "list",
                "title": "Grundlegende arithmetische Operatoren",
                "items": [
                  "+: Addition",
                  "-: Subtraktion",
                  "*: Multiplikation",
                  "/: Division",
                  "%: Modulo Restbildung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Operatoren Beispiel",
                "language": "cpp",
                "code": "int a = 10;\nint b = 3;\nint sum = a + b;\nint diff = a - b;\nint prod = a * b;\nint quot = a / b;\nint rest = a % b;"
              },
              {
                "type": "definition",
                "term": "Ganzzahldivision",
                "text": "Division zweier Ganzzahlen, bei der der Nachkommateil verworfen wird."
              },
              {
                "type": "code",
                "title": "Ganzzahldivision Beispiel",
                "language": "cpp",
                "code": "int x = 7 / 2;"
              },
              {
                "type": "definition",
                "term": "Modulo",
                "text": "Berechnet den Rest einer Ganzzahldivision."
              },
              {
                "type": "explanation",
                "title": "Inkrement und Dekrement",
                "text": [
                  "Inkrement und Dekrement erh√∂hen oder verringern einen Wert um eins.",
                  "Es wird zwischen Pr√§fix und Postfix unterschieden."
                ]
              },
              {
                "type": "list",
                "title": "Inkrement und Dekrement Operatoren",
                "items": [
                  "++x: Pr√§fix Inkrement",
                  "x++: Postfix Inkrement",
                  "--x: Pr√§fix Dekrement",
                  "x--: Postfix Dekrement"
                ]
              },
              {
                "type": "code",
                "title": "Inkrement und Dekrement Beispiel",
                "language": "cpp",
                "code": "int i = 5;\nint a = ++i;\nint b = i++;"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Legt fest, in welcher Reihenfolge Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Operatorpriorit√§t und Klammern",
                "text": [
                  "Multiplikation und Division werden vor Addition und Subtraktion ausgewertet.",
                  "Klammern k√∂nnen verwendet werden, um die Auswertungsreihenfolge explizit festzulegen."
                ]
              },
              {
                "type": "code",
                "title": "Operatorpriorit√§t Beispiel",
                "language": "cpp",
                "code": "int r1 = 2 + 3 * 4;\nint r2 = (2 + 3) * 4;"
              },
              {
                "type": "pitfall",
                "title": "Unerwartete Ganzzahldivision",
                "text": "Division mit int liefert kein Kommaergebnis, auch wenn das mathematisch erwartet wird."
              },
              {
                "type": "important",
                "text": "Der Datentyp der Operanden beeinflusst das Ergebnis arithmetischer Operationen."
              },
              {
                "type": "summary",
                "points": [
                  "Arithmetische Operatoren f√ºhren grundlegende Berechnungen aus",
                  "Ganzzahldivision verwirft den Nachkommateil",
                  "Modulo liefert den Divisionsrest",
                  "Inkrement und Dekrement unterscheiden Pr√§fix und Postfix",
                  "Klammern steuern die Auswertungsreihenfolge"
                ]
              }
            ]
          },
          {
            "title": "Vergleichsoperatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Vergleichsoperator",
                "text": "Ein Operator, der zwei Werte vergleicht und einen booleschen Wert zur√ºckliefert."
              },
              {
                "type": "list",
                "title": "Grundlegende Vergleichsoperatoren",
                "items": [
                  "==: gleich",
                  "!=: ungleich",
                  "<: kleiner als",
                  ">: gr√∂√üer als",
                  "<=: kleiner oder gleich",
                  ">=: gr√∂√üer oder gleich"
                ]
              },
              {
                "type": "code",
                "title": "Vergleichsoperatoren Beispiel",
                "language": "cpp",
                "code": "int a = 5;\nint b = 7;\nbool r1 = (a == b);\nbool r2 = (a < b);"
              },
              {
                "type": "definition",
                "term": "bool",
                "text": "Ein Datentyp mit den m√∂glichen Werten true oder false."
              },
              {
                "type": "explanation",
                "title": "Vergleiche in Bedingungen",
                "text": [
                  "Vergleichsoperatoren werden h√§ufig in if Anweisungen und Schleifen verwendet.",
                  "Das Ergebnis entscheidet √ºber den weiteren Programmfluss."
                ]
              },
              {
                "type": "code",
                "title": "Vergleich in einer Bedingung",
                "language": "cpp",
                "code": "if (a >= 0)\n{\n    std::cout << \"positiv\";\n}"
              },
              {
                "type": "definition",
                "term": "Vergleich von Gleitkommazahlen",
                "text": "Der direkte Vergleich von Gleitkommazahlen kann wegen Rundungsfehlern problematisch sein."
              },
              {
                "type": "pitfall",
                "title": "== statt =",
                "text": "Das Verwechseln von Zuweisung und Vergleich f√ºhrt zu logischen Fehlern."
              },
              {
                "type": "important",
                "text": "Vergleichsoperatoren liefern immer einen booleschen Wert."
              },
              {
                "type": "summary",
                "points": [
                  "Vergleichsoperatoren pr√ºfen Beziehungen zwischen Werten",
                  "Das Ergebnis ist immer true oder false",
                  "Sie steuern Bedingungen und Schleifen",
                  "Besondere Vorsicht bei Gleitkommazahlen"
                ]
              }
            ]
          },
          {
            "title": "Logische Operatoren in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Logischer Operator",
                "text": "Ein Operator zur logischen Verkn√ºpfung oder Negation boolescher Ausdr√ºcke."
              },
              {
                "type": "list",
                "title": "Grundlegende logische Operatoren",
                "items": [
                  "&&: logisches UND",
                  "||: logisches ODER",
                  "!: logisches NICHT"
                ]
              },
              {
                "type": "code",
                "title": "Logische Operatoren Beispiel",
                "language": "cpp",
                "code": "bool a = true;\nbool b = false;\nbool r1 = a && b;\nbool r2 = a || b;\nbool r3 = !a;"
              },
              {
                "type": "definition",
                "term": "Kurzschlussauswertung",
                "text": "Der zweite Operand wird nur ausgewertet, wenn das Ergebnis noch beeinflusst werden kann."
              },
              {
                "type": "explanation",
                "title": "Kurzschlussverhalten",
                "text": [
                  "Bei && wird der zweite Ausdruck nur gepr√ºft, wenn der erste true ist.",
                  "Bei || wird der zweite Ausdruck nur gepr√ºft, wenn der erste false ist."
                ]
              },
              {
                "type": "code",
                "title": "Kurzschluss Beispiel",
                "language": "cpp",
                "code": "if (ptr != nullptr && ptr->value > 0)\n{\n}"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Bestimmt die Reihenfolge, in der logische Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Priorit√§t und Klammern",
                "text": [
                  "! wird vor && ausgewertet.",
                  "&& wird vor || ausgewertet. Klammern erh√∂hen die Lesbarkeit."
                ]
              },
              {
                "type": "code",
                "title": "Priorit√§t Beispiel",
                "language": "cpp",
                "code": "bool r = !a || b && a;\nbool r2 = (!a || b) && a;"
              },
              {
                "type": "pitfall",
                "title": "Bitweise mit logischen Operatoren verwechseln",
                "text": "& und | sind bitweise Operatoren und nicht gleichbedeutend mit && und ||."
              },
              {
                "type": "important",
                "text": "Logische Operatoren arbeiten mit booleschen Ausdr√ºcken und nutzen Kurzschlussauswertung."
              },
              {
                "type": "summary",
                "points": [
                  "&&, || und ! verkn√ºpfen boolesche Ausdr√ºcke",
                  "Kurzschlussauswertung verhindert unn√∂tige Auswertungen",
                  "Operatorpriorit√§t beachten oder Klammern setzen",
                  "Nicht mit bitweisen Operatoren verwechseln"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          {
            "title": "const Variablen in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const",
                "text": "const kennzeichnet Werte oder Objekte, die nach ihrer Initialisierung nicht mehr ver√§ndert werden d√ºrfen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const",
                "text": [
                  "const dient dazu, unbeabsichtigte √Ñnderungen zu verhindern und Code verst√§ndlicher zu machen.",
                  "Der Compiler erzwingt die Unver√§nderlichkeit zur √úbersetzungszeit."
                ]
              },
              {
                "type": "code",
                "title": "const Variable",
                "language": "cpp",
                "code": "const int maxValue = 10;"
              },
              {
                "type": "definition",
                "term": "const Initialisierung",
                "text": "const Variablen m√ºssen beim Erzeugen initialisiert werden."
              },
              {
                "type": "pitfall",
                "title": "Fehlende Initialisierung",
                "text": "const Variablen ohne Initialisierung f√ºhren zu Compilerfehlern."
              },
              {
                "type": "definition",
                "term": "const Referenz",
                "text": "Eine Referenz, √ºber die das referenzierte Objekt nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenz Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nconst int& r = x;"
              },
              {
                "type": "definition",
                "term": "const Zeiger",
                "text": "Je nach Position von const kann der Zeiger selbst oder das Ziel unver√§nderlich sein."
              },
              {
                "type": "code",
                "title": "const und Zeiger",
                "language": "cpp",
                "code": "int x = 1;\nconst int* p1 = &x; // Zeiger auf konstante Daten\nint* const p2 = &x; // Konstanter Zeiger auf Daten\nconst int* const p3 = &x; // Beides konstant"
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die den Zustand des Objekts nicht ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "const Memberfunktion Beispiel",
                "language": "cpp",
                "code": "class A {\n    int v;\npublic:\n    int get() const { return v; }\n};"
              },
              {
                "type": "important",
                "text": "const ist ein zentrales Werkzeug f√ºr sicheren und gut wartbaren C++ Code."
              },
              {
                "type": "summary",
                "points": [
                  "const verhindert unbeabsichtigte √Ñnderungen",
                  "const Variablen m√ºssen initialisiert werden",
                  "const kann auf Objekte, Referenzen, Zeiger und Funktionen angewendet werden",
                  "const Memberfunktionen garantieren unver√§nderten Objektzustand"
                ]
              }
            ]
          },
          {
            "title": "const Parameter in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Parameter",
                "text": "Ein Funktionsparameter, der innerhalb der Funktion nicht ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Warum const Parameter verwenden",
                "text": [
                  "const Parameter verhindern unbeabsichtigte √Ñnderungen an √ºbergebenen Werten.",
                  "Sie machen Funktionsschnittstellen klarer und sicherer, besonders bei Referenzen und Zeigern."
                ]
              },
              {
                "type": "code",
                "title": "const Wertparameter",
                "language": "cpp",
                "code": "void print(const int x)\n{\n    // x darf hier nicht ver√§ndert werden\n    // x = 5; // Compilerfehler\n}"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Parameter, der per Referenz √ºbergeben wird, aber nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter Beispiel",
                "language": "cpp",
                "code": "void print(const std::string& text)\n{\n    // text wird nicht kopiert\n    // text.clear(); // Compilerfehler\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Vorteile von const Referenzen",
                "text": [
                  "Vermeidet unn√∂tige Kopien gro√üer Objekte.",
                  "Garantiert, dass die Funktion das Objekt nicht ver√§ndert."
                ]
              },
              {
                "type": "definition",
                "term": "const Zeigerparameter",
                "text": "Bei Zeigerparametern kann entweder das Ziel oder der Zeiger selbst als const markiert werden."
              },
              {
                "type": "code",
                "title": "const Zeigerparameter Beispiel",
                "language": "cpp",
                "code": "void read(const int* ptr)\n{\n    // *ptr darf nicht ver√§ndert werden\n    // *ptr = 10; // Compilerfehler\n}\n\nvoid move(int* const ptr)\n{\n    // ptr darf nicht neu gesetzt werden\n    // ptr = nullptr; // Compilerfehler\n}"
              },
              {
                "type": "pitfall",
                "title": "const vergessen",
                "text": "Fehlendes const bei Parametern kann unn√∂tige Einschr√§nkungen f√ºr Aufrufer verursachen."
              },
              {
                "type": "important",
                "text": "const Parameter sind ein Versprechen der Funktion an den Aufrufer."
              },
              {
                "type": "summary",
                "points": [
                  "const Parameter verhindern √Ñnderungen innerhalb der Funktion",
                  "const Referenzen sind effizient und sicher",
                  "Bei Zeigern bestimmt die Position von const die Bedeutung",
                  "const verbessert Lesbarkeit und API Design"
                ]
              }
            ]
          },
          {
            "title": "const Klassenmember in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Klassenmember",
                "text": "Ein Datenmember einer Klasse, dessen Wert nach der Initialisierung nicht mehr ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const Membern",
                "text": [
                  "const Member repr√§sentieren feste Eigenschaften eines Objekts, die sich w√§hrend der Lebensdauer nicht √§ndern sollen.",
                  "Der Compiler erzwingt, dass diese Member nicht neu zugewiesen werden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierungsliste",
                "text": "Mechanismus zum Initialisieren von Klassenmembern beim Erzeugen eines Objekts."
              },
              {
                "type": "code",
                "title": "const Member und Initialisierungsliste",
                "language": "cpp",
                "code": "class User {\nprivate:\n    const int id; // darf nach Konstruktion nicht ge√§ndert werden\n\npublic:\n    User(int idValue) : id(idValue) {}\n\n    int getId() const {\n        return id; // Lesen erlaubt\n    }\n};"
              },
              {
                "type": "pitfall",
                "title": "Zuweisung im Konstruktor",
                "text": "const Member k√∂nnen nicht im Konstruktorrumpf zugewiesen werden, sondern nur in der Initialisierungsliste."
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die garantiert, dass sie keine nicht-const Member ver√§ndert."
              },
              {
                "type": "code",
                "title": "const Memberfunktion und Zugriff",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    int get() const {\n        // value++;\n        // nicht erlaubt, da Funktion const ist\n        return value;\n    }\n\n    void increment() {\n        value++; // erlaubt, Funktion ist nicht const\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Zusammenspiel von const Membern und Funktionen",
                "text": [
                  "const Memberfunktionen d√ºrfen nur const Member oder lesenden Zugriff verwenden.",
                  "Nicht-const Memberfunktionen d√ºrfen alle Member ver√§ndern."
                ]
              },
              {
                "type": "important",
                "text": "const Member m√ºssen immer √ºber die Initialisierungsliste gesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "const Klassenmember sind nach der Konstruktion unver√§nderlich",
                  "Sie m√ºssen in der Initialisierungsliste gesetzt werden",
                  "const Memberfunktionen d√ºrfen den Objektzustand nicht √§ndern",
                  "const verbessert Korrektheit und Objektmodellierung"
                ]
              }
            ]
          },
          {
            "title": "const √úberladung in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const √úberladung",
                "text": "Eine Form der Funktions√ºberladung, bei der sich Funktionen nur durch const unterscheiden."
              },
              {
                "type": "explanation",
                "title": "Grundidee der const √úberladung",
                "text": [
                  "const √úberladung wird fast ausschlie√ülich bei Memberfunktionen verwendet.",
                  "Je nach const Zustand des Objekts wird eine andere Funktionsversion aufgerufen."
                ]
              },
              {
                "type": "definition",
                "term": "const Objekt",
                "text": "Ein Objekt, das als const deklariert wurde und nur const Memberfunktionen aufrufen darf."
              },
              {
                "type": "code",
                "title": "const √úberladung bei Memberfunktionen",
                "language": "cpp",
                "code": "class Box {\nprivate:\n    int value;\n\npublic:\n    Box(int v) : value(v) {}\n\n    int& get() {\n        // wird bei nicht-const Objekten aufgerufen\n        return value;\n    }\n\n    const int& get() const {\n        // wird bei const Objekten aufgerufen\n        return value;\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Bei einem nicht-const Objekt wird die nicht-const Version bevorzugt.",
                  "Bei einem const Objekt ist nur die const Version erlaubt."
                ]
              },
              {
                "type": "code",
                "title": "Aufruf der √ºberladenen Funktionen",
                "language": "cpp",
                "code": "Box b(5);\nb.get() = 10; // erlaubt, nicht-const Version\n\nconst Box cb(7);\nint x = cb.get(); // nur const Version m√∂glich"
              },
              {
                "type": "pitfall",
                "title": "Fehlende const Version",
                "text": "Ohne const √ºberladene Memberfunktion k√∂nnen const Objekte wichtige Funktionen nicht nutzen."
              },
              {
                "type": "important",
                "text": "const √úberladung erh√∂ht Korrektheit und Flexibilit√§t von Klassen."
              },
              {
                "type": "summary",
                "points": [
                  "const √úberladung unterscheidet Funktionen nach const",
                  "Sie wird haupts√§chlich bei Memberfunktionen eingesetzt",
                  "const Objekte d√ºrfen nur const Funktionen aufrufen",
                  "Nicht-const Objekte nutzen bevorzugt nicht-const Versionen"
                ]
              }
            ]
          },
          {
            "title": "constexpr in C++",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "constexpr",
                "text": "constexpr kennzeichnet Ausdr√ºcke, Variablen oder Funktionen, die zur Compilezeit ausgewertet werden k√∂nnen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von constexpr",
                "text": [
                  "constexpr erm√∂glicht es, Berechnungen bereits zur Compilezeit durchzuf√ºhren.",
                  "Dadurch werden Programme effizienter und sicherer, da Fehler fr√ºher erkannt werden."
                ]
              },
              {
                "type": "definition",
                "term": "constexpr Variable",
                "text": "Eine Variable, deren Wert zur Compilezeit bekannt sein muss."
              },
              {
                "type": "code",
                "title": "constexpr Variable Beispiel",
                "language": "cpp",
                "code": "constexpr int maxSize = 100; // Wert ist zur Compilezeit festgelegt"
              },
              {
                "type": "definition",
                "term": "constexpr Funktion",
                "text": "Eine Funktion, die bei konstanten Argumenten zur Compilezeit ausgewertet werden kann."
              },
              {
                "type": "code",
                "title": "constexpr Funktion Beispiel",
                "language": "cpp",
                "code": "constexpr int square(int x)\n{\n    return x * x;\n}\n\nconstexpr int value = square(5); // Compilezeit"
              },
              {
                "type": "explanation",
                "title": "Compilezeit vs. Laufzeit",
                "text": [
                  "constexpr Funktionen k√∂nnen sowohl zur Compilezeit als auch zur Laufzeit ausgef√ºhrt werden.",
                  "Ob Compilezeit oder Laufzeit entscheidet der Kontext der Verwendung."
                ]
              },
              {
                "type": "code",
                "title": "constexpr zur Laufzeit",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;\nint y = square(x); // Laufzeit, da x nicht konstant ist"
              },
              {
                "type": "comparison",
                "title": "const vs. constexpr",
                "columns": ["const", "constexpr"],
                "rows": [
                  {
                    "aspect": "Zeitpunkt der Auswertung",
                    "values": ["Laufzeit oder Compilezeit", "Immer Compilezeit m√∂glich"]
                  },
                  {
                    "aspect": "Einsatz",
                    "values": ["Unver√§nderlichkeit", "Konstante Ausdr√ºcke"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "constexpr mit nicht-konstanten Werten",
                "text": "constexpr erfordert zur Compilezeit bekannte Werte, sonst schl√§gt die √úbersetzung fehl."
              },
              {
                "type": "important",
                "text": "constexpr ist st√§rker als const und erm√∂glicht echte Compilezeit-Berechnungen."
              },
              {
                "type": "summary",
                "points": [
                  "constexpr erzwingt Compilezeit-Auswertbarkeit",
                  "constexpr Variablen sind echte Konstanten",
                  "constexpr Funktionen k√∂nnen auch zur Laufzeit genutzt werden",
                  "constexpr erh√∂ht Effizienz und Typsicherheit"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          {
            "title": "std::cout",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cout",
                "text": "std::cout ist der Standard-Ausgabestream in C++ zur Ausgabe von Text und Werten auf die Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cout",
                "text": [
                  "std::cout schreibt Daten in den Standard-Output, der in der Regel das Terminal ist.",
                  "Die Ausgabe erfolgt √ºber den Einf√ºgeoperator << und kann verkettet werden."
                ]
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Operator, mit dem Werte in einen Ausgabestream geschrieben werden."
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe",
                "language": "cpp",
                "code": "int x = 5;\nstd::cout << x; // gibt 5 auf der Konsole aus"
              },
              {
                "type": "explanation",
                "title": "Verkettete Ausgabe",
                "text": [
                  "Mehrere Werte k√∂nnen hintereinander ausgegeben werden.",
                  "Die Operatoren werden von links nach rechts ausgewertet."
                ]
              },
              {
                "type": "code",
                "title": "Verkettung mit Text",
                "language": "cpp",
                "code": "int a = 3;\nint b = 4;\nstd::cout << \"a = \" << a << \", b = \" << b; // kombinierte Ausgabe"
              },
              {
                "type": "definition",
                "term": "std::endl",
                "text": "Gibt einen Zeilenumbruch aus und leert zus√§tzlich den Ausgabepuffer."
              },
              {
                "type": "code",
                "title": "Zeilenumbruch",
                "language": "cpp",
                "code": "std::cout << \"Hallo\" << std::endl; // neue Zeile und flush"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Ausgaben werden zwischengespeichert und nicht sofort angezeigt."
              },
              {
                "type": "comparison",
                "title": "std::endl vs. '\\n'",
                "columns": ["std::endl", "\\n"],
                "rows": [
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Ja", "Ja"]
                  },
                  {
                    "aspect": "Flush",
                    "values": ["Ja", "Nein"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Unn√∂tiger Einsatz von std::endl",
                "text": "H√§ufiges std::endl kann Programme deutlich verlangsamen, da jedes Mal geflusht wird."
              },
              {
                "type": "important",
                "text": "std::cout ist ein gepufferter Stream und arbeitet mit dem Operator <<."
              },
              {
                "type": "summary",
                "points": [
                  "std::cout dient zur Standardausgabe",
                  "Ausgabe erfolgt mit dem Operator <<",
                  "Mehrere Ausgaben k√∂nnen verkettet werden",
                  "std::endl erzeugt Zeilenumbruch und Flush",
                  "\\n ist meist effizienter als std::endl"
                ]
              }
            ]
          },
          {
            "title": "std::cin",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cin",
                "text": "std::cin ist der Standard-Eingabestream in C++ zum Einlesen von Daten aus der Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cin",
                "text": [
                  "std::cin liest Daten aus dem Standard-Input, meist der Tastatur.",
                  "Das Einlesen erfolgt mit dem Extraktionsoperator >> und ist typabh√§ngig."
                ]
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Operator, mit dem Werte aus einem Eingabestream gelesen werden."
              },
              {
                "type": "code",
                "title": "Einfache Eingabe",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x; // liest eine Ganzzahl von der Konsole"
              },
              {
                "type": "explanation",
                "title": "Mehrere Werte einlesen",
                "text": [
                  "Mehrere Eingaben k√∂nnen in einer Anweisung verkettet werden.",
                  "Die Werte werden in der angegebenen Reihenfolge gelesen."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Eingabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b; // liest zwei Ganzzahlen"
              },
              {
                "type": "definition",
                "term": "Whitespace-Verhalten",
                "text": "std::cin √ºberspringt f√ºhrende Leerzeichen, Tabs und Zeilenumbr√ºche."
              },
              {
                "type": "code",
                "title": "Eingabe von Text",
                "language": "cpp",
                "code": "std::string name;\nstd::cin >> name; // liest bis zum n√§chsten Leerzeichen"
              },
              {
                "type": "definition",
                "term": "Stream-Zustand",
                "text": "Interner Status eines Streams, der angibt, ob die letzte Eingabe erfolgreich war."
              },
              {
                "type": "code",
                "title": "Eingabe pr√ºfen",
                "language": "cpp",
                "code": "int value;\nif (std::cin >> value) {\n    // Eingabe war erfolgreich\n}"
              },
              {
                "type": "pitfall",
                "title": "Fehlerhafte Eingaben",
                "text": "Ung√ºltige Eingaben setzen den Stream in einen Fehlerzustand und blockieren weitere Lesevorg√§nge."
              },
              {
                "type": "important",
                "text": "std::cin ist typabh√§ngig und nutzt den Operator >> zum Einlesen."
              },
              {
                "type": "summary",
                "points": [
                  "std::cin liest Daten von der Konsole",
                  "Eingabe erfolgt mit dem Operator >>",
                  "Whitespace wird automatisch √ºbersprungen",
                  "Der Stream-Zustand sollte gepr√ºft werden",
                  "Ung√ºltige Eingaben k√∂nnen weitere Eingaben verhindern"
                ]
              }
            ]
          },
          {
            "title": "std::getline",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::getline",
                "text": "std::getline liest eine komplette Zeile aus einem Eingabestream bis zum Zeilenumbruch."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::getline",
                "text": [
                  "std::getline eignet sich zum Einlesen von Texten mit Leerzeichen.",
                  "Der Zeilenumbruch wird gelesen, aber nicht im Ergebnis gespeichert."
                ]
              },
              {
                "type": "definition",
                "term": "Zeilenweises Einlesen",
                "text": "Einleseform, bei der der gesamte Inhalt bis zum Zeilenende √ºbernommen wird."
              },
              {
                "type": "code",
                "title": "Einfache Verwendung von std::getline",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(std::cin, line); // liest eine komplette Zeile"
              },
              {
                "type": "explanation",
                "title": "Unterschied zu std::cin >>",
                "text": [
                  "std::cin >> liest nur bis zum n√§chsten Leerzeichen.",
                  "std::getline liest die gesamte Zeile inklusive Leerzeichen."
                ]
              },
              {
                "type": "comparison",
                "title": "std::getline vs. std::cin >>",
                "columns": ["std::getline", "std::cin >>"],
                "rows": [
                  {
                    "aspect": "Leerzeichen",
                    "values": ["Werden mitgelesen", "Beenden die Eingabe"]
                  },
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Beendet das Lesen", "Wird √ºbersprungen"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "std::getline nach std::cin >>",
                "text": "Nach einer >> Eingabe bleibt der Zeilenumbruch im Stream und wird von getline sofort gelesen."
              },
              {
                "type": "code",
                "title": "Korrekte Kombination von cin und getline",
                "language": "cpp",
                "code": "int age;\nstd::cin >> age;\nstd::cin.ignore(); // entfernt den Zeilenumbruch\n\nstd::string name;\nstd::getline(std::cin, name); // liest den Namen korrekt"
              },
              {
                "type": "important",
                "text": "std::getline ist die richtige Wahl f√ºr ganze Textzeilen."
              },
              {
                "type": "summary",
                "points": [
                  "std::getline liest komplette Zeilen",
                  "Leerzeichen sind Teil der Eingabe",
                  "Unterschiedliches Verhalten zu std::cin >>",
                  "Nach >> muss oft ignore verwendet werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          {
            "title": "std::ifstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ifstream",
                "text": "std::ifstream ist ein Eingabestream zum Lesen von Daten aus Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ifstream",
                "text": [
                  "std::ifstream funktioniert √§hnlich wie std::cin, liest seine Daten aber aus einer Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Input verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Dateistream",
                "text": "Ein Stream, der Daten aus einer Datei liest oder in eine Datei schreibt."
              },
              {
                "type": "code",
                "title": "Datei √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ifstream file(\"data.txt\"); // √∂ffnet Datei zum Lesen"
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "√ñffnen pr√ºfen",
                "language": "cpp",
                "code": "std::ifstream file(\"data.txt\");\nif (!file) {\n    // Datei konnte nicht ge√∂ffnet werden\n}"
              },
              {
                "type": "explanation",
                "title": "Lesen aus einer Datei",
                "text": [
                  "Das Lesen aus ifstream erfolgt mit denselben Operatoren wie bei std::cin.",
                  "Auch std::getline kann f√ºr zeilenweises Lesen verwendet werden."
                ]
              },
              {
                "type": "code",
                "title": "Lesen mit >>",
                "language": "cpp",
                "code": "int x;\nfile >> x; // liest eine Ganzzahl aus der Datei"
              },
              {
                "type": "code",
                "title": "Zeilenweise lesen",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(file, line); // liest eine Zeile aus der Datei"
              },
              {
                "type": "definition",
                "term": "End of File",
                "text": "Zustand, der erreicht wird, wenn keine weiteren Daten in der Datei vorhanden sind."
              },
              {
                "type": "code",
                "title": "Lesen bis Dateiende",
                "language": "cpp",
                "code": "std::string line;\nwhile (std::getline(file, line)) {\n    // verarbeitet jede Zeile der Datei\n}"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der √ñffnungszustand nicht gepr√ºft, kann es zu undefiniertem Programmverhalten kommen."
              },
              {
                "type": "important",
                "text": "std::ifstream sollte immer auf erfolgreiches √ñffnen gepr√ºft werden."
              },
              {
                "type": "summary",
                "points": [
                  "std::ifstream liest Daten aus Dateien",
                  "Er wird √ºber <fstream> eingebunden",
                  "Lesen erfolgt wie bei std::cin",
                  "std::getline eignet sich f√ºr zeilenweises Lesen",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::ofstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ofstream",
                "text": "std::ofstream ist ein Ausgabestream zum Schreiben von Daten in Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ofstream",
                "text": [
                  "std::ofstream funktioniert √§hnlich wie std::cout, schreibt seine Ausgabe aber in eine Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Output verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei zum Schreiben mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "Datei zum Schreiben √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ofstream file(\"output.txt\"); // erstellt oder √ºberschreibt die Datei"
              },
              {
                "type": "definition",
                "term": "√úberschreiben",
                "text": "Standardverhalten von ofstream, bei dem vorhandene Dateiinhalte gel√∂scht werden."
              },
              {
                "type": "definition",
                "term": "Anh√§ngen",
                "text": "Schreiben neuer Daten ans Ende einer bestehenden Datei."
              },
              {
                "type": "code",
                "title": "Dateiinhalt anh√§ngen",
                "language": "cpp",
                "code": "std::ofstream file(\"output.txt\", std::ios::app); // schreibt ans Dateiende"
              },
              {
                "type": "explanation",
                "title": "Schreiben in eine Datei",
                "text": [
                  "Das Schreiben erfolgt mit dem Einf√ºgeoperator << wie bei std::cout.",
                  "Es k√∂nnen beliebige ausgabef√§hige Datentypen geschrieben werden."
                ]
              },
              {
                "type": "code",
                "title": "Schreiben mit <<",
                "language": "cpp",
                "code": "file << \"Ergebnis: \" << 42 << '\\n'; // schreibt Text und Zahl in die Datei"
              },
              {
                "type": "definition",
                "term": "Datei schlie√üen",
                "text": "Beendet die Verbindung zwischen Stream und Datei und schreibt den Puffer."
              },
              {
                "type": "code",
                "title": "Datei schlie√üen",
                "language": "cpp",
                "code": "file.close(); // optional, erfolgt auch automatisch"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der Stream nicht gepr√ºft, kann das Schreiben fehlschlagen, ohne dass es bemerkt wird."
              },
              {
                "type": "important",
                "text": "std::ofstream √ºberschreibt Dateien standardm√§√üig, wenn kein Modus angegeben wird."
              },
              {
                "type": "summary",
                "points": [
                  "std::ofstream schreibt Daten in Dateien",
                  "Standardm√§√üig wird die Datei √ºberschrieben",
                  "Anh√§ngen erfolgt mit std::ios::app",
                  "Schreiben erfolgt mit dem Operator <<",
                  "Streams sollten auf Fehler gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::fstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::fstream",
                "text": "std::fstream ist ein Dateistream, der sowohl Lesen als auch Schreiben in einer Datei erlaubt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::fstream",
                "text": [
                  "std::fstream kombiniert die Funktionalit√§t von std::ifstream und std::ofstream.",
                  "Er wird verwendet, wenn eine Datei sowohl gelesen als auch beschrieben werden soll."
                ]
              },
              {
                "type": "definition",
                "term": "√ñffnungsmodus",
                "text": "Ein Modus, der festlegt, wie eine Datei ge√∂ffnet wird, zum Beispiel zum Lesen oder Schreiben."
              },
              {
                "type": "list",
                "title": "H√§ufige √ñffnungsmodi",
                "items": [
                  "std::ios::in: Datei lesen",
                  "std::ios::out: Datei schreiben",
                  "std::ios::app: ans Dateiende schreiben",
                  "std::ios::trunc: Dateiinhalt l√∂schen",
                  "std::ios::binary: Bin√§rmodus"
                ]
              },
              {
                "type": "code",
                "title": "Datei mit fstream √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::fstream file(\"data.txt\", std::ios::in | std::ios::out);"
              },
              {
                "type": "definition",
                "term": "Lese- und Schreibzugriff",
                "text": "Die M√∂glichkeit, Daten aus derselben Datei zu lesen und in sie zu schreiben."
              },
              {
                "type": "code",
                "title": "Lesen und Schreiben",
                "language": "cpp",
                "code": "int x;\nfile >> x;          // liest aus der Datei\nfile << x * 2;      // schreibt in die Datei"
              },
              {
                "type": "definition",
                "term": "Dateiposition",
                "text": "Die aktuelle Lese- oder Schreibposition innerhalb der Datei."
              },
              {
                "type": "explanation",
                "title": "Dateiposition und Zeiger",
                "text": [
                  "fstream besitzt einen Lesezeiger und einen Schreibzeiger.",
                  "Diese k√∂nnen unabh√§ngig voneinander verschoben werden."
                ]
              },
              {
                "type": "explanation",
                "title": "Was ist die Dateiposition",
                "text": [
                  "Die Dateiposition beschreibt die aktuelle Stelle in der Datei, an der gelesen oder geschrieben wird.",
                  "Bei std::fstream gibt es getrennte Positionen f√ºr Lesen und Schreiben."
                ]
              },
              {
                "type": "definition",
                "term": "Lesezeiger",
                "text": "Interne Position, von der aus der n√§chste Lesevorgang beginnt."
              },
              {
                "type": "definition",
                "term": "Schreibzeiger",
                "text": "Interne Position, an der der n√§chste Schreibvorgang erfolgt."
              },
              {
                "type": "definition",
                "term": "tellg",
                "text": "Gibt die aktuelle Position des Lesezeigers zur√ºck."
              },
              {
                "type": "definition",
                "term": "tellp",
                "text": "Gibt die aktuelle Position des Schreibzeigers zur√ºck."
              },
              {
                "type": "code",
                "title": "Aktuelle Dateiposition abfragen",
                "language": "cpp",
                "code": "std::fstream file(\"data.txt\", std::ios::in | std::ios::out);\n\nstd::streampos readPos = file.tellg(); // aktuelle Leseposition\nstd::streampos writePos = file.tellp(); // aktuelle Schreibposition"
              },
              {
                "type": "definition",
                "term": "seekg",
                "text": "Setzt die Position des Lesezeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "definition",
                "term": "seekp",
                "text": "Setzt die Position des Schreibzeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "code",
                "title": "Dateiposition ver√§ndern",
                "language": "cpp",
                "code": "file.seekg(0);          // Lesezeiger an den Anfang der Datei\nfile.seekp(0);          // Schreibzeiger an den Anfang der Datei"
              },
              {
                "type": "explanation",
                "title": "Relative Positionierung",
                "text": [
                  "Die Dateiposition kann relativ zu bestimmten Referenzpunkten gesetzt werden.",
                  "Typische Referenzen sind Anfang, aktuelle Position und Dateiende."
                ]
              },
              {
                "type": "code",
                "title": "Relative Dateiposition",
                "language": "cpp",
                "code": "file.seekg(10, std::ios::beg); // 10 Bytes ab Dateianfang\nfile.seekg(0, std::ios::cur);  // aktuelle Position\nfile.seekg(-5, std::ios::end); // 5 Bytes vor Dateiende"
              },
              {
                "type": "pitfall",
                "title": "Lesen und Schreiben ohne Positionskontrolle",
                "text": "Ohne bewusstes Setzen der Dateiposition k√∂nnen Lese- und Schreibzugriffe an unerwarteten Stellen erfolgen."
              },
              {
                "type": "important",
                "text": "tellg und seekg steuern das Lesen, tellp und seekp das Schreiben."
              },
              {
                "type": "summary",
                "points": [
                  "Dateiposition bestimmt, wo gelesen oder geschrieben wird",
                  "fstream besitzt getrennte Lese- und Schreibzeiger",
                  "tellg und tellp fragen die aktuelle Position ab",
                  "seekg und seekp ver√§ndern die Position gezielt",
                  "Relative Positionierung ist mit beg, cur und end m√∂glich"
                ]
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger √ñffnungsmodus",
                "text": "Wird eine Datei ohne passenden Modus ge√∂ffnet, k√∂nnen Lese- oder Schreiboperationen fehlschlagen."
              },
              {
                "type": "important",
                "text": "std::fstream eignet sich f√ºr kombinierten Lese- und Schreibzugriff auf Dateien."
              },
              {
                "type": "summary",
                "points": [
                  "std::fstream vereint ifstream und ofstream",
                  "√ñffnungsmodi steuern das Dateiverhalten",
                  "Lesen und Schreiben sind in derselben Datei m√∂glich",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          {
            "title": "if / else",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "if Anweisung",
                "text": "Eine Kontrollstruktur, die Code nur dann ausf√ºhrt, wenn eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee von if und else",
                "text": [
                  "Mit if wird eine Bedingung gepr√ºft, die einen booleschen Wert liefert.",
                  "Mit else kann ein alternativer Codepfad definiert werden, falls die Bedingung false ist."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches if Beispiel",
                "language": "cpp",
                "code": "int x = 5;\n\nif (x > 0) {\n    // wird ausgef√ºhrt, wenn x gr√∂√üer als 0 ist\n}"
              },
              {
                "type": "definition",
                "term": "else",
                "text": "Erg√§nzt ein if um einen Codeblock, der ausgef√ºhrt wird, wenn die Bedingung false ist."
              },
              {
                "type": "code",
                "title": "if else Beispiel",
                "language": "cpp",
                "code": "int x = -3;\n\nif (x >= 0) {\n    // x ist nicht negativ\n} else {\n    // x ist negativ\n}"
              },
              {
                "type": "definition",
                "term": "else if",
                "text": "Erm√∂glicht das Pr√ºfen mehrerer Bedingungen nacheinander."
              },
              {
                "type": "code",
                "title": "else if Kette",
                "language": "cpp",
                "code": "int value = 10;\n\nif (value < 0) {\n    // negativ\n} else if (value == 0) {\n    // null\n} else {\n    // positiv\n}"
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Ein Ausdruck, der zu true oder false ausgewertet wird."
              },
              {
                "type": "explanation",
                "title": "Bedingungen formulieren",
                "text": [
                  "Bedingungen bestehen meist aus Vergleichs- und logischen Operatoren.",
                  "Komplexe Bedingungen k√∂nnen mit &&, || und ! kombiniert werden."
                ]
              },
              {
                "type": "code",
                "title": "Komplexe Bedingung",
                "language": "cpp",
                "code": "int age = 20;\nbool hasTicket = true;\n\nif (age >= 18 && hasTicket) {\n    // Zutritt erlaubt\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergleich mit = statt ==",
                "text": "Die Verwendung von = statt == in einer Bedingung f√ºhrt zu logischen Fehlern oder Warnungen."
              },
              {
                "type": "important",
                "text": "Die Bedingung in if muss immer einen booleschen Wert liefern."
              },
              {
                "type": "summary",
                "points": [
                  "if steuert bedingte Programmausf√ºhrung",
                  "else definiert einen alternativen Pfad",
                  "else if erlaubt mehrere Bedingungen",
                  "Bedingungen basieren auf Vergleichen und logischen Operatoren",
                  "Sorgf√§ltige Formulierung vermeidet logische Fehler"
                ]
              }
            ]
          },
          {
            "title": "switch",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "switch Anweisung",
                "text": "Eine Kontrollstruktur zur Auswahl eines Codepfads basierend auf dem Wert eines Ausdrucks."
              },
              {
                "type": "explanation",
                "title": "Grundidee von switch",
                "text": [
                  "switch vergleicht einen Ausdruck mit mehreren festen Werten.",
                  "Je nach Treffer wird der zugeh√∂rige Codeblock ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "case",
                "text": "Ein m√∂glicher Vergleichswert innerhalb einer switch Anweisung."
              },
              {
                "type": "definition",
                "term": "default",
                "text": "Ein optionaler Zweig, der ausgef√ºhrt wird, wenn kein case passt."
              },
              {
                "type": "code",
                "title": "Einfaches switch Beispiel",
                "language": "cpp",
                "code": "int day = 3;\n\nswitch (day) {\ncase 1:\n    // Montag\n    break;\ncase 2:\n    // Dienstag\n    break;\ncase 3:\n    // Mittwoch\n    break;\ndefault:\n    // Ung√ºltiger Tag\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "break",
                "text": "Beendet einen case Block und verhindert das Weiterlaufen in den n√§chsten case."
              },
              {
                "type": "explanation",
                "title": "Fallthrough",
                "text": [
                  "Ohne break wird der Code im n√§chsten case ebenfalls ausgef√ºhrt.",
                  "Dieses Verhalten nennt man Fallthrough."
                ]
              },
              {
                "type": "code",
                "title": "Fallthrough Beispiel",
                "language": "cpp",
                "code": "int x = 1;\n\nswitch (x) {\ncase 1:\n    // wird ausgef√ºhrt\ncase 2:\n    // wird ebenfalls ausgef√ºhrt\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "switch Ausdruck",
                "text": "Der Ausdruck in switch muss ein ganzzahliger oder enum Typ sein."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes break",
                "text": "Fehlende break Anweisungen f√ºhren oft zu unerwartetem Verhalten."
              },
              {
                "type": "important",
                "text": "switch ist geeignet f√ºr viele feste Vergleichswerte, nicht f√ºr komplexe Bedingungen."
              },
              {
                "type": "summary",
                "points": [
                  "switch w√§hlt Codepfade anhand eines Wertes",
                  "case definiert m√∂gliche Vergleichswerte",
                  "default deckt alle √ºbrigen F√§lle ab",
                  "break verhindert Fallthrough",
                  "switch funktioniert nur mit bestimmten Datentypen"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          {
            "title": "for Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "for Schleife",
                "text": "Eine Schleife, die einen Codeblock eine festgelegte Anzahl von Durchl√§ufen ausf√ºhrt."
              },
              {
                "type": "explanation",
                "title": "Grundidee der for Schleife",
                "text": [
                  "Die for Schleife besteht aus Initialisierung, Bedingung und Schritt.",
                  "Sie eignet sich besonders f√ºr z√§hlbasierte Wiederholungen."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Wird einmal vor dem ersten Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Wird vor jedem Durchlauf gepr√ºft und entscheidet √ºber das Weiterlaufen der Schleife."
              },
              {
                "type": "definition",
                "term": "Schritt",
                "text": "Wird nach jedem Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "code",
                "title": "Klassische for Schleife",
                "language": "cpp",
                "code": "for (int i = 0; i < 5; i++) {\n    // i l√§uft von 0 bis 4\n}"
              },
              {
                "type": "explanation",
                "title": "Ablauf einer for Schleife",
                "text": [
                  "Zuerst wird die Initialisierung ausgef√ºhrt.",
                  "Danach wird vor jedem Durchlauf die Bedingung gepr√ºft und am Ende der Schritt ausgef√ºhrt."
                ]
              },
              {
                "type": "code",
                "title": "for Schleife mit anderer Schrittweite",
                "language": "cpp",
                "code": "for (int i = 0; i <= 10; i += 2) {\n    // i nimmt die Werte 0, 2, 4, 6, 8, 10 an\n}"
              },
              {
                "type": "definition",
                "term": "Bereichsbasierte for Schleife",
                "text": "Moderne for Schleife zum Durchlaufen von Containern und Arrays."
              },
              {
                "type": "code",
                "title": "Bereichsbasierte for Schleife",
                "language": "cpp",
                "code": "int values[] = {1, 2, 3};\n\nfor (int v : values) {\n    // v nimmt nacheinander die Werte 1, 2, 3 an\n}"
              },
              {
                "type": "pitfall",
                "title": "Endlosschleife",
                "text": "Eine falsche Bedingung oder ein fehlender Schritt kann zu einer Endlosschleife f√ºhren."
              },
              {
                "type": "important",
                "text": "for Schleifen eignen sich besonders f√ºr bekannte oder z√§hlbare Wiederholungen."
              },
              {
                "type": "summary",
                "points": [
                  "for Schleifen bestehen aus Initialisierung, Bedingung und Schritt",
                  "Sie sind ideal f√ºr Z√§hlschleifen",
                  "Schrittweite kann frei gew√§hlt werden",
                  "Bereichsbasierte for Schleifen vereinfachen Containerzugriffe",
                  "Sorgf√§ltige Bedingungen verhindern Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "while Schleife",
                "text": "Eine Schleife, die einen Codeblock ausf√ºhrt, solange eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee der while Schleife",
                "text": [
                  "Die Bedingung wird vor jedem Durchlauf gepr√ºft.",
                  "Ist die Bedingung false, wird der Schleifenrumpf nicht ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Kopfgesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung vor dem ersten Durchlauf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\nwhile (i < 5) {\n    // wird ausgef√ºhrt, solange i kleiner als 5 ist\n    i++;\n}"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "while Schleifen werden genutzt, wenn die Anzahl der Durchl√§ufe vorher nicht bekannt ist.",
                  "H√§ufig wird die Schleife durch Benutzereingaben oder Dateiinhalte gesteuert."
                ]
              },
              {
                "type": "code",
                "title": "while mit Eingabe",
                "language": "cpp",
                "code": "int value;\n\nwhile (std::cin >> value) {\n    // l√§uft, solange die Eingabe g√ºltig ist\n}"
              },
              {
                "type": "definition",
                "term": "Endlosschleife",
                "text": "Eine Schleife, deren Bedingung niemals false wird."
              },
              {
                "type": "code",
                "title": "Bewusste Endlosschleife",
                "language": "cpp",
                "code": "while (true) {\n    // l√§uft unendlich\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergessene Zustands√§nderung",
                "text": "Wird die Schleifenbedingung im Rumpf nicht beeinflusst, entsteht unbeabsichtigt eine Endlosschleife."
              },
              {
                "type": "important",
                "text": "Die Schleifenbedingung muss irgendwann false werden, au√üer bei gewollten Endlosschleifen."
              },
              {
                "type": "summary",
                "points": [
                  "while Schleifen pr√ºfen die Bedingung vor jedem Durchlauf",
                  "Sie eignen sich f√ºr unbestimmte Wiederholungen",
                  "Die Bedingung steuert den Programmfluss",
                  "Fehlende Zustands√§nderungen f√ºhren zu Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "do-while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "do while Schleife",
                "text": "Eine Schleife, bei der der Codeblock mindestens einmal ausgef√ºhrt wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee der do while Schleife",
                "text": [
                  "Die Bedingung wird erst nach dem Schleifendurchlauf gepr√ºft.",
                  "Der Schleifenrumpf wird daher immer mindestens einmal ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Fu√ügesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung nach dem Schleifenrumpf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache do while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\ndo {\n    // wird mindestens einmal ausgef√ºhrt\n    i++;\n} while (i < 5);"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "do while wird genutzt, wenn eine Aktion mindestens einmal erfolgen muss.",
                  "H√§ufig bei Men√ºs oder wiederholten Benutzereingaben."
                ]
              },
              {
                "type": "code",
                "title": "do while mit Benutzereingabe",
                "language": "cpp",
                "code": "int choice;\n\ndo {\n    // Men√º anzeigen\n    std::cin >> choice;\n} while (choice != 0);"
              },
              {
                "type": "definition",
                "term": "Unterschied zu while",
                "text": "do while pr√ºft die Bedingung nach dem Durchlauf, while davor."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes Semikolon",
                "text": "Nach der while Bedingung der do while Schleife ist ein Semikolon Pflicht."
              },
              {
                "type": "important",
                "text": "do while garantiert mindestens einen Schleifendurchlauf."
              },
              {
                "type": "summary",
                "points": [
                  "do while ist eine fu√ügesteuerte Schleife",
                  "Der Schleifenrumpf l√§uft mindestens einmal",
                  "Die Bedingung wird am Ende gepr√ºft",
                  "Typisch f√ºr Men√ºs und Eingabeschleifen",
                  "Semikolon nach while nicht vergessen"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          {
            "title": "Funktionsdefinition",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktionsdefinition",
                "text": "Die vollst√§ndige Beschreibung einer Funktion inklusive R√ºckgabetyp, Name, Parameterliste und Funktionsrumpf."
              },
              {
                "type": "explanation",
                "title": "Bestandteile einer Funktionsdefinition",
                "text": [
                  "Eine Funktionsdefinition legt fest, was eine Funktion tut und wie sie implementiert ist.",
                  "Sie besteht aus R√ºckgabetyp, Funktionsname, Parametern und dem Codeblock."
                ]
              },
              {
                "type": "list",
                "title": "Bestandteile",
                "items": [
                  "R√ºckgabetyp",
                  "Funktionsname",
                  "Parameterliste",
                  "Funktionsrumpf"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Funktionsdefinition",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    // addiert zwei Zahlen\n    return a + b;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der Datentyp des Werts, den eine Funktion zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Funktionsname",
                "text": "Bezeichner, unter dem die Funktion aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Parameterliste",
                "text": "Liste von Variablen, √ºber die Werte an die Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "Funktionsrumpf",
                "text": "Der Codeblock, der beim Aufruf der Funktion ausgef√ºhrt wird."
              },
              {
                "type": "definition",
                "term": "void Funktion",
                "text": "Eine Funktion ohne R√ºckgabewert."
              },
              {
                "type": "code",
                "title": "void Funktionsdefinition",
                "language": "cpp",
                "code": "void printHello() {\n    // gibt eine Begr√º√üung aus\n    std::cout << \"Hallo\";\n}"
              },
              {
                "type": "definition",
                "term": "return",
                "text": "Anweisung zum Zur√ºckgeben eines Werts und Beenden der Funktion."
              },
              {
                "type": "pitfall",
                "title": "Fehlender return",
                "text": "Nicht-void Funktionen m√ºssen in allen F√§llen einen Wert zur√ºckgeben."
              },
              {
                "type": "important",
                "text": "Die Funktionsdefinition legt das Verhalten fest, die Deklaration nur die Schnittstelle."
              },
              {
                "type": "summary",
                "points": [
                  "Eine Funktionsdefinition beschreibt das Verhalten einer Funktion",
                  "Sie besteht aus R√ºckgabetyp, Name, Parametern und Rumpf",
                  "void Funktionen liefern keinen Wert zur√ºck",
                  "return beendet die Funktion und gibt einen Wert zur√ºck"
                ]
              }
            ]
          },
          { "title": "Parameter & R√ºckgabe", "content": { "text": [], "code": [] } },
          { "title": "√úberladen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          { "title": "inline", "content": { "text": [], "code": [] } },
          { "title": "constexpr Funktionen", "content": { "text": [], "code": [] } },
          { "title": "Lambda-Funktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          { "title": "C-Arrays", "content": { "text": [], "code": [] } },
          { "title": "std::array", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          { "title": "C-Strings", "content": { "text": [], "code": [] } },
          { "title": "std::string", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          { "title": "Pointer Basics", "content": { "text": [], "code": [] } },
          { "title": "Pointer Arithmetik", "content": { "text": [], "code": [] } },
          { "title": "Nullpointer", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          { "title": "Referenzen Basics", "content": { "text": [], "code": [] } },
          { "title": "Referenzparameter", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          {
          "title": "Stack vs Heap",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Stack",
              "text": "Automatisch verwalteter Speicherbereich f√ºr lokale Variablen und Funktionsaufrufe."
            },
            {
              "type": "definition",
              "term": "Heap",
              "text": "Dynamischer Speicherbereich f√ºr Objekte, deren Lebensdauer manuell oder √ºber Smart Pointer gesteuert wird."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "C++ verwendet zwei zentrale Speicherbereiche: Stack und Heap.",
                "Beide unterscheiden sich stark in Lebensdauer, Geschwindigkeit und Fehleranf√§lligkeit."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften des Stack",
              "items": [
                "Speicher wird automatisch freigegeben",
                "Sehr schneller Zugriff",
                "Lebensdauer an Block oder Funktion gebunden",
                "Begrenzte Gr√∂√üe"
              ]
            },
            {
              "type": "code",
              "title": "Stack Beispiel",
              "language": "cpp",
              "code": "void f() {\n    int x = 10;\n} // x wird automatisch freigegeben"
            },
            {
              "type": "list",
              "title": "Eigenschaften des Heap",
              "items": [
                "Speicher wird dynamisch reserviert",
                "Manuelle oder automatische Freigabe n√∂tig",
                "Gr√∂√üerer Speicherbereich",
                "Langsamer als Stack"
              ]
            },
            {
              "type": "code",
              "title": "Heap Beispiel",
              "language": "cpp",
              "code": "int* p = new int(5);\n// ...\ndelete p;"
            },
            {
              "type": "comparison",
              "title": "Vergleich",
              "columns": ["Stack", "Heap"],
              "rows": [
                {
                  "aspect": "Geschwindigkeit",
                  "values": ["sehr schnell", "langsamer"]
                },
                {
                  "aspect": "Lebensdauer",
                  "values": ["automatisch", "manuell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Dangling Pointer",
              "text": "Ein Pointer zeigt auf Speicher, der bereits freigegeben wurde."
            },
            {
              "type": "important",
              "text": "Manuelle Speicherverwaltung mit new und delete ist fehleranf√§llig."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Verwende bevorzugt std::unique_ptr oder std::shared_ptr statt new und delete."
            },
            {
              "type": "example",
              "title": "Typische Verwendung",
              "text": [
                "Lokale Variablen und Schleifen ‚Üí Stack",
                "Gro√üe Datenstrukturen oder geteilte Objekte ‚Üí Heap"
              ]
            },
            {
              "type": "summary",
              "points": [
                "Stack ist schnell und automatisch",
                "Heap ist flexibel, aber fehleranf√§llig",
                "Modernes C++ vermeidet manuelle Speicherverwaltung"
              ]
            }
          ]
        },
          { "title": "new / delete", "content": { 
            "text": [
              "### === Heap-Speicher in C++ (new / delete) ===\n",
              "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
              "\n",
              "---\n",
              "### üîπ Warum Heap?\n",
              "- Stack ist nur f√ºr **kurzlebige, kleine** Daten\n",
              "- Heap erlaubt **dynamische Gr√∂√üe** und **l√§ngere Lebenszeit**\n",
              "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
              "\n",
              "---\n",
              "### üî∏ `new` f√ºr EIN Objekt:\n",
              "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
              "- Speicher f√ºr genau **ein Objekt** wird angefordert\n",
              "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
              "\n",
              "---\n",
              "### üî∏ `new[]` f√ºr MEHRERE Objekte (Array):\n",
              "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
              "- Reserviert **zusammenh√§ngenden Speicherplatz** f√ºr mehrere Objekte\n",
              "- Muss mit **`delete[]`** freigegeben werden!\n",
              "\n",
              "---\n",
              "### ‚ùó Vorsicht bei falscher Kombination:\n",
              "- `new[]` ‚Üí `delete[]`\n",
              "- `new` ‚Üí `delete`\n",
              "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
              "\n",
              "---\n",
              "### üîπ Klassen & Konstruktoren:\n",
              "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
              "\n",
              "---\n",
              "### üîπ Wann `new[]` statt `new`?\n",
              "- Wenn du mehrere gleichartige Objekte brauchst ‚Üí `new[]`\n",
              "- Wenn du nur ein einzelnes Objekt brauchst ‚Üí `new`\n",
              "\n",
              "---\n",
              "### ‚ùó Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
              "üëâ Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gel√∂scht\\n\"; }\n};\n\nint main() {\n    // new f√ºr EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] f√ºr MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt l√∂schen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gel√∂scht\n    delete[] pArr;  // 2x Punkt gel√∂scht\n\n    return 0;\n}"
              ] 
            } 
          }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          { "title": "RAII Prinzip", "content": { "text": [], "code": [] } },
          { "title": "Smart Pointer", "content": {
            "text": [
              "### === Smart Pointer in C++ ===\n",
              "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ung√ºltige Speicherbereiche**.\n",
              "Sie geh√∂ren zum Header `<memory>` und sind seit **C++11** verf√ºgbar.\n",
              "\n",
              "---\n",
              "### Warum Smart Pointer?\n",
              "- Kein manuelles `delete` n√∂tig\n",
              "- Klare Besitzverh√§ltnisse\n",
              "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
              "\n",
              "---\n",
              "### üîπ `std::unique_ptr<T>`\n",
              "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
              "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
              "- Objekt wird beim Verlassen des Scopes automatisch gel√∂scht\n",
              "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles L√∂schen m√∂glich\n```\n",
              "\n",
              "---\n",
              "### üîπ `std::shared_ptr<T>`\n",
              "- **Mehrere Besitzer** teilen sich das Objekt\n",
              "- Automatische L√∂schung, wenn **alle Kopien** verschwinden\n",
              "- Intern wird ein **Referenzz√§hler** verwaltet (`use_count()`)\n",
              "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
              "- `reset()` l√∂scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
              "\n",
              "---\n",
              "### üîπ `std::weak_ptr<T>`\n",
              "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Z√§hler zu erh√∂hen**\n",
              "- Kann ung√ºltig werden ‚Üí **immer mit `.lock()` pr√ºfen**\n",
              "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
              "\n",
              "---\n",
              "### üîç Vergleichstabelle:\n",
              "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
              "| `unique_ptr`  | exklusiv     | ‚ùå nein     | nur mit `std::move` √ºbertragbar  |\n",
              "| `shared_ptr`  | gemeinsam    | ‚úÖ ja       | Z√§hler z√§hlt aktive Referenzen   |\n",
              "| `weak_ptr`    | kein Besitz  | ‚úÖ ja       | Beobachtet ohne mitzuz√§hlen      |\n",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzz√§hler = 2\n    std::cout << \"shared_ptr Z√§hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Z√§hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei ‚Üí Destruktor wird aufgerufen\n\n    return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        { "title": "<iostream>", "content": { "text": [], "code": [] } },
        { "title": "<fstream>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } },
        { "title": "<iomanip>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
        { "title": "<string>", "content": { "text": [], "code": [] } },
        { "title": "<string_view>", "content": { "text": [], "code": [] } },
        { "title": "<cstring>", "content": { "text": [], "code": [] } },
        { "title": "<cctype>", "content": { "text": [], "code": [] } },
        { "title": "<sstream>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        { "title": "<cmath>", "content": { "text": [], "code": [] } },
        { "title": "<cstdlib>", "content": { "text": [], "code": [] } },
        { "title": "<random>", "content": { "text": [], "code": [] } },
        { "title": "<limits>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        { "title": "<chrono>", "content": { "text": [], "code": [] } },
        { "title": "<ctime>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        { "title": "<thread>", "content": { "text": [], "code": [] } },
        { "title": "<future>", "content": { "text": [], "code": [] } },
        { "title": "<typeinfo>", "content": { "text": [], "code": [] } },
        { "title": "<new>", "content": { "text": [], "code": [] } },
        { "title": "<memory>", "content": { "text": [], "code": [] } },
        { "title": "<cstdio>", "content": { "text": [], "code": [] } }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
        { "title": "<algorithm>", "content": { "text": [], "code": [] } },
        { "title": "<iterator>", "content": { "text": [], "code": [] } },
        { "title": "<functional>", "content": { "text": [], "code": [] } },
        { "title": "<initializer_list>", "content": { "text": [], "code": [] } },
        { "title": "<tuple>", "content": { "text": [], "code": [] } },
        { "title": "<utility> (pair, swap)", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
          { "title": "Klassen Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren & Destruktoren", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
          { "title": "Basisklassen", "content": { "text": [], "code": [] } },
          { "title": "Polymorphie", "content": { "text": [], "code": [] } },
          { "title": "virtual / override", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
          { "title": "struct Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "struct vs class", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
          { "title": "enum Grundlagen", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
          { "title": "enum class Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "enum class vs enum", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
          { "title": "namespace Grundlagen", "content": {
            "text": [
                "### === Namespaces in C++ ===\n",
                "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
                "\n",
                "---\n",
                "### Warum Namespaces?\n",
                "- Zwei Funktionen mit gleichem Namen k√∂nnen in unterschiedlichen Namespaces existieren\n",
                "- Gro√üe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
                "\n",
                "---\n",
                "### Verwendung von Namespaces\n",
                "- Definition:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
                "- Aufruf:\n",
                "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
                "\n",
                "---\n",
                "### Anonyme Namespaces (Datei-spezifisch)\n",
                "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
                "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
                "\n",
                "---\n",
                "### Verschachtelte Namespaces (modernes C++)\n",
                "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
                "\n",
                "üëâ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
                "üëâ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
                "---\n"
              ],
              "code": [
                "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
              ]
            } 
          },
          { "title": "using namespace", "content": { 
            "text": [
                "### `using namespace` (nicht immer empfohlen)\n",
                "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
                "- Nachteil: Alle Namen des Namespace werden global sichtbar ‚Üí Konfliktgefahr\n",
                "- Besser: Nur gezielt importieren\n",
                "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
                "\n"
              ], 
            "code": [] } },
          { "title": "namespace vs. class", "content": { 
            "text": [ 
                "### === Unterschied: Namespace vs. Class ===\n",
                "`namespace` und `class` dienen beide zur Strukturierung, haben aber v√∂llig unterschiedliche Funktionen:\n",
                "\n",
                "---\n",
                "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
                "| Zweck                | Gruppierung von Code                   | Bauplan f√ºr Objekte (Daten + Methoden)    |\n",
                "| Objekte erzeugbar?   | ‚ùå Nein                                 | ‚úÖ Ja                                      |\n",
                "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
                "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
                "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
                "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
                "\n",
                "---\n",
                "### Beispiel zur Verdeutlichung:\n",
                "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
                "\n",
                "### üëâ Merksatz",
                "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
                "---\n"
            ], 
            "code": [] 
            } 
          }
        ]
      },
      {
        "name": "Klassenmember & Attribute",
        "icon": "üß©",
        "topics": [
          { "title": "static Member", "content": { 
            "text": [    
              "### === `static` in C++ ===\n",
              "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
              "\n",
              "---\n",
              "### üîπ `static` innerhalb einer Funktion:\n",
              "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
              "- Bleibt zwischen Aufrufen **erhalten**\n",
              "```cpp\nvoid z√§hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` in Klassen (statisch f√ºr alle Objekte):\n",
              "- Variable geh√∂rt **zur Klasse, nicht zum Objekt**\n",
              "- Wird **au√üerhalb der Klasse** definiert\n",
              "- Gleicher Wert f√ºr **alle Instanzen**\n",
              "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Klassenfunktionen:\n",
              "- Funktion geh√∂rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
              "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
              "- Wird √ºber `Klassenname::Funktion()` aufgerufen\n",
              "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
              "\n",
              "---\n",
              "### üîπ `static` bei Funktionen (au√üerhalb von Klassen):\n",
              "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
              "- N√ºtzlich zur Kapselung beim Modularisieren\n",
              "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
              "\n",
              "üëâ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschr√§nken**.\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n\nclass Test {\npublic:\n    static int z√§hler;\n    void erh√∂hen() {\n        z√§hler++;\n    }\n};\n\nint Test::z√§hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion au√üerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erh√∂hen();\n    b.erh√∂hen();\n    std::cout << \"static in Klasse: \" << Test::z√§hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
              ] 
            } 
          },
          { "title": "mutable Member", "content": { 
            "text": [  
              "### === `mutable` in C++ ===\n",
              "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu ver√§ndern**.\n",
              "\n",
              "---\n",
              "### Wann braucht man das?\n",
              "- Normalerweise d√ºrfen `const`-Funktionen **keine Membervariablen ver√§ndern**.\n",
              "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. f√ºr Logging, Caching oder Zugriffsz√§hler.\n",
              "\n",
              "---\n",
              "### Auch ohne `const` n√ºtzlich:\n",
              "- `mutable`-Member sind **immer unabh√§ngig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
              "- Sie k√∂nnen **immer ver√§ndert werden**, auch au√üerhalb von `const`-Kontexten - z.B. als interne Z√§hler oder Zust√§nde.\n",
              "\n",
              "---\n",
              "### Wichtig:\n",
              "- `mutable` funktioniert **nur bei Membervariablen**.\n",
              "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** f√ºr Klassenmitglieder.\n",
              "\n",
              "üëâ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
              "---\n"
              ], 
            "code": [
              "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZ√§hler = 0;  // darf auch in const-Funktion ver√§ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZ√§hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZ√§hler() const {\n    return leseZ√§hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZ√§hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
              ] 
            } 
          },
          { "title": "const Memberfunktionen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
          { "title": "Funktionstemplates", "content": { "text": [], "code": [] } },
          { "title": "Klassentemplates", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
          { "title": "vector", "content": { "text": [], "code": [] } },
          { "title": "array", "content": { "text": [], "code": [] } },
          { "title": "deque", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "map", "content": { "text": [], "code": [] } },
          { "title": "set", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
          { "title": "stack", "content": { "text": [], "code": [] } },
          { "title": "queue", "content": { "text": [], "code": [] } },
          { "title": "priority_queue", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Utility Types",
        "icon": "üß∞",
        "topics": [
          { "title": "pair", "content": { "text": [], "code": [] } },
          { "title": "tuple", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },

  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Fehlerbehandlung (try/catch)", "content": { "text": [], "code": [] } },
          { "title": "Pr√§prozessor (#define)", "content": { "text": [], "code": [] } },
          { "title": "CMake Basics", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Windows / Clion",
        "icon": "‚≠ê",
        "topics": [
          { "title": "Console Ausgabe UTF-8 Windows", "content": {
            "text": [
              "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
              "In Clion auf Windows, zeigt die Console keine √ú,√Ñ,√ñ usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
              "---\n",
              "## üîπ FONT Einstellen:",
              "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
              "### üîπ Einstellung in CLion\n",
              "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
              "---\n",
              "### CODE in main.lua:"
              ],
            "code": [
              "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
              ]
            } 
          },
          { "title": "Working Directory in CLion", "content": {
            "text": [
              "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
              "Standardm√§√üig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen m√∂chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis (‚ÄûWorking Directory‚Äú) √§ndern.\n",
              "\n",
              "### üîπ Zielstruktur\n",
              "```",
              "Projektordner/\n",
              "‚îú‚îÄ‚îÄ CMakeLists.txt\n",
              "‚îú‚îÄ‚îÄ data/\n",
              "‚îî‚îÄ‚îÄ cmake-build-debug/",
              "```",
              "\n",
              "### üîπ Einstellung in CLion\n",
              "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
              "2. W√§hle **‚ÄûEdit Configurations‚Ä¶‚Äú**.\n",
              "3. W√§hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
              "4. Im Feld **‚ÄûWorking directory‚Äú** tr√§gst du ein: `$ProjectFileDir$`\n",
              "   ‚Üí Das sorgt daf√ºr, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
              "\n",
              "### üîπ Pr√ºfen im Code\n",
              "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
              "\n",
              "```cpp",
              "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
              "```",
              "\n",
              "---\n",
              "### üîπ Hinweis\n",
              "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
              "```cpp",
              "std::filesystem::create_directories(\"data\");",
              "```",
              "---\n"
              ],
            "code": [
              "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
              ]
            } 
          }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
          { "title": "main.cpp Grundger√ºst", "content": { "text": [], "code": [] } },
          { "title": "Hello World Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Input/Output Vorlage", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
          { "title": "Klasse mit Header & cpp", "content": { "text": [], "code": [] } },
          { "title": "Getter & Setter", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
          { "title": "vector Beispiel", "content": { "text": [], "code": [] } },
          { "title": "map Beispiel", "content": { "text": [], "code": [] } },
          { "title": "tuple / pair Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "CMakeLists.txt Minimal", "content": { "text": [], "code": [] } },
          { "title": "Ordnerstruktur Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Modulares Projekt Setup", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Datenbanken",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SQLite",
        "icon": "üß±",
        "topics": [
          { "title": "SQLite Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "prepare / bind / step / finalize", "content": { "text": [], "code": [] } },
          { "title": "CRUD Operationen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  }

]
