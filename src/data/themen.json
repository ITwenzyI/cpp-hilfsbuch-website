[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          {
          "title": "Namensgebung ",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Namensgebung",
              "text": "Namensgebung beschreibt die Regeln und Konventionen zur Benennung von Variablen, Funktionen, Klassen, Typen und anderen Bezeichnern in C++ mit dem Ziel, Code verst√§ndlich, wartbar und eindeutig zu machen."
            },
            {
              "type": "explanation",
              "title": "Warum Namensgebung wichtig ist",
              "text": [
                "C++ erlaubt sehr viele g√ºltige Bezeichner, aber nur ein kleiner Teil davon ist sinnvoll. Der Compiler pr√ºft nur die Syntax, nicht ob ein Name verst√§ndlich ist.",
                "Gute Namen transportieren Bedeutung, reduzieren Kommentare und helfen dabei, Fehler schneller zu erkennen. Schlechte Namen machen selbst korrekten Code schwer wartbar."
              ]
            },
            {
              "type": "list",
              "title": "Allgemeine Regeln f√ºr Bezeichner",
              "items": [
                "Bezeichner bestehen aus Buchstaben, Ziffern und Unterstrichen",
                "Ein Bezeichner darf nicht mit einer Ziffer beginnen",
                "Gro√ü und Kleinschreibung sind relevant",
                "Reservierte Schl√ºsselw√∂rter d√ºrfen nicht verwendet werden"
              ]
            },
            {
              "type": "comparison",
              "title": "Gro√ü und Kleinschreibung",
              "columns": ["Bezeichner", "Bedeutung"],
              "rows": [
                {
                  "aspect": "value vs Value",
                  "values": ["zwei verschiedene Namen", "Gro√üschreibung erzeugt einen anderen Bezeichner"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "√úbliche Namenskonventionen in C++",
              "text": [
                "C++ selbst erzwingt keine Namenskonventionen, aber in der Praxis haben sich feste Muster etabliert, um Code konsistent zu halten.",
                "Welche Konvention genutzt wird, h√§ngt oft vom Projekt, Team oder Styleguide ab, sollte aber innerhalb eines Projekts einheitlich sein."
              ]
            },
            {
              "type": "list",
              "title": "Typische Konventionen",
              "items": [
                "Variablen und Funktionen meist klein geschrieben",
                "Mehrteilige Namen werden oft mit Unterstrichen getrennt",
                "Klassen und Typen beginnen h√§ufig mit einem Gro√übuchstaben",
                "Konstanten werden oft komplett gro√ü geschrieben"
              ]
            },
            {
              "type": "code",
              "title": "Beispiele f√ºr g√ºltige Bezeichner",
              "language": "cpp",
              "code": "int age;\nint user_count;\nvoid calculateSum();\nclass PatientRecord {};\nconst int MAX_SIZE = 100;"
            },
            {
              "type": "example",
              "title": "Gute vs. schlechte Namen",
              "text": [
                "count ist besser als c",
                "calculateAverage ist besser als func1",
                "patient_age ist verst√§ndlicher als pa"
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrdeutige oder nichtssagende Namen",
              "text": "Kurze oder generische Namen wie x, tmp oder data sagen nichts √ºber ihre Bedeutung aus und f√ºhren schnell zu Verst√§ndnisproblemen."
            },
            {
              "type": "important",
              "text": "Ein guter Name erkl√§rt seine Bedeutung ohne zus√§tzlichen Kommentar."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Moderne C++ Projekte legen gro√üen Wert auf sprechende Namen, da Code h√§ufiger gelesen als geschrieben wird."
            },
            {
              "type": "summary",
              "points": [
                "C++ erlaubt viele Namen, aber nicht jeder ist sinnvoll",
                "Gro√ü und Kleinschreibung unterscheidet Bezeichner",
                "Einheitliche Konventionen erh√∂hen Lesbarkeit",
                "Sprechende Namen sind wichtiger als kurze Namen"
              ]
            }
          ]
        },
          {
            "title": "Wichtige Grundbegriffe ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Deklaration",
                "text": "Macht einen Namen und seinen Typ bekannt, ohne ihn zwingend vollst√§ndig festzulegen. (z.B. `int x;`)"
              },
              {
                "type": "definition",
                "term": "Definition",
                "text": "Legt Speicher oder die konkrete Implementierung eines Namens fest. (z.B. `int x = 5;`)"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Vergibt beim Erzeugen einer Variable direkt einen Startwert."
              },
              {
                "type": "definition",
                "term": "Zuweisung",
                "text": "√Ñndert den Wert einer bereits existierenden Variable."
              },
              {
                "type": "definition",
                "term": "Variable",
                "text": "Ein benannter Speicherbereich zur Ablage von Daten."
              },
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Legt fest, welche Art von Wert gespeichert wird und wie viel Speicher ben√∂tigt wird."
              },
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "definition",
                "term": "Funktion",
                "text": "Ein benannter Codeblock, der eine bestimmte Aufgabe ausf√ºhrt."
              },
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Platzhalter in der Funktionsdefinition f√ºr √ºbergebene Werte."
              },
              {
                "type": "definition",
                "term": "Argument",
                "text": "Konkreter Wert, der beim Funktionsaufruf √ºbergeben wird."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Scope",
                "text": "Der G√ºltigkeitsbereich, in dem ein Name verwendet werden darf."
              },
              {
                "type": "definition",
                "term": "Block",
                "text": "Ein zusammengeh√∂riger Codebereich, der durch geschweifte Klammern begrenzt ist."
              },
              {
                "type": "definition",
                "term": "Namespace",
                "text": "Ein Namensraum zur Strukturierung und Vermeidung von Namenskonflikten."
              },
              {
                "type": "definition",
                "term": "Klasse",
                "text": "Ein Bauplan f√ºr Objekte, der Daten und Funktionen zusammenfasst."
              },
              {
                "type": "definition",
                "term": "Objekt",
                "text": "Eine konkrete Instanz einer Klasse."
              },
              {
                "type": "definition",
                "term": "Konstruktor",
                "text": "Spezielle Funktion, die beim Erzeugen eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Destruktor",
                "text": "Spezielle Funktion, die beim Zerst√∂ren eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Header-Datei",
                "text": "Datei, die Deklarationen f√ºr andere √úbersetzungseinheiten bereitstellt."
              },
              {
                "type": "definition",
                "term": "Quell-Datei",
                "text": "Datei, die die eigentlichen Definitionen und Implementierungen enth√§lt."
              },
              {
                "type": "important",
                "text": "Diese Begriffe bilden das Fundament zum Verstehen von C++ Code und Compiler-Fehlern."
              },
              {
                "type": "summary",
                "points": [
                  "Deklaration und Definition sind nicht dasselbe",
                  "Parameter geh√∂ren zur Funktion, Argumente zum Aufruf",
                  "Referenzen und Zeiger arbeiten beide mit bestehenden Objekten",
                  "Klassen definieren Strukturen, Objekte sind ihre Instanzen"
                ]
              }
            ]
          },
          {
            "title": "Datentypen ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Ein Datentyp legt fest, welche Art von Wert gespeichert wird und wie dieser interpretiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundlegende Datentypen",
                "text": [
                  "Grundlegende Datentypen sind fest in C++ eingebaut und bilden die Basis aller weiteren Typen.",
                  "Sie unterscheiden sich in Speicherbedarf, Wertebereich und Verwendungszweck."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige grundlegende Datentypen",
                "items": [
                  "int: Ganzzahltyp",
                  "double: Gleitkommazahl",
                  "char: Einzelnes Zeichen",
                  "bool: Wahrheitswert true oder false",
                  "void: Kein Wert"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Datentypen Beispiel",
                "language": "cpp",
                "code": "int a = 5;\ndouble b = 3.14;\nbool ok = true;"
              },
              {
                "type": "definition",
                "term": "size_t",
                "text": "Ein vorzeichenloser Ganzzahltyp zur Darstellung von Gr√∂√üen und Indizes."
              },
              {
                "type": "code",
                "title": "size_t Beispiel",
                "language": "cpp",
                "code": "size_t len = 10;"
              },
              {
                "type": "definition",
                "term": "std::string",
                "text": "Ein Standardtyp zur komfortablen Verarbeitung von Texten."
              },
              {
                "type": "code",
                "title": "std::string Beispiel",
                "language": "cpp",
                "code": "std::string name = \"C++\";"
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert f√ºr einen ung√ºltigen Zeiger."
              },
              {
                "type": "code",
                "title": "nullptr Beispiel",
                "language": "cpp",
                "code": "int* p = nullptr;"
              },
              {
                "type": "definition",
                "term": "auto",
                "text": "L√§sst den Compiler den Datentyp einer Variablen automatisch ableiten."
              },
              {
                "type": "code",
                "title": "auto Beispiel",
                "language": "cpp",
                "code": "auto x = 42;"
              },
              {
                "type": "definition",
                "term": "decltype",
                "text": "Ermittelt den Typ eines Ausdrucks, ohne ihn auszuwerten."
              },
              {
                "type": "code",
                "title": "decltype Beispiel",
                "language": "cpp",
                "code": "int a = 0;\ndecltype(a) b = 1;"
              },
              {
                "type": "definition",
                "term": "struct",
                "text": "Ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer Werte."
              },
              {
                "type": "definition",
                "term": "class",
                "text": "Ein benutzerdefinierter Datentyp mit Kapselung und Zugriffskontrolle."
              },
              {
                "type": "code",
                "title": "struct und class mit Funktionen",
                "language": "cpp",
                "code": "struct Point {\n    int x;\n    int y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n};\n\nclass Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n\n    int get() const {\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "enum",
                "text": "Ein Datentyp mit einer festen Menge benannter Ganzzahlwerte."
              },
              {
                "type": "code",
                "title": "enum Beispiel",
                "language": "cpp",
                "code": "enum Color { Red, Green, Blue };"
              },
              {
                "type": "definition",
                "term": "enum class",
                "text": "Stark typisierte Enumeration mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung zu int."
              },
              {
                "type": "code",
                "title": "enum class Beispiel",
                "language": "cpp",
                "code": "enum class Status { Ok, Error, Unknown };\n\nStatus s = Status::Ok;"
              },
              {
                "type": "definition",
                "term": "typedef",
                "text": "Erstellt einen Aliasnamen f√ºr einen bestehenden Datentyp."
              },
              {
                "type": "definition",
                "term": "using",
                "text": "Moderne Alternative zu typedef f√ºr Typaliasse."
              },
              {
                "type": "code",
                "title": "typedef und using Beispiel",
                "language": "cpp",
                "code": "typedef unsigned int uint;\nusing Index = size_t;"
              },
              {
                "type": "explanation",
                "title": "Typumwandlung in C++",
                "text": [
                  "Typumwandlungen werden verwendet, wenn ein Wert in einem anderen Datentyp weiterverarbeitet werden soll.",
                  "Explizite Casts wie static_cast sind sicherer und besser lesbar als implizite Umwandlungen."
                ]
              },
              {
                "type": "list",
                "title": "G√§ngige Cast-Arten",
                "items": [
                  "static_cast: normale, √ºberpr√ºfbare Umwandlungen",
                  "const_cast: Entfernen oder Hinzuf√ºgen von const",
                  "reinterpret_cast: bitweise Umdeutung, sehr gef√§hrlich",
                  "dynamic_cast: sichere Laufzeitpr√ºfung bei Vererbung"
                ]
              },
              {
                "type": "code",
                "title": "Typumwandlung Beispiel",
                "language": "cpp",
                "code": "double d = 4.9;\nint i = static_cast<int>(d);"
              },
              {
                "type": "important",
                "text": "Datentypen bestimmen Speicher, Verhalten und Sicherheit von C++ Programmen."
              },
              {
                "type": "summary",
                "points": [
                  "Grundlegende Typen bilden die Basis aller Programme",
                  "size_t, string und nullptr sind zentrale Standardtypen",
                  "auto und decltype vereinfachen typsicheren Code",
                  "struct, class und enum erlauben eigene Datentypen",
                  "using ersetzt typedef in modernem C++"
                ]
              }
            ]
          },
          {
            "title": "I/O Grundprinzipien",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "I/O",
                "text": "Input und Output bezeichnen das Einlesen von Daten in ein Programm und das Ausgeben von Daten nach au√üen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Ein und Ausgabe",
                "text": [
                  "C++ arbeitet bei Ein und Ausgabe mit sogenannten Streams. Ein Stream ist eine Abfolge von Zeichen oder Daten.",
                  "Programme lesen Daten aus einem Eingabestrom und schreiben Daten in einen Ausgabestrom."
                ]
              },
              {
                "type": "definition",
                "term": "Stream",
                "text": "Ein abstrakter Datenstrom, der Zeichen sequenziell transportiert."
              },
              {
                "type": "definition",
                "term": "Standard Input",
                "text": "Der voreingestellte Eingabestrom, meist die Tastatur."
              },
              {
                "type": "definition",
                "term": "Standard Output",
                "text": "Der voreingestellte Ausgabestrom, meist die Konsole."
              },
              {
                "type": "definition",
                "term": "Standard Error",
                "text": "Separater Ausgabestrom f√ºr Fehlermeldungen."
              },
              {
                "type": "list",
                "title": "Wichtige Standard-Streams",
                "items": [
                  "std::cin: Standardeingabe",
                  "std::cout: Standardausgabe",
                  "std::cerr: Fehlerausgabe",
                  "std::clog: Protokollausgabe"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe mit cout",
                "language": "cpp",
                "code": "std::cout << \"Hallo Welt\" << std::endl;"
              },
              {
                "type": "code",
                "title": "Einfache Eingabe mit cin",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;"
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Schreibt Daten in einen Ausgabestrom."
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Liest Daten aus einem Eingabestrom."
              },
              {
                "type": "explanation",
                "title": "Verkettung von Streams",
                "text": [
                  "Einf√ºge und Extraktionsoperatoren k√∂nnen verkettet werden.",
                  "Dadurch lassen sich mehrere Werte in einer Anweisung ein oder ausgeben."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Ein und Ausgabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b;\nstd::cout << a << \" \" << b;"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Zwischenspeicherung von Ausgaben, bevor sie tats√§chlich geschrieben werden."
              },
              {
                "type": "definition",
                "term": "Flush",
                "text": "Erzwingt das sofortige Schreiben des Ausgabepuffers."
              },
              {
                "type": "code",
                "title": "Flush Beispiel",
                "language": "cpp",
                "code": "std::cout << \"Text\" << std::flush;"
              },
              {
                "type": "pitfall",
                "title": "Eingabe ohne Pr√ºfung",
                "text": "Fehlerhafte Eingaben k√∂nnen Streams in einen Fehlerzustand versetzen und weitere Eingaben verhindern."
              },
              {
                "type": "important",
                "text": "I/O in C++ basiert auf Streams und Operatoren, nicht auf direkten Ger√§tezugriffen."
              },
              {
                "type": "summary",
                "points": [
                  "Ein und Ausgabe erfolgt √ºber Streams",
                  "cin, cout und cerr sind zentrale Standard-Streams",
                  "<< schreibt, >> liest",
                  "Streams k√∂nnen verkettet werden",
                  "Pufferung beeinflusst, wann Ausgaben sichtbar werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          {
            "title": "Arithmetische Operatoren",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Arithmetischer Operator",
                "text": "Ein Operator zur Durchf√ºhrung mathematischer Berechnungen auf numerischen Datentypen."
              },
              {
                "type": "list",
                "title": "Grundlegende arithmetische Operatoren",
                "items": [
                  "+: Addition",
                  "-: Subtraktion",
                  "*: Multiplikation",
                  "/: Division",
                  "%: Modulo Restbildung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Operatoren Beispiel",
                "language": "cpp",
                "code": "int a = 10;\nint b = 3;\nint sum = a + b;\nint diff = a - b;\nint prod = a * b;\nint quot = a / b;\nint rest = a % b;"
              },
              {
                "type": "definition",
                "term": "Ganzzahldivision",
                "text": "Division zweier Ganzzahlen, bei der der Nachkommateil verworfen wird."
              },
              {
                "type": "code",
                "title": "Ganzzahldivision Beispiel",
                "language": "cpp",
                "code": "int x = 7 / 2;"
              },
              {
                "type": "definition",
                "term": "Modulo",
                "text": "Berechnet den Rest einer Ganzzahldivision."
              },
              {
                "type": "explanation",
                "title": "Inkrement und Dekrement",
                "text": [
                  "Inkrement und Dekrement erh√∂hen oder verringern einen Wert um eins.",
                  "Es wird zwischen Pr√§fix und Postfix unterschieden."
                ]
              },
              {
                "type": "list",
                "title": "Inkrement und Dekrement Operatoren",
                "items": [
                  "++x: Pr√§fix Inkrement",
                  "x++: Postfix Inkrement",
                  "--x: Pr√§fix Dekrement",
                  "x--: Postfix Dekrement"
                ]
              },
              {
                "type": "code",
                "title": "Inkrement und Dekrement Beispiel",
                "language": "cpp",
                "code": "int i = 5;\nint a = ++i;\nint b = i++;"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Legt fest, in welcher Reihenfolge Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Operatorpriorit√§t und Klammern",
                "text": [
                  "Multiplikation und Division werden vor Addition und Subtraktion ausgewertet.",
                  "Klammern k√∂nnen verwendet werden, um die Auswertungsreihenfolge explizit festzulegen."
                ]
              },
              {
                "type": "code",
                "title": "Operatorpriorit√§t Beispiel",
                "language": "cpp",
                "code": "int r1 = 2 + 3 * 4;\nint r2 = (2 + 3) * 4;"
              },
              {
                "type": "pitfall",
                "title": "Unerwartete Ganzzahldivision",
                "text": "Division mit int liefert kein Kommaergebnis, auch wenn das mathematisch erwartet wird."
              },
              {
                "type": "important",
                "text": "Der Datentyp der Operanden beeinflusst das Ergebnis arithmetischer Operationen."
              },
              {
                "type": "summary",
                "points": [
                  "Arithmetische Operatoren f√ºhren grundlegende Berechnungen aus",
                  "Ganzzahldivision verwirft den Nachkommateil",
                  "Modulo liefert den Divisionsrest",
                  "Inkrement und Dekrement unterscheiden Pr√§fix und Postfix",
                  "Klammern steuern die Auswertungsreihenfolge"
                ]
              }
            ]
          },
          {
            "title": "Vergleichsoperatoren ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Vergleichsoperator",
                "text": "Ein Operator, der zwei Werte vergleicht und einen booleschen Wert zur√ºckliefert."
              },
              {
                "type": "list",
                "title": "Grundlegende Vergleichsoperatoren",
                "items": [
                  "==: gleich",
                  "!=: ungleich",
                  "<: kleiner als",
                  ">: gr√∂√üer als",
                  "<=: kleiner oder gleich",
                  ">=: gr√∂√üer oder gleich"
                ]
              },
              {
                "type": "code",
                "title": "Vergleichsoperatoren Beispiel",
                "language": "cpp",
                "code": "int a = 5;\nint b = 7;\nbool r1 = (a == b);\nbool r2 = (a < b);"
              },
              {
                "type": "definition",
                "term": "bool",
                "text": "Ein Datentyp mit den m√∂glichen Werten true oder false."
              },
              {
                "type": "explanation",
                "title": "Vergleiche in Bedingungen",
                "text": [
                  "Vergleichsoperatoren werden h√§ufig in if Anweisungen und Schleifen verwendet.",
                  "Das Ergebnis entscheidet √ºber den weiteren Programmfluss."
                ]
              },
              {
                "type": "code",
                "title": "Vergleich in einer Bedingung",
                "language": "cpp",
                "code": "if (a >= 0)\n{\n    std::cout << \"positiv\";\n}"
              },
              {
                "type": "definition",
                "term": "Vergleich von Gleitkommazahlen",
                "text": "Der direkte Vergleich von Gleitkommazahlen kann wegen Rundungsfehlern problematisch sein."
              },
              {
                "type": "pitfall",
                "title": "== statt =",
                "text": "Das Verwechseln von Zuweisung und Vergleich f√ºhrt zu logischen Fehlern."
              },
              {
                "type": "important",
                "text": "Vergleichsoperatoren liefern immer einen booleschen Wert."
              },
              {
                "type": "summary",
                "points": [
                  "Vergleichsoperatoren pr√ºfen Beziehungen zwischen Werten",
                  "Das Ergebnis ist immer true oder false",
                  "Sie steuern Bedingungen und Schleifen",
                  "Besondere Vorsicht bei Gleitkommazahlen"
                ]
              }
            ]
          },
          {
            "title": "Logische Operatoren ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Logischer Operator",
                "text": "Ein Operator zur logischen Verkn√ºpfung oder Negation boolescher Ausdr√ºcke."
              },
              {
                "type": "list",
                "title": "Grundlegende logische Operatoren",
                "items": [
                  "&&: logisches UND",
                  "||: logisches ODER",
                  "!: logisches NICHT"
                ]
              },
              {
                "type": "code",
                "title": "Logische Operatoren Beispiel",
                "language": "cpp",
                "code": "bool a = true;\nbool b = false;\nbool r1 = a && b;\nbool r2 = a || b;\nbool r3 = !a;"
              },
              {
                "type": "definition",
                "term": "Kurzschlussauswertung",
                "text": "Der zweite Operand wird nur ausgewertet, wenn das Ergebnis noch beeinflusst werden kann."
              },
              {
                "type": "explanation",
                "title": "Kurzschlussverhalten",
                "text": [
                  "Bei && wird der zweite Ausdruck nur gepr√ºft, wenn der erste true ist.",
                  "Bei || wird der zweite Ausdruck nur gepr√ºft, wenn der erste false ist."
                ]
              },
              {
                "type": "code",
                "title": "Kurzschluss Beispiel",
                "language": "cpp",
                "code": "if (ptr != nullptr && ptr->value > 0)\n{\n}"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Bestimmt die Reihenfolge, in der logische Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Priorit√§t und Klammern",
                "text": [
                  "! wird vor && ausgewertet.",
                  "&& wird vor || ausgewertet. Klammern erh√∂hen die Lesbarkeit."
                ]
              },
              {
                "type": "code",
                "title": "Priorit√§t Beispiel",
                "language": "cpp",
                "code": "bool r = !a || b && a;\nbool r2 = (!a || b) && a;"
              },
              {
                "type": "pitfall",
                "title": "Bitweise mit logischen Operatoren verwechseln",
                "text": "& und | sind bitweise Operatoren und nicht gleichbedeutend mit && und ||."
              },
              {
                "type": "important",
                "text": "Logische Operatoren arbeiten mit booleschen Ausdr√ºcken und nutzen Kurzschlussauswertung."
              },
              {
                "type": "summary",
                "points": [
                  "&&, || und ! verkn√ºpfen boolesche Ausdr√ºcke",
                  "Kurzschlussauswertung verhindert unn√∂tige Auswertungen",
                  "Operatorpriorit√§t beachten oder Klammern setzen",
                  "Nicht mit bitweisen Operatoren verwechseln"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          {
            "title": "const Variablen ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const",
                "text": "const kennzeichnet Werte oder Objekte, die nach ihrer Initialisierung nicht mehr ver√§ndert werden d√ºrfen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const",
                "text": [
                  "const dient dazu, unbeabsichtigte √Ñnderungen zu verhindern und Code verst√§ndlicher zu machen.",
                  "Der Compiler erzwingt die Unver√§nderlichkeit zur √úbersetzungszeit."
                ]
              },
              {
                "type": "code",
                "title": "const Variable",
                "language": "cpp",
                "code": "const int maxValue = 10;"
              },
              {
                "type": "definition",
                "term": "const Initialisierung",
                "text": "const Variablen m√ºssen beim Erzeugen initialisiert werden."
              },
              {
                "type": "pitfall",
                "title": "Fehlende Initialisierung",
                "text": "const Variablen ohne Initialisierung f√ºhren zu Compilerfehlern."
              },
              {
                "type": "definition",
                "term": "const Referenz",
                "text": "Eine Referenz, √ºber die das referenzierte Objekt nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenz Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nconst int& r = x;"
              },
              {
                "type": "definition",
                "term": "const Zeiger",
                "text": "Je nach Position von const kann der Zeiger selbst oder das Ziel unver√§nderlich sein."
              },
              {
                "type": "code",
                "title": "const und Zeiger",
                "language": "cpp",
                "code": "int x = 1;\nconst int* p1 = &x; // Zeiger auf konstante Daten\nint* const p2 = &x; // Konstanter Zeiger auf Daten\nconst int* const p3 = &x; // Beides konstant"
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die den Zustand des Objekts nicht ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "const Memberfunktion Beispiel",
                "language": "cpp",
                "code": "class A {\n    int v;\npublic:\n    int get() const { return v; }\n};"
              },
              {
                "type": "important",
                "text": "const ist ein zentrales Werkzeug f√ºr sicheren und gut wartbaren C++ Code."
              },
              {
                "type": "summary",
                "points": [
                  "const verhindert unbeabsichtigte √Ñnderungen",
                  "const Variablen m√ºssen initialisiert werden",
                  "const kann auf Objekte, Referenzen, Zeiger und Funktionen angewendet werden",
                  "const Memberfunktionen garantieren unver√§nderten Objektzustand"
                ]
              }
            ]
          },
          {
            "title": "const Parameter ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Parameter",
                "text": "Ein Funktionsparameter, der innerhalb der Funktion nicht ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Warum const Parameter verwenden",
                "text": [
                  "const Parameter verhindern unbeabsichtigte √Ñnderungen an √ºbergebenen Werten.",
                  "Sie machen Funktionsschnittstellen klarer und sicherer, besonders bei Referenzen und Zeigern."
                ]
              },
              {
                "type": "code",
                "title": "const Wertparameter",
                "language": "cpp",
                "code": "void print(const int x)\n{\n    // x darf hier nicht ver√§ndert werden\n    // x = 5; // Compilerfehler\n}"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Parameter, der per Referenz √ºbergeben wird, aber nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter Beispiel",
                "language": "cpp",
                "code": "void print(const std::string& text)\n{\n    // text wird nicht kopiert\n    // text.clear(); // Compilerfehler\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Vorteile von const Referenzen",
                "text": [
                  "Vermeidet unn√∂tige Kopien gro√üer Objekte.",
                  "Garantiert, dass die Funktion das Objekt nicht ver√§ndert."
                ]
              },
              {
                "type": "definition",
                "term": "const Zeigerparameter",
                "text": "Bei Zeigerparametern kann entweder das Ziel oder der Zeiger selbst als const markiert werden."
              },
              {
                "type": "code",
                "title": "const Zeigerparameter Beispiel",
                "language": "cpp",
                "code": "void read(const int* ptr)\n{\n    // *ptr darf nicht ver√§ndert werden\n    // *ptr = 10; // Compilerfehler\n}\n\nvoid move(int* const ptr)\n{\n    // ptr darf nicht neu gesetzt werden\n    // ptr = nullptr; // Compilerfehler\n}"
              },
              {
                "type": "pitfall",
                "title": "const vergessen",
                "text": "Fehlendes const bei Parametern kann unn√∂tige Einschr√§nkungen f√ºr Aufrufer verursachen."
              },
              {
                "type": "important",
                "text": "const Parameter sind ein Versprechen der Funktion an den Aufrufer."
              },
              {
                "type": "summary",
                "points": [
                  "const Parameter verhindern √Ñnderungen innerhalb der Funktion",
                  "const Referenzen sind effizient und sicher",
                  "Bei Zeigern bestimmt die Position von const die Bedeutung",
                  "const verbessert Lesbarkeit und API Design"
                ]
              }
            ]
          },
          {
            "title": "const Klassenmember ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Klassenmember",
                "text": "Ein Datenmember einer Klasse, dessen Wert nach der Initialisierung nicht mehr ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const Membern",
                "text": [
                  "const Member repr√§sentieren feste Eigenschaften eines Objekts, die sich w√§hrend der Lebensdauer nicht √§ndern sollen.",
                  "Der Compiler erzwingt, dass diese Member nicht neu zugewiesen werden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierungsliste",
                "text": "Mechanismus zum Initialisieren von Klassenmembern beim Erzeugen eines Objekts."
              },
              {
                "type": "code",
                "title": "const Member und Initialisierungsliste",
                "language": "cpp",
                "code": "class User {\nprivate:\n    const int id; // darf nach Konstruktion nicht ge√§ndert werden\n\npublic:\n    User(int idValue) : id(idValue) {}\n\n    int getId() const {\n        return id; // Lesen erlaubt\n    }\n};"
              },
              {
                "type": "pitfall",
                "title": "Zuweisung im Konstruktor",
                "text": "const Member k√∂nnen nicht im Konstruktorrumpf zugewiesen werden, sondern nur in der Initialisierungsliste."
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die garantiert, dass sie keine nicht-const Member ver√§ndert."
              },
              {
                "type": "code",
                "title": "const Memberfunktion und Zugriff",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    int get() const {\n        // value++;\n        // nicht erlaubt, da Funktion const ist\n        return value;\n    }\n\n    void increment() {\n        value++; // erlaubt, Funktion ist nicht const\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Zusammenspiel von const Membern und Funktionen",
                "text": [
                  "const Memberfunktionen d√ºrfen nur const Member oder lesenden Zugriff verwenden.",
                  "Nicht-const Memberfunktionen d√ºrfen alle Member ver√§ndern."
                ]
              },
              {
                "type": "important",
                "text": "const Member m√ºssen immer √ºber die Initialisierungsliste gesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "const Klassenmember sind nach der Konstruktion unver√§nderlich",
                  "Sie m√ºssen in der Initialisierungsliste gesetzt werden",
                  "const Memberfunktionen d√ºrfen den Objektzustand nicht √§ndern",
                  "const verbessert Korrektheit und Objektmodellierung"
                ]
              }
            ]
          },
          {
            "title": "const √úberladung ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const √úberladung",
                "text": "Eine Form der Funktions√ºberladung, bei der sich Funktionen nur durch const unterscheiden."
              },
              {
                "type": "explanation",
                "title": "Grundidee der const √úberladung",
                "text": [
                  "const √úberladung wird fast ausschlie√ülich bei Memberfunktionen verwendet.",
                  "Je nach const Zustand des Objekts wird eine andere Funktionsversion aufgerufen."
                ]
              },
              {
                "type": "definition",
                "term": "const Objekt",
                "text": "Ein Objekt, das als const deklariert wurde und nur const Memberfunktionen aufrufen darf."
              },
              {
                "type": "code",
                "title": "const √úberladung bei Memberfunktionen",
                "language": "cpp",
                "code": "class Box {\nprivate:\n    int value;\n\npublic:\n    Box(int v) : value(v) {}\n\n    int& get() {\n        // wird bei nicht-const Objekten aufgerufen\n        return value;\n    }\n\n    const int& get() const {\n        // wird bei const Objekten aufgerufen\n        return value;\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Bei einem nicht-const Objekt wird die nicht-const Version bevorzugt.",
                  "Bei einem const Objekt ist nur die const Version erlaubt."
                ]
              },
              {
                "type": "code",
                "title": "Aufruf der √ºberladenen Funktionen",
                "language": "cpp",
                "code": "Box b(5);\nb.get() = 10; // erlaubt, nicht-const Version\n\nconst Box cb(7);\nint x = cb.get(); // nur const Version m√∂glich"
              },
              {
                "type": "pitfall",
                "title": "Fehlende const Version",
                "text": "Ohne const √ºberladene Memberfunktion k√∂nnen const Objekte wichtige Funktionen nicht nutzen."
              },
              {
                "type": "important",
                "text": "const √úberladung erh√∂ht Korrektheit und Flexibilit√§t von Klassen."
              },
              {
                "type": "summary",
                "points": [
                  "const √úberladung unterscheidet Funktionen nach const",
                  "Sie wird haupts√§chlich bei Memberfunktionen eingesetzt",
                  "const Objekte d√ºrfen nur const Funktionen aufrufen",
                  "Nicht-const Objekte nutzen bevorzugt nicht-const Versionen"
                ]
              }
            ]
          },
          {
            "title": "constexpr ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "constexpr",
                "text": "constexpr kennzeichnet Ausdr√ºcke, Variablen oder Funktionen, die zur Compilezeit ausgewertet werden k√∂nnen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von constexpr",
                "text": [
                  "constexpr erm√∂glicht es, Berechnungen bereits zur Compilezeit durchzuf√ºhren.",
                  "Dadurch werden Programme effizienter und sicherer, da Fehler fr√ºher erkannt werden."
                ]
              },
              {
                "type": "definition",
                "term": "constexpr Variable",
                "text": "Eine Variable, deren Wert zur Compilezeit bekannt sein muss."
              },
              {
                "type": "code",
                "title": "constexpr Variable Beispiel",
                "language": "cpp",
                "code": "constexpr int maxSize = 100; // Wert ist zur Compilezeit festgelegt"
              },
              {
                "type": "definition",
                "term": "constexpr Funktion",
                "text": "Eine Funktion, die bei konstanten Argumenten zur Compilezeit ausgewertet werden kann."
              },
              {
                "type": "code",
                "title": "constexpr Funktion Beispiel",
                "language": "cpp",
                "code": "constexpr int square(int x)\n{\n    return x * x;\n}\n\nconstexpr int value = square(5); // Compilezeit"
              },
              {
                "type": "explanation",
                "title": "Compilezeit vs. Laufzeit",
                "text": [
                  "constexpr Funktionen k√∂nnen sowohl zur Compilezeit als auch zur Laufzeit ausgef√ºhrt werden.",
                  "Ob Compilezeit oder Laufzeit entscheidet der Kontext der Verwendung."
                ]
              },
              {
                "type": "code",
                "title": "constexpr zur Laufzeit",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;\nint y = square(x); // Laufzeit, da x nicht konstant ist"
              },
              {
                "type": "comparison",
                "title": "const vs. constexpr",
                "columns": ["const", "constexpr"],
                "rows": [
                  {
                    "aspect": "Zeitpunkt der Auswertung",
                    "values": ["Laufzeit oder Compilezeit", "Immer Compilezeit m√∂glich"]
                  },
                  {
                    "aspect": "Einsatz",
                    "values": ["Unver√§nderlichkeit", "Konstante Ausdr√ºcke"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "constexpr mit nicht-konstanten Werten",
                "text": "constexpr erfordert zur Compilezeit bekannte Werte, sonst schl√§gt die √úbersetzung fehl."
              },
              {
                "type": "important",
                "text": "constexpr ist st√§rker als const und erm√∂glicht echte Compilezeit-Berechnungen."
              },
              {
                "type": "summary",
                "points": [
                  "constexpr erzwingt Compilezeit-Auswertbarkeit",
                  "constexpr Variablen sind echte Konstanten",
                  "constexpr Funktionen k√∂nnen auch zur Laufzeit genutzt werden",
                  "constexpr erh√∂ht Effizienz und Typsicherheit"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          {
            "title": "std::cout",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cout",
                "text": "std::cout ist der Standard-Ausgabestream in C++ zur Ausgabe von Text und Werten auf die Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cout",
                "text": [
                  "std::cout schreibt Daten in den Standard-Output, der in der Regel das Terminal ist.",
                  "Die Ausgabe erfolgt √ºber den Einf√ºgeoperator << und kann verkettet werden."
                ]
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Operator, mit dem Werte in einen Ausgabestream geschrieben werden."
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe",
                "language": "cpp",
                "code": "int x = 5;\nstd::cout << x; // gibt 5 auf der Konsole aus"
              },
              {
                "type": "explanation",
                "title": "Verkettete Ausgabe",
                "text": [
                  "Mehrere Werte k√∂nnen hintereinander ausgegeben werden.",
                  "Die Operatoren werden von links nach rechts ausgewertet."
                ]
              },
              {
                "type": "code",
                "title": "Verkettung mit Text",
                "language": "cpp",
                "code": "int a = 3;\nint b = 4;\nstd::cout << \"a = \" << a << \", b = \" << b; // kombinierte Ausgabe"
              },
              {
                "type": "definition",
                "term": "std::endl",
                "text": "Gibt einen Zeilenumbruch aus und leert zus√§tzlich den Ausgabepuffer."
              },
              {
                "type": "code",
                "title": "Zeilenumbruch",
                "language": "cpp",
                "code": "std::cout << \"Hallo\" << std::endl; // neue Zeile und flush"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Ausgaben werden zwischengespeichert und nicht sofort angezeigt."
              },
              {
                "type": "comparison",
                "title": "std::endl vs. '\\n'",
                "columns": ["std::endl", "\\n"],
                "rows": [
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Ja", "Ja"]
                  },
                  {
                    "aspect": "Flush",
                    "values": ["Ja", "Nein"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Unn√∂tiger Einsatz von std::endl",
                "text": "H√§ufiges std::endl kann Programme deutlich verlangsamen, da jedes Mal geflusht wird."
              },
              {
                "type": "important",
                "text": "std::cout ist ein gepufferter Stream und arbeitet mit dem Operator <<."
              },
              {
                "type": "summary",
                "points": [
                  "std::cout dient zur Standardausgabe",
                  "Ausgabe erfolgt mit dem Operator <<",
                  "Mehrere Ausgaben k√∂nnen verkettet werden",
                  "std::endl erzeugt Zeilenumbruch und Flush",
                  "\\n ist meist effizienter als std::endl"
                ]
              }
            ]
          },
          {
            "title": "std::cin",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cin",
                "text": "std::cin ist der Standard-Eingabestream in C++ zum Einlesen von Daten aus der Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cin",
                "text": [
                  "std::cin liest Daten aus dem Standard-Input, meist der Tastatur.",
                  "Das Einlesen erfolgt mit dem Extraktionsoperator >> und ist typabh√§ngig."
                ]
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Operator, mit dem Werte aus einem Eingabestream gelesen werden."
              },
              {
                "type": "code",
                "title": "Einfache Eingabe",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x; // liest eine Ganzzahl von der Konsole"
              },
              {
                "type": "explanation",
                "title": "Mehrere Werte einlesen",
                "text": [
                  "Mehrere Eingaben k√∂nnen in einer Anweisung verkettet werden.",
                  "Die Werte werden in der angegebenen Reihenfolge gelesen."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Eingabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b; // liest zwei Ganzzahlen"
              },
              {
                "type": "definition",
                "term": "Whitespace-Verhalten",
                "text": "std::cin √ºberspringt f√ºhrende Leerzeichen, Tabs und Zeilenumbr√ºche."
              },
              {
                "type": "code",
                "title": "Eingabe von Text",
                "language": "cpp",
                "code": "std::string name;\nstd::cin >> name; // liest bis zum n√§chsten Leerzeichen"
              },
              {
                "type": "definition",
                "term": "Stream-Zustand",
                "text": "Interner Status eines Streams, der angibt, ob die letzte Eingabe erfolgreich war."
              },
              {
                "type": "code",
                "title": "Eingabe pr√ºfen",
                "language": "cpp",
                "code": "int value;\nif (std::cin >> value) {\n    // Eingabe war erfolgreich\n}"
              },
              {
                "type": "pitfall",
                "title": "Fehlerhafte Eingaben",
                "text": "Ung√ºltige Eingaben setzen den Stream in einen Fehlerzustand und blockieren weitere Lesevorg√§nge."
              },
              {
                "type": "important",
                "text": "std::cin ist typabh√§ngig und nutzt den Operator >> zum Einlesen."
              },
              {
                "type": "summary",
                "points": [
                  "std::cin liest Daten von der Konsole",
                  "Eingabe erfolgt mit dem Operator >>",
                  "Whitespace wird automatisch √ºbersprungen",
                  "Der Stream-Zustand sollte gepr√ºft werden",
                  "Ung√ºltige Eingaben k√∂nnen weitere Eingaben verhindern"
                ]
              }
            ]
          },
          {
            "title": "std::getline",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::getline",
                "text": "std::getline liest eine komplette Zeile aus einem Eingabestream bis zum Zeilenumbruch."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::getline",
                "text": [
                  "std::getline eignet sich zum Einlesen von Texten mit Leerzeichen.",
                  "Der Zeilenumbruch wird gelesen, aber nicht im Ergebnis gespeichert."
                ]
              },
              {
                "type": "definition",
                "term": "Zeilenweises Einlesen",
                "text": "Einleseform, bei der der gesamte Inhalt bis zum Zeilenende √ºbernommen wird."
              },
              {
                "type": "code",
                "title": "Einfache Verwendung von std::getline",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(std::cin, line); // liest eine komplette Zeile"
              },
              {
                "type": "explanation",
                "title": "Unterschied zu std::cin >>",
                "text": [
                  "std::cin >> liest nur bis zum n√§chsten Leerzeichen.",
                  "std::getline liest die gesamte Zeile inklusive Leerzeichen."
                ]
              },
              {
                "type": "comparison",
                "title": "std::getline vs. std::cin >>",
                "columns": ["std::getline", "std::cin >>"],
                "rows": [
                  {
                    "aspect": "Leerzeichen",
                    "values": ["Werden mitgelesen", "Beenden die Eingabe"]
                  },
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Beendet das Lesen", "Wird √ºbersprungen"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "std::getline nach std::cin >>",
                "text": "Nach einer >> Eingabe bleibt der Zeilenumbruch im Stream und wird von getline sofort gelesen."
              },
              {
                "type": "code",
                "title": "Korrekte Kombination von cin und getline",
                "language": "cpp",
                "code": "int age;\nstd::cin >> age;\nstd::cin.ignore(); // entfernt den Zeilenumbruch\n\nstd::string name;\nstd::getline(std::cin, name); // liest den Namen korrekt"
              },
              {
                "type": "important",
                "text": "std::getline ist die richtige Wahl f√ºr ganze Textzeilen."
              },
              {
                "type": "summary",
                "points": [
                  "std::getline liest komplette Zeilen",
                  "Leerzeichen sind Teil der Eingabe",
                  "Unterschiedliches Verhalten zu std::cin >>",
                  "Nach >> muss oft ignore verwendet werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          {
            "title": "std::ifstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ifstream",
                "text": "std::ifstream ist ein Eingabestream zum Lesen von Daten aus Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ifstream",
                "text": [
                  "std::ifstream funktioniert √§hnlich wie std::cin, liest seine Daten aber aus einer Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Input verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Dateistream",
                "text": "Ein Stream, der Daten aus einer Datei liest oder in eine Datei schreibt."
              },
              {
                "type": "code",
                "title": "Datei √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ifstream file(\"data.txt\"); // √∂ffnet Datei zum Lesen"
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "√ñffnen pr√ºfen",
                "language": "cpp",
                "code": "std::ifstream file(\"data.txt\");\nif (!file) {\n    // Datei konnte nicht ge√∂ffnet werden\n}"
              },
              {
                "type": "explanation",
                "title": "Lesen aus einer Datei",
                "text": [
                  "Das Lesen aus ifstream erfolgt mit denselben Operatoren wie bei std::cin.",
                  "Auch std::getline kann f√ºr zeilenweises Lesen verwendet werden."
                ]
              },
              {
                "type": "code",
                "title": "Lesen mit >>",
                "language": "cpp",
                "code": "int x;\nfile >> x; // liest eine Ganzzahl aus der Datei"
              },
              {
                "type": "code",
                "title": "Zeilenweise lesen",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(file, line); // liest eine Zeile aus der Datei"
              },
              {
                "type": "definition",
                "term": "End of File",
                "text": "Zustand, der erreicht wird, wenn keine weiteren Daten in der Datei vorhanden sind."
              },
              {
                "type": "code",
                "title": "Lesen bis Dateiende",
                "language": "cpp",
                "code": "std::string line;\nwhile (std::getline(file, line)) {\n    // verarbeitet jede Zeile der Datei\n}"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der √ñffnungszustand nicht gepr√ºft, kann es zu undefiniertem Programmverhalten kommen."
              },
              {
                "type": "important",
                "text": "std::ifstream sollte immer auf erfolgreiches √ñffnen gepr√ºft werden."
              },
              {
                "type": "summary",
                "points": [
                  "std::ifstream liest Daten aus Dateien",
                  "Er wird √ºber <fstream> eingebunden",
                  "Lesen erfolgt wie bei std::cin",
                  "std::getline eignet sich f√ºr zeilenweises Lesen",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::ofstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ofstream",
                "text": "std::ofstream ist ein Ausgabestream zum Schreiben von Daten in Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ofstream",
                "text": [
                  "std::ofstream funktioniert √§hnlich wie std::cout, schreibt seine Ausgabe aber in eine Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Output verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei zum Schreiben mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "Datei zum Schreiben √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ofstream file(\"output.txt\"); // erstellt oder √ºberschreibt die Datei"
              },
              {
                "type": "definition",
                "term": "√úberschreiben",
                "text": "Standardverhalten von ofstream, bei dem vorhandene Dateiinhalte gel√∂scht werden."
              },
              {
                "type": "definition",
                "term": "Anh√§ngen",
                "text": "Schreiben neuer Daten ans Ende einer bestehenden Datei."
              },
              {
                "type": "code",
                "title": "Dateiinhalt anh√§ngen",
                "language": "cpp",
                "code": "std::ofstream file(\"output.txt\", std::ios::app); // schreibt ans Dateiende"
              },
              {
                "type": "explanation",
                "title": "Schreiben in eine Datei",
                "text": [
                  "Das Schreiben erfolgt mit dem Einf√ºgeoperator << wie bei std::cout.",
                  "Es k√∂nnen beliebige ausgabef√§hige Datentypen geschrieben werden."
                ]
              },
              {
                "type": "code",
                "title": "Schreiben mit <<",
                "language": "cpp",
                "code": "file << \"Ergebnis: \" << 42 << '\\n'; // schreibt Text und Zahl in die Datei"
              },
              {
                "type": "definition",
                "term": "Datei schlie√üen",
                "text": "Beendet die Verbindung zwischen Stream und Datei und schreibt den Puffer."
              },
              {
                "type": "code",
                "title": "Datei schlie√üen",
                "language": "cpp",
                "code": "file.close(); // optional, erfolgt auch automatisch"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der Stream nicht gepr√ºft, kann das Schreiben fehlschlagen, ohne dass es bemerkt wird."
              },
              {
                "type": "important",
                "text": "std::ofstream √ºberschreibt Dateien standardm√§√üig, wenn kein Modus angegeben wird."
              },
              {
                "type": "summary",
                "points": [
                  "std::ofstream schreibt Daten in Dateien",
                  "Standardm√§√üig wird die Datei √ºberschrieben",
                  "Anh√§ngen erfolgt mit std::ios::app",
                  "Schreiben erfolgt mit dem Operator <<",
                  "Streams sollten auf Fehler gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::fstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::fstream",
                "text": "std::fstream ist ein Dateistream, der sowohl Lesen als auch Schreiben in einer Datei erlaubt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::fstream",
                "text": [
                  "std::fstream kombiniert die Funktionalit√§t von std::ifstream und std::ofstream.",
                  "Er wird verwendet, wenn eine Datei sowohl gelesen als auch beschrieben werden soll."
                ]
              },
              {
                "type": "definition",
                "term": "√ñffnungsmodus",
                "text": "Ein Modus, der festlegt, wie eine Datei ge√∂ffnet wird, zum Beispiel zum Lesen oder Schreiben."
              },
              {
                "type": "list",
                "title": "H√§ufige √ñffnungsmodi",
                "items": [
                  "std::ios::in: Datei lesen",
                  "std::ios::out: Datei schreiben",
                  "std::ios::app: ans Dateiende schreiben",
                  "std::ios::trunc: Dateiinhalt l√∂schen",
                  "std::ios::binary: Bin√§rmodus"
                ]
              },
              {
                "type": "code",
                "title": "Datei mit fstream √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::fstream file(\"data.txt\", std::ios::in | std::ios::out);"
              },
              {
                "type": "definition",
                "term": "Lese- und Schreibzugriff",
                "text": "Die M√∂glichkeit, Daten aus derselben Datei zu lesen und in sie zu schreiben."
              },
              {
                "type": "code",
                "title": "Lesen und Schreiben",
                "language": "cpp",
                "code": "int x;\nfile >> x;          // liest aus der Datei\nfile << x * 2;      // schreibt in die Datei"
              },
              {
                "type": "definition",
                "term": "Dateiposition",
                "text": "Die aktuelle Lese- oder Schreibposition innerhalb der Datei."
              },
              {
                "type": "explanation",
                "title": "Dateiposition und Zeiger",
                "text": [
                  "fstream besitzt einen Lesezeiger und einen Schreibzeiger.",
                  "Diese k√∂nnen unabh√§ngig voneinander verschoben werden."
                ]
              },
              {
                "type": "explanation",
                "title": "Was ist die Dateiposition",
                "text": [
                  "Die Dateiposition beschreibt die aktuelle Stelle in der Datei, an der gelesen oder geschrieben wird.",
                  "Bei std::fstream gibt es getrennte Positionen f√ºr Lesen und Schreiben."
                ]
              },
              {
                "type": "definition",
                "term": "Lesezeiger",
                "text": "Interne Position, von der aus der n√§chste Lesevorgang beginnt."
              },
              {
                "type": "definition",
                "term": "Schreibzeiger",
                "text": "Interne Position, an der der n√§chste Schreibvorgang erfolgt."
              },
              {
                "type": "definition",
                "term": "tellg",
                "text": "Gibt die aktuelle Position des Lesezeigers zur√ºck."
              },
              {
                "type": "definition",
                "term": "tellp",
                "text": "Gibt die aktuelle Position des Schreibzeigers zur√ºck."
              },
              {
                "type": "code",
                "title": "Aktuelle Dateiposition abfragen",
                "language": "cpp",
                "code": "std::fstream file(\"data.txt\", std::ios::in | std::ios::out);\n\nstd::streampos readPos = file.tellg(); // aktuelle Leseposition\nstd::streampos writePos = file.tellp(); // aktuelle Schreibposition"
              },
              {
                "type": "definition",
                "term": "seekg",
                "text": "Setzt die Position des Lesezeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "definition",
                "term": "seekp",
                "text": "Setzt die Position des Schreibzeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "code",
                "title": "Dateiposition ver√§ndern",
                "language": "cpp",
                "code": "file.seekg(0);          // Lesezeiger an den Anfang der Datei\nfile.seekp(0);          // Schreibzeiger an den Anfang der Datei"
              },
              {
                "type": "explanation",
                "title": "Relative Positionierung",
                "text": [
                  "Die Dateiposition kann relativ zu bestimmten Referenzpunkten gesetzt werden.",
                  "Typische Referenzen sind Anfang, aktuelle Position und Dateiende."
                ]
              },
              {
                "type": "code",
                "title": "Relative Dateiposition",
                "language": "cpp",
                "code": "file.seekg(10, std::ios::beg); // 10 Bytes ab Dateianfang\nfile.seekg(0, std::ios::cur);  // aktuelle Position\nfile.seekg(-5, std::ios::end); // 5 Bytes vor Dateiende"
              },
              {
                "type": "pitfall",
                "title": "Lesen und Schreiben ohne Positionskontrolle",
                "text": "Ohne bewusstes Setzen der Dateiposition k√∂nnen Lese- und Schreibzugriffe an unerwarteten Stellen erfolgen."
              },
              {
                "type": "important",
                "text": "tellg und seekg steuern das Lesen, tellp und seekp das Schreiben."
              },
              {
                "type": "summary",
                "points": [
                  "Dateiposition bestimmt, wo gelesen oder geschrieben wird",
                  "fstream besitzt getrennte Lese- und Schreibzeiger",
                  "tellg und tellp fragen die aktuelle Position ab",
                  "seekg und seekp ver√§ndern die Position gezielt",
                  "Relative Positionierung ist mit beg, cur und end m√∂glich"
                ]
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger √ñffnungsmodus",
                "text": "Wird eine Datei ohne passenden Modus ge√∂ffnet, k√∂nnen Lese- oder Schreiboperationen fehlschlagen."
              },
              {
                "type": "important",
                "text": "std::fstream eignet sich f√ºr kombinierten Lese- und Schreibzugriff auf Dateien."
              },
              {
                "type": "summary",
                "points": [
                  "std::fstream vereint ifstream und ofstream",
                  "√ñffnungsmodi steuern das Dateiverhalten",
                  "Lesen und Schreiben sind in derselben Datei m√∂glich",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          {
            "title": "if / else",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "if Anweisung",
                "text": "Eine Kontrollstruktur, die Code nur dann ausf√ºhrt, wenn eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee von if und else",
                "text": [
                  "Mit if wird eine Bedingung gepr√ºft, die einen booleschen Wert liefert.",
                  "Mit else kann ein alternativer Codepfad definiert werden, falls die Bedingung false ist."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches if Beispiel",
                "language": "cpp",
                "code": "int x = 5;\n\nif (x > 0) {\n    // wird ausgef√ºhrt, wenn x gr√∂√üer als 0 ist\n}"
              },
              {
                "type": "definition",
                "term": "else",
                "text": "Erg√§nzt ein if um einen Codeblock, der ausgef√ºhrt wird, wenn die Bedingung false ist."
              },
              {
                "type": "code",
                "title": "if else Beispiel",
                "language": "cpp",
                "code": "int x = -3;\n\nif (x >= 0) {\n    // x ist nicht negativ\n} else {\n    // x ist negativ\n}"
              },
              {
                "type": "definition",
                "term": "else if",
                "text": "Erm√∂glicht das Pr√ºfen mehrerer Bedingungen nacheinander."
              },
              {
                "type": "code",
                "title": "else if Kette",
                "language": "cpp",
                "code": "int value = 10;\n\nif (value < 0) {\n    // negativ\n} else if (value == 0) {\n    // null\n} else {\n    // positiv\n}"
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Ein Ausdruck, der zu true oder false ausgewertet wird."
              },
              {
                "type": "explanation",
                "title": "Bedingungen formulieren",
                "text": [
                  "Bedingungen bestehen meist aus Vergleichs- und logischen Operatoren.",
                  "Komplexe Bedingungen k√∂nnen mit &&, || und ! kombiniert werden."
                ]
              },
              {
                "type": "code",
                "title": "Komplexe Bedingung",
                "language": "cpp",
                "code": "int age = 20;\nbool hasTicket = true;\n\nif (age >= 18 && hasTicket) {\n    // Zutritt erlaubt\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergleich mit = statt ==",
                "text": "Die Verwendung von = statt == in einer Bedingung f√ºhrt zu logischen Fehlern oder Warnungen."
              },
              {
                "type": "important",
                "text": "Die Bedingung in if muss immer einen booleschen Wert liefern."
              },
              {
                "type": "summary",
                "points": [
                  "if steuert bedingte Programmausf√ºhrung",
                  "else definiert einen alternativen Pfad",
                  "else if erlaubt mehrere Bedingungen",
                  "Bedingungen basieren auf Vergleichen und logischen Operatoren",
                  "Sorgf√§ltige Formulierung vermeidet logische Fehler"
                ]
              }
            ]
          },
          {
            "title": "switch",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "switch Anweisung",
                "text": "Eine Kontrollstruktur zur Auswahl eines Codepfads basierend auf dem Wert eines Ausdrucks."
              },
              {
                "type": "explanation",
                "title": "Grundidee von switch",
                "text": [
                  "switch vergleicht einen Ausdruck mit mehreren festen Werten.",
                  "Je nach Treffer wird der zugeh√∂rige Codeblock ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "case",
                "text": "Ein m√∂glicher Vergleichswert innerhalb einer switch Anweisung."
              },
              {
                "type": "definition",
                "term": "default",
                "text": "Ein optionaler Zweig, der ausgef√ºhrt wird, wenn kein case passt."
              },
              {
                "type": "code",
                "title": "Einfaches switch Beispiel",
                "language": "cpp",
                "code": "int day = 3;\n\nswitch (day) {\ncase 1:\n    // Montag\n    break;\ncase 2:\n    // Dienstag\n    break;\ncase 3:\n    // Mittwoch\n    break;\ndefault:\n    // Ung√ºltiger Tag\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "break",
                "text": "Beendet einen case Block und verhindert das Weiterlaufen in den n√§chsten case."
              },
              {
                "type": "explanation",
                "title": "Fallthrough",
                "text": [
                  "Ohne break wird der Code im n√§chsten case ebenfalls ausgef√ºhrt.",
                  "Dieses Verhalten nennt man Fallthrough."
                ]
              },
              {
                "type": "code",
                "title": "Fallthrough Beispiel",
                "language": "cpp",
                "code": "int x = 1;\n\nswitch (x) {\ncase 1:\n    // wird ausgef√ºhrt\ncase 2:\n    // wird ebenfalls ausgef√ºhrt\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "switch Ausdruck",
                "text": "Der Ausdruck in switch muss ein ganzzahliger oder enum Typ sein."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes break",
                "text": "Fehlende break Anweisungen f√ºhren oft zu unerwartetem Verhalten."
              },
              {
                "type": "important",
                "text": "switch ist geeignet f√ºr viele feste Vergleichswerte, nicht f√ºr komplexe Bedingungen."
              },
              {
                "type": "summary",
                "points": [
                  "switch w√§hlt Codepfade anhand eines Wertes",
                  "case definiert m√∂gliche Vergleichswerte",
                  "default deckt alle √ºbrigen F√§lle ab",
                  "break verhindert Fallthrough",
                  "switch funktioniert nur mit bestimmten Datentypen"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          {
            "title": "for Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "for Schleife",
                "text": "Eine Schleife, die einen Codeblock eine festgelegte Anzahl von Durchl√§ufen ausf√ºhrt."
              },
              {
                "type": "explanation",
                "title": "Grundidee der for Schleife",
                "text": [
                  "Die for Schleife besteht aus Initialisierung, Bedingung und Schritt.",
                  "Sie eignet sich besonders f√ºr z√§hlbasierte Wiederholungen."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Wird einmal vor dem ersten Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Wird vor jedem Durchlauf gepr√ºft und entscheidet √ºber das Weiterlaufen der Schleife."
              },
              {
                "type": "definition",
                "term": "Schritt",
                "text": "Wird nach jedem Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "code",
                "title": "Klassische for Schleife",
                "language": "cpp",
                "code": "for (int i = 0; i < 5; i++) {\n    // i l√§uft von 0 bis 4\n}"
              },
              {
                "type": "explanation",
                "title": "Ablauf einer for Schleife",
                "text": [
                  "Zuerst wird die Initialisierung ausgef√ºhrt.",
                  "Danach wird vor jedem Durchlauf die Bedingung gepr√ºft und am Ende der Schritt ausgef√ºhrt."
                ]
              },
              {
                "type": "code",
                "title": "for Schleife mit anderer Schrittweite",
                "language": "cpp",
                "code": "for (int i = 0; i <= 10; i += 2) {\n    // i nimmt die Werte 0, 2, 4, 6, 8, 10 an\n}"
              },
              {
                "type": "definition",
                "term": "Bereichsbasierte for Schleife",
                "text": "Moderne for Schleife zum Durchlaufen von Containern und Arrays."
              },
              {
                "type": "code",
                "title": "Bereichsbasierte for Schleife",
                "language": "cpp",
                "code": "int values[] = {1, 2, 3};\n\nfor (int v : values) {\n    // v nimmt nacheinander die Werte 1, 2, 3 an\n}"
              },
              {
                "type": "pitfall",
                "title": "Endlosschleife",
                "text": "Eine falsche Bedingung oder ein fehlender Schritt kann zu einer Endlosschleife f√ºhren."
              },
              {
                "type": "important",
                "text": "for Schleifen eignen sich besonders f√ºr bekannte oder z√§hlbare Wiederholungen."
              },
              {
                "type": "summary",
                "points": [
                  "for Schleifen bestehen aus Initialisierung, Bedingung und Schritt",
                  "Sie sind ideal f√ºr Z√§hlschleifen",
                  "Schrittweite kann frei gew√§hlt werden",
                  "Bereichsbasierte for Schleifen vereinfachen Containerzugriffe",
                  "Sorgf√§ltige Bedingungen verhindern Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "while Schleife",
                "text": "Eine Schleife, die einen Codeblock ausf√ºhrt, solange eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee der while Schleife",
                "text": [
                  "Die Bedingung wird vor jedem Durchlauf gepr√ºft.",
                  "Ist die Bedingung false, wird der Schleifenrumpf nicht ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Kopfgesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung vor dem ersten Durchlauf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\nwhile (i < 5) {\n    // wird ausgef√ºhrt, solange i kleiner als 5 ist\n    i++;\n}"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "while Schleifen werden genutzt, wenn die Anzahl der Durchl√§ufe vorher nicht bekannt ist.",
                  "H√§ufig wird die Schleife durch Benutzereingaben oder Dateiinhalte gesteuert."
                ]
              },
              {
                "type": "code",
                "title": "while mit Eingabe",
                "language": "cpp",
                "code": "int value;\n\nwhile (std::cin >> value) {\n    // l√§uft, solange die Eingabe g√ºltig ist\n}"
              },
              {
                "type": "definition",
                "term": "Endlosschleife",
                "text": "Eine Schleife, deren Bedingung niemals false wird."
              },
              {
                "type": "code",
                "title": "Bewusste Endlosschleife",
                "language": "cpp",
                "code": "while (true) {\n    // l√§uft unendlich\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergessene Zustands√§nderung",
                "text": "Wird die Schleifenbedingung im Rumpf nicht beeinflusst, entsteht unbeabsichtigt eine Endlosschleife."
              },
              {
                "type": "important",
                "text": "Die Schleifenbedingung muss irgendwann false werden, au√üer bei gewollten Endlosschleifen."
              },
              {
                "type": "summary",
                "points": [
                  "while Schleifen pr√ºfen die Bedingung vor jedem Durchlauf",
                  "Sie eignen sich f√ºr unbestimmte Wiederholungen",
                  "Die Bedingung steuert den Programmfluss",
                  "Fehlende Zustands√§nderungen f√ºhren zu Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "do-while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "do while Schleife",
                "text": "Eine Schleife, bei der der Codeblock mindestens einmal ausgef√ºhrt wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee der do while Schleife",
                "text": [
                  "Die Bedingung wird erst nach dem Schleifendurchlauf gepr√ºft.",
                  "Der Schleifenrumpf wird daher immer mindestens einmal ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Fu√ügesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung nach dem Schleifenrumpf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache do while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\ndo {\n    // wird mindestens einmal ausgef√ºhrt\n    i++;\n} while (i < 5);"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "do while wird genutzt, wenn eine Aktion mindestens einmal erfolgen muss.",
                  "H√§ufig bei Men√ºs oder wiederholten Benutzereingaben."
                ]
              },
              {
                "type": "code",
                "title": "do while mit Benutzereingabe",
                "language": "cpp",
                "code": "int choice;\n\ndo {\n    // Men√º anzeigen\n    std::cin >> choice;\n} while (choice != 0);"
              },
              {
                "type": "definition",
                "term": "Unterschied zu while",
                "text": "do while pr√ºft die Bedingung nach dem Durchlauf, while davor."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes Semikolon",
                "text": "Nach der while Bedingung der do while Schleife ist ein Semikolon Pflicht."
              },
              {
                "type": "important",
                "text": "do while garantiert mindestens einen Schleifendurchlauf."
              },
              {
                "type": "summary",
                "points": [
                  "do while ist eine fu√ügesteuerte Schleife",
                  "Der Schleifenrumpf l√§uft mindestens einmal",
                  "Die Bedingung wird am Ende gepr√ºft",
                  "Typisch f√ºr Men√ºs und Eingabeschleifen",
                  "Semikolon nach while nicht vergessen"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          {
            "title": "Funktionsdefinition",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktionsdefinition",
                "text": "Die vollst√§ndige Beschreibung einer Funktion inklusive R√ºckgabetyp, Name, Parameterliste und Funktionsrumpf."
              },
              {
                "type": "explanation",
                "title": "Bestandteile einer Funktionsdefinition",
                "text": [
                  "Eine Funktionsdefinition legt fest, was eine Funktion tut und wie sie implementiert ist.",
                  "Sie besteht aus R√ºckgabetyp, Funktionsname, Parametern und dem Codeblock."
                ]
              },
              {
                "type": "list",
                "title": "Bestandteile",
                "items": [
                  "R√ºckgabetyp",
                  "Funktionsname",
                  "Parameterliste",
                  "Funktionsrumpf"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Funktionsdefinition",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    // addiert zwei Zahlen\n    return a + b;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der Datentyp des Werts, den eine Funktion zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Funktionsname",
                "text": "Bezeichner, unter dem die Funktion aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Parameterliste",
                "text": "Liste von Variablen, √ºber die Werte an die Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "Funktionsrumpf",
                "text": "Der Codeblock, der beim Aufruf der Funktion ausgef√ºhrt wird."
              },
              {
                "type": "definition",
                "term": "void Funktion",
                "text": "Eine Funktion ohne R√ºckgabewert."
              },
              {
                "type": "code",
                "title": "void Funktionsdefinition",
                "language": "cpp",
                "code": "void printHello() {\n    // gibt eine Begr√º√üung aus\n    std::cout << \"Hallo\";\n}"
              },
              {
                "type": "definition",
                "term": "return",
                "text": "Anweisung zum Zur√ºckgeben eines Werts und Beenden der Funktion."
              },
              {
                "type": "pitfall",
                "title": "Fehlender return",
                "text": "Nicht-void Funktionen m√ºssen in allen F√§llen einen Wert zur√ºckgeben."
              },
              {
                "type": "important",
                "text": "Die Funktionsdefinition legt das Verhalten fest, die Deklaration nur die Schnittstelle."
              },
              {
                "type": "summary",
                "points": [
                  "Eine Funktionsdefinition beschreibt das Verhalten einer Funktion",
                  "Sie besteht aus R√ºckgabetyp, Name, Parametern und Rumpf",
                  "void Funktionen liefern keinen Wert zur√ºck",
                  "return beendet die Funktion und gibt einen Wert zur√ºck"
                ]
              }
            ]
          },
          {
            "title": "Parameter & R√ºckgabe",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Variablen in der Funktionsdefinition, √ºber die Werte an eine Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung an den Aufrufer zur√ºckliefert."
              },
              {
                "type": "explanation",
                "title": "√úbersicht der √úbergabearten",
                "text": [
                  "C++ unterscheidet zwischen √úbergabe per Wert, per Referenz und per Zeiger.",
                  "Die Wahl beeinflusst Performance, Sicherheit und √Ñnderbarkeit der Daten."
                ]
              },
              {
                "type": "definition",
                "term": "√úbergabe per Wert",
                "text": "Der Parameter erh√§lt eine Kopie des √ºbergebenen Werts."
              },
              {
                "type": "code",
                "title": "Parameter per Wert",
                "language": "cpp",
                "code": "void setToZero(int x) {\n    x = 0; // √§ndert nur die Kopie\n}\n\nint a = 5;\nsetToZero(a); // a bleibt 5"
              },
              {
                "type": "definition",
                "term": "√úbergabe per Referenz",
                "text": "Der Parameter ist ein Alias f√ºr die √ºbergebene Variable."
              },
              {
                "type": "code",
                "title": "Parameter per Referenz",
                "language": "cpp",
                "code": "void setToZero(int& x) {\n    x = 0; // √§ndert die Originalvariable\n}\n\nint a = 5;\nsetToZero(a); // a wird 0"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert und nicht ver√§ndert\n    std::cout << text;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Wert",
                "text": "Die Funktion gibt eine Kopie des Ergebnisses zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Wert",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b; // R√ºckgabe einer Kopie\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Referenz",
                "text": "Die Funktion gibt eine Referenz auf ein existierendes Objekt zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Referenz",
                "language": "cpp",
                "code": "int& access(int& x) {\n    return x; // Referenz auf bestehenden Wert\n}"
              },
              {
                "type": "pitfall",
                "title": "Referenz auf lokale Variable zur√ºckgeben",
                "text": "Das Zur√ºckgeben einer Referenz auf eine lokale Variable f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Typen per Wert, gro√üe Objekte per const Referenz √ºbergeben."
              },
              {
                "type": "summary",
                "points": [
                  "Parameter definieren die Eingaben einer Funktion",
                  "√úbergabe per Wert kopiert Daten",
                  "Referenzen erlauben direkten Zugriff auf Originaldaten",
                  "R√ºckgaben k√∂nnen per Wert oder Referenz erfolgen",
                  "Referenzen auf lokale Variablen d√ºrfen nie zur√ºckgegeben werden"
                ]
              }
            ]
          },
          {
            "title": "Funktions√ºberladung",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktions√ºberladung",
                "text": "Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Parameterliste."
              },
              {
                "type": "explanation",
                "title": "Grundidee der √úberladung",
                "text": [
                  "Funktionen k√∂nnen denselben Namen tragen, solange sich ihre Parameter unterscheiden.",
                  "Der Compiler entscheidet anhand der Argumente, welche Funktion aufgerufen wird."
                ]
              },
              {
                "type": "definition",
                "term": "Signatur",
                "text": "Kombination aus Funktionsname und Parametertypen."
              },
              {
                "type": "code",
                "title": "Einfache Funktions√ºberladung",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b;\n}\n\ndouble add(double a, double b) {\n    return a + b;\n}"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Die Auswahl erfolgt zur Compilezeit.",
                  "R√ºckgabetyp allein reicht nicht zur √úberladung aus."
                ]
              },
              {
                "type": "code",
                "title": "√úberladung mit unterschiedlicher Parameteranzahl",
                "language": "cpp",
                "code": "int sum(int a, int b) {\n    return a + b;\n}\n\nint sum(int a, int b, int c) {\n    return a + b + c;\n}"
              },
              {
                "type": "definition",
                "term": "√úberladung und const",
                "text": "const kann Teil der Funktionssignatur sein, insbesondere bei Memberfunktionen."
              },
              {
                "type": "pitfall",
                "title": "Mehrdeutige Aufrufe",
                "text": "Unklare Typumwandlungen k√∂nnen dazu f√ºhren, dass der Compiler keine passende √úberladung findet."
              },
              {
                "type": "important",
                "text": "Funktions√ºberladung verbessert Lesbarkeit, wenn gleiche Konzepte logisch zusammengeh√∂ren."
              },
              {
                "type": "summary",
                "points": [
                  "Mehrere Funktionen k√∂nnen denselben Namen haben",
                  "Die Parameterliste muss sich unterscheiden",
                  "Die Entscheidung erfolgt zur Compilezeit",
                  "Der R√ºckgabetyp allein gen√ºgt nicht",
                  "√úberladung sollte klar und eindeutig bleiben"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          {
            "title": "inline Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "inline Funktion",
                "text": "Eine Funktion, bei der der Compiler versucht, den Funktionsaufruf durch den Funktionscode zu ersetzen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von inline",
                "text": [
                  "inline soll den Overhead eines Funktionsaufrufs vermeiden.",
                  "Der Compiler darf inline ignorieren, es ist nur eine Empfehlung."
                ]
              },
              {
                "type": "definition",
                "term": "Funktionsaufruf Overhead",
                "text": "Zus√§tzlicher Aufwand durch Sprung, R√ºcksprung und Parameter√ºbergabe bei einem Funktionsaufruf."
              },
              {
                "type": "code",
                "title": "inline Funktionsdefinition",
                "language": "cpp",
                "code": "inline int square(int x) {\n    // einfacher, kurzer Code\n    return x * x;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann inline sinnvoll ist",
                "text": [
                  "Bei sehr kleinen, h√§ufig aufgerufenen Funktionen.",
                  "Typisch bei Getter und Setter Funktionen."
                ]
              },
              {
                "type": "code",
                "title": "Typischer Einsatz in Klassen",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    int get() const { // implizit inline\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "implizit inline",
                "text": "Funktionen, die innerhalb einer Klassendefinition definiert sind, gelten automatisch als inline."
              },
              {
                "type": "explanation",
                "title": "inline und Header Dateien",
                "text": [
                  "inline Funktionen d√ºrfen in Header Dateien definiert werden.",
                  "Mehrfache Definitionen sind erlaubt, solange sie identisch sind."
                ]
              },
              {
                "type": "pitfall",
                "title": "Zu gro√üe inline Funktionen",
                "text": "Gro√üe inline Funktionen k√∂nnen den Code aufbl√§hen und die Performance verschlechtern."
              },
              {
                "type": "important",
                "text": "inline ist kein Garant f√ºr Performance, die Entscheidung trifft der Compiler."
              },
              {
                "type": "summary",
                "points": [
                  "inline reduziert Funktionsaufruf Overhead",
                  "Der Compiler entscheidet, ob inline angewendet wird",
                  "Besonders sinnvoll f√ºr kleine Funktionen",
                  "Methoden in Klassen sind implizit inline",
                  "Zu viel inline kann schaden"
                ]
              }
            ]
          },
          {
            "title": "Lambda Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Lambda Funktion",
                "text": "Eine anonyme Funktion, die direkt an der Verwendungsstelle definiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Lambda Funktionen",
                "text": [
                  "Lambda Funktionen sind kurze Funktionsobjekte ohne eigenen Namen.",
                  "Sie werden h√§ufig f√ºr Callbacks, kurze Berechnungen und Standardalgorithmen genutzt."
                ]
              },
              {
                "type": "definition",
                "term": "Lambda Syntax",
                "text": "Besteht aus Capture Liste, Parameterliste, optionalem R√ºckgabetyp und Funktionsrumpf."
              },
              {
                "type": "code",
                "title": "Grundlegende Lambda Syntax",
                "language": "cpp",
                "code": "auto f = [](int x) {\n    return x * 2;\n};"
              },
              {
                "type": "definition",
                "term": "Capture Liste",
                "text": "Legt fest, welche √§u√üeren Variablen im Lambda verwendet werden d√ºrfen und wie sie √ºbergeben werden."
              },
              {
                "type": "list",
                "title": "Wichtige Capture Modi",
                "items": [
                  "[]: keine Variablen capturen",
                  "[x]: x per Wert capturen",
                  "[&x]: x per Referenz capturen",
                  "[=]: alle verwendeten Variablen per Wert capturen",
                  "[&]: alle verwendeten Variablen per Referenz capturen",
                  "[=, &x]: alle per Wert, x per Referenz",
                  "[&, x]: alle per Referenz, x per Wert"
                ]
              },
              {
                "type": "code",
                "title": "Capture Beispiele",
                "language": "cpp",
                "code": "int a = 1;\nint b = 2;\n\nauto l1 = [a]() { return a; };        // Wert-Capture\nauto l2 = [&b]() { b++; };            // Referenz-Capture\nauto l3 = [=]() { return a + b; };    // alle per Wert\nauto l4 = [=, &b]() { b += a; };      // Mischung"
              },
              {
                "type": "definition",
                "term": "mutable Lambda",
                "text": "Ein Lambda, das erlaubt, per Wert gecapturete Variablen zu ver√§ndern."
              },
              {
                "type": "code",
                "title": "mutable Lambda Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nauto l = [x]() mutable {\n    x++;            // erlaubt wegen mutable\n    return x;\n};"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der R√ºckgabetyp eines Lambdas wird meist automatisch bestimmt, kann aber explizit angegeben werden."
              },
              {
                "type": "code",
                "title": "Expliziter R√ºckgabetyp",
                "language": "cpp",
                "code": "auto div = [](int a, int b) -> double {\n    return static_cast<double>(a) / b;\n};"
              },
              {
                "type": "definition",
                "term": "std::function",
                "text": "Ein Typ, der beliebige aufrufbare Objekte mit einer festen Signatur speichern kann."
              },
              {
                "type": "explanation",
                "title": "Lambda mit std::function",
                "text": [
                  "Lambdas k√∂nnen in std::function gespeichert werden.",
                  "Dies ist flexibel, aber langsamer als direkte Nutzung eines Lambdas."
                ]
              },
              {
                "type": "code",
                "title": "Lambda in std::function",
                "language": "cpp",
                "code": "#include <functional>\n\nstd::function<int(int)> f = [](int x) {\n    return x * x;\n};"
              },
              {
                "type": "definition",
                "term": "Lambda in Algorithmen",
                "text": "Lambda Funktionen werden h√§ufig als Pr√§dikate oder Aktionen in Standardalgorithmen verwendet."
              },
              {
                "type": "code",
                "title": "Lambda mit std::algorithm",
                "language": "cpp",
                "code": "#include <algorithm>\n#include <vector>\n\nstd::vector<int> v = {1, 2, 3, 4};\n\nint count = std::count_if(v.begin(), v.end(), [](int x) {\n    return x % 2 == 0; // z√§hlt gerade Zahlen\n});"
              },
              {
                "type": "pitfall",
                "title": "Referenz Capture und Lebensdauer",
                "text": "Referenz-Captures sind gef√§hrlich, wenn das Lambda l√§nger lebt als die referenzierte Variable."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Logik direkt als Lambda, komplexe Logik als normale Funktion."
              },
              {
                "type": "summary",
                "points": [
                  "Lambda Funktionen sind anonyme Funktionsobjekte",
                  "Capture Listen steuern Zugriff auf √§u√üere Variablen",
                  "mutable erlaubt √Ñnderungen an Wert-Captures",
                  "Lambdas k√∂nnen in std::function gespeichert werden",
                  "Standardalgorithmen nutzen Lambdas intensiv"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          {
            "title": "C Arrays",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C Array",
                "text": "Ein C Array ist eine feste, zusammenh√§ngende Sequenz von Elementen gleichen Typs."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Arrays",
                "text": [
                  "C Arrays haben eine feste Gr√∂√üe, die zur Compilezeit bekannt sein muss.",
                  "Der Name des Arrays verweist implizit auf das erste Element."
                ]
              },
              {
                "type": "code",
                "title": "Deklaration eines C Arrays",
                "language": "cpp",
                "code": "int values[5]; // Array mit 5 int Elementen"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Beim Erzeugen eines Arrays k√∂nnen Startwerte angegeben werden."
              },
              {
                "type": "code",
                "title": "Initialisierung eines C Arrays",
                "language": "cpp",
                "code": "int numbers[3] = {1, 2, 3};"
              },
              {
                "type": "definition",
                "term": "Indexzugriff",
                "text": "Zugriff auf ein Element √ºber seinen Index, beginnend bei 0."
              },
              {
                "type": "code",
                "title": "Zugriff per Index",
                "language": "cpp",
                "code": "int x = numbers[0]; // erstes Element"
              },
              {
                "type": "definition",
                "term": "Arraygr√∂√üe",
                "text": "Die Anzahl der Elemente eines C Arrays."
              },
              {
                "type": "explanation",
                "title": "Arraygr√∂√üe ermitteln",
                "text": [
                  "C Arrays kennen ihre Gr√∂√üe nicht selbst.",
                  "Die Gr√∂√üe muss separat verwaltet oder berechnet werden."
                ]
              },
              {
                "type": "code",
                "title": "Arraygr√∂√üe berechnen",
                "language": "cpp",
                "code": "int size = sizeof(numbers) / sizeof(numbers[0]);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Arrays pr√ºfen nicht, ob ein Index g√ºltig ist, was zu undefiniertem Verhalten f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Arrays sind einfach, aber unsicher und unflexibel."
              },
              {
                "type": "summary",
                "points": [
                  "C Arrays haben feste Gr√∂√üe",
                  "Index beginnt bei 0",
                  "Keine automatische Gr√∂√üenverwaltung",
                  "Kein Bounds Check",
                  "In modernem C++ oft durch Container ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::array",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::array",
                "text": "std::array ist ein Container aus der Standardbibliothek mit fester Gr√∂√üe und sicherem Zugriff."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::array",
                "text": [
                  "std::array kapselt ein C Array in einer Klasse.",
                  "Es bietet zus√§tzliche Funktionen wie size und at."
                ]
              },
              {
                "type": "definition",
                "term": "Template Parameter",
                "text": "std::array ben√∂tigt einen Datentyp und eine feste Gr√∂√üe als Template Argumente."
              },
              {
                "type": "code",
                "title": "Deklaration von std::array",
                "language": "cpp",
                "code": "#include <array>\n\nstd::array<int, 3> values = {1, 2, 3};"
              },
              {
                "type": "explanation",
                "title": "Vorteile gegen√ºber C Arrays",
                "text": [
                  "std::array kennt seine eigene Gr√∂√üe.",
                  "Es unterst√ºtzt range based for Schleifen und Standardalgorithmen."
                ]
              },
              {
                "type": "code",
                "title": "std::array in einer for Schleife",
                "language": "cpp",
                "code": "for (int v : values) {\n    // Zugriff auf jedes Element\n}"
              },
              {
                "type": "pitfall",
                "title": "Feste Gr√∂√üe",
                "text": "Auch std::array hat eine feste Gr√∂√üe und kann nicht zur Laufzeit wachsen."
              },
              {
                "type": "important",
                "text": "std::array ist die sichere Alternative zu C Arrays bei fester Gr√∂√üe."
              },
              {
                "type": "summary",
                "points": [
                  "std::array ist ein Wrapper um C Arrays",
                  "Die Gr√∂√üe ist Teil des Typs",
                  "size liefert die Elementanzahl",
                  "at bietet Bounds Checking",
                  "Bevorzugt gegen√ºber rohen C Arrays"
                ]
              },
              {
                "type": "explanation",
                "title": "Wichtige Funktionen von std::array",
                "text": [
                  "std::array stellt im Vergleich zu C Arrays zus√§tzliche Memberfunktionen bereit.",
                  "Diese Funktionen erh√∂hen Sicherheit, Lesbarkeit und Integration mit der Standardbibliothek."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Elemente im Array."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> a = {1, 2, 3};\nstd::size_t n = a.size(); // n ist 3"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob das Array leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (a.empty()) {\n    // nur true bei Gr√∂√üe 0\n}"
              },
              {
                "type": "definition",
                "term": "operator[]",
                "text": "Greift ohne Indexpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Indexzugriff mit []",
                "language": "cpp",
                "code": "int x = a[0]; // kein Bounds Check"
              },
              {
                "type": "definition",
                "term": "at",
                "text": "Greift mit Laufzeitpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Sicherer Zugriff mit at",
                "language": "cpp",
                "code": "int x = a.at(1); // wirft Ausnahme bei ung√ºltigem Index"
              },
              {
                "type": "definition",
                "term": "front",
                "text": "Liefert das erste Element des Arrays."
              },
              {
                "type": "code",
                "title": "front Beispiel",
                "language": "cpp",
                "code": "int first = a.front();"
              },
              {
                "type": "definition",
                "term": "back",
                "text": "Liefert das letzte Element des Arrays."
              },
              {
                "type": "code",
                "title": "back Beispiel",
                "language": "cpp",
                "code": "int last = a.back();"
              },
              {
                "type": "definition",
                "term": "data",
                "text": "Gibt einen Zeiger auf das interne C Array zur√ºck."
              },
              {
                "type": "code",
                "title": "data Beispiel",
                "language": "cpp",
                "code": "int* ptr = a.data(); // kompatibel mit C APIs"
              },
              {
                "type": "definition",
                "term": "fill",
                "text": "Setzt alle Elemente des Arrays auf denselben Wert."
              },
              {
                "type": "code",
                "title": "fill Beispiel",
                "language": "cpp",
                "code": "a.fill(0); // alle Elemente werden 0"
              },
              {
                "type": "definition",
                "term": "swap",
                "text": "Tauscht den Inhalt zweier Arrays gleicher Gr√∂√üe und gleichen Typs."
              },
              {
                "type": "code",
                "title": "swap Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> b = {4, 5, 6};\na.swap(b); // Inhalte von a und b werden getauscht"
              },
              {
                "type": "important",
                "text": "at bietet Sicherheit, operator[] bietet Geschwindigkeit ohne Pr√ºfung."
              },
              {
                "type": "summary",
                "points": [
                  "std::array kennt seine eigene Gr√∂√üe",
                  "size und empty liefern Metainformationen",
                  "at pr√ºft Indizes zur Laufzeit",
                  "front und back erlauben direkten Randzugriff",
                  "data erm√∂glicht Interoperabilit√§t mit C Code"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          {
            "title": "C Strings",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C String",
                "text": "Ein C String ist ein Array von char, das mit einem Nullterminator '\\0' endet."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Strings",
                "text": [
                  "C Strings stammen aus der C Sprache und werden in C++ weiterhin unterst√ºtzt.",
                  "Das Ende des Strings wird durch das Zeichen '\\0' markiert."
                ]
              },
              {
                "type": "definition",
                "term": "Nullterminator",
                "text": "Ein spezielles Zeichen '\\0', das das Ende eines C Strings kennzeichnet."
              },
              {
                "type": "code",
                "title": "Deklaration eines C Strings",
                "language": "cpp",
                "code": "char text[6] = \"Hallo\"; // 'H','a','l','l','o','\\0'"
              },
              {
                "type": "definition",
                "term": "Stringliterale",
                "text": "Feste Zeichenketten, die im Programmcode definiert sind."
              },
              {
                "type": "code",
                "title": "Stringliteral",
                "language": "cpp",
                "code": "const char* msg = \"Hallo Welt\";"
              },
              {
                "type": "definition",
                "term": "cstring",
                "text": "Header mit Funktionen zur Arbeit mit C Strings."
              },
              {
                "type": "code",
                "title": "C String Funktionen",
                "language": "cpp",
                "code": "#include <cstring>\n\nsize_t len = std::strlen(text);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Strings pr√ºfen nicht, ob genug Speicher vorhanden ist, was zu Buffer Overflows f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Strings sind fehleranf√§llig und sollten in modernem C++ nur gezielt eingesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "C Strings sind char Arrays mit Nullterminator",
                  "Die L√§nge ist nicht im Typ gespeichert",
                  "Arbeiten mit C Strings ist unsicher",
                  "cstring stellt Hilfsfunktionen bereit",
                  "In modernem C++ meist durch std::string ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::string",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::string",
                "text": "std::string ist ein Standardcontainer zur sicheren und komfortablen Verarbeitung von Texten."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::string",
                "text": [
                  "std::string verwaltet Speicher automatisch.",
                  "Er kennt seine L√§nge und w√§chst dynamisch."
                ]
              },
              {
                "type": "definition",
                "term": "Dynamische L√§nge",
                "text": "Die L√§nge eines std::string kann sich zur Laufzeit √§ndern."
              },
              {
                "type": "code",
                "title": "Deklaration und Initialisierung",
                "language": "cpp",
                "code": "#include <string>\n\nstd::string name = \"Kilian\";"
              },
              {
                "type": "definition",
                "term": "Zugriff auf Zeichen",
                "text": "Einzelne Zeichen k√∂nnen √ºber einen Index gelesen oder ver√§ndert werden."
              },
              {
                "type": "code",
                "title": "Indexzugriff",
                "language": "cpp",
                "code": "char c = name[0]; // erstes Zeichen"
              },
              {
                "type": "definition",
                "term": "Konkatenation",
                "text": "Zusammenf√ºgen von Strings."
              },
              {
                "type": "code",
                "title": "Strings verketten",
                "language": "cpp",
                "code": "std::string a = \"Hallo\";\nstd::string b = \"Welt\";\nstd::string c = a + \" \" + b;"
              },
              {
                "type": "definition",
                "term": "c_str",
                "text": "Liefert einen C String Zeiger auf den internen Speicher."
              },
              {
                "type": "code",
                "title": "Umwandlung zu C String",
                "language": "cpp",
                "code": "const char* raw = name.c_str();"
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger Zeiger von c_str",
                "text": "Der von c_str gelieferte Zeiger wird ung√ºltig, wenn der String ver√§ndert wird."
              },
              {
                "type": "important",
                "text": "std::string ist der Standard f√ºr Textverarbeitung in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "std::string verwaltet Speicher automatisch",
                  "Die L√§nge ist jederzeit bekannt",
                  "Strings k√∂nnen sicher ver√§ndert und verkettet werden",
                  "c_str erm√∂glicht Interoperabilit√§t mit C APIs",
                  "std::string ist C Strings klar vorzuziehen"
                ]
              },
              {
                "type": "explanation",
                "title": "Funktionen von std::string",
                "text": [
                  "Der Header <string> liefert viele n√ºtzliche Funktionen f√ºr std::string Variablen."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Zeichen im String."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::size_t len = name.size();"
              },
              {
                "type": "definition",
                "term": "length",
                "text": "Liefert die Anzahl der Zeichen im String. Entspricht funktional size."
              },
              {
                "type": "code",
                "title": "length Beispiel",
                "language": "cpp",
                "code": "std::string s = \"Hallo\";\nstd::size_t n = s.length(); // n ist 5"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob der String leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (s.empty()) {\n    // String enth√§lt keine Zeichen\n}"
              },
              {
                "type": "definition",
                "term": "clear",
                "text": "Entfernt alle Zeichen aus dem String."
              },
              {
                "type": "code",
                "title": "clear Beispiel",
                "language": "cpp",
                "code": "s.clear(); // String ist danach leer"
              },
              {
                "type": "definition",
                "term": "append",
                "text": "H√§ngt Text an das Ende des Strings an."
              },
              {
                "type": "code",
                "title": "append Beispiel",
                "language": "cpp",
                "code": "s.append(\" Welt\"); // entspricht s += \" Welt\""
              },
              {
                "type": "definition",
                "term": "substr",
                "text": "Erzeugt einen Teilstring aus dem String."
              },
              {
                "type": "code",
                "title": "substr Beispiel",
                "language": "cpp",
                "code": "std::string sub = s.substr(0, 2); // erste zwei Zeichen"
              },
              {
                "type": "definition",
                "term": "find",
                "text": "Sucht nach einem Teilstring oder Zeichen und liefert die Position."
              },
              {
                "type": "code",
                "title": "find Beispiel",
                "language": "cpp",
                "code": "std::size_t pos = s.find(\"ll\");\nif (pos != std::string::npos) {\n    // Teilstring gefunden\n}"
              },
              {
                "type": "definition",
                "term": "replace",
                "text": "Ersetzt einen Teil des Strings durch einen anderen Text."
              },
              {
                "type": "code",
                "title": "replace Beispiel",
                "language": "cpp",
                "code": "s.replace(0, 5, \"Hi\"); // ersetzt die ersten 5 Zeichen"
              },
              {
                "type": "definition",
                "term": "compare",
                "text": "Vergleicht zwei Strings lexikografisch."
              },
              {
                "type": "code",
                "title": "compare Beispiel",
                "language": "cpp",
                "code": "int r = s.compare(\"Hallo\");\n// r == 0: gleich, <0: kleiner, >0: gr√∂√üer"
              },
              {
                "type": "important",
                "text": "size und length sind gleichwertig, size ist der bevorzugte Stil in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "size und length liefern die Stringl√§nge",
                  "empty pr√ºft auf leeren String",
                  "append und += h√§ngen Text an",
                  "substr erzeugt Teilstrings",
                  "find sucht Teilstrings sicher √ºber npos"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          {
            "title": "Pointer Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Ein Zeiger speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Zeigern",
                "text": [
                  "Zeiger erm√∂glichen den indirekten Zugriff auf Variablen √ºber ihre Adresse.",
                  "Sie werden h√§ufig f√ºr dynamischen Speicher, Arrays und Funktionsparameter verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Adresse",
                "text": "Die Speicherposition einer Variable im Arbeitsspeicher."
              },
              {
                "type": "definition",
                "term": "Dereferenzierung",
                "text": "Der Zugriff auf den Wert, auf den ein Zeiger zeigt."
              },
              {
                "type": "code",
                "title": "Pointer Deklaration und Nutzung",
                "language": "cpp",
                "code": "int x = 5;\nint* p = &x;     // p speichert die Adresse von x\nint y = *p;      // Dereferenzierung, y wird 5"
              },
              {
                "type": "definition",
                "term": "Zeigertyp",
                "text": "Der Typ eines Zeigers gibt an, auf welchen Datentyp er zeigt."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierter Zeiger",
                "text": "Ein nicht initialisierter Zeiger zeigt auf eine undefinierte Adresse."
              },
              {
                "type": "important",
                "text": "Ein Zeiger sollte immer initialisiert werden, idealerweise mit nullptr."
              },
              {
                "type": "summary",
                "points": [
                  "Zeiger speichern Adressen",
                  "Dereferenzierung erfolgt mit *",
                  "Der Zeigertyp bestimmt den Zieltyp",
                  "Uninitialisierte Zeiger sind gef√§hrlich"
                ]
              }
            ]
          },
          {
            "title": "Pointer Arithmetik",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Pointer Arithmetik",
                "text": "Rechenoperationen auf Zeigern, die sich an der Gr√∂√üe des Zieltyps orientieren."
              },
              {
                "type": "explanation",
                "title": "Grundidee der Pointer Arithmetik",
                "text": [
                  "Zeiger k√∂nnen vor und zur√ºck bewegt werden.",
                  "Die Schrittweite entspricht der Gr√∂√üe des Datentyps."
                ]
              },
              {
                "type": "definition",
                "term": "Inkrementieren eines Zeigers",
                "text": "Verschiebt den Zeiger auf das n√§chste Element desselben Typs."
              },
              {
                "type": "code",
                "title": "Pointer Arithmetik mit Arrays",
                "language": "cpp",
                "code": "int arr[3] = {10, 20, 30};\nint* p = arr;        // zeigt auf arr[0]\nint a = *p;          // 10\np++;                 // zeigt auf arr[1]\nint b = *p;          // 20"
              },
              {
                "type": "definition",
                "term": "Array und Pointer",
                "text": "Der Name eines Arrays zerf√§llt oft implizit zu einem Zeiger auf das erste Element."
              },
              {
                "type": "explanation",
                "title": "Erlaubte und unerlaubte Operationen",
                "text": [
                  "Addition und Subtraktion mit Ganzzahlen ist erlaubt.",
                  "Addition zweier Zeiger ist nicht erlaubt."
                ]
              },
              {
                "type": "pitfall",
                "title": "Au√üerhalb des Arrays",
                "text": "Pointer Arithmetik au√üerhalb der Arraygrenzen f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Pointer Arithmetik ist eng an Arrays gebunden und erfordert gro√üe Sorgfalt."
              },
              {
                "type": "summary",
                "points": [
                  "Pointer bewegen sich in Schritten der Typgr√∂√üe",
                  "Typischer Einsatz bei Arrays",
                  "Arrayname verh√§lt sich wie Zeiger",
                  "Grenzen d√ºrfen nicht √ºberschritten werden"
                ]
              }
            ]
          },
          {
            "title": "Nullpointer",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Nullpointer",
                "text": "Ein Zeiger, der auf kein g√ºltiges Objekt zeigt."
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert zur sicheren Darstellung eines Nullpointers."
              },
              {
                "type": "explanation",
                "title": "Grundidee von nullptr",
                "text": [
                  "nullptr ersetzt √§ltere Konzepte wie NULL oder 0.",
                  "Er ist eindeutig als Zeigerwert typisiert."
                ]
              },
              {
                "type": "code",
                "title": "nullptr verwenden",
                "language": "cpp",
                "code": "int* p = nullptr; // zeigt auf nichts\n\nif (p == nullptr) {\n    // Zeiger ist ung√ºltig\n}"
              },
              {
                "type": "definition",
                "term": "Nullpointer Dereferenzierung",
                "text": "Der Zugriff auf einen Nullpointer ist undefiniertes Verhalten."
              },
              {
                "type": "pitfall",
                "title": "Dereferenzierung von nullptr",
                "text": "Das Dereferenzieren eines Nullpointers f√ºhrt meist zu Programmabst√ºrzen."
              },
              {
                "type": "important",
                "text": "nullptr ist der einzige empfohlene Weg, einen leeren Zeiger darzustellen."
              },
              {
                "type": "summary",
                "points": [
                  "Nullpointer zeigen auf kein Objekt",
                  "nullptr ist typsicher",
                  "Vor Dereferenzierung immer pr√ºfen",
                  "NULL und 0 sollten vermieden werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          {
            "title": "Referenzen Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Eine Referenz ist ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzen",
                "text": [
                  "Referenzen erm√∂glichen den direkten Zugriff auf eine Variable, ohne deren Adresse explizit zu verwenden.",
                  "Sie verhalten sich wie Aliase und sind nach der Initialisierung fest gebunden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung einer Referenz",
                "text": "Eine Referenz muss beim Erzeugen an ein Objekt gebunden werden."
              },
              {
                "type": "code",
                "title": "Referenz deklarieren",
                "language": "cpp",
                "code": "int x = 10;\nint& ref = x; // ref ist ein Alias f√ºr x"
              },
              {
                "type": "definition",
                "term": "Alias Verhalten",
                "text": "√Ñnderungen √ºber die Referenz wirken sich direkt auf das referenzierte Objekt aus."
              },
              {
                "type": "code",
                "title": "Alias Beispiel",
                "language": "cpp",
                "code": "ref = 20;      // √§ndert x\nint y = x;     // y ist 20"
              },
              {
                "type": "definition",
                "term": "Neu binden",
                "text": "Referenzen k√∂nnen nach der Initialisierung nicht auf ein anderes Objekt zeigen."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierte Referenz",
                "text": "Referenzen m√ºssen immer initialisiert werden, sonst ist der Code ung√ºltig."
              },
              {
                "type": "important",
                "text": "Referenzen sind keine Zeiger und k√∂nnen nicht null sein."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzen sind Aliase f√ºr bestehende Objekte",
                  "Sie m√ºssen sofort initialisiert werden",
                  "Referenzen k√∂nnen nicht neu gebunden werden",
                  "Zugriff erfolgt ohne Dereferenzierung",
                  "Referenzen k√∂nnen nicht null sein"
                ]
              }
            ]
          },
          {
            "title": "Referenzparameter",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenzparameter",
                "text": "Ein Funktionsparameter, der per Referenz √ºbergeben wird und direkt auf das Argument zugreift."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzparametern",
                "text": [
                  "Referenzparameter erlauben es, Argumente innerhalb einer Funktion zu ver√§ndern.",
                  "Sie vermeiden Kopien und sind effizient f√ºr gro√üe Objekte."
                ]
              },
              {
                "type": "definition",
                "term": "√Ñnderbarer Referenzparameter",
                "text": "Ein Referenzparameter ohne const, der das √ºbergebene Objekt ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "Referenzparameter ver√§ndern Wert",
                "language": "cpp",
                "code": "void increment(int& x) {\n    x++; // √§ndert die Originalvariable\n}\n\nint a = 5;\nincrement(a); // a ist jetzt 6"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann const Referenzen verwenden",
                "text": [
                  "Bei gro√üen Objekten, die nicht ver√§ndert werden sollen.",
                  "Als Standard f√ºr Lesezugriff in Funktionsschnittstellen."
                ]
              },
              {
                "type": "pitfall",
                "title": "Unerwartete √Ñnderungen",
                "text": "Nicht-const Referenzparameter k√∂nnen Seiteneffekte verursachen."
              },
              {
                "type": "important",
                "text": "Standardregel: √úbergabe per Wert f√ºr kleine Typen, per const Referenz f√ºr gro√üe Typen."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzparameter greifen direkt auf Argumente zu",
                  "Sie vermeiden Kopien",
                  "Nicht-const Referenzen erlauben √Ñnderungen",
                  "const Referenzen verhindern Seiteneffekte",
                  "Referenzparameter sind sicherer als Zeiger"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          {
            "title": "Stack vs. Heap",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Speicherverwaltung",
                "text": "Mechanismen zur Reservierung und Freigabe von Speicher f√ºr Variablen und Objekte."
              },
              {
                "type": "definition",
                "term": "Stack",
                "text": "Automatischer Speicherbereich f√ºr lokale Variablen mit klar definierter Lebensdauer."
              },
              {
                "type": "definition",
                "term": "Heap",
                "text": "Dynamischer Speicherbereich f√ºr Objekte mit frei bestimmbarer Lebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Stack Speicher",
                "text": [
                  "Stack Speicher wird automatisch verwaltet.",
                  "Variablen werden beim Betreten eines G√ºltigkeitsbereichs angelegt und beim Verlassen automatisch freigegeben."
                ]
              },
              {
                "type": "code",
                "title": "Stack Beispiel",
                "language": "cpp",
                "code": "void foo() {\n    int x = 5;   // liegt auf dem Stack\n} // x wird hier automatisch zerst√∂rt"
              },
              {
                "type": "explanation",
                "title": "Grundidee von Heap Speicher",
                "text": [
                  "Heap Speicher wird manuell angefordert und freigegeben.",
                  "Objekte auf dem Heap leben so lange, bis sie explizit freigegeben werden.",
                  "Der Heap ist nicht an Blockgrenzen oder Funktionslebensdauer gebunden.",
                  "Heap Speicher ist flexibler, aber fehleranf√§lliger als Stack Speicher."
                ]
              },
              {
                "type": "code",
                "title": "Heap Grundprinzip",
                "language": "cpp",
                "code": "int* p = new int(5); // Speicher auf dem Heap\n// p zeigt auf ein Heap Objekt"
              },
              {
                "type": "comparison",
                "title": "Stack vs. Heap",
                "columns": ["Stack", "Heap"],
                "rows": [
                  {
                    "aspect": "Verwaltung",
                    "values": ["Automatisch", "Manuell"]
                  },
                  {
                    "aspect": "Lebensdauer",
                    "values": ["An G√ºltigkeitsbereich gebunden", "Beliebig steuerbar"]
                  },
                  {
                    "aspect": "Geschwindigkeit",
                    "values": ["Sehr schnell", "Langsamer"]
                  },
                  {
                    "aspect": "Fehleranf√§lligkeit",
                    "values": ["Gering", "Hoch"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Heap Speicher vergessen freizugeben",
                "text": "Nicht freigegebener Heap Speicher f√ºhrt zu Speicherlecks."
              },
              {
                "type": "important",
                "text": "Stack wann immer m√∂glich nutzen, Heap nur wenn n√∂tig."
              },
              {
                "type": "summary",
                "points": [
                  "Stack Speicher ist automatisch und sicher",
                  "Heap Speicher ist flexibel, aber manuell zu verwalten",
                  "Heap Objekte leben unabh√§ngig von Funktionen",
                  "Fehler im Heap f√ºhren oft zu schwer findbaren Bugs"
                ]
              }
            ]
          },
          {
            "title": "new & delete",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "new",
                "text": "Operator zum Anfordern von Speicher auf dem Heap und zum Erzeugen eines Objekts."
              },
              {
                "type": "definition",
                "term": "delete",
                "text": "Operator zum Freigeben von mit new reserviertem Heap Speicher."
              },
              {
                "type": "explanation",
                "title": "Grundprinzip von new und delete",
                "text": [
                  "new reserviert Speicher und ruft den Konstruktor auf.",
                  "delete ruft den Destruktor auf und gibt den Speicher frei."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches new und delete",
                "language": "cpp",
                "code": "int* p = new int(10); // Heap Speicher\n// Nutzung von *p\ndelete p;              // Speicher freigeben\np = nullptr;           // guter Stil"
              },
              {
                "type": "definition",
                "term": "Speicherleck",
                "text": "Nicht freigegebener Heap Speicher, der nicht mehr erreichbar ist."
              },
              {
                "type": "pitfall",
                "title": "delete vergessen",
                "text": "Wird delete nicht aufgerufen, bleibt der Speicher bis Programmende belegt."
              },
              {
                "type": "definition",
                "term": "new[]",
                "text": "Reserviert Speicher f√ºr ein Array auf dem Heap."
              },
              {
                "type": "definition",
                "term": "delete[]",
                "text": "Gibt Speicher frei, der mit new[] reserviert wurde."
              },
              {
                "type": "code",
                "title": "new[] und delete[]",
                "language": "cpp",
                "code": "int* arr = new int[3]; // Array auf dem Heap\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n\ndelete[] arr;          // korrektes Freigeben"
              },
              {
                "type": "pitfall",
                "title": "new[] mit delete",
                "text": "new[] und delete m√ºssen zusammen verwendet werden, genauso new und delete[]."
              },
              {
                "type": "code",
                "title": "Falsche Kombination",
                "language": "cpp",
                "code": "int* arr = new int[5];\n// delete arr; // falsch, f√ºhrt zu undefiniertem Verhalten"
              },
              {
                "type": "explanation",
                "title": "Warum new[] und delete[] zusammengeh√∂ren",
                "text": [
                  "Bei new[] m√ºssen mehrere Destruktoren aufgerufen werden.",
                  "delete[] wei√ü, wie viele Elemente zerst√∂rt werden m√ºssen."
                ]
              },
              {
                "type": "definition",
                "term": "Dangling Pointer",
                "text": "Ein Zeiger, der auf bereits freigegebenen Speicher zeigt."
              },
              {
                "type": "pitfall",
                "title": "Dangling Pointer",
                "text": "Zugriff auf freigegebenen Speicher f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "In modernem C++ sollten new und delete m√∂glichst durch Container und Smart Pointer ersetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "new reserviert Heap Speicher",
                  "delete gibt Heap Speicher frei",
                  "new[] erfordert delete[]",
                  "Vergessenes delete verursacht Speicherlecks",
                  "Dangling Pointer sind extrem gef√§hrlich"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          {
            "title": "RAII Prinzip",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "RAII",
                "text": "RAII steht f√ºr Resource Acquisition Is Initialization und koppelt Ressourcen an Objektlebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von RAII",
                "text": [
                  "Eine Ressource wird im Konstruktor eines Objekts erworben.",
                  "Die Freigabe erfolgt automatisch im Destruktor, wenn das Objekt den G√ºltigkeitsbereich verl√§sst."
                ]
              },
              {
                "type": "definition",
                "term": "Ressource",
                "text": "Alles, was explizit angefordert und freigegeben werden muss, zum Beispiel Speicher, Dateien oder Mutexes."
              },
              {
                "type": "code",
                "title": "RAII mit Speicher",
                "language": "cpp",
                "code": "class Buffer {\nprivate:\n    int* data;\n\npublic:\n    Buffer() {\n        data = new int[10]; // Ressource erwerben\n    }\n\n    ~Buffer() {\n        delete[] data;      // Ressource freigeben\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Vorteile von RAII",
                "text": [
                  "Automatische Freigabe auch bei return oder Exceptions.",
                  "Kein explizites Aufr√§umen im Code n√∂tig."
                ]
              },
              {
                "type": "pitfall",
                "title": "RAII umgehen",
                "text": "Manuelles new und delete au√üerhalb von RAII Klassen untergr√§bt das Prinzip."
              },
              {
                "type": "important",
                "text": "RAII ist das zentrale Speicherverwaltungsprinzip in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "Ressourcen sind an Objekte gebunden",
                  "Konstruktor erwirbt, Destruktor gibt frei",
                  "Sicher bei Exceptions",
                  "Grundlage f√ºr Smart Pointer"
                ]
              }
            ]
          },
          {
            "title": "Smart Pointer",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Smart Pointer",
                "text": "Objekte, die Zeiger kapseln und Speicher automatisch nach RAII verwalten."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Smart Pointern",
                "text": [
                  "Smart Pointer ersetzen rohe Zeiger mit automatischer Speicherfreigabe.",
                  "Sie verhindern Speicherlecks und Dangling Pointer."
                ]
              },
              {
                "type": "definition",
                "term": "std::unique_ptr",
                "text": [
                  "Ein Smart Pointer mit exklusivem Besitz an einer Ressource.", 
                  " Objekt wird beim Verlassen des Scopes automatisch gel√∂scht"
                ]
              },
              {
                "type": "code",
                "title": "unique_ptr Beispiel",
                "language": "cpp",
                "code": "#include <memory>\n\nstd::unique_ptr<int> p = std::make_unique<int>(5);\n// kein delete n√∂tig"
              },
              {
                "type": "definition",
                "term": "Move Semantik",
                "text": "√úbertr√§gt Besitz einer Ressource von einem Objekt auf ein anderes."
              },
              {
                "type": "code",
                "title": "unique_ptr verschieben",
                "language": "cpp",
                "code": "std::unique_ptr<int> a = std::make_unique<int>(3);\nstd::unique_ptr<int> b = std::move(a); // Besitzwechsel"
              },
              {
                "type": "definition",
                "term": "std::shared_ptr",
                "text": "Ein Smart Pointer mit gemeinsamem Besitz und Referenzz√§hlung. Automatische L√∂schung, wenn alle Kopien verschwinden."
              },
              {
                "type": "code",
                "title": "shared_ptr Beispiel",
                "language": "cpp",
                "code": "#include <memory>\n\nstd::shared_ptr<int> p1 = std::make_shared<int>(10);\nstd::shared_ptr<int> p2 = p1; // geteilter Besitz"
              },
              {
                "type": "explanation",
                "title": "Referenzz√§hlung bei std::shared_ptr",
                "text": [
                  "std::shared_ptr verwaltet eine Ressource √ºber eine interne Referenzz√§hlung.",
                  "Die Ressource wird automatisch freigegeben, wenn die Referenzz√§hlung auf null f√§llt."
                ]
              },
              {
                "type": "definition",
                "term": "use_count",
                "text": "Gibt die aktuelle Anzahl der shared_ptr zur√ºck, die dieselbe Ressource besitzen."
              },
              {
                "type": "code",
                "title": "Referenzz√§hlung abfragen",
                "language": "cpp",
                "code": "std::shared_ptr<int> p1 = std::make_shared<int>(42);\nstd::shared_ptr<int> p2 = p1;\n\nstd::size_t count = p1.use_count(); // count ist 2"
              },
              {
                "type": "note",
                "variant": "info",
                "text": "use_count dient nur zur Diagnose. Logik sollte nicht davon abh√§ngig gemacht werden."
              },
              {
                "type": "definition",
                "term": "reset",
                "text": "L√∂st einen shared_ptr von seiner Ressource und verringert die Referenzz√§hlung."
              },
              {
                "type": "code",
                "title": "shared_ptr freigeben",
                "language": "cpp",
                "code": "std::shared_ptr<int> p = std::make_shared<int>(5);\n\np.reset(); // Referenzz√§hlung wird reduziert\n// wenn dies der letzte shared_ptr war, wird die Ressource gel√∂scht"
              },
              {
                "type": "explanation",
                "title": "Wann wird die Ressource gel√∂scht",
                "text": [
                  "Die Ressource wird automatisch zerst√∂rt, sobald der letzte shared_ptr sie freigibt.",
                  "Das kann durch reset oder durch Verlassen des G√ºltigkeitsbereichs passieren."
                ]
              },
              {
                "type": "important",
                "text": "shared_ptr Speicher wird niemals manuell gel√∂scht, sondern immer √ºber Referenzz√§hlung."
              },
              {
                "type": "definition",
                "term": "std::weak_ptr",
                "text": "Ein nicht-besitzender Smart Pointer zur Beobachtung eines shared_ptr ohne den Z√§hler zu erh√∂hen."
              },
              {
                "type": "code",
                "title": "weak_ptr Beispiel",
                "language": "cpp",
                "code": "std::weak_ptr<int> w = p1;\nif (auto sp = w.lock()) {\n    // Ressource existiert noch\n}"
              },
              {
                "type": "explanation",
                "title": "weak_ptr::lock",
                "text": [
                  "lock erzeugt aus einem std::weak_ptr tempor√§r einen std::shared_ptr.",
                  "Existiert die verwaltete Ressource noch, liefert lock einen g√ºltigen shared_ptr.",
                  "Wurde die Ressource bereits freigegeben, liefert lock einen leeren shared_ptr."
                ]
              },
              {
                "type": "pitfall",
                "title": "Zyklische Referenzen",
                "text": "shared_ptr Zyklen verhindern automatische Freigabe ohne weak_ptr."
              },
              {
                "type": "important",
                "text": "unique_ptr ist Standardwahl, shared_ptr nur bei echtem geteiltem Besitz."
              },
              {
                "type": "summary",
                "points": [
                  "Smart Pointer implementieren RAII",
                  "unique_ptr f√ºr exklusiven Besitz",
                  "shared_ptr f√ºr geteilten Besitz",
                  "weak_ptr bricht Besitzzyklen",
                  "Rohzeiger m√∂glichst vermeiden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        {
          "title": "iostream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<iostream>",
              "text": "Header f√ºr Ein und Ausgabe √ºber die Konsole."
            },
            {
              "type": "explanation",
              "title": "Zweck von <iostream>",
              "text": [
                "<iostream> stellt die grundlegenden Standard Streams f√ºr die Konsole bereit.",
                "Er wird f√ºr Benutzereingaben, Ausgaben und einfache Debugzwecke verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Streams",
              "items": [
                "std::cin: Standardeingabe",
                "std::cout: Standardausgabe",
                "std::cerr: Fehlerausgabe ‚Üí ungepuffert ‚Üí sofort sichtbar",
                "std::clog: Protokollausgabe ‚Üí gepuffert ‚Üí bei Flush oder Ende sichtbar"
              ]
            },
            {
              "type": "code",
              "title": "Standard Ein und Ausgabe mit cin und cout",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int x;\n\n    std::cin >> x;               // Liest eine Zahl von der Standardeingabe\n    std::cout << x << '\\n';      // Gibt die Zahl auf der Standardausgabe aus\n}\n"
            },
            {
              "type": "code",
              "title": "Fehlerausgabe mit cerr ‚Üí ungepuffert ‚Üí sofort sichtbar",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int x;\n\n    // Versuch, eine Zahl einzulesen\n    if (!(std::cin >> x)) {\n        // std::cerr ist f√ºr Fehlermeldungen gedacht\n        // Die Ausgabe ist ungepuffert und erscheint sofort\n        // Auch wenn die normale Ausgabe (cout) umgeleitet ist\n        std::cerr << \"Fehler: Ung√ºltige Eingabe\" << std::endl;\n        // Typische Ausgabe auf stderr:\n        // Fehler: Ung√ºltige Eingabe\n        return 1;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Log-Ausgabe mit clog ‚Üí gepuffert ‚Üí bei Flush oder Ende sichtbar",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    // std::clog ist f√ºr Log- und Statusmeldungen gedacht\n    // Die Ausgabe ist gepuffert (effizienter als cerr)\n    std::clog << \"Programmstart\" << std::endl;\n    // Typische Ausgabe auf stderr (gepuffert):\n    // Programmstart\n\n    int x = 42;\n\n    // Log-Meldung √ºber internen Zustand\n    std::clog << \"Verarbeite Wert: \" << x << std::endl;\n    // Typische Ausgabe:\n    // Verarbeite Wert: 42\n}\n"
            },
            {
              "type": "code",
              "title": "Vergleich von cout, cerr und clog",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    std::cout << \"Normale Ausgabe\" << std::endl;\n    std::clog << \"Log Meldung\" << std::endl;\n    std::cerr << \"Fehlermeldung\" << std::endl;\n}\n"
            },
            {
              "type": "important",
              "text": "<iostream> ist die Basis f√ºr nahezu jede Konsolenanwendung."
            },
            {
              "type": "summary",
              "points": [
                "Grundlegender Ein und Ausgabe Header",
                "Arbeitet mit Streams",
                "cin liest, cout schreibt",
                "cerr f√ºr Fehlermeldungen"
              ]
            }
          ]
        },
        {
          "title": "fstream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<fstream>",
              "text": "Header f√ºr dateibasierte Ein und Ausgabe."
            },
            {
              "type": "explanation",
              "title": "Zweck von <fstream>",
              "text": [
                "<fstream> erlaubt das Lesen aus und Schreiben in Dateien.",
                "Er nutzt dasselbe Stream Prinzip wie <iostream>, aber mit Dateien statt Konsole."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Klassen",
              "items": [
                "std::ifstream: Datei lesen",
                "std::ofstream: Datei schreiben",
                "std::fstream: Lesen und Schreiben"
              ]
            },
            {
              "type": "code",
              "title": "Datei schreiben mit ofstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    // ofstream = output file stream (nur schreiben)\n    std::ofstream file(\"daten.txt\");\n\n    // Pr√ºfen, ob die Datei erfolgreich ge√∂ffnet wurde\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    // Schreiben funktioniert wie bei std::cout\n    file << \"Hallo Datei\" << std::endl;\n    file << 42 << std::endl;\n\n    // Datei explizit schlie√üen (optional, passiert auch im Destruktor)\n    file.close();\n\n    // Typischer Inhalt von daten.txt:\n    // Hallo Datei\n    // 42\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen mit ifstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    // ifstream = input file stream (nur lesen)\n    std::ifstream file(\"daten.txt\");\n\n    // Pr√ºfen, ob die Datei existiert und ge√∂ffnet werden konnte\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    std::string line;\n\n    // Zeilenweises Lesen bis Dateiende\n    while (std::getline(file, line)) {\n        std::cout << line << std::endl;\n    }\n\n    // Datei schlie√üen (optional)\n    file.close();\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen und schreiben mit fstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    // fstream kann lesen UND schreiben\n    std::fstream file(\"log.txt\", std::ios::in | std::ios::out | std::ios::app);\n\n    // ios::app -> Schreiben immer ans Dateiende\n\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    // Schreiben in die Datei\n    file << \"Neue Log-Zeile\" << std::endl;\n\n    // Zur√ºck an den Anfang springen, um zu lesen\n    file.seekg(0);\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::cout << line << std::endl;\n    }\n\n    file.close();\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Datei nicht gepr√ºft",
              "text": "Wird der √ñffnungszustand nicht gepr√ºft, k√∂nnen Lese oder Schreibfehler unbemerkt bleiben."
            },
            {
              "type": "summary",
              "points": [
                "Dateibasierte Streams",
                "ifstream f√ºr Lesen",
                "ofstream f√ºr Schreiben",
                "fstream f√ºr beides"
              ]
            }
          ]
        },
        {
          "title": "iomanip",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<iomanip>",
              "text": "Header mit Manipulatoren zur Steuerung der Ausgabeformatierung."
            },
            {
              "type": "explanation",
              "title": "Einsatzgebiet von <iomanip>",
              "text": [
                "<iomanip> ver√§ndert, wie Werte ausgegeben werden, nicht die Werte selbst.",
                "Er wird h√§ufig f√ºr saubere Konsolenausgaben und Tabellen verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Manipulatoren",
              "items": [
                "std::setw: Feldbreite setzen",
                "std::setprecision: Anzahl der Stellen",
                "std::fixed: feste Nachkommastellen",
                "std::left / std::right: Ausrichtung",
                "std::put_time: Zeitangaben formatieren",
                "std::boolalpha: true/false als Text"
              ]
            },
            {
              "type": "code",
              "title": "Feste Nachkommastellen",
              "language": "cpp",
              "code": "#include <iomanip>\n\nstd::cout << std::fixed << std::setprecision(2) << 3.14159; // 3.14"
            },
            {
              "type": "code",
              "title": "Feldbreite und Ausrichtung",
              "language": "cpp",
              "code": "std::cout << std::setw(10) << std::right << 42;\nstd::cout << std::setw(10) << std::left << 42;"
            },
            {
              "type": "code",
              "title": "Tabellenartige Ausgabe",
              "language": "cpp",
              "code": "std::cout << std::setw(10) << \"Name\"\n          << std::setw(5) << \"Age\" << '\\n';\n\nstd::cout << std::setw(10) << \"Anna\"\n          << std::setw(5) << 23 << '\\n';"
            },
            {
              "type": "code",
              "title": "boolalpha verwenden",
              "language": "cpp",
              "code": "bool flag = true;\nstd::cout << std::boolalpha << flag; // gibt \"true\" aus"
            },
            {
              "type": "code",
              "title": "Manipulatoren kombinieren",
              "language": "cpp",
              "code": "double x = 12.3456;\nstd::cout << std::setw(8)\n          << std::fixed\n          << std::setprecision(1)\n          << x;"
            },
            {
              "type": "code",
              "title": "Datum und Uhrzeit mit put_time",
              "language": "cpp",
              "code": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr);\n    std::tm* local = std::localtime(&now);\n\n    std::cout << std::put_time(local, \"%d.%m.%Y %H:%M:%S\"); // z.B. 20.12.2025 14:32:10\n}\n"
            },
            {
              "type": "explanation",
              "title": "put_time",
              "text": [
                "std::put_time formatiert Zeitangaben aus einer tm Struktur f√ºr die Ausgabe.",
                "Das Format folgt den gleichen Platzhaltern wie strftime aus der C Bibliothek."
              ]
            },
            {
              "type": "pitfall",
              "title": "Abh√§ngigkeit von <ctime>",
              "text": "put_time ben√∂tigt eine gueltige tm Struktur, die meist aus <ctime> stammt."
            },
            {
              "type": "important",
              "text": "put_time ist der empfohlene Weg zur formatierten Zeit Ausgabe mit Streams."
            },
            {
              "type": "summary",
              "points": [
                "Manipulatoren steuern die Darstellung",
                "setw f√ºr Spaltenbreite",
                "setprecision und fixed f√ºr Zahlen",
                "put_time f√ºr formatierte Zeit Ausgabe",
                "Formatierung wirkt auf den Stream"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
          {
            "title": "string",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<string>",
                "text": "Der Header <string> stellt die Klasse std::string und zugeh√∂rige Funktionen f√ºr sichere und dynamische Zeichenketten bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<string> bietet eine moderne Alternative zu C-Strings und kapselt Speicherverwaltung sowie L√§ngenverwaltung vollst√§ndig.",
                  "Strings k√∂nnen sicher kopiert, verglichen, erweitert und ver√§ndert werden."
                ]
              },
              {
                "type": "explanation",
                "title": "std::string",
                "text": [
                  "std::string repr√§sentiert eine ver√§nderbare Folge von Zeichen mit bekannter L√§nge.",
                  "Der Typ verwaltet seinen Speicher selbst und verhindert viele typische Fehler aus der C-Welt."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Funktionen und Methoden",
                "items": [
                  "size() / length() - Anzahl der Zeichen",
                  "empty() - pr√ºft ob der String leer ist",
                  "operator[] / at() - Zugriff auf einzelne Zeichen",
                  "append(), operator+= - Anh√§ngen von Text",
                  "substr(pos, len) - Teilstring erzeugen",
                  "find(str) - Suche nach Teilstrings",
                  "c_str() - Zugriff auf C-String Darstellung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Verwendung",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s = \"Hallo\";          // Initialisierung\n    s += \" Welt\";                     // Anh√§ngen\n\n    std::cout << s << std::endl;       // Ausgabe: Hallo Welt\n    std::cout << s.size() << std::endl; // Ausgabe der L√§nge\n}\n"
              },
              {
                "type": "code",
                "title": "Zugriff und Teilstrings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string text = \"Informatik\";\n\n    char c = text[0];                  // Zugriff ohne Bereichspr√ºfung\n    char d = text.at(1);               // Zugriff mit Pr√ºfung\n\n    std::string sub = text.substr(0, 4); // \"Info\"\n\n    std::cout << c << \" \" << d << \" \" << sub << std::endl;\n}\n"
              },
              {
                "type": "comparison",
                "title": "std::string vs C-String",
                "columns": ["std::string", "char*"],
                "rows": [
                  {
                    "aspect": "Speicherverwaltung",
                    "values": ["Automatisch", "Manuell"]
                  },
                  {
                    "aspect": "L√§ngeninformation",
                    "values": ["Direkt verf√ºgbar", "Nur durch strlen"]
                  },
                  {
                    "aspect": "Sicherheit",
                    "values": ["Hoch", "Fehleranf√§llig"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "operator[] ohne Pr√ºfung",
                "text": "Der Zugriff mit operator[] pr√ºft keine Grenzen und kann bei falschen Indizes zu undefiniertem Verhalten f√ºhren."
              },
              {
                "type": "important",
                "text": "In modernem C++ sollte std::string fast immer gegen√ºber C-Strings bevorzugt werden."
              },
              {
                "type": "summary",
                "points": [
                  "<string> stellt std::string bereit",
                  "Automatische Speicherverwaltung erh√∂ht Sicherheit",
                  "Bietet umfangreiche String-Operationen"
                ]
              }
            ]
          },
          {
            "title": "string_view",
            "difficulty": "intermediate",
            "blocks": [
              {
                "type": "definition",
                "term": "<string_view>",
                "text": "Der Header <string_view> stellt den Typ std::string_view bereit, der eine nicht-besitzende Sicht auf eine Zeichenkette beschreibt."
              },
              {
                "type": "explanation",
                "title": "Grundidee",
                "text": [
                  "std::string_view speichert lediglich einen Zeiger auf Zeichen und eine L√§nge, besitzt aber keinen eigenen Speicher.",
                  "Dadurch k√∂nnen Strings effizient gelesen und weitergereicht werden, ohne Kopien zu erzeugen."
                ]
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzszenarien",
                "text": [
                  "Funktionsparameter f√ºr nur-lesenden Zugriff auf Strings.",
                  "Arbeiten mit Teilstrings ohne Erzeugung neuer std::string Objekte."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Eigenschaften",
                "items": [
                  "Kein Besitz am Speicher",
                  "Konstante Zeit f√ºr Kopieren und Zuweisung",
                  "Kann aus std::string, C-String und String-Literalen erstellt werden",
                  "Nur lesender Zugriff auf die Zeichen"
                ]
              },
              {
                "type": "code",
                "title": "Verwendung als Funktionsparameter",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n#include <string_view>\n\nvoid print(std::string_view sv) {\n    std::cout << sv << std::endl; // Gibt den betrachteten String aus\n}\n\nint main() {\n    std::string s = \"Hallo Welt\";\n    print(s);                     // Keine Kopie von s\n    print(\"C++\");                // Auch String-Literale sind erlaubt\n}\n"
              },
              {
                "type": "code",
                "title": "Teilstring ohne Kopie",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string_view>\n\nint main() {\n    std::string_view sv = \"Informatik\";\n    std::string_view sub = sv.substr(0, 4); // Sicht auf \"Info\"\n\n    std::cout << sub << std::endl;           // Ausgabe: Info\n}\n"
              },
              {
                "type": "comparison",
                "title": "std::string_view vs std::string",
                "columns": ["std::string_view", "std::string"],
                "rows": [
                  {
                    "aspect": "Speicherbesitz",
                    "values": ["Nein", "Ja"]
                  },
                  {
                    "aspect": "Kopierkosten",
                    "values": ["Sehr gering", "Abh√§ngig von L√§nge"]
                  },
                  {
                    "aspect": "Ver√§nderbarkeit",
                    "values": ["Nein", "Ja"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Lebensdauerproblem",
                "text": "Ein std::string_view wird ung√ºltig, sobald der zugrunde liegende String zerst√∂rt oder ver√§ndert wird."
              },
              {
                "type": "important",
                "text": "std::string_view eignet sich ideal f√ºr nur-lesenden Zugriff, darf aber niemals l√§nger leben als der referenzierte String."
              },
              {
                "type": "summary",
                "points": [
                  "<string_view> bietet eine effiziente String-Sicht",
                  "Keine Speicherverwaltung, keine Kopien",
                  "Lebensdauer des Original-Strings ist entscheidend"
                ]
              }
            ]
          },
          {
          "title": "sstream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<sstream>",
              "text": "Header f√ºr String Streams, mit denen Strings wie Ein und Ausgabestr√∂me behandelt werden."
            },
            {
              "type": "explanation",
              "title": "Einsatzgebiet von <sstream>",
              "text": [
                "<sstream> wird genutzt, um Text sicher in andere Datentypen umzuwandeln oder strukturiert zusammenzusetzen.",
                "Er ist besonders hilfreich beim Parsen von Eingaben oder beim Erzeugen formatierter Strings."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Klassen",
              "items": [
                "std::stringstream: Lesen und Schreiben",
                "std::istringstream: Nur Lesen aus Strings",
                "std::ostringstream: Nur Schreiben in Strings"
              ]
            },
            {
              "type": "code",
              "title": "String zu Zahl umwandeln",
              "language": "cpp",
              "code": "#include <sstream>\n\nstd::string text = \"42\";\nstd::stringstream ss(text);\nint value;\nss >> value; // value ist 42"
            },
            {
              "type": "code",
              "title": "Mehrere Werte aus einem String lesen",
              "language": "cpp",
              "code": "std::string line = \"10 20 30\";\nstd::istringstream iss(line);\nint a, b, c;\niss >> a >> b >> c; // a=10, b=20, c=30"
            },
            {
              "type": "code",
              "title": "Zahl zu String erzeugen",
              "language": "cpp",
              "code": "std::ostringstream oss;\noss << 3.14;\nstd::string result = oss.str(); // \"3.14\""
            },
            {
              "type": "code",
              "title": "Komplexen String zusammensetzen",
              "language": "cpp",
              "code": "int id = 5;\nstd::string name = \"Max\";\n\nstd::ostringstream oss;\noss << \"ID=\" << id << \", Name=\" << name;\nstd::string output = oss.str();"
            },
            {
              "type": "pitfall",
              "title": "stringstream wiederverwenden",
              "text": "Beim Wiederverwenden muss der Streaminhalt und der Zustand zur√ºckgesetzt werden."
            },
            {
              "type": "important",
              "text": "<sstream> ist die sichere Alternative zu manueller String Verarbeitung."
            },
            {
              "type": "summary",
              "points": [
                "Strings k√∂nnen wie Streams gelesen werden",
                "Ideal f√ºr Parsen und Typumwandlungen",
                "ostringstream zum Erzeugen von Text",
                "Sicherer als C Funktionen"
              ]
            }
            ]
          },
          {
            "title": "cstring",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<cstring>",
                "text": "Der Header <cstring> stellt Funktionen zur Arbeit mit nullterminierten C-Strings und rohen Speicherbereichen bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<cstring> ist die C++ Variante des C-Headers string.h und enth√§lt niedrigstufige String- und Speicherfunktionen.",
                  "Die Funktionen arbeiten mit char-Arrays und setzen ein korrekt gesetztes Nullterminierungszeichen voraus."
                ]
              },
              {
                "type": "explanation",
                "title": "C-Strings",
                "text": [
                  "Ein C-String ist ein Array von char, das mit dem Zeichen '\\0' endet.",
                  "Die L√§nge wird nicht gespeichert, sondern zur Laufzeit durch Suchen des Terminators bestimmt."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige String-Funktionen",
                "items": [
                  "strlen(str) - L√§nge eines C-Strings ohne '\\0'",
                  "strcpy(dest, src) - kopiert einen String",
                  "strncpy(dest, src, n) - kopiert maximal n Zeichen",
                  "strcmp(a, b) - vergleicht zwei Strings",
                  "strcat(dest, src) - h√§ngt Strings aneinander"
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Speicherfunktionen",
                "items": [
                  "memcpy(dest, src, n) - kopiert n Bytes Speicher",
                  "memmove(dest, src, n) - sicheres Kopieren bei √úberlappung",
                  "memset(ptr, value, n) - setzt Speicher auf einen Wert",
                  "memcmp(a, b, n) - vergleicht Speicherbereiche"
                ]
              },
              {
                "type": "code",
                "title": "L√§nge und Vergleich von C-Strings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    const char a[] = \"Hallo\";\n    const char b[] = \"Welt\";\n\n    std::cout << std::strlen(a) << std::endl; // Ausgabe: 5\n    std::cout << std::strcmp(a, b) << std::endl; // Ungleich 0, da verschieden\n}\n"
              },
              {
                "type": "code",
                "title": "Kopieren von Strings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    char dest[10];\n    const char src[] = \"C++\";\n\n    std::strcpy(dest, src);           // Kopiert inkl. '\\0'\n    std::cout << dest << std::endl;   // Ausgabe: C++\n}\n"
              },
              {
                "type": "code",
                "title": "Arbeiten mit Speicherfunktionen",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    int a[3] = {1, 2, 3};\n    int b[3];\n\n    std::memcpy(b, a, sizeof(a));     // Kopiert rohe Bytes\n    std::cout << b[0] << std::endl;   // Ausgabe: 1\n}\n"
              },
              {
                "type": "comparison",
                "title": "memcpy vs memmove",
                "columns": ["memcpy", "memmove"],
                "rows": [
                  {
                    "aspect": "√úberlappende Speicherbereiche",
                    "values": ["Nicht erlaubt", "Erlaubt"]
                  },
                  {
                    "aspect": "Performance",
                    "values": ["Meist schneller", "Etwas langsamer"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Fehlendes Nullterminierungszeichen",
                "text": "Fehlt das abschlie√üende '\\0', lesen Funktionen wie strlen oder strcpy √ºber das Arrayende hinaus."
              },
              {
                "type": "important",
                "text": "Funktionen aus <cstring> sind fehleranf√§llig und sollten in modernem C++ m√∂glichst durch std::string ersetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "<cstring> arbeitet mit C-Strings und rohem Speicher",
                  "Keine automatische L√§ngen oder Speicherverwaltung",
                  "Hohe Fehleranf√§lligkeit bei falscher Nutzung"
                ]
              }
            ]
          },
          {
            "title": "cctype",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<cctype>",
                "text": "Der Header <cctype> stellt Funktionen zur Klassifikation und einfachen Umwandlung einzelner Zeichen bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<cctype> ist die C++ Variante des C-Headers ctype.h und arbeitet auf einzelnen Zeichen.",
                  "Die Funktionen werden h√§ufig beim Parsen von Text, bei Validierungen und einfachen Analysen eingesetzt."
                ]
              },
              {
                "type": "explanation",
                "title": "Funktionsprinzip",
                "text": [
                  "Die Funktionen pr√ºfen Eigenschaften eines Zeichens wie Ziffer, Buchstabe oder Leerzeichen.",
                  "R√ºckgabewerte sind ganzzahlig, werden aber logisch wie bool verwendet."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Pr√ºf-Funktionen",
                "items": [
                  "std::isdigit(c) - pr√ºft ob c eine Ziffer ist",
                  "std::isalpha(c) - pr√ºft ob c ein Buchstabe ist",
                  "std::isalnum(c) - pr√ºft ob c Buchstabe oder Ziffer ist",
                  "std::isspace(c) - pr√ºft ob c ein Leerzeichen ist",
                  "std::islower(c) - pr√ºft ob c klein geschrieben ist",
                  "std::isupper(c) - pr√ºft ob c gro√ü geschrieben ist"
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Umwandlungs-Funktionen",
                "items": [
                  "std::tolower(c) - wandelt Zeichen in Kleinbuchstaben um",
                  "std::toupper(c) - wandelt Zeichen in Gro√übuchstaben um"
                ]
              },
              {
                "type": "code",
                "title": "Zeichen klassifizieren",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cctype>\n\nint main() {\n    char c = '7';\n\n    if (std::isdigit(c)) {\n        std::cout << \"Ziffer\" << std::endl; // Wird ausgegeben\n    }\n\n    if (std::isalpha(c)) {\n        std::cout << \"Buchstabe\" << std::endl;\n    }\n}\n"
              },
              {
                "type": "code",
                "title": "Gro√ü- und Kleinschreibung",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cctype>\n\nint main() {\n    char c = 'a';\n\n    char upper = std::toupper(c); // Wandelt in 'A'\n    char lower = std::tolower('Z'); // Wandelt in 'z'\n\n    std::cout << upper << \" \" << lower << std::endl; // Ausgabe: A z\n}\n"
              },
              {
                "type": "pitfall",
                "title": "Vorzeichen von char",
                "text": "Die Funktionen aus <cctype> erwarten unsigned char Werte oder EOF, bei negativem char kann undefiniertes Verhalten auftreten."
              },
              {
                "type": "important",
                "text": "Vor der √úbergabe an <cctype>-Funktionen sollte char bei Bedarf zu unsigned char gecastet werden."
              },
              {
                "type": "summary",
                "points": [
                  "<cctype> klassifiziert und wandelt einzelne Zeichen",
                  "Wichtig f√ºr Parser und Texteingaben",
                  "Achtung bei negativem char Wert"
                ]
              }
            ]
          }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        {
          "title": "cmath",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cmath>",
              "text": "Der Header <cmath> stellt mathematische Funktionen f√ºr Gleitkomma- und Ganzzahlberechnungen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cmath> enth√§lt elementare mathematische Funktionen wie Wurzeln, Potenzen, Logarithmen und trigonometrische Funktionen.",
                "Die Funktionen sind gr√∂√ütenteils aus der C-Standardbibliothek √ºbernommen, aber im Namensraum std definiert."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "Numerische Berechnungen in Technik, Physik und Informatik.",
                "Mathematische Transformationen, Simulationen und Auswertungen."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "sqrt(x) - Quadratwurzel",
                "pow(x, y) - Potenzfunktion",
                "",
                "abs(x) - Absolutwert",
                "copysign(a, b) - Betrag von a, Vorzeichen von b",
                "",
                "sin(x), cos(x), tan(x) - Trigonometrische Funktionen",
                "asin(x), acos(x), atan(x) - Trigonometrische Umkehrfunktionen",
                "",
                "log(x) - nat√ºrlicher Logarithmus (ln)",
                "log10(x) - Logarithmus zur Basis 10", 
                "",
                "floor(x) - rundet nach unten",
                "ceil(x) - rundet nach oben",
                "round(x) - rundet zur n√§chsten ganzen Zahl",
                "trunc(x) - schneidet Nachkommastellen ab",
                "",
                "fmin(a, b) - kleinere Zahl (float-sicher)",
                "fmax(a, b) - gr√∂√üere Zahl",
                "isinf(x) - pr√ºft auf ¬±‚àû",
                "isnan(x) - pr√ºft auf NaN"
              ]
            },
            {
              "type": "code",
              "title": "Quadratwurzel und Potenz",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double x = 9.0;\n    double y = 2.0;\n\n    std::cout << std::sqrt(x) << std::endl; // Ausgabe: 3\n    std::cout << std::pow(x, y) << std::endl; // Ausgabe: 81\n}\n"
            },
            {
              "type": "code",
              "title": "Trigonometrische Funktionen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double angle = 3.141592653589793 / 2.0; // pi/2\n\n    std::cout << std::sin(angle) << std::endl; // Ausgabe: 1\n    std::cout << std::cos(angle) << std::endl; // Ausgabe: 0\n}\n"
            },
            {
              "type": "code",
              "title": "Rundungsfunktionen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double v = 3.7;\n\n    std::cout << std::floor(v) << std::endl; // Ausgabe: 3\n    std::cout << std::ceil(v) << std::endl;  // Ausgabe: 4\n    std::cout << std::round(v) << std::endl; // Ausgabe: 4\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Ganzzahlargumente",
              "text": "Viele Funktionen aus <cmath> arbeiten intern mit Gleitkommazahlen, was bei Ganzzahlargumenten zu impliziten Typumwandlungen f√ºhrt."
            },
            {
              "type": "important",
              "text": "Trigonometrische Funktionen erwarten Winkel immer im Bogenma√ü, nicht in Grad."
            },
            {
              "type": "summary",
              "points": [
                "<cmath> stellt mathematische Standardfunktionen bereit",
                "Funktionen liegen im Namensraum std",
                "Trigonometrische Funktionen arbeiten mit Bogenma√ü"
              ]
            }
          ]
        },
        {
          "title": "cstdlib",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cstdlib>",
              "text": "Der Header <cstdlib> stellt grundlegende Hilfsfunktionen f√ºr Speicherverwaltung, Zufallszahlen, Programmsteuerung und Konvertierungen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cstdlib> ist die C++ Variante des C-Headers stdlib.h und enth√§lt viele niedrigstufige Standardfunktionen.",
                "Die Funktionen sind im Namensraum std definiert und werden h√§ufig f√ºr systemnahe oder einfache Hilfsaufgaben genutzt."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "Erzeugen einfacher Zufallszahlen.",
                "Konvertieren von Strings in numerische Typen oder Beenden eines Programms."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::rand() - erzeugt eine Pseudozufallszahl",
                "std::srand(seed) - initialisiert den Zufallszahlengenerator",
                "std::abs(x) - Absolutwert f√ºr Ganzzahlen",
                "std::atoi(str), std::atof(str) - String zu Zahl Konvertierung",
                "std::exit(code) - sofortiges Beenden des Programms"
              ]
            },
            {
              "type": "code",
              "title": "Zufallszahlen erzeugen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nint main() {\n    std::srand(std::time(nullptr)); // Initialisierung mit aktueller Zeit\n\n    int r = std::rand() % 10;        // Zufallszahl zwischen 0 und 9\n    std::cout << r << std::endl;     // Beispielausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "String zu Ganzzahl konvertieren",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n\nint main() {\n    const char* text = \"123\";\n\n    int value = std::atoi(text);     // Konvertierung nach int\n    std::cout << value << std::endl; // Ausgabe: 123\n}\n"
            },
            {
              "type": "code",
              "title": "Programm beenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n\nint main() {\n    std::cout << \"Fehler aufgetreten\" << std::endl;\n    std::exit(1);                    // Beendet das Programm sofort\n}\n"
            },
            {
              "type": "pitfall",
              "title": "atoi und fehlende Fehlerpr√ºfung",
              "text": "std::atoi liefert bei ung√ºltigen Eingaben keinen Fehler, sondern 0, was eine sichere Fehlerbehandlung unm√∂glich macht."
            },
            {
              "type": "important",
              "text": "F√ºr moderne Zufallszahlen sollte <random> statt rand und srand verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "<cstdlib> enth√§lt grundlegende Standardfunktionen",
                "Bietet Zufallszahlen, Konvertierungen und exit",
                "Viele Funktionen sind historisch und nur eingeschr√§nkt sicher"
              ]
            }
          ]
        },
        {
          "title": "random",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<random>",
              "text": "Der Header <random> stellt moderne, flexible und statistisch saubere Zufallszahlengeneratoren und Verteilungen bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<random> trennt klar zwischen Zufallszahlengeneratoren und Wahrscheinlichkeitsverteilungen.",
                "Dadurch ist die Erzeugung reproduzierbarer und qualitativ hochwertiger Zufallszahlen m√∂glich."
              ]
            },
            {
              "type": "explanation",
              "title": "Aufbau des Random-Systems",
              "text": [
                "Ein Generator erzeugt rohe Zufallswerte, zum Beispiel std::mt19937.",
                "Eine Verteilung formt diese Werte in den gew√ºnschten Zahlenbereich oder die gew√ºnschte Statistik um."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Generatoren",
              "items": [
                "std::mt19937 - Mersenne-Twister mit 32 Bit",
                "std::mt19937_64 - Mersenne-Twister mit 64 Bit",
                "std::default_random_engine - Implementierungsabh√§ngiger Standardgenerator"
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Verteilungen",
              "items": [
                "std::uniform_int_distribution - Gleichverteilung ganzer Zahlen",
                "std::uniform_real_distribution - Gleichverteilung reeller Zahlen",
                "std::normal_distribution - Normalverteilung",
                "std::bernoulli_distribution - Wahr oder Falsch mit Wahrscheinlichkeit p"
              ]
            },
            {
              "type": "code",
              "title": "Moderne Zufallszahlen f√ºr ganze Zahlen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::random_device rd;           // Liefert einen nichtdeterministischen Seed\n    std::mt19937 gen(rd());           // Initialisierung des Generators\n    std::uniform_int_distribution<int> dist(1, 6); // Zahlen von 1 bis 6\n\n    int wuerfel = dist(gen);           // Erzeugt eine Zufallszahl\n    std::cout << wuerfel << std::endl; // Beispielausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "Zufallszahlen f√ºr Gleitkommazahlen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::mt19937 gen(42); // Fester Seed f√ºr reproduzierbare Ergebnisse\n    std::uniform_real_distribution<double> dist(0.0, 1.0);\n\n    double value = dist(gen);\n    std::cout << value << std::endl; // Zufallszahl zwischen 0.0 und 1.0\n}\n"
            },
            {
              "type": "code",
              "title": "Normalverteilung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::mt19937 gen(std::random_device{}());\n    std::normal_distribution<double> dist(0.0, 1.0); // Mittelwert 0, Standardabweichung 1\n\n    double x = dist(gen);\n    std::cout << x << std::endl; // Beispielausgabe\n}\n"
            },
            {
              "type": "comparison",
              "title": "Vergleich mit rand",
              "columns": ["<random>", "rand()"],
              "rows": [
                {
                  "aspect": "Qualit√§t",
                  "values": ["Hoch und kontrollierbar", "Gering"]
                },
                {
                  "aspect": "Verteilungen",
                  "values": ["Viele vorhanden", "Nur Gleichverteilung"]
                },
                {
                  "aspect": "Reproduzierbarkeit",
                  "values": ["Gezielt steuerbar", "Unzuverl√§ssig"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Seed mehrfach setzen",
              "text": "Wird der Generator in kurzen Zeitabst√§nden neu ges√§t, k√∂nnen identische Zufallsfolgen entstehen."
            },
            {
              "type": "important",
              "text": "<random> ist der empfohlene Weg f√ºr Zufallszahlen in modernem C++ und ersetzt rand und srand."
            },
            {
              "type": "summary",
              "points": [
                "<random> trennt Generator und Verteilung",
                "Erlaubt hochwertige und reproduzierbare Zufallszahlen",
                "Sollte rand vollst√§ndig ersetzen"
              ]
            }
          ]
        },
        {
          "title": "limits",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<limits>",
              "text": "Der Header <limits> stellt zur Compilezeit abrufbare Eigenschaften fundamentaler Datentypen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<limits> erlaubt es, Grenzwerte und Eigenschaften von Datentypen wie int, double oder char programmatisch abzufragen.",
                "Dadurch wird Code robuster, portabler und unabh√§ngig von konkreten Plattformannahmen."
              ]
            },
            {
              "type": "explanation",
              "title": "numeric_limits",
              "text": [
                "Die zentrale Schnittstelle ist die Templateklasse std::numeric_limits<T>.",
                "Sie stellt statische Konstanten und Funktionen f√ºr den jeweiligen Typ T bereit."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Eigenschaften",
              "items": [
                "min() - kleinster darstellbarer Wert",
                "max() - gr√∂√üter darstellbarer Wert",
                "lowest() - kleinster darstellbarer Wert inklusive negativer Zahlen",
                "epsilon() - kleinste Differenz bei Gleitkommazahlen",
                "is_integer - pr√ºft ob der Typ ganzzahlig ist",
                "digits - Anzahl der Bin√§rstellen des Typs"
              ]
            },
            {
              "type": "code",
              "title": "Grenzwerte eines int",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<int>::min() << std::endl; // Kleinster int-Wert\n    std::cout << std::numeric_limits<int>::max() << std::endl; // Gr√∂√üter int-Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Gleitkomma Eigenschaften",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<double>::epsilon() << std::endl; // Maschinengenauigkeit\n    std::cout << std::numeric_limits<double>::lowest() << std::endl;  // Kleinster Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Typ Eigenschaften abfragen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<int>::is_integer << std::endl; // 1 f√ºr int\n    std::cout << std::numeric_limits<double>::is_integer << std::endl; // 0 f√ºr double\n}\n"
            },
            {
              "type": "comparison",
              "title": "min vs lowest",
              "columns": ["min()", "lowest()"],
              "rows": [
                {
                  "aspect": "Ganzzahltypen",
                  "values": ["Kleinster negativer Wert", "Identisch zu min()"]
                },
                {
                  "aspect": "Gleitkommatypen",
                  "values": ["Kleinster positiver Wert", "Kleinster negativer Wert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "min bei double",
              "text": "Bei Gleitkommazahlen liefert min() nicht den negativsten Wert, sondern den kleinsten positiven normalisierten Wert."
            },
            {
              "type": "important",
              "text": "<limits> sollte immer verwendet werden statt fest kodierter Zahlen wie INT_MAX oder magischer Konstanten."
            },
            {
              "type": "summary",
              "points": [
                "<limits> liefert Typgrenzen zur Compilezeit",
                "numeric_limits ist typsicher und portabel",
                "Besonders wichtig f√ºr robuste numerische Programme"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        {
          "title": "chrono",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<chrono>",
              "text": "Der Header <chrono> stellt typsichere Zeitpunkte, Zeitspannen und Uhren f√ºr Zeitmessung und Zeitberechnungen bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<chrono> trennt klar zwischen Zeitpunkten, Zeitdauern und Uhren.",
                "Zeit wird nicht als nackte Zahl behandelt, sondern als eigener Typ mit Einheit."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Konzepte",
              "text": [
                "std::chrono::duration beschreibt eine Zeitspanne wie Sekunden oder Millisekunden.",
                "std::chrono::time_point beschreibt einen konkreten Zeitpunkt relativ zu einer Uhr."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Uhren",
              "items": [
                "std::chrono::steady_clock - monotone Uhr f√ºr Zeitmessungen",
                "std::chrono::system_clock - Systemzeit und Kalenderzeit",
                "std::chrono::high_resolution_clock - m√∂glichst hohe Aufl√∂sung"
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Zeitdauern",
              "items": [
                "std::chrono::seconds",
                "std::chrono::milliseconds",
                "std::chrono::microseconds",
                "std::chrono::nanoseconds"
              ]
            },
            {
              "type": "code",
              "title": "Zeit messen mit steady_clock",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < 1000000; ++i) {\n        // Leere Schleife zur Laufzeitmessung\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n    std::cout << duration.count() << std::endl; // Vergangene Zeit in ms\n}\n"
            },
            {
              "type": "code",
              "title": "Arbeiten mit durations",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::seconds s(2);\n    std::chrono::milliseconds ms = s; // Implizite Umrechnung\n\n    std::cout << ms.count() << std::endl; // Ausgabe: 2000\n}\n"
            },
            {
              "type": "code",
              "title": "system_clock und aktuelle Zeit",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    auto now = std::chrono::system_clock::now();\n    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch());\n\n    std::cout << seconds.count() << std::endl; // Sekunden seit Epoche\n}\n"
            },
            {
              "type": "comparison",
              "title": "steady_clock vs system_clock",
              "columns": ["steady_clock", "system_clock"],
              "rows": [
                {
                  "aspect": "Monoton",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Geeignet f√ºr Messungen",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Bezug zur Uhrzeit",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "note",
              "variant": "formatting",
              "text": "Um Zeit oder Datum zu formatieren, nutzt man den Header <iomanip>, mit der Funktion put_time."
            },
            {
              "type": "pitfall",
              "title": "Falsche Uhr f√ºr Messungen",
              "text": "system_clock kann durch Systemzeit√§nderungen springen und ist f√ºr Laufzeitmessungen ungeeignet."
            },
            {
              "type": "important",
              "text": "F√ºr Zeitmessungen sollte immer steady_clock verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "<chrono> bietet typsichere Zeitmessung",
                "Trennung von duration, time_point und clock",
                "steady_clock ist Standard f√ºr Laufzeitmessungen"
              ]
            }
          ]
        },
        {
          "title": "ctime",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<ctime>",
              "text": "Der Header <ctime> stellt C-kompatible Funktionen und Typen zur Arbeit mit Kalenderzeit und Uhrzeit bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<ctime> ist die C++ Variante des C-Headers time.h und arbeitet mit der Systemzeit.",
                "Er bietet einfache, aber unflexible Mechanismen zur Zeitmessung und Zeitdarstellung."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Typen",
              "text": [
                "time_t repr√§sentiert einen Zeitpunkt als Sekunden seit der Epoch.",
                "struct tm speichert eine aufgeschl√ºsselte Kalenderzeit wie Jahr, Monat und Tag."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::time(nullptr) - aktuelle Systemzeit als time_t",
                "std::localtime - Umwandlung von time_t in lokale Zeit",
                "std::gmtime - Umwandlung in UTC Zeit",
                "std::difftime - Differenz zweier Zeitpunkte",
                "std::asctime - Umwandlung von tm in lesbaren Text",
                "std::ctime - Umwandlung von time_t in lesbaren Text"
              ]
            },
            {
              "type": "code",
              "title": "Aktuelle Zeit ermitteln",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr); // Aktuelle Zeit\n    std::cout << now << std::endl;        // Sekunden seit Epoch\n}\n"
            },
            {
              "type": "code",
              "title": "Kalenderzeit mit tm",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr);\n    std::tm* local = std::localtime(&now); // Lokale Zeit\n\n    std::cout << local->tm_year + 1900 << std::endl; // Jahr\n    std::cout << local->tm_mon + 1 << std::endl;     // Monat\n    std::cout << local->tm_mday << std::endl;        // Tag\n}\n"
            },
            {
              "type": "code",
              "title": "Zeitdifferenz berechnen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t t1 = 1000;\n    std::time_t t2 = 1500;\n\n    double diff = std::difftime(t2, t1); // Differenz in Sekunden\n    std::cout << diff << std::endl;      // Ausgabe: 500\n}\n"
            },
            {
              "type": "comparison",
              "title": "<ctime> vs <chrono>",
              "columns": ["<ctime>", "<chrono>"],
              "rows": [
                {
                  "aspect": "Typensicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Zeitmessung",
                  "values": ["Eingeschr√§nkt", "Flexibel"]
                },
                {
                  "aspect": "Modernes C++",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "note",
              "variant": "formatting",
              "text": "Um Zeit oder Datum zu formatieren, nutzt man den Header <iomanip>, mit der Funktion put_time."
            },
            {
              "type": "pitfall",
              "title": "localtime und Thread-Sicherheit",
              "text": "std::localtime liefert einen Zeiger auf statischen Speicher und ist nicht thread-sicher."
            },
            {
              "type": "important",
              "text": "<ctime> ist historisch und sollte in modernem C++ nach M√∂glichkeit durch <chrono> ersetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "<ctime> arbeitet mit System und Kalenderzeit",
                "Einfach, aber wenig typsicher",
                "Heute meist durch <chrono> ersetzt"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        {
          "title": "thread",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<thread>",
              "text": "Der Header <thread> stellt Funktionen und Typen zur nebenl√§ufigen Ausf√ºhrung von Code in eigenen Threads bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<thread> erm√∂glicht es, mehrere Ausf√ºhrungsstr√§nge parallel oder nebenl√§ufig laufen zu lassen.",
                "Jeder Thread f√ºhrt eine Funktion unabh√§ngig vom aufrufenden Thread aus."
              ]
            },
            {
              "type": "explanation",
              "title": "std::thread",
              "text": [
                "std::thread repr√§sentiert einen ausf√ºhrenden Thread.",
                "Ein Thread startet sofort bei der Konstruktion und muss vor Programmende beendet oder verbunden werden."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::thread - startet einen neuen Thread",
                "join() - wartet auf das Ende eines Threads",
                "detach() - trennt den Thread vom Objekt",
                "std::this_thread::sleep_for - pausiert den aktuellen Thread",
                "std::this_thread::get_id - liefert die Thread ID"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher Thread",
              "language": "cpp",
              "code": "#include <iostream>\n#include <thread>\n\nvoid work() {\n    std::cout << \"Thread l√§uft\" << std::endl;\n}\n\nint main() {\n    std::thread t(work); // Startet neuen Thread\n    t.join();            // Wartet bis Thread fertig ist\n}\n"
            },
            {
              "type": "code",
              "title": "sleep_for verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <thread>\n#include <chrono>\n\nint main() {\n    std::cout << \"Start\" << std::endl;\n\n    std::this_thread::sleep_for(std::chrono::seconds(2)); // Pausiert f√ºr 2 Sekunden\n\n    std::cout << \"Weiter\" << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "sleep_for",
              "text": [
                "sleep_for pausiert den aktuell laufenden Thread f√ºr eine bestimmte Zeitspanne.",
                "Die Zeitspanne wird als std::chrono::duration √ºbergeben."
              ]
            },
            {
              "type": "comparison",
              "title": "join vs detach",
              "columns": ["join()", "detach()"],
              "rows": [
                {
                  "aspect": "Warten auf Thread",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Lebensdauer kontrollierbar",
                  "values": ["Ja", "Nein"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessener join",
              "text": "Wird ein joinbarer Thread nicht gejoint oder detached, beendet std::terminate das Programm."
            },
            {
              "type": "important",
              "text": "sleep_for geh√∂rt zu <thread>, nutzt aber Zeittypen aus <chrono>."
            },
            {
              "type": "summary",
              "points": [
                "<thread> erm√∂glicht nebenl√§ufige Aus√ºhrung",
                "Threads m√ºssen gejoint oder detached werden",
                "sleep_for pausiert den aktuellen Thread kontrolliert"
              ]
            }
          ]
        },
        {
          "title": "future",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<future>",
              "text": "Der Header <future> stellt Mechanismen zur asynchronen Ausf√ºhrung und zum sicheren Austausch von Ergebnissen zwischen Threads bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<future> kapselt nebenl√§ufige Berechnungen und deren Ergebnisse in Objekten.",
                "Das Ergebnis wird sp√§ter abgeholt, sobald die Berechnung abgeschlossen ist."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Typen",
              "text": [
                "std::future repr√§sentiert ein zuk√ºnftiges Ergebnis einer Berechnung.",
                "std::promise dient dazu, ein Ergebnis explizit zu setzen.",
                "std::async startet eine Funktion asynchron und liefert ein future zur√ºck."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "std::future<T> - Zugriff auf ein sp√§teres Ergebnis",
                "std::promise<T> - Setzen eines Ergebnisses",
                "std::async - komfortabler Start asynchroner Aufgaben",
                "get() - holt das Ergebnis und blockiert falls n√∂tig",
                "wait() - wartet auf Abschluss ohne Ergebnisabfrage"
              ]
            },
            {
              "type": "code",
              "title": "Asynchrone Berechnung mit async",
              "language": "cpp",
              "code": "#include <iostream>\n#include <future>\n\nint berechne() {\n    return 42;\n}\n\nint main() {\n    std::future<int> f = std::async(std::launch::async, berechne);\n\n    int ergebnis = f.get();        // Blockiert bis Ergebnis verf√ºgbar ist\n    std::cout << ergebnis << std::endl; // Ausgabe: 42\n}\n"
            },
            {
              "type": "code",
              "title": "future blockiert bei get",
              "language": "cpp",
              "code": "#include <iostream>\n#include <future>\n#include <chrono>\n#include <thread>\n\nint arbeit() {\n    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simuliert Arbeit\n    return 7;\n}\n\nint main() {\n    std::future<int> f = std::async(std::launch::async, arbeit);\n\n    std::cout << \"Warte auf Ergebnis...\" << std::endl;\n    std::cout << f.get() << std::endl; // Wartet ca. 2 Sekunden\n}\n"
            },
            {
              "type": "comparison",
              "title": "future vs thread",
              "columns": ["std::future", "std::thread"],
              "rows": [
                {
                  "aspect": "R√ºckgabewert",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Fehler√ºbertragung",
                  "values": ["Ja, per Exception", "Nein"]
                },
                {
                  "aspect": "Synchronisation",
                  "values": ["Automatisch", "Manuell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "get nur einmal erlaubt",
              "text": "std::future::get darf nur einmal aufgerufen werden, danach ist das future leer."
            },
            {
              "type": "important",
              "text": "<future> vereinfacht nebenl√§ufige Programmierung erheblich, da Ergebnisse und Exceptions sicher √ºbertragen werden."
            },
            {
              "type": "summary",
              "points": [
                "<future> erm√∂glicht asynchrone Berechnungen mit R√ºckgabewert",
                "std::async ist der einfachste Einstieg",
                "get blockiert bis das Ergebnis verf√ºgbar ist",
                "Exceptions werden automatisch weitergereicht"
              ]
            }
          ]
        },
        {
          "title": "typeinfo",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<typeinfo>",
              "text": "Der Header <typeinfo> stellt Laufzeitinformationen √ºber Typen bereit und wird f√ºr Runtime Type Information verwendet."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<typeinfo> erm√∂glicht es, Typinformationen erst zur Laufzeit abzufragen.",
                "Dies ist vor allem bei Polymorphie und dynamischem Casting relevant."
              ]
            },
            {
              "type": "explanation",
              "title": "RTTI Grundidee",
              "text": [
                "RTTI bedeutet, dass der tats√§chliche Typ eines Objekts zur Laufzeit bestimmt werden kann.",
                "Dies funktioniert nur bei Klassen mit mindestens einer virtuellen Funktion."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "typeid(expr) - liefert Typinformation eines Ausdrucks",
                "std::type_info - Klasse zur Repr√§sentation von Typinformationen",
                "name() - liefert einen implementationsabh√§ngigen Typnamen",
                "operator== - Vergleich von Typinformationen"
              ]
            },
            {
              "type": "code",
              "title": "Typ mit typeid abfragen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <typeinfo>\n\nint main() {\n    int x = 5;\n    double y = 3.14;\n\n    std::cout << typeid(x).name() << std::endl; // Typ von x\n    std::cout << typeid(y).name() << std::endl; // Typ von y\n}\n"
            },
            {
              "type": "code",
              "title": "RTTI bei Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <typeinfo>\n\nstruct Base {\n    virtual ~Base() {} // notwendig f√ºr RTTI\n};\n\nstruct Derived : Base {};\n\nint main() {\n    Base* b = new Derived();\n\n    std::cout << typeid(*b).name() << std::endl; // Tats√§chlicher Typ: Derived\n    delete b;\n}\n"
            },
            {
              "type": "comparison",
              "title": "typeid vs dynamic_cast",
              "columns": ["typeid", "dynamic_cast"],
              "rows": [
                {
                  "aspect": "Zweck",
                  "values": ["Typabfrage", "Sicheres Casten"]
                },
                {
                  "aspect": "R√ºckgabewert",
                  "values": ["type_info", "Zeiger oder Referenz"]
                },
                {
                  "aspect": "RTTI notwendig",
                  "values": ["Ja", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Implementationsabh√§ngiger Typname",
              "text": "Der von name() gelieferte Typname ist nicht standardisiert und nicht portabel."
            },
            {
              "type": "important",
              "text": "<typeinfo> sollte sparsam eingesetzt werden, da gutes Design meist ohne explizite Typabfragen auskommt."
            },
            {
              "type": "summary",
              "points": [
                "<typeinfo> erm√∂glicht Laufzeit Typinformationen",
                "typeid liefert std::type_info",
                "RTTI erfordert virtuelle Funktionen",
                "Typnamen sind implementationsabh√§ngig"
              ]
            }
          ]
        },
        {
          "title": "new",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<new>",
              "text": "Der Header <new> stellt Mechanismen f√ºr dynamische Speicherallokation und Speicherfehlerbehandlung bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<new> definiert die Operatoren new und delete sowie Hilfsmittel zur Kontrolle ihres Verhaltens.",
                "Er wird verwendet, wenn Speicher dynamisch zur Laufzeit angefordert oder freigegeben wird."
              ]
            },
            {
              "type": "explanation",
              "title": "new und delete",
              "text": [
                "new reserviert Speicher und ruft anschlie√üend den Konstruktor eines Objekts auf.",
                "delete ruft den Destruktor auf und gibt den reservierten Speicher wieder frei."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "operator new - reserviert Speicher",
                "operator delete - gibt Speicher frei",
                "std::nothrow - unterdr√ºckt Exceptions bei Speicherfehlern",
                "std::bad_alloc - Exception bei fehlgeschlagener Allokation",
                "placement new - Konstruktion an vorgegebenem Speicherort"
              ]
            },
            {
              "type": "code",
              "title": "Dynamische Speicherallokation",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nint main() {\n    int* p = new int(42);          // Speicher reservieren und Wert setzen\n    std::cout << *p << std::endl; // Ausgabe: 42\n    delete p;                     // Speicher freigeben\n}\n"
            },
            {
              "type": "code",
              "title": "new mit nothrow",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nint main() {\n    int* p = new (std::nothrow) int;\n\n    if (p == nullptr) {\n        std::cout << \"Kein Speicher verf√ºgbar\" << std::endl;\n    } else {\n        *p = 10;\n        std::cout << *p << std::endl;\n        delete p;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "placement new",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nstruct Test {\n    int x;\n    Test(int v) : x(v) {}\n};\n\nint main() {\n    alignas(Test) char buffer[sizeof(Test)];\n\n    Test* t = new (buffer) Test(5); // Objekt im bestehenden Speicher konstruieren\n    std::cout << t->x << std::endl; // Ausgabe: 5\n\n    t->~Test(); // Destruktor manuell aufrufen\n}\n"
            },
            {
              "type": "comparison",
              "title": "new vs malloc",
              "columns": ["new", "malloc"],
              "rows": [
                {
                  "aspect": "Konstruktoraufruf",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Typensicherheit",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Fehlerbehandlung",
                  "values": ["Exception", "nullptr"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessenes delete",
              "text": "Nicht freigegebener Speicher f√ºhrt zu Speicherlecks."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten new und delete m√∂glichst durch Smart Pointer ersetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "<new> steuert dynamische Speicherallokation",
                "new ruft Konstruktoren auf, delete Destruktoren",
                "std::bad_alloc signalisiert Speicherfehler",
                "placement new konstruiert Objekte in vorhandenem Speicher"
              ]
            }
          ]
        },
        {
          "title": "memory",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<memory>",
              "text": "Der Header <memory> stellt Smart Pointer und Hilfsmittel f√ºr sichere und moderne Speicherverwaltung bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<memory> abstrahiert dynamische Speicherverwaltung und verhindert viele typische Fehler wie Speicherlecks.",
                "Statt rohem new und delete werden Smart Pointer verwendet, die Speicher automatisch freigeben."
              ]
            },
            {
              "type": "explanation",
              "title": "Smart Pointer Grundidee",
              "text": [
                "Smart Pointer kapseln einen rohen Zeiger in einem Objekt mit klarer Besitzsemantik.",
                "Der Speicher wird automatisch freigegeben, wenn der letzte Besitzer verschwindet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Smart Pointer",
              "items": [
                "std::unique_ptr - exklusiver Besitz eines Objekts",
                "std::shared_ptr - geteilter Besitz mit Referenzz√§hlung",
                "std::weak_ptr - schwache Referenz ohne Besitz",
                "std::make_unique - sichere Erzeugung von unique_ptr",
                "std::make_shared - effiziente Erzeugung von shared_ptr"
              ]
            },
            {
              "type": "code",
              "title": "unique_ptr verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p = std::make_unique<int>(42);\n\n    std::cout << *p << std::endl; // Zugriff auf den Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Besitz√ºbertragung mit move",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> a = std::make_unique<int>(10);\n    std::unique_ptr<int> b = std::move(a); // Besitz wird √ºbertragen\n\n    if (a == nullptr) {\n        std::cout << \"a ist leer\" << std::endl;\n    }\n\n    std::cout << *b << std::endl; // Ausgabe: 10\n}\n"
            },
            {
              "type": "code",
              "title": "shared_ptr verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(5);\n    std::shared_ptr<int> p2 = p1; // Referenzz√§hlung +1\n\n    std::cout << p1.use_count() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "code",
              "title": "weak_ptr zur Zyklusvermeidung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(7);\n    std::weak_ptr<int> wp = sp;\n\n    if (auto locked = wp.lock()) {\n        std::cout << *locked << std::endl; // Zugriff nur wenn Objekt existiert\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "unique_ptr vs shared_ptr",
              "columns": ["unique_ptr", "shared_ptr"],
              "rows": [
                {
                  "aspect": "Besitz",
                  "values": ["Exklusiv", "Geteilt"]
                },
                {
                  "aspect": "Kopierbar",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Overhead",
                  "values": ["Sehr gering", "H√∂her durch Referenzz√§hlung"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zyklische Referenzen",
              "text": "Zwei shared_ptr aufeinander verhindern die Speicherfreigabe und f√ºhren zu Speicherlecks."
            },
            {
              "type": "important",
              "text": "<memory> ist zentral f√ºr modernes C++ und sollte rohes new und delete fast immer ersetzen."
            },
            {
              "type": "summary",
              "points": [
                "<memory> stellt Smart Pointer bereit",
                "unique_ptr f√ºr exklusiven Besitz",
                "shared_ptr f√ºr geteilten Besitz",
                "weak_ptr verhindert Referenzzyklen",
                "Automatische Speicherfreigabe erh√∂ht Sicherheit"
              ]
            }
          ]
        },
        {
          "title": "cstdio",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cstdio>",
              "text": "Der Header <cstdio> stellt C-kompatible Funktionen f√ºr Ein- und Ausgabe √ºber Dateien und Standardstreams bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cstdio> ist die C++ Variante des C-Headers stdio.h und arbeitet mit C-Streams.",
                "Er wird f√ºr einfache, schnelle oder systemnahe Ein- und Ausgabeoperationen genutzt."
              ]
            },
            {
              "type": "explanation",
              "title": "C-Streams",
              "text": [
                "Ein- und Ausgabe erfolgt √ºber FILE* Objekte.",
                "Standardstreams sind stdin, stdout und stderr."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "printf(format, ...) - formatierte Ausgabe",
                "scanf(format, ...) - formatierte Eingabe",
                "fprintf(stream, ...) - Ausgabe in Datei",
                "fscanf(stream, ...) - Eingabe aus Datei",
                "fopen(name, mode) - Datei √∂ffnen",
                "fclose(file) - Datei schlie√üen",
                "fgets(buffer, n, stream) - Zeile lesen",
                "fputs(text, stream) - Text schreiben"
              ]
            },
            {
              "type": "code",
              "title": "Formatierte Ausgabe mit printf",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    int x = 5;\n    double y = 3.14;\n\n    std::printf(\"x = %d, y = %.2f\\n\", x, y); // Formatierte Ausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "Datei schreiben",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    FILE* f = std::fopen(\"test.txt\", \"w\");\n\n    if (f != nullptr) {\n        std::fprintf(f, \"Hallo Datei\\n\");\n        std::fclose(f);\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    char buffer[100];\n    FILE* f = std::fopen(\"test.txt\", \"r\");\n\n    if (f != nullptr) {\n        std::fgets(buffer, 100, f);\n        std::printf(\"%s\", buffer);\n        std::fclose(f);\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "<cstdio> vs <iostream>",
              "columns": ["<cstdio>", "<iostream>"],
              "rows": [
                {
                  "aspect": "Typensicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Performance",
                  "values": ["Oft h√∂her", "Etwas geringer"]
                },
                {
                  "aspect": "Modernes C++",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "scanf und Formatfehler",
              "text": "Falsche Formatstrings bei scanf f√ºhren leicht zu undefiniertem Verhalten."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten <iostream> oder <fstream> bevorzugt werden, au√üer bei bewusster C-Kompatibilit√§t."
            },
            {
              "type": "summary",
              "points": [
                "<cstdio> stellt C-Style Ein- und Ausgabe bereit",
                "Arbeitet mit FILE* und Formatstrings",
                "Schnell, aber nicht typsicher",
                "Heute meist durch iostreams ersetzt"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
       {
        "title": "algorithm",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<algorithm>",
            "text": "Der Header <algorithm> stellt eine gro√üe Sammlung generischer Algorithmen zur Verarbeitung von Containern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<algorithm> arbeitet iteratorbasiert und ist dadurch unabh√§ngig vom konkreten Containertyp.",
              "Die Algorithmen trennen klar Datenhaltung von Verarbeitung und f√∂rdern wiederverwendbaren Code."
            ]
          },
          {
            "type": "explanation",
            "title": "Zusammenspiel mit Containern",
            "text": [
              "Algorithmen arbeiten typischerweise mit Iteratorpaaren wie begin() und end().",
              "Sie funktionieren mit Standardcontainern wie vector, list, array oder deque."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Such- und Z√§hlalgorithmen",
            "items": [
              "std::find - sucht erstes Vorkommen eins Elements",
              "std::count - z√§hlt Vorkommen eines Werts",
              "std::count_if - z√§hlt mit Pr√§dikat(Bedingungen)",
              "std::find_if - sucht mit Bedingung",
              "std::all_of / any_of / none_of - logische Pr√ºfungen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige √Ñnderungsalgorithmen",
            "items": [
              "std::sort - sortiert Elemente",
              "std::reverse - kehrt Reihenfolge um",
              "std::remove - entfernt logisch Elemente, verschiebt sie nach hinten und gibt einen Iterator auf den Beginn der entfernten Elemente zur√ºck. Containergr√∂√üe bleibt unver√§ndert",
              "std::unique - entfernt logisch aufeinanderfolgende Duplikate, verschiebt sie nach hinten und gibt einen Iterator auf den Beginn der entfernten Elemente zur√ºck. Containergr√∂√üe bleibt unver√§ndert",
              "std::transform - transformiert Elemente durch eine Funktion und speichert die Ergebnisse im Zielcontainer"
            ]
          },
          {
            "type": "code",
            "title": "Suchen und Z√§hlen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 2, 4};\n\n    auto it = std::find(v.begin(), v.end(), 2);\n    int anzahl = std::count(v.begin(), v.end(), 2);\n\n    std::cout << anzahl << std::endl; // Ausgabe: 2\n}\n"
          },
          {
            "type": "code",
            "title": "Sortieren mit sort",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {4, 1, 3, 2};\n\n    std::sort(v.begin(), v.end()); // Aufsteigend sortieren\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "remove-erase Idiom",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 2, 4};\n\n    v.erase(std::remove(v.begin(), v.end(), 2), v.end());\n\n    for (int x : v) {\n        std::cout << x << \" \"; // Ausgabe: 1 3 4\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Transformieren mit transform",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Ausgangscontainer\n    std::vector<int> v = {1, 2, 3, 4};\n\n    // std::transform arbeitet elementweise:\n    // 1. v.begin()  -> Start des Eingabebereichs\n    // 2. v.end()    -> Ende des Eingabebereichs\n    // 3. v.begin()  -> Start des Zielbereichs\n    //                 (hier: wir schreiben die Ergebnisse direkt wieder in denselben Vector)\n    // 4. Lambda     -> Funktion, die auf jedes Element angewendet wird\n    std::transform(\n        v.begin(),   // Eingabe: erstes Element\n        v.end(),     // Eingabe: letztes Element (exklusiv)\n        v.begin(),   // Ausgabe: Zielposition f√ºr das Ergebnis\n        [](int x) {  // Lambda-Funktion: nimmt ein Element x\n            return x * 2; // und gibt das transformierte Element zur√ºck\n        }\n    );\n\n    // Ausgabe des transformierten Vektors\n    for (int x : v) {\n        std::cout << x << \" \"; // Ausgabe: 2 4 6 8\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Pr√ºfen mit all_of, any_of und none_of",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Beispielcontainer\n    std::vector<int> v = {2, 4, 6, 8};\n\n    // all_of: pr√ºft, ob ALLE Elemente die Bedingung erf√ºllen\n    // ‚Üí true, wenn jedes Element die Lambda-Bedingung erf√ºllt\n    bool alleGerade = std::all_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x % 2 == 0; // Bedingung: Element ist gerade\n        }\n    );\n\n    // any_of: pr√ºft, ob MINDESTENS EIN Element die Bedingung erf√ºllt\n    bool mindestensEinsGroesserFuenf = std::any_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x > 5; // Bedingung: Element ist gr√∂√üer als 5\n        }\n    );\n\n    // none_of: pr√ºft, ob KEIN Element die Bedingung erf√ºllt\n    bool keinNegatives = std::none_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x < 0; // Bedingung: Element ist negativ\n        }\n    );\n\n    // Ergebnisse ausgeben\n    std::cout << std::boolalpha;\n    std::cout << \"alle gerade: \" << alleGerade << std::endl;               // true\n    std::cout << \"mindestens eins > 5: \" << mindestensEinsGroesserFuenf << std::endl; // true\n    std::cout << \"kein negatives: \" << keinNegatives << std::endl;         // true\n}\n"
          },
          {
            "type": "comparison",
            "title": "Algorithmen vs Container-Methoden",
            "columns": ["<algorithm>", "Container-Methoden"],
            "rows": [
              {
                "aspect": "Generisch",
                "values": ["Ja", "Nein"]
              },
              {
                "aspect": "Iteratorbasiert",
                "values": ["Ja", "Nein"]
              },
              {
                "aspect": "Wiederverwendbarkeit",
                "values": ["Hoch", "Begrenzt"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "remove l√∂scht nicht wirklich",
            "text": "std::remove verschiebt Elemente nur und √§ndert nicht die Containergr√∂√üe."
          },
          {
            "type": "important",
            "text": "<algorithm> ist zentral f√ºr idiomatisches(typisch) und modernes C++ und sollte gegen√ºber manuellen Schleifen bevorzugt werden."
          },
          {
            "type": "summary",
            "points": [
              "<algorithm> bietet viele generische Algorithmen",
              "Arbeitet iteratorbasiert mit Containern",
              "F√∂rdert sauberen und wiederverwendbaren Code"
            ]
          }
        ]
      },
      {
        "title": "iterator",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<iterator>",
            "text": "Der Header <iterator> stellt Iterator-Typen, Hilfsfunktionen und Iterator-Adapter f√ºr die Arbeit mit Containern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "Iteratoren abstrahieren den Zugriff auf Container, ohne deren interne Struktur offenzulegen.",
              "Sie erm√∂glichen es Algorithmen, unabh√§ngig vom konkreten Containertyp zu arbeiten."
            ]
          },
          {
            "type": "explanation",
            "title": "Iterator-Kategorien",
            "text": [
              "Iterator-Kategorien beschreiben die F√§higkeiten eines Iterators und bestimmen, welche Operationen und Laufzeiten ein Algorithmus nutzen darf.",
              "Algorithmen aus <algorithm> setzen bestimmte Iterator-Kategorien voraus."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Iterator-Kategorien",
            "items": [
              "Input Iterator - lesender Vorw√§rtszugriff, kein Mehrfachdurchlauf garantiert",
              "Output Iterator - schreibender Zugriff, kein Lesen m√∂glich",
              "Forward Iterator - les- und schreibbar mit Mehrfachdurchlauf",
              "Bidirectional Iterator - Vorw√§rts- und R√ºckw√§rtsbewegung",
              "Random Access Iterator - direkter Sprung auf beliebige Positionen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile aus <iterator>",
            "items": [
              "std::iterator_traits - Typ- und Eigenschaftsinformationen eines Iterators",
              "std::advance - Iterator um n Positionen verschieben",
              "std::distance - Abstand zwischen zwei Iteratoren berechnen",
              "std::next / std::prev - neuen Iterator relativ zu einem bestehenden erzeugen",
              "Iterator-Adapter wie back_inserter - erm√∂glichen sicheres Einf√ºgen in Container"
            ]
          },
          {
            "type": "code",
            "title": "Iterator bewegen mit advance",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() {\n    std::vector<int> v = {10, 20, 30, 40};\n    auto it = v.begin();\n\n    std::advance(it, 2); // Bewegt Iterator zwei Positionen weiter\n    std::cout << *it << std::endl; // Ausgabe: 30\n}\n"
          },
          {
            "type": "code",
            "title": "Abstand zwischen Iteratoren",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    auto d = std::distance(v.begin(), v.end());\n    std::cout << d << std::endl; // Ausgabe: 5\n}\n"
          },
          {
            "type": "code",
            "title": "Iterator-Adapter back_inserter",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nint main() {\n    // Quellcontainer mit Daten\n    std::vector<int> a = {1, 2, 3};\n\n    // Zielcontainer ist leer\n    std::vector<int> b;\n\n    // std::copy kopiert Elemente von a nach b\n    // Problem: b ist leer und hat keinen reservierten Speicher\n    // L√∂sung: std::back_inserter erzeugt einen speziellen Iterator,\n    //          der intern b.push_back(x) aufruft\n    std::copy(\n        a.begin(),           // Start des Eingabebereichs\n        a.end(),             // Ende des Eingabebereichs\n        std::back_inserter(b) // Ziel: f√ºgt Elemente sicher mit push_back ein\n    );\n\n    // Ausgabe des Zielcontainers\n    for (int x : b) {\n        std::cout << x << \" \"; // Ausgabe: 1 2 3\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Iterator traits",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\n// Generische Funktion, die mit beliebigen Iteratoren arbeitet\ntemplate <typename Iterator>\nvoid printFirstElement(Iterator it) {\n    // iterator_traits extrahiert Typinformationen aus dem Iterator. Hier int\n    using ValueType = typename std::iterator_traits<Iterator>::value_type;\n\n    // Jetzt kennen wir den Typ der Elemente, auf die der Iterator zeigt\n    ValueType value = *it;\n\n    std::cout << value << std::endl;\n}\n\nint main() {\n    std::vector<int> v = {10, 20, 30};\n\n    // √úbergabe eines Vector-Iterators\n    printFirstElement(v.begin()); // Ausgabe: 10\n}\n"
          },
          {
            "type": "comparison",
            "title": "Iterator-Kategorien im Vergleich",
            "columns": ["Kategorie", "F√§higkeiten"],
            "rows": [
              {
                "aspect": "Input Iterator",
                "values": ["Lesen", "Einmaliger Zugriff"]
              },
              {
                "aspect": "Bidirectional Iterator",
                "values": ["Vorw√§rts und r√ºckw√§rts", "Mehrfacher Zugriff"]
              },
              {
                "aspect": "Random Access Iterator",
                "values": ["Direkter Indexzugriff", "Arithmetik m√∂glich"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Ung√ºltige Iteratoren",
            "text": "Operationen wie Einf√ºgen oder L√∂schen k√∂nnen Iteratoren ung√ºltig machen."
          },
          {
            "type": "important",
            "text": "<iterator> ist zentral f√ºr das Zusammenspiel von Containern und Algorithmen in C++."
          },
          {
            "type": "summary",
            "points": [
              "<iterator> definiert Iterator-Konzepte und Hilfsfunktionen",
              "Iteratoren abstrahieren Containerzugriff",
              "advance und distance sind zentrale Werkzeuge",
              "Iterator-Adapter erleichtern sicheres Einf√ºgen"
            ]
          }
        ]
      },
      {
        "title": "functional",
        "difficulty": "intermediate",
        "blocks": [
          {
            "type": "definition",
            "term": "<functional>",
            "text": "Der Header <functional> stellt Funktionsobjekte, Wrapper und Hilfsmittel f√ºr funktionale Programmierung in C++ bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<functional> erm√∂glicht es, Funktionen wie Werte zu behandeln.",
              "Funktionen, Lambdas und Funktionsobjekte k√∂nnen einheitlich gespeichert und weitergereicht werden."
            ]
          },
          {
            "type": "explanation",
            "title": "Funktionsobjekte",
            "text": [
              "Ein Funktionsobjekt ist ein Objekt, das den operator() √ºberl√§dt.",
              "Viele Standard-Funktionsobjekte sind bereits in <functional> definiert."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Funktionsobjekte",
            "items": [
              "std::plus<T>: a + b, std::minus<T>: a - b, std::multiplies<T>: a * b, std::divides<T>: a / b - arithmetische Operationen",
              "std::less, std::greater - Vergleichsoperationen",
              "std::logical_and<T>: a && b, std::logical_or - logische Operationen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::function - typsicherer Funktionswrapper",
              "std::bind - teilweise Funktionsbindung",
              "std::ref / std::cref - Referenzen in Funktionsobjekten"
            ]
          },
          {
            "type": "code",
            "title": "std::function verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    std::function<int(int, int)> f = add;\n    std::cout << f(2, 3) << std::endl; // Ausgabe: 5\n}\n"
          },
          {
            "type": "code",
            "title": "Lambda mit std::function",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    std::function<bool(int)> ist_gerade = [](int x) {\n        return x % 2 == 0;\n    };\n\n    std::cout << ist_gerade(4) << std::endl; // Ausgabe: 1\n}\n"
          },
          {
            "type": "code",
            "title": "std::bind verwenden (mit _1 und _3)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\n// Funktion mit drei Parametern\nint combine(int a, int b, int c) {\n    return a + b * c;\n}\n\nint main() {\n    // Erstes Beispiel: einfacher bind mit einem Platzhalter\n    auto f = std::bind(\n        combine,\n        10,                     // a = 10 (fest gebunden)\n        std::placeholders::_1,  // b = erstes Argument beim Aufruf\n        2                       // c = 2 (fest gebunden)\n    );\n\n    // f(x) entspricht intern: combine(10, x, 2)\n    std::cout << f(3) << std::endl; // 10 + 3*2 = 16\n\n\n    // Zweites Beispiel: Nutzung von _3\n    auto g = std::bind(\n        combine,\n        std::placeholders::_3,  // a = drittes Argument beim Aufruf\n        5,                      // b = 5 (fest gebunden)\n        std::placeholders::_1   // c = erstes Argument beim Aufruf\n    );\n\n    // Aufruf von g mit drei Argumenten:\n    // g(x, y, z) -> combine(z, 5, x)\n    std::cout << g(2, 99, 4) << std::endl; // 4 + 5*2 = 14\n}\n"
          },
          {
            "type": "code",
            "title": "std::ref: bind kopiert sonst, ref √§ndert das",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    int x = 10;\n\n    // Ohne std::ref w√ºrde bind x kopieren.\n    // Dann w√ºrde die √Ñnderung nur die Kopie betreffen.\n    auto addToX = std::bind(\n        std::plus<int>{},        // Funktionsobjekt: plus(a, b) -> a + b\n        std::ref(x),             // a referenziert x (kein Kopieren)\n        std::placeholders::_1    // b kommt beim Aufruf\n    );\n\n    // addToX(5) berechnet x + 5\n    // Wir weisen das Ergebnis wieder x zu, um die √Ñnderung sichtbar zu machen.\n    x = addToX(5);\n\n    std::cout << x << std::endl; // Ausgabe: 15\n}\n"
          },
          {
            "type": "code",
            "title": "std::cref: bind liest aus einer Referenz, ohne zu kopieren",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    int x = 10;\n\n    // std::cref(x) speichert eine Referenz auf x, aber als const Referenz.\n    // Das ist sinnvoll, wenn du garantiert nicht √§ndern willst oder darfst.\n    auto addX = std::bind(\n        std::plus<int>{},        // a + b\n        std::cref(x),            // a ist const Referenz auf x\n        std::placeholders::_1    // b kommt beim Aufruf\n    );\n\n    // addX(7) bedeutet intern: x + 7\n    std::cout << addX(7) << std::endl; // Ausgabe: 17\n\n    // x bleibt unver√§ndert, weil wir nur gelesen haben.\n    std::cout << x << std::endl; // Ausgabe: 10\n}\n"
          },
          {
            "type": "comparison",
            "title": "std::function vs Template-Parameter",
            "columns": ["std::function", "Template"],
            "rows": [
              {
                "aspect": "Flexibilit√§t",
                "values": ["Sehr hoch", "Hoch"]
              },
              {
                "aspect": "Laufzeit-Overhead",
                "values": ["Vorhanden", "Keiner"]
              },
              {
                "aspect": "Typ-Erasure",
                "values": ["Ja", "Nein"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Overhead von std::function",
            "text": "std::function verursacht Laufzeit-Overhead und sollte in Performance-kritischem Code bewusst eingesetzt werden."
          },
          {
            "type": "important",
            "text": "<functional> ist zentral f√ºr moderne C++ APIs, Callback-Mechanismen und Algorithmen."
          },
          {
            "type": "summary",
            "points": [
              "<functional> unterst√ºtzt funktionale Programmierung",
              "std::function kapselt Funktionen typsicher",
              "Funktionsobjekte und Lambdas sind gleichwertig nutzbar",
              "std::bind erm√∂glicht partielle Funktionsbindung"
            ]
          }
        ]
      },
      {
        "title": "initializer_list",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<initializer_list>",
            "text": "Der Header <initializer_list> stellt den Typ std::initializer_list f√ºr Initialisierung mit geschweiften Klammern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<initializer_list> erm√∂glicht die √úbergabe einer Liste von Werten in geschweiften Klammern.",
              "Dies wird h√§ufig f√ºr Konstruktoren und Funktionsparameter genutzt."
            ]
          },
          {
            "type": "explanation",
            "title": "std::initializer_list",
            "text": [
              "std::initializer_list erlaubt es, mehrere Werte kompakt mit {} an Funktionen oder Konstruktoren zu √ºbergeben, ohne einen Container zu erzeugen.",
              "std::initializer_list repr√§sentiert eine unver√§nderliche Sequenz von Elementen gleichen Typs.",
              "Die enthaltenen Elemente sind konstant und k√∂nnen nicht ver√§ndert werden."
            ]
          },
          {
            "type": "list",
            "title": "Typische Einsatzgebiete",
            "items": [
              "Initialisierung von Containern wie std::vector oder std::set",
              "Konstruktoren mit variabler Anzahl an Argumenten",
              "Funktionsaufrufe mit Listenliteralen"
            ]
          },
          {
            "type": "code",
            "title": "Container-Initialisierung",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4};\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Konstruktor mit initializer_list",
            "language": "cpp",
            "code": "#include <iostream>\n#include <initializer_list>\n\nstruct Summe {\n    int wert = 0;\n\n    Summe(std::initializer_list<int> liste) {\n        for (int x : liste) {\n            wert += x;\n        }\n    }\n};\n\nint main() {\n    Summe s = {1, 2, 3};\n    std::cout << s.wert << std::endl; // Ausgabe: 6\n}\n"
          },
          {
            "type": "code",
            "title": "Als Funktionsparameter",
            "language": "cpp",
            "code": "#include <iostream>\n#include <initializer_list>\n\nvoid drucke(std::initializer_list<int> liste) {\n    for (int x : liste) {\n        std::cout << x << \" \";\n    }\n}\n\nint main() {\n    drucke({5, 10, 15});\n}\n"
          },
          {
            "type": "comparison",
            "title": "initializer_list vs Container",
            "columns": ["initializer_list", "Container"],
            "rows": [
              {
                "aspect": "Ver√§nderbar",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Besitzt Speicher",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Lebensdauer",
                "values": ["Kurzzeitig", "Verwaltet"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Mehrdeutige Konstruktoren",
            "text": "Konstruktoren mit initializer_list werden bei geschweiften Klammern bevorzugt und k√∂nnen andere Konstruktoren verdr√§ngen."
          },
          {
            "type": "important",
            "text": "<initializer_list> vereinfacht Initialisierung, sollte aber bewusst eingesetzt werden."
          },
          {
            "type": "summary",
            "points": [
              "<initializer_list> erm√∂glicht Initialisierung mit {}",
              "Elemente sind konstant und nicht ver√§nderbar",
              "H√§ufig in Konstruktoren und Containern",
              "Kann zu Mehrdeutigkeiten f√ºhren"
            ]
          }
        ]
      },
      {
        "title": "tuple",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<tuple>",
            "text": "Der Header <tuple> stellt den Typ std::tuple zur Speicherung einer festen Anzahl heterogener Werte bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "std::tuple kann mehrere Werte unterschiedlicher Typen in einem Objekt b√ºndeln.",
              "Im Gegensatz zu Structs sind die Elemente positionsbasiert und nicht benannt."
            ]
          },
          {
            "type": "explanation",
            "title": "Eigenschaften von std::tuple",
            "text": [
              "Die Anzahl und Typen der Elemente sind zur Compilezeit festgelegt.",
              "Zugriff erfolgt √ºber Indizes oder √ºber strukturierte Bindungen."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::tuple<T, S, ...> - Tupeltyp mit beliebigen Typen",
              "std::make_tuple - erstellt ein Tupel mit Typableitung",
              "std::get<I> - Zugriff auf ein Element per Index",
              "std::tie - Bindet Variablen an Tupel",
              "std::tuple_size - Anzahl der Elemente"
            ]
          },
          {
            "type": "code",
            "title": "Einfaches tuple erstellen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    std::tuple<int, double, char> t(1, 3.14, 'a');\n\n    std::cout << std::get<0>(t) << std::endl; // Ausgabe: 1\n    std::cout << std::get<1>(t) << std::endl; // Ausgabe: 3.14\n    std::cout << std::get<2>(t) << std::endl; // Ausgabe: a\n}\n"
          },
          {
            "type": "code",
            "title": "make_tuple verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    auto t = std::make_tuple(42, true, 2.5);\n\n    std::cout << std::get<1>(t) << std::endl; // Ausgabe: 1\n}\n"
          },
          {
            "type": "code",
            "title": "Strukturierte Bindung (neue Variablen)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    std::tuple<int, double> t(7, 4.2);\n\n    auto [a, b] = t; // Entpacken des Tupels und binden an neue Variablen\n    std::cout << a << \" \" << b << std::endl;\n}\n"
          },
          {
            "type": "code",
            "title": "tuple mit std::tie zerlegen (bestehende Variablen)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nstd::tuple<int, int> berechne() {\n    return {10, 20};\n}\n\nint main() {\n    int a;\n    int b;\n\n    // std::tie bindet die Tuple-Elemente an bestehende Variablen\n    std::tie(a, b) = berechne();\n\n    std::cout << a << \" \" << b << std::endl; // Ausgabe: 10 20\n}\n"
          },
          {
            "type": "comparison",
            "title": "tuple vs struct",
            "columns": ["std::tuple", "struct"],
            "rows": [
              {
                "aspect": "Elementnamen",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Typheterogen",
                "values": ["Ja", "Ja"]
              },
              {
                "aspect": "Lesbarkeit",
                "values": ["Geringer", "H√∂her"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Un√ºbersichtlicher Code",
            "text": "Zugriff √ºber Indizes wie get<2> kann die Lesbarkeit stark verschlechtern."
          },
          {
            "type": "important",
            "text": "std::tuple eignet sich gut f√ºr R√ºckgabewerte, sollte aber nicht als Ersatz f√ºr klar benannte Structs missbraucht werden."
          },
          {
            "type": "summary",
            "points": [
              "<tuple> b√ºndelt heterogene Werte",
              "Zugriff √ºber Indizes oder strukturierte Bindungen",
              "Geeignet f√ºr R√ºckgabewerte mehrerer Werte",
              "Structs sind oft besser lesbar"
            ]
          }
        ]
      },
      {
        "title": "utility (pair, swap)",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<utility>",
            "text": "Der Header <utility> stellt grundlegende Hilfstypen und Funktionen wie std::pair und std::swap bereit."
          },
          {
            "type": "explanation",
            "title": "Zweck des Headers",
            "text": [
              "<utility> enth√§lt kleine, aber zentrale Bausteine der Standardbibliothek.",
              "Viele Container, Algorithmen und APIs bauen intern auf diesen Typen auf."
            ]
          },
          {
            "type": "explanation",
            "title": "std::pair",
            "text": [
              "std::pair speichert genau zwei Werte, die unterschiedliche Typen haben k√∂nnen.",
              "Der Zugriff erfolgt √ºber die √∂ffentlichen Member first und second."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::pair<T1, T2> - Tupel aus genau zwei Werten",
              "std::make_pair - erstellt ein pair mit Typableitung",
              "first / second - Zugriff auf die Elemente",
              "std::swap - tauscht zwei Werte",
              "std::move - wandelt ein Objekt in einen rvalue um, sodass ein Move m√∂glich ist"
            ]
          },
          {
            "type": "code",
            "title": "pair erstellen und verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    std::pair<int, std::string> p(1, \"eins\");\n\n    std::cout << p.first << std::endl;  // Ausgabe: 1\n    std::cout << p.second << std::endl; // Ausgabe: eins\n}\n"
          },
          {
            "type": "code",
            "title": "make_pair und strukturierte Bindung",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    auto p = std::make_pair(10, 3.14);\n\n    auto [a, b] = p; // Strukturierte Bindung\n    std::cout << a << \" \" << b << std::endl;\n}\n"
          },
          {
            "type": "code",
            "title": "swap verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    int a = 5;\n    int b = 10;\n\n    std::swap(a, b); // Werte tauschen\n\n    std::cout << a << \" \" << b << std::endl; // Ausgabe: 10 5\n}\n"
          },
          {
            "type": "code",
            "title": "std::move: Besitz von Ressourcen √ºbertragen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nint main() {\n    std::vector<int> a = {1, 2, 3, 4};\n\n    // a besitzt initial 4 Elemente\n    std::cout << \"a.size() vor move: \" << a.size() << std::endl;\n    // Ausgabe: a.size() vor move: 4\n\n    // std::move wandelt a in einen rvalue um\n    // Der Move-Konstruktor von std::vector wird verwendet\n    std::vector<int> b = std::move(a);\n\n    // b √ºbernimmt den Speicher von a\n    std::cout << \"b.size(): \" << b.size() << std::endl;\n    // Ausgabe: b.size(): 4\n\n    // a ist nach dem Move weiterhin g√ºltig,\n    // aber sein Inhalt ist nicht mehr definiert\n    // Bei std::vector ist a typischerweise leer\n    std::cout << \"a.size() nach move: \" << a.size() << std::endl;\n    // Typische Ausgabe: a.size() nach move: 0\n}\n"
          },
          {
            "type": "comparison",
            "title": "pair vs tuple",
            "columns": ["std::pair", "std::tuple"],
            "rows": [
              {
                "aspect": "Anzahl Elemente",
                "values": ["Genau 2", "Beliebig"]
              },
              {
                "aspect": "Lesbarkeit",
                "values": ["H√∂her", "Geringer"]
              },
              {
                "aspect": "Typableitung",
                "values": ["make_pair", "make_tuple"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "first und second",
            "text": "Die Bedeutung von first und second ist semantisch nicht festgelegt und kann Code schwer lesbar machen."
          },
          {
            "type": "important",
            "text": "std::pair eignet sich gut f√ºr einfache Zweierkombinationen, sollte aber nicht komplexe Datenstrukturen ersetzen."
          },
          {
            "type": "summary",
            "points": [
              "<utility> stellt pair und swap bereit",
              "std::pair b√ºndelt zwei Werte",
              "swap tauscht Inhalte effizient",
              "F√ºr mehr als zwei Werte ist tuple besser geeignet"
            ]
          }
        ]
      }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
        {
          "title": "Klassen Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Klasse",
              "text": "Eine Klasse ist ein benutzerdefinierter Datentyp, der Daten und zugeh√∂rige Funktionen kapselt."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Klassen",
              "text": [
                "Klassen sind das zentrale Konzept der objektorientierten Programmierung in C++.",
                "Sie b√ºndeln Daten und Verhalten und bilden reale oder logische Konzepte ab."
              ]
            },
            {
              "type": "explanation",
              "title": "Bestandteile einer Klasse",
              "text": [
                "Eine Klasse besteht aus Attributen f√ºr den Zustand und Methoden f√ºr das Verhalten.",
                "√úber Zugriffsspezifizierer wird gesteuert, welche Teile von au√üen sichtbar sind."
              ]
            },
            {
              "type": "list",
              "title": "Zugriffsspezifizierer",
              "items": [
                "public - von √ºberall zugreifbar",
                "private - nur innerhalb der Klasse zugreifbar",
                "protected - innerhalb der Klasse und abgeleiteter Klassen"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Person {\npublic:\n    void begruessen() {\n        std::cout << \"Hallo\" << std::endl;\n    }\n\nprivate:\n    int alter;\n};\n\nint main() {\n    Person p;\n    p.begruessen(); // Zugriff auf √∂ffentliche Methode\n}\n"
            },
            {
              "type": "comparison",
              "title": "class vs struct",
              "columns": ["class", "struct"],
              "rows": [
                {
                  "aspect": "Standard-Zugriff",
                  "values": ["private", "public"]
                },
                {
                  "aspect": "Einsatz",
                  "values": ["Objektorientierung", "Datenstrukturen"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Fehlende Kapselung",
              "text": "√ñffentliche Attribute verletzen die Kapselung und machen Code schwer wartbar."
            },
            {
              "type": "important",
              "text": "Klassen sollten Daten kapseln und nur notwendige Schnittstellen nach au√üen anbieten."
            },
            {
              "type": "summary",
              "points": [
                "Klassen b√ºndeln Daten und Verhalten",
                "Zugriff wird √ºber public, private und protected gesteuert",
                "Kapselung ist ein zentrales OOP-Prinzip"
              ]
            }
          ]
        },
        {
          "title": "Konstruktoren & Destruktoren",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Konstruktor und Destruktor",
              "text": "Konstruktoren initialisieren Objekte beim Erzeugen, Destruktoren r√§umen beim Zerst√∂ren auf."
            },
            {
              "type": "explanation",
              "title": "Konstruktoren",
              "text": [
                "Ein Konstruktor wird automatisch beim Erzeugen eines Objekts aufgerufen.",
                "Er hat keinen R√ºckgabetyp und tr√§gt den gleichen Namen wie die Klasse."
              ]
            },
            {
              "type": "explanation",
              "title": "Destruktoren",
              "text": [
                "Ein Destruktor wird automatisch beim Zerst√∂ren eines Objekts aufgerufen.",
                "Er wird h√§ufig genutzt, um Ressourcen wie Speicher oder Dateien freizugeben."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Eigenschaften",
              "items": [
                "Konstruktoren k√∂nnen √ºberladen werden",
                "Destruktoren haben keine Parameter",
                "Pro Klasse existiert maximal ein Destruktor"
              ]
            },
            {
              "type": "code",
              "title": "Konstruktor und Destruktor",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Test {\npublic:\n    Test() {\n        std::cout << \"Konstruktor\" << std::endl;\n    }\n\n    ~Test() {\n        std::cout << \"Destruktor\" << std::endl;\n    }\n};\n\nint main() {\n    Test t; // Konstruktor wird aufgerufen\n} // Destruktor wird hier automatisch aufgerufen\n"
            },
            {
              "type": "code",
              "title": "Konstruktor mit Parametern",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt(int x, int y) : x(x), y(y) {}\n\n    void anzeigen() {\n        std::cout << x << \", \" << y << std::endl;\n    }\n\nprivate:\n    int x;\n    int y;\n};\n\nint main() {\n    Punkt p(3, 4);\n    p.anzeigen();\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Nicht initialisierte Attribute",
              "text": "Werden Attribute nicht im Konstruktor initialisiert, k√∂nnen undefinierte Werte entstehen."
            },
            {
              "type": "important",
              "text": "Initialisierung sollte bevorzugt √ºber Initialisierungslisten erfolgen."
            },
            {
              "type": "summary",
              "points": [
                "Konstruktoren initialisieren Objekte",
                "Destruktoren geben Ressourcen frei",
                "Initialisierungslisten sind Best Practice",
                "Automatischer Aufruf durch Lebensdauer"
              ]
            }
          ]
        },
        {
          "title": "Copy-Konstruktor & Zuweisungsoperator",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Copy-Konstruktor und Copy-Zuweisungsoperator",
              "text": "Der Copy-Konstruktor erstellt ein neues Objekt als Kopie eines bestehenden, der Zuweisungsoperator √ºberschreibt ein bestehendes Objekt mit den Werten eines anderen."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Beide Mechanismen regeln, wie Objekte kopiert werden.",
                "Sie sind besonders wichtig, wenn eine Klasse Ressourcen wie Speicher oder Dateien verwaltet."
              ]
            },
            {
              "type": "explanation",
              "title": "Copy-Konstruktor",
              "text": [
                "Der Copy-Konstruktor wird beim Erzeugen eines neuen Objekts aus einem bestehenden aufgerufen.",
                "Er hat die Signatur Klasse(const Klasse& other)."
              ]
            },
            {
              "type": "explanation",
              "title": "Copy-Zuweisungsoperator",
              "text": [
                "Der Zuweisungsoperator wird aufgerufen, wenn ein existierendes Objekt einem anderen zugewiesen wird.",
                "Er hat die Signatur Klasse& operator=(const Klasse& other)."
              ]
            },
            {
              "type": "list",
              "title": "Typische Aufrufstellen",
              "items": [
                "√úbergabe von Objekten per Wert an Funktionen",
                "R√ºckgabe von Objekten per Wert",
                "Zuweisung mit dem = Operator",
                "Initialisierung aus einem bestehenden Objekt"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher Copy-Konstruktor",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    int x;\n\n    Punkt(int x) : x(x) {}\n\n    Punkt(const Punkt& other) : x(other.x) {\n        std::cout << \"Copy-Konstruktor\" << std::endl;\n    }\n};\n\nint main() {\n    Punkt a(5);\n    Punkt b = a; // Copy-Konstruktor\n}\n"
            },
            {
              "type": "code",
              "title": "Copy-Zuweisungsoperator",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    int x;\n\n    Punkt(int x) : x(x) {}\n\n    Punkt& operator=(const Punkt& other) {\n        if (this != &other) {\n            x = other.x; // Selbstzuweisung pr√ºfen\n        }\n        return *this;\n    }\n};\n\nint main() {\n    Punkt a(1);\n    Punkt b(2);\n\n    b = a; // Copy-Zuweisung\n}\n"
            },
            {
              "type": "comparison",
              "title": "Copy-Konstruktor vs Zuweisung",
              "columns": ["Copy-Konstruktor", "Zuweisungsoperator"],
              "rows": [
                {
                  "aspect": "Objekt existiert bereits",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Wird bei Initialisierung aufgerufen",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Muss Selbstzuweisung pr√ºfen",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Flache Kopie bei Ressourcen",
              "text": "Bei Klassen mit Zeigern f√ºhrt eine flache Kopie oft zu doppeltem Freigeben oder Speicherfehlern."
            },
            {
              "type": "important",
              "text": "Sobald eine Klasse Ressourcen besitzt, m√ºssen Copy-Konstruktor und Zuweisungsoperator bewusst definiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Copy-Konstruktor erzeugt neue Objekte",
                "Zuweisungsoperator √ºberschreibt bestehende Objekte",
                "Selbstzuweisung muss ber√ºcksichtigt werden",
                "Besonders wichtig bei Ressourcenverwaltung"
              ]
            }
          ]
        },
        {
          "title": "Move-Konstruktor & Move-Zuweisung & Rvalue-Referenzen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Move-Semantik",
              "text": "Move-Semantik erlaubt das effiziente √úbertragen von Ressourcen aus tempor√§ren Objekten mithilfe von Rvalue-Referenzen."
            },
            {
              "type": "explanation",
              "title": "Motivation",
              "text": [
                "Das Kopieren von Objekten mit dynamischen Ressourcen ist teuer.",
                "Move-Semantik erm√∂glicht es, Besitz zu √ºbernehmen statt Daten zu kopieren."
              ]
            },
            {
              "type": "explanation",
              "title": "Rvalue-Referenzen",
              "text": [
                "Rvalue-Referenzen werden mit && deklariert.",
                "Sie binden an tempor√§re Objekte oder an Objekte, die explizit mit std::move markiert wurden."
              ]
            },
            {
              "type": "explanation",
              "title": "Move-Konstruktor",
              "text": [
                "Der Move-Konstruktor erzeugt ein neues Objekt, indem er Ressourcen aus einem anderen Objekt √ºbernimmt.",
                "Er hat die Signatur Klasse(Klasse&& other)."
              ]
            },
            {
              "type": "explanation",
              "title": "Move-Zuweisungsoperator",
              "text": [
                "Der Move-Zuweisungsoperator √ºberschreibt ein bestehendes Objekt mit den Ressourcen eines anderen.",
                "Er hat die Signatur Klasse& operator=(Klasse&& other)."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzf√§lle",
              "items": [
                "R√ºckgabe gro√üer Objekte aus Funktionen",
                "Einf√ºgen in Container wie std::vector",
                "Explizite Verwendung von std::move",
                "Optimierung von Performance-kritischem Code"
              ]
            },
            {
              "type": "code",
              "title": "Move-Konstruktor",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    Puffer(int wert) {\n        daten = new int(wert);\n    }\n\n    Puffer(Puffer&& other) noexcept : daten(other.daten) {\n        other.daten = nullptr;\n        std::cout << \"Move-Konstruktor\" << std::endl;\n    }\n\n    ~Puffer() {\n        delete daten;\n    }\n};\n\nint main() {\n    Puffer a(5);\n    Puffer b = std::move(a); // Move-Konstruktor\n}\n"
            },
            {
              "type": "code",
              "title": "Move-Zuweisungsoperator",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    Puffer(int wert) {\n        daten = new int(wert);\n    }\n\n    Puffer& operator=(Puffer&& other) noexcept {\n        if (this != &other) {\n            delete daten;            // Alte Ressource freigeben\n            daten = other.daten;     // Ressource √ºbernehmen\n            other.daten = nullptr;   // Quelle leeren\n        }\n        return *this;\n    }\n\n    ~Puffer() {\n        delete daten;\n    }\n};\n\nint main() {\n    Puffer a(1);\n    Puffer b(2);\n\n    b = std::move(a); // Move-Zuweisung\n}\n"
            },
            {
              "type": "code",
              "title": "Rvalue-Referenz als Parameter",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\nvoid verarbeite(std::string&& s) {\n    std::cout << s << std::endl;\n}\n\nint main() {\n    verarbeite(std::string(\"Hallo\")); // tempor√§res Objekt\n}\n"
            },
            {
              "type": "comparison",
              "title": "Copy vs Move",
              "columns": ["Copy", "Move"],
              "rows": [
                {
                  "aspect": "Ressourcenbehandlung",
                  "values": ["Kopieren", "√úbernehmen"]
                },
                {
                  "aspect": "Kosten",
                  "values": ["Hoch", "Sehr gering"]
                },
                {
                  "aspect": "Zustand der Quelle",
                  "values": ["Unver√§ndert", "G√ºltig aber leer"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessene Absicherung",
              "text": "Wird die Quelle nach der Move-Operation nicht korrekt geleert, kann es zu doppeltem Freigeben kommen."
            },
            {
              "type": "important",
              "text": "Move-Konstruktoren und Move-Zuweisungsoperatoren sollten noexcept sein, damit Standardcontainer sie effizient nutzen k√∂nnen."
            },
            {
              "type": "summary",
              "points": [
                "Rvalue-Referenzen erm√∂glichen Move-Semantik",
                "Move-Konstruktor erzeugt neue Objekte effizient",
                "Move-Zuweisung √ºberschreibt bestehende Objekte",
                "std::move markiert Objekte als verschiebbar"
              ]
            }
          ]
        },
        {
          "title": "Rule of Five",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Rule of Five",
              "text": "Die Rule of Five besagt, dass eine Klasse bei eigener Ressourcenverwaltung in der Regel f√ºnf spezielle Memberfunktionen explizit definieren sollte."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Sobald eine Klasse eine Ressource wie dynamischen Speicher, Dateien oder Handles besitzt, reicht das implizite Verhalten des Compilers oft nicht aus.",
                "Die Rule of Five erweitert die fr√ºhere Rule of Three um Move-Semantik."
              ]
            },
            {
              "type": "explanation",
              "title": "Die f√ºnf speziellen Memberfunktionen",
              "text": [
                "Diese Funktionen steuern Erzeugung, Kopieren, Verschieben und Zerst√∂rung von Objekten.",
                "Sie m√ºssen konsistent zusammen implementiert werden, um Fehler zu vermeiden."
              ]
            },
            {
              "type": "list",
              "title": "Bestandteile der Rule of Five",
              "items": [
                "Destruktor",
                "Copy-Konstruktor",
                "Copy-Zuweisungsoperator",
                "Move-Konstruktor",
                "Move-Zuweisungsoperator"
              ]
            },
            {
              "type": "code",
              "title": "Beispielklasse mit Ressource",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    // Konstruktor\n    Puffer(int wert) : daten(new int(wert)) {}\n\n    // Destruktor\n    ~Puffer() {\n        delete daten;\n    }\n\n    // Copy-Konstruktor\n    Puffer(const Puffer& other) : daten(new int(*other.daten)) {}\n\n    // Copy-Zuweisungsoperator\n    Puffer& operator=(const Puffer& other) {\n        if (this != &other) {\n            delete daten;\n            daten = new int(*other.daten);\n        }\n        return *this;\n    }\n\n    // Move-Konstruktor\n    Puffer(Puffer&& other) noexcept : daten(other.daten) {\n        other.daten = nullptr;\n    }\n\n    // Move-Zuweisungsoperator\n    Puffer& operator=(Puffer&& other) noexcept {\n        if (this != &other) {\n            delete daten;\n            daten = other.daten;\n            other.daten = nullptr;\n        }\n        return *this;\n    }\n};\n"
            },
            {
              "type": "comparison",
              "title": "Rule of Three vs Rule of Five",
              "columns": ["Rule of Three", "Rule of Five"],
              "rows": [
                {
                  "aspect": "Ber√ºcksichtigung von Move-Semantik",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Moderne C++ Relevanz",
                  "values": ["Begrenzt", "Hoch"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unvollst√§ndige Implementierung",
              "text": "Wer nur einige der f√ºnf Funktionen definiert, riskiert inkonsistentes Verhalten und Speicherfehler."
            },
            {
              "type": "important",
              "text": "Wenn keine eigene Ressource verwaltet wird, sollten diese Funktionen gar nicht definiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Rule of Five gilt bei eigener Ressourcenverwaltung",
                "Umfasst Copy und Move Semantik",
                "Verhindert Speicherfehler und doppeltes Freigeben",
                "Ohne Ressourcen besser gar nicht implementieren"
              ]
            }
          ]
        },
        {
          "title": "Implizite Klassenbestandteile & = delete",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Implizite Klassenbestandteile",
              "text": "Implizite Klassenbestandteile sind spezielle Memberfunktionen, die der Compiler automatisch generiert, wenn sie nicht explizit definiert werden."
            },
            {
              "type": "explanation",
              "title": "Automatisch generierte Funktionen",
              "text": [
                "Der Compiler erzeugt bestimmte Memberfunktionen automatisch, wenn keine eigene Implementierung vorhanden ist.",
                "Dieses Verhalten kann zu unerwarteten Kopien oder Zuweisungen f√ºhren, insbesondere bei Ressourcenverwaltung."
              ]
            },
            {
              "type": "list",
              "title": "Implizit generierte Memberfunktionen",
              "items": [
                "Standardkonstruktor",
                "Destruktor",
                "Copy-Konstruktor",
                "Copy-Zuweisungsoperator",
                "Move-Konstruktor",
                "Move-Zuweisungsoperator"
              ]
            },
            {
              "type": "explanation",
              "title": "Steuerung mit = delete",
              "text": [
                "Mit = delete kann die automatische Generierung oder Nutzung bestimmter Funktionen verboten werden.",
                "Dadurch wird fehlerhafte oder unerw√ºnschte Verwendung bereits zur Compilezeit verhindert."
              ]
            },
            {
              "type": "code",
              "title": "Kopieren verbieten mit = delete",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass NichtKopierbar {\npublic:\n    NichtKopierbar() = default;\n    NichtKopierbar(const NichtKopierbar&) = delete;\n    NichtKopierbar& operator=(const NichtKopierbar&) = delete;\n};\n\nint main() {\n    NichtKopierbar a;\n    // NichtKopierbar b = a; // Fehler: Copy-Konstruktor ist gel√∂scht\n}\n"
            },
            {
              "type": "code",
              "title": "Gezielte Standardimplementierung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Einfach {\npublic:\n    Einfach() = default; // explizit erlaubter Standardkonstruktor\n};\n\nint main() {\n    Einfach e;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Implizit vs explizit gel√∂scht",
              "columns": ["Implizit generiert", "= delete"],
              "rows": [
                {
                  "aspect": "Verf√ºgbarkeit",
                  "values": ["Automatisch", "Verboten"]
                },
                {
                  "aspect": "Fehlerzeitpunkt",
                  "values": ["Zur Laufzeit m√∂glich", "Zur Compilezeit"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unerwartete Kopien",
              "text": "Ohne explizite Kontrolle kann der Compiler Kopieroperationen erzeugen, die bei Ressourcen zu Fehlern f√ºhren."
            },
            {
              "type": "important",
              "text": "= delete ist ein wichtiges Werkzeug, um Klassenschnittstellen eindeutig und sicher zu gestalten."
            },
            {
              "type": "summary",
              "points": [
                "Compiler erzeugt spezielle Memberfunktionen automatisch",
                "= delete verbietet deren Nutzung explizit",
                "Fehler werden zur Compilezeit erkannt",
                "Besonders wichtig bei Ressourcenverwaltung"
              ]
            }
          ]
        },
        {
          "title": "explicit & friend",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "explicit und friend",
              "text": "explicit verhindert implizite Typumwandlungen bei Konstruktoren, friend erlaubt gezielten Zugriff auf private Klassenbestandteile."
            },
            {
              "type": "explanation",
              "title": "explicit",
              "text": [
                "Das Schl√ºsselwort explicit wird bei Konstruktoren mit einem Parameter verwendet.",
                "Es verhindert implizite Typkonvertierungen, die sonst automatisch vom Compiler durchgef√ºhrt w√ºrden."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum explicit wichtig ist",
              "text": [
                "Implizite Konvertierungen k√∂nnen zu unerwartetem Verhalten und schwer auffindbaren Fehlern f√ºhren.",
                "explicit macht Konstruktoraufrufe bewusst und eindeutig."
              ]
            },
            {
              "type": "code",
              "title": "Implizite Konvertierung ohne explicit",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zahl {\npublic:\n    Zahl(int x) : x(x) {}\n\n    int x;\n};\n\nvoid ausgabe(Zahl z) {\n    std::cout << z.x << std::endl;\n}\n\nint main() {\n    ausgabe(5); // implizite Konvertierung von int zu Zahl\n}\n"
            },
            {
              "type": "code",
              "title": "explicit verhindert implizite Konvertierung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zahl {\npublic:\n    explicit Zahl(int x) : x(x) {}\n\n    int x;\n};\n\nvoid ausgabe(Zahl z) {\n    std::cout << z.x << std::endl;\n}\n\nint main() {\n    // ausgabe(5); // Fehler: implizite Konvertierung verboten\n    ausgabe(Zahl(5)); // expliziter Aufruf\n}\n"
            },
            {
              "type": "explanation",
              "title": "friend",
              "text": [
                "Mit friend kann einer fremden Funktion oder Klasse Zugriff auf private und protected Member gew√§hrt werden.",
                "friend durchbricht gezielt die Kapselung, ohne die Member √∂ffentlich zu machen."
              ]
            },
            {
              "type": "code",
              "title": "friend Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Geheim {\n    int wert = 42;\n\n    friend void zeige(const Geheim& g);\n};\n\nvoid zeige(const Geheim& g) {\n    std::cout << g.wert << std::endl; // Zugriff erlaubt\n}\n\nint main() {\n    Geheim g;\n    zeige(g);\n}\n"
            },
            {
              "type": "code",
              "title": "friend Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass A {\n    int x = 10;\n\n    friend class B;\n};\n\nclass B {\npublic:\n    void drucke(const A& a) {\n        std::cout << a.x << std::endl; // Zugriff auf private Member\n    }\n};\n\nint main() {\n    A a;\n    B b;\n    b.drucke(a);\n}\n"
            },
            {
              "type": "comparison",
              "title": "explicit vs friend",
              "columns": ["explicit", "friend"],
              "rows": [
                {
                  "aspect": "Zweck",
                  "values": ["Verhindert implizite Konvertierung", "Erlaubt privaten Zugriff"]
                },
                {
                  "aspect": "Beeinflusst Kapselung",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "√úberm√§√üiger friend Einsatz",
              "text": "Zu viele friend Deklarationen schw√§chen die Kapselung und erschweren Wartung."
            },
            {
              "type": "important",
              "text": "explicit sollte standardm√§√üig bei Ein-Parameter-Konstruktoren verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "explicit verhindert unerw√ºnschte implizite Konvertierungen",
                "friend erlaubt gezielten Zugriff auf private Member",
                "Beide Schl√ºsselw√∂rter erh√∂hen Code-Sicherheit bei richtiger Nutzung"
              ]
            }
          ]
        },
        {
          "title": "Getter-Funktionen & Setter-Funktionen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Getter und Setter",
              "text": "Getter- und Setter-Funktionen sind Methoden, mit denen kontrolliert auf private Attribute einer Klasse zugegriffen wird."
            },
            {
              "type": "explanation",
              "title": "Zweck von Getter und Setter",
              "text": [
                "Sie kapseln den Zugriff auf interne Daten einer Klasse.",
                "Dadurch k√∂nnen Invarianten und Validierungen zentral sichergestellt werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Getter-Funktionen",
              "text": [
                "Getter liefern den aktuellen Wert eines Attributs zur√ºck.",
                "Sie sollten den Zustand des Objekts nicht ver√§ndern."
              ]
            },
            {
              "type": "explanation",
              "title": "Setter-Funktionen",
              "text": [
                "Setter setzen oder √§ndern den Wert eines Attributs.",
                "Dabei kann √ºberpr√ºft werden, ob der neue Wert g√ºltig ist."
              ]
            },
            {
              "type": "list",
              "title": "Best Practices",
              "items": [
                "Attribute private halten",
                "Getter m√∂glichst const deklarieren",
                "Validierung im Setter durchf√ºhren",
                "Nicht f√ºr jedes Attribut automatisch Setter bereitstellen"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Getter und Setter",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Person {\npublic:\n    void setAlter(int neuesAlter) {\n        if (neuesAlter >= 0) {\n            alter = neuesAlter;\n        }\n    }\n\n    int getAlter() const {\n        return alter;\n    }\n\nprivate:\n    int alter = 0;\n};\n\nint main() {\n    Person p;\n    p.setAlter(25);\n    std::cout << p.getAlter() << std::endl; // Ausgabe: 25\n}\n"
            },
            {
              "type": "comparison",
              "title": "Direkter Zugriff vs Getter/Setter",
              "columns": ["Direkter Zugriff", "Getter/Setter"],
              "rows": [
                {
                  "aspect": "Kapselung",
                  "values": ["Keine", "Vorhanden"]
                },
                {
                  "aspect": "Validierung m√∂glich",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Triviale Getter und Setter",
              "text": "Unkritische Weitergabe aller Attribute als Getter und Setter kann unn√∂tigen Boilerplate-Code erzeugen."
            },
            {
              "type": "important",
              "text": "Getter und Setter sollten Verhalten ausdr√ºcken und nicht nur als mechanischer Zugriff dienen."
            },
            {
              "type": "summary",
              "points": [
                "Getter lesen, Setter schreiben Attribute",
                "Kapselung sch√ºtzt interne Zust√§nde",
                "Validierung im Setter erh√∂ht Sicherheit",
                "Getter sollten const sein"
              ]
            }
          ]
        }
      ]
      },

      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
        {
          "title": "Basisklassen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Basisklasse",
              "text": "Eine Basisklasse ist eine Klasse, von der andere Klassen Eigenschaften und Verhalten erben."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Vererbung",
              "text": [
                "Vererbung erm√∂glicht es, gemeinsamen Code in einer Basisklasse zu b√ºndeln.",
                "Abgeleitete Klassen erweitern oder spezialisieren das Verhalten der Basisklasse."
              ]
            },
            {
              "type": "explanation",
              "title": "Basisklasse und abgeleitete Klasse",
              "text": [
                "Die Basisklasse definiert gemeinsame Attribute und Methoden.",
                "Die abgeleitete Klasse erbt diese Bestandteile und kann sie nutzen oder √ºberschreiben."
              ]
            },
            {
              "type": "list",
              "title": "Zugriff in der Vererbung",
              "items": [
                "public Member sind in abgeleiteten Klassen zugreifbar",
                "protected Member sind nur f√ºr abgeleitete Klassen sichtbar",
                "private Member sind nicht direkt zugreifbar"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Basisklasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Tier {\npublic:\n    void sprechen() const {\n        std::cout << \"Tier macht ein Ger√§usch\" << std::endl;\n    }\n\nprotected:\n    int alter = 0;\n};\n\nclass Hund : public Tier {\npublic:\n    void bellen() const {\n        std::cout << \"Hund bellt\" << std::endl;\n    }\n};\n\nint main() {\n    Hund h;\n    h.sprechen(); // geerbte Methode\n    h.bellen();   // eigene Methode\n}\n"
            },
            {
              "type": "comparison",
              "title": "Basisklasse vs abgeleitete Klasse",
              "columns": ["Basisklasse", "Abgeleitete Klasse"],
              "rows": [
                {
                  "aspect": "Rolle",
                  "values": ["Allgemein", "Spezialisiert"]
                },
                {
                  "aspect": "Code-Wiederverwendung",
                  "values": ["Definiert", "Nutzt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Private Member",
              "text": "Private Member der Basisklasse sind in abgeleiteten Klassen nicht direkt zugreifbar."
            },
            {
              "type": "important",
              "text": "Basisklassen sollten eine klare, stabile Schnittstelle f√ºr abgeleitete Klassen bereitstellen."
            },
            {
              "type": "summary",
              "points": [
                "Basisklassen b√ºndeln gemeinsamen Code",
                "Abgeleitete Klassen erweitern Verhalten",
                "Zugriff wird durch public, protected und private gesteuert",
                "Vererbung f√∂rdert Wiederverwendbarkeit"
              ]
            }
          ]
        },
        {
          "title": "Polymorphie mit virtual & override",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Polymorphie",
              "text": "Polymorphie bezeichnet die F√§higkeit, dass unterschiedliche Objekte √ºber eine gemeinsame Basisklassen-Schnittstelle unterschiedlich reagieren."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Polymorphie basiert auf Vererbung und virtuellen Funktionen.",
                "Ein Basisklassen-Zeiger oder eine Referenz kann auf Objekte verschiedener abgeleiteter Klassen zeigen."
              ]
            },
            {
              "type": "explanation",
              "title": "virtual",
              "text": [
                "Mit virtual deklarierte Funktionen werden dynamisch gebunden.",
                "Welche Implementierung aufgerufen wird, entscheidet sich zur Laufzeit anhand des tats√§chlichen Objekttyps."
              ]
            },
            {
              "type": "explanation",
              "title": "override",
              "text": [
                "override kennzeichnet explizit das √úberschreiben einer virtuellen Funktion.",
                "Der Compiler pr√ºft die Signatur und verhindert unbeabsichtigtes √úberladen statt √úberschreiben."
              ]
            },
            {
              "type": "list",
              "title": "Voraussetzungen f√ºr Polymorphie",
              "items": [
                "Vererbung zwischen Basisklasse und abgeleiteten Klassen",
                "Virtuelle Funktion in der Basisklasse",
                "Zugriff √ºber Basisklassen-Zeiger oder Referenz"
              ]
            },
            {
              "type": "code",
              "title": "Polymorpher Aufruf mit virtual und override",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Tier {\npublic:\n    virtual void sprechen() const {\n        std::cout << \"Tier macht ein Ger√§usch\" << std::endl;\n    }\n\n    virtual ~Tier() = default; // Virtueller Destruktor\n};\n\nclass Hund : public Tier {\npublic:\n    void sprechen() const override {\n        std::cout << \"Hund bellt\" << std::endl;\n    }\n};\n\nclass Katze : public Tier {\npublic:\n    void sprechen() const override {\n        std::cout << \"Katze miaut\" << std::endl;\n    }\n};\n\nint main() {\n    Tier* t1 = new Hund();\n    Tier* t2 = new Katze();\n\n    t1->sprechen(); // Hund bellt\n    t2->sprechen(); // Katze miaut\n\n    delete t1;\n    delete t2;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Ohne virtual vs mit virtual",
              "columns": ["Ohne virtual", "Mit virtual"],
              "rows": [
                {
                  "aspect": "Bindungszeitpunkt",
                  "values": ["Compilezeit", "Laufzeit"]
                },
                {
                  "aspect": "Aufgerufene Funktion",
                  "values": ["Basisklasse", "Tats√§chlicher Objekttyp"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Fehlender virtueller Destruktor",
              "text": "Wird ein Objekt √ºber einen Basisklassen-Zeiger gel√∂scht ohne virtuellen Destruktor, entsteht undefiniertes Verhalten."
            },
            {
              "type": "important",
              "text": "Basisklassen mit virtuellen Funktionen sollten immer einen virtuellen Destruktor besitzen."
            },
            {
              "type": "summary",
              "points": [
                "Polymorphie erm√∂glicht unterschiedliches Verhalten √ºber eine gemeinsame Schnittstelle",
                "virtual aktiviert dynamische Bindung",
                "override sch√ºtzt vor falschem √úberschreiben",
                "Virtuelle Destruktoren sind essenziell"
              ]
            }
          ]
        },
        {
          "title": "Abstrakte Klassen & Schnittstellenklassen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Abstrakte Klasse",
              "text": "Eine abstrakte Klasse ist eine Klasse, die nicht instanziiert werden kann und mindestens eine reine virtuelle Funktion besitzt."
            },
            {
              "type": "explanation",
              "title": "Grundidee abstrakter Klassen",
              "text": [
                "Abstrakte Klassen definieren ein gemeinsames Verhalten f√ºr abgeleitete Klassen.",
                "Sie dienen als konzeptionelle Basis und erzwingen bestimmte Funktionen in Unterklassen."
              ]
            },
            {
              "type": "explanation",
              "title": "Reine virtuelle Funktionen",
              "text": [
                "Eine reine virtuelle Funktion wird mit = 0 deklariert.",
                "Abgeleitete Klassen m√ºssen diese Funktion implementieren, um instanziierbar zu sein."
              ]
            },
            {
              "type": "code",
              "title": "Abstrakte Klasse mit reiner virtueller Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Form {\npublic:\n    virtual double flaeche() const = 0; // reine virtuelle Funktion\n\n    virtual ~Form() = default;\n};\n\nclass Rechteck : public Form {\npublic:\n    Rechteck(double b, double h) : breite(b), hoehe(h) {}\n\n    double flaeche() const override {\n        return breite * hoehe;\n    }\n\nprivate:\n    double breite;\n    double hoehe;\n};\n\nint main() {\n    Form* f = new Rechteck(3, 4);\n    std::cout << f->flaeche() << std::endl; // Ausgabe: 12\n    delete f;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Schnittstellenklassen",
              "text": [
                "Eine Schnittstellenklasse ist eine spezielle Form der abstrakten Klasse.",
                "Sie enth√§lt ausschlie√ülich reine virtuelle Funktionen und meist keine Attribute."
              ]
            },
            {
              "type": "list",
              "title": "Merkmale von Schnittstellenklassen",
              "items": [
                "Nur reine virtuelle Funktionen",
                "Keine oder nur konstante Attribute",
                "Kein konkretes Verhalten",
                "√ñffentliche virtuelle Schnittstelle"
              ]
            },
            {
              "type": "code",
              "title": "Schnittstellenklasse Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Druckbar {\npublic:\n    virtual void drucken() const = 0;\n    virtual ~Druckbar() = default;\n};\n\nclass Bericht : public Druckbar {\npublic:\n    void drucken() const override {\n        std::cout << \"Bericht wird gedruckt\" << std::endl;\n    }\n};\n\nint main() {\n    Druckbar* d = new Bericht();\n    d->drucken();\n    delete d;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Abstrakte Klasse vs Schnittstellenklasse",
              "columns": ["Abstrakte Klasse", "Schnittstellenklasse"],
              "rows": [
                {
                  "aspect": "Enth√§lt Implementierungen",
                  "values": ["M√∂glich", "Nein"]
                },
                {
                  "aspect": "Attribute",
                  "values": ["Erlaubt", "In der Regel nicht"]
                },
                {
                  "aspect": "Ziel",
                  "values": ["Gemeinsame Basis", "Reine Schnittstelle"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessene Implementierung",
              "text": "Wird eine reine virtuelle Funktion nicht implementiert, bleibt die abgeleitete Klasse abstrakt."
            },
            {
              "type": "important",
              "text": "Abstrakte Klassen und Schnittstellen f√∂rdern sauberes Design und klare Verantwortlichkeiten."
            },
            {
              "type": "summary",
              "points": [
                "Abstrakte Klassen sind nicht instanziierbar",
                "Reine virtuelle Funktionen erzwingen Implementierung",
                "Schnittstellenklassen definieren nur Vertr√§ge",
                "Virtuelle Destruktoren sind Pflicht"
              ]
            }
          ]
        },
        {
          "title": "final Klassen & Memberfunktionen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "final",
              "text": "Das Schl√ºsselwort final verhindert weitere Vererbung von Klassen oder das √úberschreiben virtueller Memberfunktionen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von final",
              "text": [
                "final wird eingesetzt, um eine Klasse oder eine virtuelle Funktion bewusst abzuschlie√üen.",
                "Dadurch wird sichergestellt, dass bestimmtes Verhalten nicht mehr ver√§ndert werden kann."
              ]
            },
            {
              "type": "explanation",
              "title": "final bei Klassen",
              "text": [
                "Eine mit final deklarierte Klasse kann nicht mehr abgeleitet werden.",
                "Dies ist sinnvoll f√ºr Klassen mit abgeschlossener Implementierung oder sicherheitskritischem Verhalten."
              ]
            },
            {
              "type": "code",
              "title": "Finale Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Logger final {\npublic:\n    void log() const {\n        std::cout << \"Logeintrag\" << std::endl;\n    }\n};\n\n// class FileLogger : public Logger {}; // Fehler: Vererbung verboten\n\nint main() {\n    Logger l;\n    l.log();\n}\n"
            },
            {
              "type": "explanation",
              "title": "final bei Memberfunktionen",
              "text": [
                "Virtuelle Funktionen k√∂nnen mit final markiert werden.",
                "Dadurch wird verhindert, dass abgeleitete Klassen diese Funktion √ºberschreiben."
              ]
            },
            {
              "type": "code",
              "title": "Finale Memberfunktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    virtual void ausgabe() const {\n        std::cout << \"Basis\" << std::endl;\n    }\n};\n\nclass Abgeleitet : public Basis {\npublic:\n    void ausgabe() const final {\n        std::cout << \"Abgeleitet\" << std::endl;\n    }\n};\n\n// class Weiter : public Abgeleitet {\n// public:\n//     void ausgabe() const override {} // Fehler: Funktion ist final\n// };\n\nint main() {\n    Basis* b = new Abgeleitet();\n    b->ausgabe();\n    delete b;\n}\n"
            },
            {
              "type": "comparison",
              "title": "final Klasse vs final Funktion",
              "columns": ["final Klasse", "final Funktion"],
              "rows": [
                {
                  "aspect": "Vererbung verhindern",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "√úberschreiben verhindern",
                  "values": ["Indirekt", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zu restriktiver Einsatz",
              "text": "√úberm√§√üiger Einsatz von final kann Erweiterbarkeit und Testbarkeit unn√∂tig einschr√§nken."
            },
            {
              "type": "important",
              "text": "final macht Designentscheidungen explizit und verhindert unbeabsichtigte Erweiterungen."
            },
            {
              "type": "summary",
              "points": [
                "final verhindert weitere Vererbung",
                "finale Memberfunktionen d√ºrfen nicht √ºberschrieben werden",
                "Erh√∂ht Stabilit√§t und Designklarheit",
                "Sollte bewusst und sparsam eingesetzt werden"
              ]
            }
          ]
        },
        {
          "title": "Mehrfachvererbung",
          "difficulty": "advanced",
          "blocks": [
            {
              "type": "definition",
              "term": "Mehrfachvererbung",
              "text": "Mehrfachvererbung bezeichnet die Vererbung von mehr als einer Basisklasse in einer abgeleiteten Klasse."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Mehrfachvererbung",
              "text": [
                "Eine Klasse kann gleichzeitig Eigenschaften und Verhalten aus mehreren Basisklassen √ºbernehmen.",
                "Dies erm√∂glicht flexible Modellierung, erh√∂ht aber die Komplexit√§t des Designs."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzf√§lle",
              "text": [
                "Kombination unabh√§ngiger Rollen oder F√§higkeiten.",
                "Implementierung mehrerer Schnittstellen in einer Klasse."
              ]
            },
            {
              "type": "list",
              "title": "Probleme der Mehrfachvererbung",
              "items": [
                "Namenskonflikte zwischen Basisklassen",
                "Mehrdeutiger Zugriff auf Member",
                "Diamond-Problem",
                "Erh√∂hte Komplexit√§t"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Mehrfachvererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Druckbar {\npublic:\n    void drucken() const {\n        std::cout << \"Drucken\" << std::endl;\n    }\n};\n\nclass Speicherbar {\npublic:\n    void speichern() const {\n        std::cout << \"Speichern\" << std::endl;\n    }\n};\n\nclass Dokument : public Druckbar, public Speicherbar {\n};\n\nint main() {\n    Dokument d;\n    d.drucken();\n    d.speichern();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Diamond-Problem",
              "text": [
                "Das Diamond-Problem entsteht, wenn zwei Basisklassen von einer gemeinsamen Oberklasse erben.",
                "Die abgeleitete Klasse enth√§lt dann mehrere Kopien der gemeinsamen Basisklasse."
              ]
            },
            {
              "type": "code",
              "title": "Diamond-Problem ohne virtuelle Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    int wert = 1;\n};\n\nclass Links : public Basis {};\nclass Rechts : public Basis {};\n\nclass Unten : public Links, public Rechts {};\n\nint main() {\n    Unten u;\n    // u.wert = 5; // Fehler: Mehrdeutig\n}\n"
            },
            {
              "type": "explanation",
              "title": "Virtuelle Vererbung",
              "text": [
                "Virtuelle Vererbung stellt sicher, dass eine gemeinsame Basisklasse nur einmal existiert.",
                "Sie wird mit virtual in der Vererbungsdeklaration angegeben."
              ]
            },
            {
              "type": "code",
              "title": "Diamond-Problem mit virtueller Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    int wert = 1;\n};\n\nclass Links : public virtual Basis {};\nclass Rechts : public virtual Basis {};\n\nclass Unten : public Links, public Rechts {};\n\nint main() {\n    Unten u;\n    u.wert = 5; // eindeutig\n    std::cout << u.wert << std::endl;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Normale vs virtuelle Vererbung",
              "columns": ["Normale Vererbung", "Virtuelle Vererbung"],
              "rows": [
                {
                  "aspect": "Anzahl Basisobjekte",
                  "values": ["Mehrere", "Genau eines"]
                },
                {
                  "aspect": "Komplexit√§t",
                  "values": ["Geringer", "H√∂her"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "√úberm√§√üige Nutzung",
              "text": "Mehrfachvererbung kann Design unn√∂tig verkomplizieren und sollte gezielt eingesetzt werden."
            },
            {
              "type": "important",
              "text": "Mehrfachvererbung ist sinnvoll bei Schnittstellen, bei Klassen mit Implementierung jedoch riskant."
            },
            {
              "type": "summary",
              "points": [
                "Mehrfachvererbung erlaubt mehrere Basisklassen",
                "Kann zu Mehrdeutigkeiten f√ºhren",
                "Diamond-Problem ist zentraler Sonderfall",
                "Virtuelle Vererbung l√∂st das Diamond-Problem"
              ]
            }
          ]
        }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
        {
          "title": "struct Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "struct",
              "text": "struct ist ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer zusammengeh√∂riger Daten unter einem Namen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von struct",
              "text": [
                "structs dienen dazu, einfache Daten logisch zusammenzufassen.",
                "Der Fokus liegt typischerweise auf Daten und nicht auf komplexem Verhalten."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Alle Member sind standardm√§√üig √∂ffentlich zugreifbar.",
                "structs k√∂nnen Attribute, Methoden, Konstruktoren und Destruktoren enthalten."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Zusammenfassen von Messwerten oder Koordinaten",
                "Einfache R√ºckgabestrukturen von Funktionen",
                "Plain-Data-Strukturen ohne Invarianten"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches struct",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n};\n\nint main() {\n    Punkt p{3, 4};\n    std::cout << p.x << \", \" << p.y << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "struct mit Methode",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct Rechteck {\n    int breite;\n    int hoehe;\n\n    int flaeche() const {\n        return breite * hoehe;\n    }\n};\n\nint main() {\n    Rechteck r{5, 4};\n    std::cout << r.flaeche() << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Fehlende Validierung",
              "text": "√ñffentliche Attribute erlauben unkontrollierte Zustands√§nderungen."
            },
            {
              "type": "important",
              "text": "structs eignen sich besonders f√ºr einfache, datenorientierte Typen."
            },
            {
              "type": "summary",
              "points": [
                "struct b√ºndelt zusammengeh√∂rige Daten",
                "Member sind standardm√§√üig public",
                "Geeignet f√ºr einfache Datenstrukturen"
              ]
            }
          ]
        },
        {
          "title": "struct vs class",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "struct und class",
              "text": "struct und class sind nahezu identische Sprachkonstrukte in C++ mit unterschiedlichem Standard-Zugriffsverhalten."
            },
            {
              "type": "explanation",
              "title": "Gemeinsamkeiten",
              "text": [
                "Beide k√∂nnen Attribute, Methoden, Konstruktoren und Destruktoren enthalten.",
                "Beide unterst√ºtzen Vererbung, Polymorphie und Zugriffsspezifizierer."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentraler Unterschied",
              "text": [
                "Bei struct sind Member standardm√§√üig public.",
                "Bei class sind Member standardm√§√üig private."
              ]
            },
            {
              "type": "comparison",
              "title": "Direkter Vergleich",
              "columns": ["struct", "class"],
              "rows": [
                {
                  "aspect": "Standard-Zugriff",
                  "values": ["public", "private"]
                },
                {
                  "aspect": "Typischer Einsatzzweck",
                  "values": ["Datenstruktur", "Objekt mit Logik"]
                }
              ]
            },
            {
              "type": "code",
              "title": "Standard-Zugriff bei struct",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct A {\n    int x; // public\n};\n\nint main() {\n    A a;\n    a.x = 5;\n}\n"
            },
            {
              "type": "code",
              "title": "Standard-Zugriff bei class",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass B {\n    int x; // private\n};\n\nint main() {\n    B b;\n    // b.x = 5; // Fehler: private Zugriff\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Falsche Semantik",
              "text": "Die Wahl von struct oder class sollte die beabsichtigte Bedeutung des Typs widerspiegeln."
            },
            {
              "type": "important",
              "text": "Die Wahl zwischen struct und class ist semantisch und konzeptionell, nicht technisch."
            },
            {
              "type": "summary",
              "points": [
                "struct und class sind technisch gleichwertig",
                "Unterschied liegt im Standard-Zugriff",
                "struct f√ºr Daten, class f√ºr Logik",
                "Semantik sollte klar erkennbar sein"
              ]
            }
          ]
        }
      ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
        {
          "title": "enum Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum",
              "text": "Ein enum ist ein benutzerdefinierter Aufz√§hlungstyp, der eine endliche Menge benannter ganzzahliger Werte definiert."
            },
            {
              "type": "explanation",
              "title": "Grundidee von enum",
              "text": [
                "enum wird verwendet, um zusammengeh√∂rige konstante Werte logisch zu gruppieren.",
                "Dadurch wird Code lesbarer und weniger fehleranf√§llig als mit reinen Ganzzahlen."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Enum-Werte sind intern Ganzzahlen.",
                "Die erste Konstante beginnt standardm√§√üig bei 0 und wird hochgez√§hlt.",
                "Enum-Namen liegen im umgebenden Namensraum."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Zust√§nde und Statuswerte",
                "Optionen oder Modi",
                "Ergebnisse von Funktionen",
                "Endliche Auswahlm√∂glichkeiten"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches enum",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Farbe {\n    Rot,\n    Gruen,\n    Blau\n};\n\nint main() {\n    Farbe f = Rot;\n\n    if (f == Rot) {\n        std::cout << \"Rot\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Enum mit expliziten Werten",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Status {\n    OK = 0,\n    Fehler = 1,\n    Unbekannt = 100\n};\n\nint main() {\n    Status s = Fehler;\n    std::cout << s << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Namenskonflikte",
              "text": "Enum-Werte liegen im gleichen Namensraum und k√∂nnen mit anderen Namen kollidieren."
            },
            {
              "type": "important",
              "text": "Enums ersetzen magische Zahlen und machen Code verst√§ndlicher."
            },
            {
              "type": "summary",
              "points": [
                "enum definiert benannte Ganzzahlwerte",
                "Standardstartwert ist 0",
                "Verbessert Lesbarkeit und Wartbarkeit",
                "Geeignet f√ºr endliche Zust√§nde"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
        {
          "title": "enum class Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum class",
              "text": "enum class ist ein stark typisierter Aufz√§hlungstyp mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung in Ganzzahlen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von enum class",
              "text": [
                "enum class wurde eingef√ºhrt, um typische Probleme klassischer Enums zu vermeiden.",
                "Die Aufz√§hlungswerte sind klar gekapselt und typsicher."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Enum-Werte liegen im Namensraum des enum class Typs.",
                "Es gibt keine implizite Umwandlung zu int.",
                "Der zugrundeliegende Typ kann explizit festgelegt werden."
              ]
            },
            {
              "type": "list",
              "title": "Vorteile von enum class",
              "items": [
                "Keine Namenskonflikte",
                "Starke Typisierung",
                "Bessere Lesbarkeit",
                "H√∂here Typsicherheit"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches enum class",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Farbe {\n    Rot,\n    Gruen,\n    Blau\n};\n\nint main() {\n    Farbe f = Farbe::Rot;\n\n    if (f == Farbe::Rot) {\n        std::cout << \"Rot\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Expliziter zugrundeliegender Typ",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Status : int {\n    OK = 0,\n    Fehler = 1,\n    Unbekannt = 100\n};\n\nint main() {\n    Status s = Status::Fehler;\n    std::cout << static_cast<int>(s) << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Vergessener Scope",
              "text": "Enum-Werte m√ºssen immer mit dem Typnamen qualifiziert werden, zum Beispiel Farbe::Rot."
            },
            {
              "type": "important",
              "text": "enum class sollte in modernem C++ dem klassischen enum vorgezogen werden."
            },
            {
              "type": "summary",
              "points": [
                "enum class ist stark typisiert",
                "Keine implizite Umwandlung zu int",
                "Eigener G√ºltigkeitsbereich",
                "Bevorzugt in modernem C++"
              ]
            }
          ]
        },
        {
          "title": "enum class vs. enum",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum vs enum class",
              "text": "enum ist ein klassischer Aufz√§hlungstyp mit schwacher Typisierung, enum class ist ein stark typisierter Aufz√§hlungstyp mit eigenem G√ºltigkeitsbereich."
            },
            {
              "type": "explanation",
              "title": "Grundidee des Vergleichs",
              "text": [
                "Beide Konstrukte dienen zur Definition endlicher Mengen benannter Werte.",
                "enum class wurde eingef√ºhrt, um Sicherheits- und Designprobleme klassischer Enums zu l√∂sen."
              ]
            },
            {
              "type": "explanation",
              "title": "Klassisches enum",
              "text": [
                "Enum-Werte liegen im umgebenden Namensraum.",
                "Es existiert eine implizite Umwandlung zu Ganzzahlen."
              ]
            },
            {
              "type": "explanation",
              "title": "enum class",
              "text": [
                "Enum-Werte sind im G√ºltigkeitsbereich des Typs gekapselt.",
                "Es gibt keine implizite Umwandlung zu Ganzzahlen."
              ]
            },
            {
              "type": "comparison",
              "title": "Direkter Vergleich",
              "columns": ["enum", "enum class"],
              "rows": [
                {
                  "aspect": "Typisierung",
                  "values": ["Schwach", "Stark"]
                },
                {
                  "aspect": "Namensraum",
                  "values": ["Umgebend", "Eigener Typbereich"]
                },
                {
                  "aspect": "Implizite Umwandlung zu int",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Namenskonflikte m√∂glich",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Empfehlung in modernem C++",
                  "values": ["Eingeschr√§nkt", "Bevorzugt"]
                }
              ]
            },
            {
              "type": "code",
              "title": "Klassisches enum",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Farbe {\n    Rot,\n    Gruen\n};\n\nint main() {\n    Farbe f = Rot;\n    int x = f; // implizite Umwandlung erlaubt\n    std::cout << x << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "enum class",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Farbe {\n    Rot,\n    Gruen\n};\n\nint main() {\n    Farbe f = Farbe::Rot;\n    // int x = f; // Fehler: keine implizite Umwandlung\n    int x = static_cast<int>(f);\n    std::cout << x << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Unbeabsichtigte Typvermischung",
              "text": "Klassische Enums k√∂nnen versehentlich mit Ganzzahlen oder anderen Enums vermischt werden."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollte enum class verwendet werden, au√üer es gibt einen triftigen Grund f√ºr enum."
            },
            {
              "type": "summary",
              "points": [
                "enum ist schwach typisiert",
                "enum class ist stark typisiert",
                "enum class vermeidet Namenskonflikte",
                "enum class ist Standard in modernem C++"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
        {
          "title": "namespace Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "namespace",
              "text": "Ein namespace ist ein G√ºltigkeitsbereich zur Strukturierung von Namen und zur Vermeidung von Namenskonflikten."
            },
            {
              "type": "explanation",
              "title": "Grundidee von namespace",
              "text": [
                "Namespaces gruppieren zusammengeh√∂rige Funktionen, Klassen und Variablen.",
                "Sie verhindern Kollisionen gleichnamiger Bezeichner in gr√∂√üeren Programmen."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Namespaces k√∂nnen verschachtelt werden.",
                "Der Zugriff erfolgt √ºber den Scope-Operator \"::\".",
                "Namespaces erzeugen keinen eigenen Speicher."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Strukturierung gro√üer Codebasen",
                "Trennung von Bibliotheken",
                "Vermeidung von Namenskonflikten",
                "Klarere Schnittstellen"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace Mathe {\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n\nint main() {\n    std::cout << Mathe::add(2, 3) << std::endl; // Ausgabe: 5\n}\n"
            },
            {
              "type": "code",
              "title": "Verschachtelte Namespaces",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace Projekt {\n    namespace Modul {\n        void info() {\n            std::cout << \"Modul\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    Projekt::Modul::info();\n}\n"
            },
            {
              "type": "code",
              "title": "Namespaces zur Strukturierung von Code",
              "language": "cpp",
              "code": "#include <iostream>\n\n// Namespace f√ºr mathematische Funktionen\nnamespace math {\n\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    int mul(int a, int b) {\n        return a * b;\n    }\n}\n\n// Namespace f√ºr Logging-Funktionen\nnamespace log {\n\n    void print(const std::string& msg) {\n        std::cout << \"[LOG] \" << msg << std::endl;\n    }\n\n}\n\n// Verschachtelter Namespace (seit C++17 bevorzugte Schreibweise)\nnamespace util::debug {\n\n    void printValue(int x) {\n        std::cout << \"[DEBUG] Wert = \" << x << std::endl;\n    }\n\n}\n\nint main() {\n    // Zugriff mit vollqualifiziertem Namen\n    int sum = math::add(3, 4);\n    int product = math::mul(3, 4);\n\n    log::print(\"Berechnung abgeschlossen\");\n\n    util::debug::printValue(sum);\n\n    // Ausgabe:\n    // [LOG] Berechnung abgeschlossen\n    // [DEBUG] Wert = 7\n}\n"
            },
            {
              "type": "code",
              "title": "Klasse in einem Namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\n// Oberer Namespace f√ºr Hilfsfunktionen\nnamespace util {\n\n    // Klasse geh√∂rt logisch zu util\n    class Counter {\n    public:\n        Counter() : value(0) {}\n\n        void increment() {\n            ++value;\n        }\n\n        int get() const {\n            return value;\n        }\n\n    private:\n        int value;\n    };\n\n    // Unter-Namespace f√ºr Debug-Funktionen\n    namespace debug {\n\n        // Funktion arbeitet mit der Klasse aus util\n        void printCounter(const Counter& c) {\n            std::cout << \"[DEBUG] Counter = \" << c.get() << std::endl;\n        }\n\n    }\n}\n\nint main() {\n    // Vollqualifizierter Zugriff auf die Klasse\n    util::Counter c;\n\n    c.increment();\n    c.increment();\n\n    // Zugriff auf Unter-Namespace\n    util::debug::printCounter(c);\n\n    // Ausgabe:\n    // [DEBUG] Counter = 2\n}\n"
            },
            {
              "type": "pitfall",
              "title": "using namespace std",
              "text": "using namespace std kann Namenskonflikte verursachen und sollte in Header-Dateien vermieden werden."
            },
            {
              "type": "important",
              "text": "Namespaces sind essenziell f√ºr sauberen, wartbaren und modularen Code."
            },
            {
              "type": "summary",
              "points": [
                "Namespaces strukturieren Namen",
                "Verhindern Namenskonflikte",
                "Zugriff √ºber ::",
                "Wichtig f√ºr gro√üe Projekte"
              ]
            }
          ]
        },
        {
          "title": "using namespace",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "using namespace",
              "text": "using namespace bindet alle Namen eines Namespaces in den aktuellen G√ºltigkeitsbereich ein."
            },
            {
              "type": "explanation",
              "title": "Grundidee von using namespace",
              "text": [
                "using namespace erspart das wiederholte Schreiben des Namespace-Namens.",
                "Alle enthaltenen Namen werden so behandelt, als l√§gen sie im aktuellen Scope."
              ]
            },
            {
              "type": "explanation",
              "title": "Namensaufl√∂sung",
              "text": [
                "Bei mehreren gleichnamigen Bezeichnern entscheidet die Namensaufl√∂sungsregel des Compilers.",
                "Lokale Namen haben Vorrang vor eingebundenen Namespace-Namen."
              ]
            },
            {
              "type": "list",
              "title": "M√∂gliche Probleme",
              "items": [
                "Namenskonflikte bei gleichnamigen Funktionen oder Typen",
                "Unklare Herkunft von Bezeichnern",
                "Schwer wartbarer Code in gro√üen Projekten",
                "Probleme beim Einbinden mehrerer Bibliotheken"
              ]
            },
            {
              "type": "code",
              "title": "using namespace verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    cout << \"Hallo\" << endl; // std:: wird nicht ben√∂tigt\n}\n"
            },
            {
              "type": "code",
              "title": "Namenskonflikt durch using namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace A {\n    void funktion() {\n        std::cout << \"A\" << std::endl;\n    }\n}\n\nnamespace B {\n    void funktion() {\n        std::cout << \"B\" << std::endl;\n    }\n}\n\nusing namespace A;\nusing namespace B;\n\nint main() {\n    // funktion(); // Fehler: Mehrdeutig\n    A::funktion();\n    B::funktion();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Gezieltes using",
              "text": [
                "Statt ganzer Namespaces k√∂nnen einzelne Namen importiert werden.",
                "Dies reduziert das Risiko von Namenskonflikten erheblich."
              ]
            },
            {
              "type": "code",
              "title": "Gezieltes using-Deklaration",
              "language": "cpp",
              "code": "#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\nint main() {\n    cout << \"Gezielt\" << endl;\n}\n"
            },
            {
              "type": "comparison",
              "title": "using namespace vs qualifizierter Zugriff",
              "columns": ["using namespace", "Qualifizierter Zugriff"],
              "rows": [
                {
                  "aspect": "Kurzschreibweise",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Namenssicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Empfehlung in Header-Dateien",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "using namespace in Header-Dateien",
              "text": "using namespace in Header-Dateien zwingt allen Einbindern diese Namen auf und kann massive Konflikte verursachen."
            },
            {
              "type": "important",
              "text": "using namespace sollte nur lokal und bewusst eingesetzt werden, niemals global oder in Header-Dateien."
            },
            {
              "type": "summary",
              "points": [
                "using namespace bindet alle Namen eines Namespaces ein",
                "Kann zu Namenskonflikten f√ºhren",
                "Gezieltes using ist sicherer",
                "Qualifizierter Zugriff ist Best Practice"
              ]
            }
          ]
        }

        ]
      },
      {
        "name": "Member & Attribute",
        "icon": "üß©",
        "topics": [
        {
          "title": "static Member",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "static Member",
              "text": "Static Member sind Klassenmitglieder, die zur Klasse selbst geh√∂ren und nicht zu einzelnen Objekten."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Ein static Member existiert genau einmal, unabh√§ngig davon, wie viele Objekte einer Klasse erzeugt werden.",
                "Alle Instanzen greifen auf denselben static Member zu."
              ]
            },
            {
              "type": "explanation",
              "title": "Static Attribute",
              "text": [
                "Static Attribute speichern klassenweite Zust√§nde oder Z√§hler.",
                "Sie m√ºssen genau einmal definiert werden, meist in einer Source-Datei."
              ]
            },
            {
              "type": "explanation",
              "title": "Static Memberfunktionen",
              "text": [
                "Static Memberfunktionen geh√∂ren zur Klasse und nicht zu einem Objekt.",
                "Sie k√∂nnen nur auf andere static Member zugreifen."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von static Membern",
              "items": [
                "Geh√∂ren zur Klasse, nicht zur Instanz",
                "Existieren unabh√§ngig von Objekten",
                "Zugriff √ºber Klassenname::Member",
                "N√ºtzlich f√ºr Z√§hler, Hilfsfunktionen und Konstanten"
              ]
            },
            {
              "type": "code",
              "title": "Static Attribut",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zaehler {\npublic:\n    static int anzahl;\n};\n\nint Zaehler::anzahl = 0; // Definition des static Attributs\n\nint main() {\n    Zaehler::anzahl++;\n    Zaehler::anzahl++;\n    std::cout << Zaehler::anzahl << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "code",
              "title": "Static Memberfunktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Rechner {\npublic:\n    static int add(int a, int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    std::cout << Rechner::add(3, 4) << std::endl; // Ausgabe: 7\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Zugriff auf nicht-static Member",
              "text": "Static Memberfunktionen k√∂nnen nicht direkt auf nicht-static Attribute zugreifen."
            },
            {
              "type": "important",
              "text": "Static Member sind ideal f√ºr klassenweite Informationen und Funktionen ohne Objektbezug."
            },
            {
              "type": "summary",
              "points": [
                "Static Member geh√∂ren zur Klasse",
                "Existieren genau einmal",
                "Zugriff √ºber Klassenname::",
                "Keine Objektinstanz notwendig"
              ]
            }
          ]
        },
        
        {
          "title": "const Memberfunktionen & mutable Member",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "const und mutable",
              "text": "const Memberfunktionen sch√ºtzen den Objektzustand, mutable erlaubt gezielte √Ñnderungen einzelner Attribute trotz const."
            },
            {
              "type": "explanation",
              "title": "const Memberfunktionen",
              "text": [
                "Eine const Memberfunktion garantiert, dass der sichtbare Zustand des Objekts nicht ver√§ndert wird.",
                "Innerhalb einer const Funktion d√ºrfen keine normalen Member ge√§ndert werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Logische vs physische Konstanz",
              "text": [
                "Const sch√ºtzt die logische Konstanz eines Objekts aus Sicht des Nutzers.",
                "mutable erlaubt interne, technische √Ñnderungen ohne Verletzung dieser Logik."
              ]
            },
            {
              "type": "explanation",
              "title": "mutable Member",
              "text": [
                "mutable hebt die const Einschr√§nkung f√ºr einzelne Attribute auf.",
                "Damit k√∂nnen interne Zust√§nde auch in const Memberfunktionen ge√§ndert werden."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Caching von berechneten Werten",
                "Lazy Evaluation",
                "Zugriffs- oder Statistikz√§hler",
                "Interne Debug- oder Logging-Daten"
              ]
            },
            {
              "type": "code",
              "title": "const Memberfunktion ohne mutable",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt(int x, int y) : x(x), y(y) {}\n\n    int getX() const {\n        return x; // erlaubt\n    }\n\n    // void setX(int v) const { x = v; } // Fehler: √Ñnderung nicht erlaubt\n\nprivate:\n    int x;\n    int y;\n};\n"
            },
            {
              "type": "code",
              "title": "mutable f√ºr Cache in const Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Quadrat {\npublic:\n    Quadrat(int s) : seite(s) {}\n\n    int flaeche() const {\n        if (!cacheGueltig) {\n            cache = seite * seite; // erlaubt durch mutable\n            cacheGueltig = true;\n        }\n        return cache;\n    }\n\nprivate:\n    int seite;\n    mutable int cache = 0;\n    mutable bool cacheGueltig = false;\n};\n\nint main() {\n    const Quadrat q(4);\n    std::cout << q.flaeche() << std::endl; // Ausgabe: 16\n}\n"
            },
            {
              "type": "comparison",
              "title": "const ohne mutable vs mit mutable",
              "columns": ["const ohne mutable", "const mit mutable"],
              "rows": [
                {
                  "aspect": "√Ñnderung von Membern",
                  "values": ["Verboten", "Gezielt erlaubt"]
                },
                {
                  "aspect": "Geeignet f√ºr Cache",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Missbrauch von mutable",
              "text": "mutable darf nicht verwendet werden, um fachlich relevante Zustands√§nderungen zu verstecken."
            },
            {
              "type": "important",
              "text": "const und mutable dienen der klaren Trennung zwischen logischer Schnittstelle und interner Implementierung."
            },
            {
              "type": "summary",
              "points": [
                "const sch√ºtzt die logische Objektkonstanz",
                "mutable erlaubt interne √Ñnderungen",
                "Typisch f√ºr Cache und Lazy Evaluation",
                "Missbrauch f√ºhrt zu unklarem Design"
              ]
            }
          ]
        }
        
        ]
      },



      {
        "name": "Casting",
        "icon": "üîÑ",
        "topics": [
        {
          "title": "Implizite Konvertierung",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Implizite Konvertierung",
              "text": "Implizite Konvertierung bezeichnet automatische Typumwandlungen, die der Compiler ohne explizite Anweisung durchf√ºhrt."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Der Compiler wandelt Typen automatisch um, wenn dies nach den Sprachregeln erlaubt ist.",
                "Ziel ist es, Ausdr√ºcke und Zuweisungen m√∂glichst bequem nutzbar zu machen."
              ]
            },
            {
              "type": "explanation",
              "title": "Implizite Konvertierungen bei Built-in-Typen",
              "text": [
                "Numerische Typen werden h√§ufig automatisch angepasst.",
                "Dabei kann es zu Pr√§zisionsverlust oder Werte√§nderungen kommen."
              ]
            },
            {
              "type": "code",
              "title": "Numerische implizite Konvertierung",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int a = 5;\n    double b = a;   // int -> double (implizit)\n\n    double x = 3.7;\n    int y = x;      // double -> int (implizit, Abschneiden)\n\n    std::cout << b << \" \" << y << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Implizite Konvertierung bei Funktionsaufrufen",
              "text": [
                "Argumente werden implizit an den Parametertyp angepasst.",
                "Dies kann zu unerwarteten Ergebnissen f√ºhren."
              ]
            },
            {
              "type": "code",
              "title": "Implizite Konvertierung bei Funktionen",
              "language": "cpp",
              "code": "#include <iostream>\n\nvoid printDouble(double d) {\n    std::cout << d << std::endl;\n}\n\nint main() {\n    int value = 10;\n    printDouble(value); // int -> double\n}\n"
            },
            {
              "type": "explanation",
              "title": "Implizite Konvertierung bei Klassen",
              "text": [
                "Konstruktoren mit einem Parameter erlauben implizite Typumwandlungen.",
                "Dies kann zu schwer nachvollziehbarem Code f√ºhren."
              ]
            },
            {
              "type": "code",
              "title": "Implizite Konvertierung √ºber Konstruktor",
              "language": "cpp",
              "code": "#include <string>\n#include <iostream>\n\nclass UserId {\npublic:\n    UserId(int id) : id(id) {}\n\n    int get() const { return id; }\n\nprivate:\n    int id;\n};\n\nint main() {\n    UserId u = 42; // int -> UserId (implizit)\n    std::cout << u.get() << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Implizite Konvertierungsoperatoren",
              "text": [
                "Klassen k√∂nnen implizite Konvertierungsoperatoren definieren.",
                "Diese werden automatisch bei Bedarf aufgerufen."
              ]
            },
            {
              "type": "code",
              "title": "operator Typ() implizit",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Meter {\npublic:\n    Meter(double m) : wert(m) {}\n\n    operator double() const { // implizite Konvertierung\n        return wert;\n    }\n\nprivate:\n    double wert;\n};\n\nint main() {\n    Meter m(2.5);\n    double d = m; // Meter -> double\n\n    std::cout << d << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Risiken impliziter Konvertierungen",
              "text": [
                "Implizite Konvertierungen k√∂nnen Informationen verlieren.",
                "Sie erschweren das Lesen und Debuggen von Code."
              ]
            },
            {
              "type": "comparison",
              "title": "Implizit vs explizit",
              "columns": ["Implizit", "Explizit"],
              "rows": [
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Oft schlechter", "Besser"]
                },
                {
                  "aspect": "Kontrolle",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Fehleranf√§lligkeit",
                  "values": ["H√∂her", "Geringer"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unerwartete Typumwandlungen",
              "text": "Unbeabsichtigte implizite Konvertierungen sind eine h√§ufige Fehlerquelle in C++."
            },
            {
              "type": "important",
              "text": "Implizite Konvertierungen sollten bewusst zugelassen oder durch explicit verhindert werden."
            },
            {
              "type": "summary",
              "points": [
                "Implizite Konvertierungen erfolgen automatisch",
                "H√§ufig bei numerischen Typen und Funktionen",
                "Konstruktoren mit einem Parameter erlauben implizite Umwandlungen",
                "Konvertierungsoperatoren k√∂nnen implizit wirken",
                "Bewusster Umgang ist entscheidend"
              ]
            }
          ]
        },
        {
          "title": "Explizites Casting",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Explizites Casting",
              "text": "Explizites Casting bezeichnet die bewusste und ausdr√ºcklich vom Programmierer angegebene Typumwandlung."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Beim expliziten Casting wird eine Typumwandlung klar im Code sichtbar gemacht.",
                "C++ stellt daf√ºr spezielle Cast-Operatoren bereit, die unterschiedliche Zwecke erf√ºllen."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum explizit casten",
              "text": [
                "Explizites Casting erh√∂ht die Lesbarkeit und Kontrolle.",
                "Gef√§hrliche oder verlustbehaftete Umwandlungen werden bewusst gekennzeichnet."
              ]
            },
            {
              "type": "list",
              "title": "Cast-Arten in C++",
              "items": [
                "static_cast",
                "dynamic_cast",
                "const_cast",
                "reinterpret_cast"
              ]
            },
            {
              "type": "explanation",
              "title": "static_cast",
              "text": [
                "static_cast ist der am h√§ufigsten verwendete Cast.",
                "Er wird f√ºr wohldefinierte, √ºberpr√ºfbare Typumwandlungen genutzt."
              ]
            },
            {
              "type": "code",
              "title": "static_cast bei numerischen Typen",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    double x = 3.9;\n    int y = static_cast<int>(x); // explizites Abschneiden\n\n    std::cout << y << std::endl; // 3\n}\n"
            },
            {
              "type": "code",
              "title": "static_cast bei Klassen",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Base {};\nclass Derived : public Base {};\n\nint main() {\n    Derived d;\n    Base* b = static_cast<Base*>(&d); // Upcast, sicher\n}\n"
            },
            {
              "type": "explanation",
              "title": "dynamic_cast",
              "text": [
                "dynamic_cast wird f√ºr polymorphe Typen mit virtuellen Funktionen verwendet.",
                "Er pr√ºft zur Laufzeit, ob der Cast g√ºltig ist."
              ]
            },
            {
              "type": "code",
              "title": "dynamic_cast bei Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Base {\npublic:\n    virtual ~Base() = default;\n};\n\nclass Derived : public Base {};\n\nint main() {\n    Base* b = new Derived();\n\n    Derived* d = dynamic_cast<Derived*>(b);\n    if (d) {\n        std::cout << \"Cast erfolgreich\" << std::endl;\n    }\n\n    delete b;\n}\n"
            },
            {
              "type": "explanation",
              "title": "const_cast",
              "text": [
                "const_cast entfernt oder erg√§nzt const-Qualifizierer.",
                "Er darf nur verwendet werden, wenn das urspr√ºngliche Objekt nicht const ist."
              ]
            },
            {
              "type": "code",
              "title": "const_cast Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n\nvoid print(int* x) {\n    *x = 10;\n}\n\nint main() {\n    int value = 5;\n    const int* ptr = &value;\n\n    print(const_cast<int*>(ptr)); // const entfernen\n\n    std::cout << value << std::endl; // 10\n}\n"
            },
            {
              "type": "explanation",
              "title": "reinterpret_cast",
              "text": [
                "reinterpret_cast f√ºhrt eine bitweise Neuinterpretation durch.",
                "Er ist extrem gef√§hrlich und nur f√ºr sehr spezielle Low-Level-F√§lle gedacht."
              ]
            },
            {
              "type": "code",
              "title": "reinterpret_cast Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int x = 42;\n    void* p = &x;\n\n    int* y = reinterpret_cast<int*>(p);\n    std::cout << *y << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "C-Style Cast (nicht empfohlen)",
              "text": [
                "Der klassische (Typ)wert Cast existiert weiterhin.",
                "Er ist un√ºbersichtlich, da er mehrere Cast-Arten gleichzeitig erlaubt."
              ]
            },
            {
              "type": "comparison",
              "title": "static_cast vs dynamic_cast",
              "columns": ["static_cast", "dynamic_cast"],
              "rows": [
                {
                  "aspect": "Pr√ºfung",
                  "values": ["Compile-Zeit", "Laufzeit"]
                },
                {
                  "aspect": "Performance",
                  "values": ["Sehr hoch", "Langsamer"]
                },
                {
                  "aspect": "Polymorphie n√∂tig",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Falscher Cast-Typ",
              "text": "Ein falscher Cast kann zu undefiniertem Verhalten oder schwer auffindbaren Fehlern f√ºhren."
            },
            {
              "type": "important",
              "text": "static_cast ist der Standard-Cast, dynamic_cast nur bei echter Laufzeitpr√ºfung verwenden."
            },
            {
              "type": "summary",
              "points": [
                "Explizites Casting macht Typumwandlungen sichtbar",
                "static_cast f√ºr normale, sichere Umwandlungen",
                "dynamic_cast f√ºr polymorphe Laufzeitpr√ºfungen",
                "const_cast nur f√ºr Qualifizierer",
                "reinterpret_cast nur in Ausnahmef√§llen"
              ]
            }
          ]
        }
      ]
      }

    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
        {
          "title": "Funktionstemplates",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Funktionstemplate",
              "text": "Ein Funktionstemplate ist eine Vorlage f√ºr Funktionen, die mit verschiedenen Datentypen arbeiten kann."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Funktionstemplates",
              "text": [
                "Funktionstemplates erm√∂glichen generischen Code ohne Duplikation.",
                "Der konkrete Typ wird vom Compiler zur Compilezeit eingesetzt."
              ]
            },
            {
              "type": "explanation",
              "title": "Typinferenz",
              "text": [
                "Der Compiler leitet die Template-Typen meist automatisch aus den Funktionsargumenten ab.",
                "Explizite Typangaben sind nur in Sonderf√§llen notwendig."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von Funktionstemplates",
              "items": [
                "Typsicher zur Compilezeit",
                "Kein Laufzeit-Overhead",
                "Code-Wiederverwendung f√ºr viele Typen",
                "Fehler werden beim Instanziieren erkannt"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Funktionstemplate",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\nint main() {\n    std::cout << add(2, 3) << std::endl;       // int\n    std::cout << add(1.5, 2.5) << std::endl;   // double\n}\n"
            },
            {
              "type": "code",
              "title": "Explizite Template-Argumente",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nT quadrieren(T x) {\n    return x * x;\n}\n\nint main() {\n    std::cout << quadrieren<int>(4) << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "Mehrere Template-Typen",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T, typename U>\nauto multipliziere(T a, U b) {\n    return a * b;\n}\n\nint main() {\n    std::cout << multipliziere(3, 2.5) << std::endl; // double\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Ungeeignete Typen",
              "text": "Funktionstemplates setzen voraus, dass die verwendeten Typen die ben√∂tigten Operationen unterst√ºtzen."
            },
            {
              "type": "important",
              "text": "Funktionstemplates werden zur Compilezeit instanziiert und verursachen keinen Laufzeit-Overhead."
            },
            {
              "type": "summary",
              "points": [
                "Funktionstemplates erm√∂glichen generischen Code",
                "Typen werden zur Compilezeit eingesetzt",
                "Typinferenz erfolgt meist automatisch",
                "Fehler werden fr√ºh erkannt"
              ]
            }
          ]
        },
        {
          "title": "Klassentemplates",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Klassentemplate",
              "text": "Ein Klassentemplate ist eine Vorlage f√ºr Klassen, die mit unterschiedlichen Datentypen instanziiert werden kann."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Klassentemplates",
              "text": [
                "Klassentemplates erm√∂glichen die Definition generischer Datenstrukturen.",
                "Der konkrete Typ wird beim Erzeugen der Klasse festgelegt."
              ]
            },
            {
              "type": "explanation",
              "title": "Instanziierung",
              "text": [
                "Ein Klassentemplate erzeugt erst bei der Verwendung mit einem konkreten Typ eine echte Klasse.",
                "Jede Typinstanziierung erzeugt eine eigene Klassenvariante."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von Klassentemplates",
              "items": [
                "Typsicher zur Compilezeit",
                "Keine Laufzeitkosten",
                "Hohe Wiederverwendbarkeit",
                "Fehler werden beim Instanziieren sichtbar"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Klassentemplate",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nclass Box {\npublic:\n    Box(T wert) : wert(wert) {}\n\n    T get() const {\n        return wert;\n    }\n\nprivate:\n    T wert;\n};\n\nint main() {\n    Box<int> a(5);\n    Box<double> b(3.14);\n\n    std::cout << a.get() << std::endl;\n    std::cout << b.get() << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "Klassentemplate mit mehreren Typen",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T, typename U>\nclass Paar {\npublic:\n    Paar(T erstes, U zweites) : erstes(erstes), zweites(zweites) {}\n\n    T getErstes() const {\n        return erstes;\n    }\n\n    U getZweites() const {\n        return zweites;\n    }\n\nprivate:\n    T erstes;\n    U zweites;\n};\n\nint main() {\n    Paar<int, double> p(1, 2.5);\n    std::cout << p.getErstes() << \", \" << p.getZweites() << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Definition im Header",
              "text": "Klassentemplates m√ºssen vollst√§ndig im Header definiert sein, da der Compiler den Code sehen muss."
            },
            {
              "type": "important",
              "text": "Klassentemplates werden zur Compilezeit instanziiert und sind vollst√§ndig typsicher."
            },
            {
              "type": "summary",
              "points": [
                "Klassentemplates definieren generische Klassen",
                "Typen werden bei der Instanziierung festgelegt",
                "Keine Laufzeitkosten",
                "Ideal f√ºr generische Datenstrukturen"
              ]
            }
          ]
        }
        ]
      }
    ]
  },






  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
        {
          "title": "std::vector",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::vector",
              "text": "std::vector ist ein sequenzieller STL-Container, der Elemente in zusammenh√§ngendem Speicher ablegt und seine Gr√∂√üe dynamisch anpasst."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::vector verh√§lt sich wie ein dynamisches Array mit automatischer Speicherverwaltung.",
                "Die Elemente liegen zusammenh√§ngend im Speicher, was schnellen Indexzugriff erm√∂glicht."
              ]
            },
            {
              "type": "explanation",
              "title": "Speicherverhalten",
              "text": [
                "Beim Wachsen kann der Vector seinen Speicher neu allozieren.",
                "Dabei werden alle Elemente in einen neuen Speicherbereich kopiert oder verschoben."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<vector>"
              ]
            },
            {
              "type": "explanation",
              "title": "Gr√∂√üe und Kapazit√§t",
              "text": [
                "size gibt die aktuelle Anzahl der gespeicherten Elemente an.",
                "capacity beschreibt, wie viele Elemente ohne erneute Reallokation gespeichert werden k√∂nnen."
              ]
            },
            {
              "type": "code",
              "title": "size und capacity",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v;\n\n    v.push_back(1);\n    v.push_back(2);\n\n    std::cout << v.size() << std::endl;     // Anzahl Elemente\n    std::cout << v.capacity() << std::endl; // reservierter Speicher\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente hinzuf√ºgen",
              "text": [
                "push_back f√ºgt ein bereits existierendes Objekt am Ende ein.",
                "emplace_back konstruiert das Objekt direkt im Speicher des Vectors."
              ]
            },
            {
              "type": "code",
              "title": "push_back vs emplace_back",
              "language": "cpp",
              "code": "#include <vector>\n#include <string>\n\nint main() {\n    std::vector<std::string> v;\n\n    v.push_back(std::string(\"Hallo\"));\n    v.emplace_back(\"Welt\"); // effizienter\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf Elemente",
              "text": [
                "operator[] bietet schnellen Zugriff ohne Bereichspr√ºfung.",
                "at pr√ºft die Grenzen und wirft bei Fehlern eine Exception."
              ]
            },
            {
              "type": "code",
              "title": "operator[] vs at",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {10, 20, 30};\n\n    std::cout << v[0] << std::endl;    // kein Check\n    std::cout << v.at(1) << std::endl; // mit Check\n}\n"
            },
            {
              "type": "explanation",
              "title": "Entfernen von Elementen",
              "text": [
                "pop_back entfernt das letzte Element.",
                "clear entfernt alle Elemente, beh√§lt aber die Kapazit√§t."
              ]
            },
            {
              "type": "code",
              "title": "Elemente entfernen",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3};\n\n    v.pop_back(); // entfernt 3\n    v.clear();    // Vector ist leer\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteratoren",
              "text": [
                "std::vector stellt begin und end Iteratoren bereit.",
                "Iteratoren erm√∂glichen die Nutzung von STL-Algorithmen."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren mit Iteratoren",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3};\n\n    for (auto it = v.begin(); it != v.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zusammenspiel mit Algorithmen",
              "text": [
                "std::vector ist optimal f√ºr STL-Algorithmen geeignet.",
                "Die zusammenh√§ngende Speicherstruktur sorgt f√ºr hohe Performance."
              ]
            },
            {
              "type": "code",
              "title": "std::sort mit vector",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {3, 1, 4, 1, 5};\n\n    std::sort(v.begin(), v.end());\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "std::vector: wichtiges im √úberblick (ausf√ºhrlich kommentiert)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\n// Kleine Hilfsfunktion: Vector ausgeben\nstatic void printVec(const std::vector<int>& v, const char* name) {\n    std::cout << name << \" (size=\" << v.size()\n              << \", capacity=\" << v.capacity() << \"): \";\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n}\n\nint main() {\n    // 1) Erzeugen und Initialisieren\n    std::vector<int> a;                 // leer\n    std::vector<int> b(5);              // 5 Elemente, alle 0\n    std::vector<int> c(5, 7);           // 5 Elemente, alle 7\n    std::vector<int> d = {1, 2, 3, 4};  // Initializer List\n\n    printVec(a, \"a\");\n    printVec(b, \"b\");\n    printVec(c, \"c\");\n    printVec(d, \"d\");\n\n\n    // 2) size, capacity, reserve, shrink_to_fit\n    // size: Anzahl der Elemente\n    // capacity: reservierter Speicher (kann gr√∂√üer als size sein)\n   \n\n    std::vector<int> v;\n    v.reserve(10); // Speicher f√ºr mindestens 10 Elemente reservieren (verhindert h√§ufige Reallokationen)\n\n    std::cout << \"v.size()=\" << v.size() << \", v.capacity()=\" << v.capacity() << \"\\n\";\n\n\n    // 3) Elemente hinzuf√ºgen: push_back und emplace_back\n    // push_back: f√ºgt ein Element hinzu (Kopie oder Move)\n    // emplace_back: konstruiert das Element direkt im Vector (bei komplexen Typen oft sinnvoll)\n    v.push_back(10);\n    v.push_back(20);\n    v.emplace_back(30);\n\n    printVec(v, \"v nach push_back/emplace_back\");\n\n\n    // 4) Zugriff auf Elemente: operator[], at, front, back\n    // operator[]: schnell, aber kein Bounds Check\n    // at: wirft bei ung√ºltigem Index eine Exception\n    \n    std::cout << \"v[0]=\" << v[0] << \"\\n\";\n    std::cout << \"v.front()=\" << v.front() << \", v.back()=\" << v.back() << \"\\n\";\n\n    // Sicherer Zugriff mit at (hier ok)\n    std::cout << \"v.at(1)=\" << v.at(1) << \"\\n\";\n\n\n    // 5) Iterieren: begin/end, range-based for\n    \n    for (auto it = v.begin(); it != v.end(); ++it) {\n        std::cout << *it << \" \";\n    }\n    std::cout << \"\\n\";\n\n\n    // 6) insert und erase\n    // insert: f√ºgt an einer Position ein\n    // erase: entfernt an einer Position oder in einem Bereich\n    \n\n    // Einf√ºgen am Anfang\n    v.insert(v.begin(), 5);\n    printVec(v, \"v nach insert vorne\");\n\n    // Einf√ºgen in der Mitte (nach dem ersten Element)\n    v.insert(v.begin() + 1, 99);\n    printVec(v, \"v nach insert mitte\");\n\n    // Entfernen eines Elements (das eben eingef√ºgte 99)\n    v.erase(v.begin() + 1);\n    printVec(v, \"v nach erase einzel\");\n\n\n    // 7) resize, clear, empty\n    // resize vergr√∂√üert oder verkleinert size\n    // clear entfernt alle Elemente (capacity bleibt typischerweise)\n    \n\n    v.resize(6, 1); // falls gr√∂√üer, neue Elemente werden mit 1 gef√ºllt\n    printVec(v, \"v nach resize(6,1)\");\n\n    v.resize(2); // verkleinern: √ºbersch√ºssige Elemente werden entfernt\n    printVec(v, \"v nach resize(2)\");\n\n    std::cout << \"v.empty()=\" << std::boolalpha << v.empty() << \"\\n\";\n\n    v.clear();\n    std::cout << \"nach clear: v.size()=\" << v.size() << \", v.empty()=\" << v.empty() << \"\\n\";\n\n\n    // 8) assign und swap\n    // assign ersetzt kompletten Inhalt\n    // swap tauscht Inhalte effizient\n    \n\n    std::vector<int> x = {1, 2, 3};\n    std::vector<int> y = {9, 8};\n\n    x.assign(4, 7); // x wird zu {7,7,7,7}\n    printVec(x, \"x nach assign(4,7)\");\n\n    x.swap(y);\n    printVec(x, \"x nach swap\");\n    printVec(y, \"y nach swap\");\n\n\n    // 9) data: roher Pointer auf zusammenh√§ngenden Speicher\n    // n√ºtzlich f√ºr C APIs oder low level Zugriff\n    \n    const int* p = x.data();\n    if (!x.empty()) {\n        std::cout << \"x.data()[0]=\" << p[0] << \"\\n\";\n    }\n\n\n    // 10) Algorithmen mit vector: sort, find, count, remove-erase\n    \n\n    std::vector<int> z = {4, 1, 3, 2, 2, 5};\n    printVec(z, \"z start\");\n\n    std::sort(z.begin(), z.end());\n    printVec(z, \"z nach sort\");\n\n    auto it = std::find(z.begin(), z.end(), 3);\n    if (it != z.end()) {\n        std::cout << \"3 gefunden\\n\";\n    }\n\n    int cnt2 = std::count(z.begin(), z.end(), 2);\n    std::cout << \"Anzahl der 2: \" << cnt2 << \"\\n\";\n\n    // remove-erase: logisch entfernen und dann wirklich l√∂schen\n    z.erase(std::remove(z.begin(), z.end(), 2), z.end());\n    printVec(z, \"z nach remove-erase (2 entfernt)\");\n\n\n    // 11) Bonus: sum mit accumulate\n    int sum = std::accumulate(z.begin(), z.end(), 0);\n    std::cout << \"Summe von z: \" << sum << \"\\n\";\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Iteratoren nach Reallokation",
              "text": "push_back oder emplace_back k√∂nnen eine Reallokation ausl√∂sen und alle Iteratoren ung√ºltig machen."
            },
            {
              "type": "important",
              "text": "std::vector ist der wichtigste und am h√§ufigsten verwendete STL-Container."
            },
            {
              "type": "summary",
              "points": [
                "std::vector speichert Elemente zusammenh√§ngend",
                "Dynamische Gr√∂√üe mit automatischer Speicherverwaltung",
                "Schneller Indexzugriff",
                "Ideal f√ºr STL-Algorithmen",
                "Standardwahl f√ºr sequenzielle Daten"
              ]
            }
          ]
        },
        {
          "title": "std::list",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::list",
              "text": "list ist ein sequenzieller STL-Container, der Elemente als doppelt verkettete Liste speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::list speichert jedes Element in einem eigenen Knoten mit Verweisen auf Vorg√§nger und Nachfolger.",
                "Die Elemente liegen nicht zusammenh√§ngend im Speicher."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Eigenschaften",
              "text": [
                "Konstante Zeit f√ºr Einf√ºgen und Entfernen an beliebiger Position.",
                "Kein direkter Indexzugriff m√∂glich.",
                "Iteratoren bleiben beim Einf√ºgen und Entfernen anderer Elemente g√ºltig."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<list>"
              ]
            },
            {
              "type": "explanation",
              "title": "Gr√∂√üe und Zustand",
              "text": [
                "size liefert die aktuelle Anzahl der Elemente.",
                "empty pr√ºft, ob die Liste leer ist."
              ]
            },
            {
              "type": "code",
              "title": "size und empty",
              "language": "cpp",
              "code": "#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> l = {1, 2, 3};\n\n    std::cout << l.size() << std::endl;\n    std::cout << l.empty() << std::endl; // false\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente einf√ºgen",
              "text": [
                "push_back und push_front f√ºgen Elemente am Ende oder Anfang ein.",
                "insert f√ºgt Elemente an einer Iteratorposition ein."
              ]
            },
            {
              "type": "code",
              "title": "push_front, push_back und insert",
              "language": "cpp",
              "code": "#include <list>\n\nint main() {\n    std::list<int> l;\n\n    l.push_back(2);\n    l.push_front(1);\n\n    auto it = l.begin();\n    ++it;\n    l.insert(it, 42); // Einf√ºgen in der Mitte\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "pop_front und pop_back entfernen das erste oder letzte Element.",
                "erase entfernt das Element an einer Iteratorposition."
              ]
            },
            {
              "type": "code",
              "title": "pop und erase",
              "language": "cpp",
              "code": "#include <list>\n\nint main() {\n    std::list<int> l = {1, 2, 3};\n\n    l.pop_front(); // entfernt 1\n    l.pop_back();  // entfernt 3\n\n    auto it = l.begin();\n    l.erase(it); // entfernt 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Spezielle Memberfunktionen",
              "text": [
                "remove entfernt alle Elemente mit einem bestimmten Wert.",
                "splice verschiebt Elemente effizient zwischen Listen.",
                "sort sortiert die Liste ohne zus√§tzliche Speicherallokation."
              ]
            },
            {
              "type": "code",
              "title": "remove, splice und sort",
              "language": "cpp",
              "code": "#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> a = {3, 1, 2, 2};\n    std::list<int> b = {10, 20};\n\n    a.remove(2);      // entfernt alle 2er\n    a.sort();         // sortiert die Liste\n    a.splice(a.end(), b); // verschiebt alle Elemente aus b nach a\n\n    for (int x : a) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::list vs std::vector",
              "columns": ["std::list", "std::vector"],
              "rows": [
                {
                  "aspect": "Speicherlayout",
                  "values": ["Nicht zusammenh√§ngend", "Zusammenh√§ngend"]
                },
                {
                  "aspect": "Einf√ºgen in der Mitte",
                  "values": ["Sehr effizient", "Teuer"]
                },
                {
                  "aspect": "Indexzugriff",
                  "values": ["Nicht m√∂glich", "O(1)"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Falsche Containerwahl",
              "text": "std::list ist f√ºr zuf√§lligen Zugriff ungeeignet und oft langsamer als std::vector durch schlechte Cache-Lokalit√§t."
            },
            {
              "type": "important",
              "text": "std::list ist ideal, wenn h√§ufiges Einf√ºgen und Entfernen an beliebigen Positionen ben√∂tigt wird."
            },
            {
              "type": "summary",
              "points": [
                "std::list ist eine doppelt verkettete Liste",
                "Kein Indexzugriff",
                "Stabile Iteratoren",
                "Effizientes Einf√ºgen und Entfernen",
                "Spezielle Funktionen wie splice und remove"
              ]
            }
          ]
        },
        {
          "title": "std::deque",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::deque",
              "text": "std::deque ist ein sequenzieller STL-Container mit effizientem Einf√ºgen und Entfernen an beiden Enden."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::deque steht f√ºr double ended queue.",
                "Die Elemente liegen in mehreren zusammenh√§ngenden Speicherbl√∂cken, nicht in einem einzigen."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Eigenschaften",
              "text": [
                "Konstanter Zeitaufwand f√ºr push_front und push_back.",
                "Direkter Indexzugriff √§hnlich wie bei std::vector.",
                "Bessere Flexibilit√§t an den Enden als std::vector."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<deque>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zugriff und Gr√∂√üe",
              "text": [
                "operator[] und at erm√∂glichen direkten Zugriff auf Elemente.",
                "size und empty liefern Informationen √ºber den Zustand des Containers."
              ]
            },
            {
              "type": "code",
              "title": "Zugriff auf Elemente",
              "language": "cpp",
              "code": "#include <iostream>\n#include <deque>\n\nint main() {\n    std::deque<int> d = {10, 20, 30};\n\n    std::cout << d[0] << std::endl;\n    std::cout << d.at(1) << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente einf√ºgen",
              "text": [
                "push_back f√ºgt am Ende ein.",
                "push_front f√ºgt am Anfang ein.",
                "emplace_back und emplace_front konstruieren Elemente direkt."
              ]
            },
            {
              "type": "code",
              "title": "push_front und push_back",
              "language": "cpp",
              "code": "#include <deque>\n\nint main() {\n    std::deque<int> d;\n\n    d.push_back(2);\n    d.push_front(1);\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "pop_back entfernt das letzte Element.",
                "pop_front entfernt das erste Element.",
                "clear entfernt alle Elemente."
              ]
            },
            {
              "type": "code",
              "title": "pop_front und pop_back",
              "language": "cpp",
              "code": "#include <deque>\n\nint main() {\n    std::deque<int> d = {1, 2, 3};\n\n    d.pop_front(); // entfernt 1\n    d.pop_back();  // entfernt 3\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteratoren und Algorithmen",
              "text": [
                "std::deque unterst√ºtzt Random-Access-Iteratoren.",
                "Alle STL-Algorithmen k√∂nnen verwendet werden."
              ]
            },
            {
              "type": "code",
              "title": "std::sort mit deque",
              "language": "cpp",
              "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n\nint main() {\n    std::deque<int> d = {3, 1, 4, 1, 5};\n\n    std::sort(d.begin(), d.end());\n\n    for (int x : d) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::deque vs std::vector",
              "columns": ["std::deque", "std::vector"],
              "rows": [
                {
                  "aspect": "Einf√ºgen vorne",
                  "values": ["Effizient", "Teuer"]
                },
                {
                  "aspect": "Speicherlayout",
                  "values": ["Blockweise", "Zusammenh√§ngend"]
                },
                {
                  "aspect": "Cache-Lokalit√§t",
                  "values": ["Etwas schlechter", "Sehr gut"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unn√∂tiger Einsatz",
              "text": "std::deque ist oft langsamer als std::vector, wenn kein push_front ben√∂tigt wird."
            },
            {
              "type": "important",
              "text": "std::deque ist sinnvoll, wenn h√§ufiger Zugriff an beiden Enden ben√∂tigt wird."
            },
            {
              "type": "summary",
              "points": [
                "std::deque ist eine doppelseitige Warteschlange",
                "Direkter Indexzugriff m√∂glich",
                "Effizientes Einf√ºgen an beiden Enden",
                "Random-Access-Iteratoren",
                "Alternative zu std::vector bei push_front Bedarf"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
        {
          "title": "std::map",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::map",
              "text": "std::map ist ein assoziativer STL-Container, der Schl√ºssel-Wert-Paare sortiert und eindeutig nach Schl√ºsseln speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::map speichert Elemente automatisch sortiert nach dem Schl√ºssel.",
                "Jeder Schl√ºssel kommt h√∂chstens einmal vor."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "std::map ist typischerweise als balancierter Suchbaum implementiert.",
                "Alle grundlegenden Operationen laufen in logarithmischer Zeit."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<map>"
              ]
            },
            {
              "type": "explanation",
              "title": "Einf√ºgen von Elementen",
              "text": [
                "insert f√ºgt ein Schl√ºssel-Wert-Paar ein, wenn der Schl√ºssel noch nicht existiert.",
                "operator[] erzeugt bei Bedarf automatisch einen Eintrag."
              ]
            },
            {
              "type": "code",
              "title": "insert und operator[]",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m;\n\n    m.insert({1, \"eins\"});\n    m[2] = \"zwei\"; // erzeugt Eintrag falls nicht vorhanden\n\n    std::cout << m[1] << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff und Suche",
              "text": [
                "find sucht nach einem Schl√ºssel und liefert einen Iterator.",
                "count pr√ºft, ob ein Schl√ºssel existiert."
              ]
            },
            {
              "type": "code",
              "title": "find und count",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n\nint main() {\n    std::map<int, int> m = {{1, 10}, {2, 20}};\n\n    auto it = m.find(2);\n    if (it != m.end()) {\n        std::cout << it->second << std::endl;\n    }\n\n    std::cout << m.count(3) << std::endl; // 0 oder 1\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "erase entfernt Elemente nach Schl√ºssel oder Iterator.",
                "clear entfernt alle Eintr√§ge."
              ]
            },
            {
              "type": "code",
              "title": "erase und clear",
              "language": "cpp",
              "code": "#include <map>\n\nint main() {\n    std::map<int, int> m = {{1, 10}, {2, 20}};\n\n    m.erase(1);\n    m.clear();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteration",
              "text": [
                "Iteration erfolgt immer in sortierter Reihenfolge der Schl√ºssel.",
                "Iteratoren liefern Zugriff auf Schl√ºssel und Wert."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren √ºber map",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n\nint main() {\n    std::map<int, int> m = {{2, 20}, {1, 10}};\n\n    for (const auto& p : m) {\n        std::cout << p.first << \": \" << p.second << std::endl;\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::map vs std::unordered_map",
              "columns": ["std::map", "std::unordered_map"],
              "rows": [
                {
                  "aspect": "Ordnung",
                  "values": ["Sortiert", "Nicht sortiert"]
                },
                {
                  "aspect": "Zeitkomplexit√§t",
                  "values": ["O(log n)", "√ò O(1)"]
                },
                {
                  "aspect": "Iterator-Reihenfolge",
                  "values": ["Deterministisch", "Nicht definiert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "operator[] bei Lesen",
              "text": "operator[] erzeugt bei nicht vorhandenem Schl√ºssel automatisch einen Eintrag."
            },
            {
              "type": "important",
              "text": "std::map eignet sich f√ºr geordnete Schl√ºssel-Wert-Daten mit stabiler Iterationsreihenfolge."
            },
            {
              "type": "summary",
              "points": [
                "std::map speichert sortierte Schl√ºssel-Wert-Paare",
                "Eindeutige Schl√ºssel",
                "Logarithmische Laufzeit",
                "Sortierte Iteration",
                "Geeignet f√ºr geordnete Daten"
              ]
            }
          ]
        },
        {
          "title": "std::set",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::set",
              "text": "std::set ist ein assoziativer STL-Container, der eindeutige Elemente automatisch sortiert speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::set speichert nur Schl√ºssel ohne zugeh√∂rigen Wert.",
                "Jedes Element kommt h√∂chstens einmal vor."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "std::set ist typischerweise als balancierter Suchbaum implementiert.",
                "Alle grundlegenden Operationen laufen in logarithmischer Zeit."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<set>"
              ]
            },
            {
              "type": "explanation",
              "title": "Einf√ºgen von Elementen",
              "text": [
                "insert f√ºgt ein Element ein, wenn es noch nicht existiert.",
                "Doppelte Werte werden ignoriert."
              ]
            },
            {
              "type": "code",
              "title": "insert verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s;\n\n    s.insert(3);\n    s.insert(1);\n    s.insert(3); // wird ignoriert\n\n    for (int x : s) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Suche und Zugriff",
              "text": [
                "find sucht nach einem Element und liefert einen Iterator.",
                "count pr√ºft, ob ein Element vorhanden ist."
              ]
            },
            {
              "type": "code",
              "title": "find und count",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s = {1, 2, 3};\n\n    if (s.count(2)) {\n        std::cout << \"Gefunden\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "erase entfernt Elemente nach Wert oder Iterator.",
                "clear entfernt alle Elemente."
              ]
            },
            {
              "type": "code",
              "title": "erase und clear",
              "language": "cpp",
              "code": "#include <set>\n\nint main() {\n    std::set<int> s = {1, 2, 3};\n\n    s.erase(2);\n    s.clear();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteration",
              "text": [
                "Iteration erfolgt immer in sortierter Reihenfolge.",
                "Elemente sind unver√§nderlich √ºber Iteratoren."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren √ºber set",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s = {3, 1, 2};\n\n    for (int x : s) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::set vs std::vector",
              "columns": ["std::set", "std::vector"],
              "rows": [
                {
                  "aspect": "Eindeutige Elemente",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Sortiert",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Zugriff per Index",
                  "values": ["Nicht m√∂glich", "O(1)"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Elemente √§ndern",
              "text": "Elemente d√ºrfen nicht direkt ver√§ndert werden, da dies die Sortierung zerst√∂ren w√ºrde."
            },
            {
              "type": "important",
              "text": "std::set ist ideal f√ºr eindeutige, sortierte Datenmengen."
            },
            {
              "type": "summary",
              "points": [
                "std::set speichert eindeutige Werte",
                "Automatisch sortiert",
                "Logarithmische Laufzeit",
                "Kein Indexzugriff",
                "Geeignet f√ºr Mengen"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
        {
          "title": "std::stack",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::stack",
              "text": "std::stack ist ein Container-Adapter, der das LIFO-Prinzip verwendet, bei dem das zuletzt eingef√ºgte Element zuerst entfernt wird."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::stack stellt eine Stapelstruktur bereit.",
                "Der Zugriff ist nur auf das oberste Element erlaubt."
              ]
            },
            {
              "type": "explanation",
              "title": "Container-Adapter",
              "text": [
                "std::stack ist kein eigenst√§ndiger Container.",
                "Er nutzt intern standardm√§√üig std::deque als Speicherstruktur."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<stack>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push legt ein Element oben auf den Stack.",
                "pop entfernt das oberste Element.",
                "top liefert Zugriff auf das oberste Element.",
                "empty und size liefern Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::stack",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stack>\n\nint main() {\n    std::stack<int> s;\n\n    s.push(1);\n    s.push(2);\n    s.push(3);\n\n    std::cout << s.top() << std::endl; // Ausgabe: 3\n    s.pop();\n    std::cout << s.top() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Es gibt keinen direkten Zugriff auf andere Elemente als das oberste.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "code",
              "title": "empty und size",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stack>\n\nint main() {\n    std::stack<int> s;\n\n    std::cout << s.empty() << std::endl; // true\n    s.push(5);\n    std::cout << s.size() << std::endl;  // 1\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::stack vs std::vector",
              "columns": ["std::stack", "std::vector"],
              "rows": [
                {
                  "aspect": "Zugriff",
                  "values": ["Nur oberstes Element", "Beliebiger Index"]
                },
                {
                  "aspect": "Datenstruktur",
                  "values": ["LIFO", "Sequenziell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zugriff nach pop",
              "text": "Nach pop darf top nicht mehr verwendet werden, da das Element entfernt wurde."
            },
            {
              "type": "important",
              "text": "std::stack eignet sich f√ºr Algorithmen mit R√ºckverfolgung oder verschachtelten Aufrufen."
            },
            {
              "type": "summary",
              "points": [
                "std::stack arbeitet nach dem LIFO-Prinzip",
                "Zugriff nur auf das oberste Element",
                "Kein direkter Iteratorzugriff",
                "Container-Adapter auf Basis von std::deque"
              ]
            }
          ]
        },
        {
          "title": "std::queue",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::queue",
              "text": "std::queue ist ein Container-Adapter, der das FIFO-Prinzip verwendet, bei dem das zuerst eingef√ºgte Element zuerst entfernt wird."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::queue modelliert eine Warteschlange.",
                "Elemente werden hinten eingef√ºgt und vorne entfernt."
              ]
            },
            {
              "type": "explanation",
              "title": "Container-Adapter",
              "text": [
                "std::queue ist kein eigenst√§ndiger Container.",
                "Intern wird standardm√§√üig std::deque verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<queue>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push f√ºgt ein Element am Ende ein.",
                "pop entfernt das vorderste Element.",
                "front und back liefern Zugriff auf Anfang und Ende.",
                "empty und size geben Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::queue",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::queue<int> q;\n\n    q.push(1);\n    q.push(2);\n    q.push(3);\n\n    std::cout << q.front() << std::endl; // Ausgabe: 1\n    q.pop();\n    std::cout << q.front() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Kein direkter Zugriff auf mittlere Elemente.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "code",
              "title": "front, back, empty und size",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::queue<int> q;\n\n    std::cout << q.empty() << std::endl; // true\n    q.push(10);\n    q.push(20);\n\n    std::cout << q.front() << std::endl; // 10\n    std::cout << q.back() << std::endl;  // 20\n    std::cout << q.size() << std::endl;  // 2\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::queue vs std::deque",
              "columns": ["std::queue", "std::deque"],
              "rows": [
                {
                  "aspect": "Zugriff",
                  "values": ["FIFO eingeschr√§nkt", "Voller Zugriff"]
                },
                {
                  "aspect": "Abstraktion",
                  "values": ["Warteschlange", "Sequenzieller Container"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zugriff nach pop",
              "text": "Nach pop darf front nicht mehr verwendet werden, da das Element entfernt wurde."
            },
            {
              "type": "important",
              "text": "std::queue ist ideal f√ºr Breitensuche, Scheduling und Producer-Consumer-Modelle."
            },
            {
              "type": "summary",
              "points": [
                "std::queue arbeitet nach dem FIFO-Prinzip",
                "Zugriff nur vorne und hinten",
                "Kein direkter Zugriff auf mittlere Elemente",
                "Container-Adapter auf Basis von std::deque"
              ]
            }
          ]
        },
        {
          "title": "std::priority_queue",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::priority_queue",
              "text": "std::priority_queue ist ein Container-Adapter, der stets das Element mit der h√∂chsten Priorit√§t bereitstellt."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::priority_queue organisiert Elemente nach Priorit√§t.",
                "Der Zugriff erfolgt immer auf das aktuell wichtigste Element."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "Intern basiert std::priority_queue auf einem Heap.",
                "Standardm√§√üig wird ein Max-Heap verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<queue>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push f√ºgt ein Element ein.",
                "pop entfernt das Element mit der h√∂chsten Priorit√§t.",
                "top liefert Zugriff auf das wichtigste Element.",
                "empty und size geben Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::priority_queue",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::priority_queue<int> pq;\n\n    pq.push(3);\n    pq.push(1);\n    pq.push(5);\n\n    std::cout << pq.top() << std::endl; // Ausgabe: 5\n    pq.pop();\n    std::cout << pq.top() << std::endl; // Ausgabe: 3\n}\n"
            },
            {
              "type": "explanation",
              "title": "Min-Heap erstellen",
              "text": [
                "Durch einen Comparator kann die Ordnung umgekehrt werden.",
                "So l√§sst sich ein Min-Heap realisieren."
              ]
            },
            {
              "type": "code",
              "title": "priority_queue als Min-Heap",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nint main() {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n\n    pq.push(3);\n    pq.push(1);\n    pq.push(5);\n\n    std::cout << pq.top() << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Es gibt keinen direkten Zugriff auf alle Elemente.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "comparison",
              "title": "std::priority_queue vs std::queue",
              "columns": ["std::priority_queue", "std::queue"],
              "rows": [
                {
                  "aspect": "Ordnungsprinzip",
                  "values": ["Priorit√§t", "FIFO"]
                },
                {
                  "aspect": "Zugriff",
                  "values": ["H√∂chste Priorit√§t", "Vorderstes Element"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Reihenfolge missverstehen",
              "text": "Die priority_queue ist nicht vollst√§ndig sortiert, nur das oberste Element ist garantiert korrekt."
            },
            {
              "type": "important",
              "text": "std::priority_queue ist ideal f√ºr Scheduling, Dijkstra und Ereignisverwaltung."
            },
            {
              "type": "summary",
              "points": [
                "std::priority_queue stellt immer das wichtigste Element bereit",
                "Basiert auf einem Heap",
                "Standardm√§√üig Max-Heap",
                "Min-Heap √ºber Comparator m√∂glich",
                "Kein direkter Iteratorzugriff"
              ]
            }
          ]
        }
        ]
      }
    ]
  },




  {
    "category": "Design",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Patterns",
        "icon": "üß©",
        "topics": [
        {
          "title": "Strategy Pattern",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Strategy Pattern",
              "text": "Das Strategy Pattern kapselt austauschbare Algorithmen in eigene Klassen und macht sie √ºber ein gemeinsames Interface zur Laufzeit wechselbar."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Statt lange if else oder switch Anweisungen zu verwenden, wird das variierende Verhalten ausgelagert.",
                "Der Kontext kennt nur ein gemeinsames Strategie Interface, nicht die konkrete Implementierung.",
                "Das Verhalten kann zur Laufzeit ge√§ndert werden, ohne den Kontext zu ver√§ndern."
              ]
            },
            {
              "type": "explanation",
              "title": "Struktur",
              "text": [
                "Strategy Interface: Definiert die gemeinsame Schnittstelle f√ºr alle Algorithmen.",
                "ConcreteStrategy: Implementiert das Interface mit einem konkreten Verhalten.",
                "Context: Enth√§lt eine Referenz auf eine Strategy und delegiert die Ausf√ºhrung."
              ]
            },
            {
              "type": "code",
              "title": "Strategy Pattern: Rabatte austauschbar",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n#include <string>\n\n// Strategy Interface: definiert die austauschbare \"Berechnungsregel\"\n// Vorteil: Checkout kennt nur dieses Interface, nicht die konkreten Regeln.\nstruct DiscountStrategy {\n    virtual ~DiscountStrategy() = default;\n    virtual double apply(double price) const = 0;\n    virtual const char* name() const = 0;\n};\n\n// Konkrete Strategie 1: kein Rabatt\nstruct NoDiscount : DiscountStrategy {\n    double apply(double price) const override {\n        return price;\n    }\n    const char* name() const override {\n        return \"NoDiscount\";\n    }\n};\n\n// Konkrete Strategie 2: prozentualer Rabatt\nstruct PercentageDiscount : DiscountStrategy {\n    double percent; // z.B. 10 = 10%\n\n    explicit PercentageDiscount(double p) : percent(p) {}\n\n    double apply(double price) const override {\n        // Beispiel: 10% Rabatt => price * (1 - 0.10)\n        return price * (1.0 - percent / 100.0);\n    }\n    const char* name() const override {\n        return \"PercentageDiscount\";\n    }\n};\n\n// Konkrete Strategie 3: fester Betrag Rabatt (z.B. Gutschein)\nstruct FixedDiscount : DiscountStrategy {\n    double amount;\n\n    explicit FixedDiscount(double a) : amount(a) {}\n\n    double apply(double price) const override {\n        // Nicht negativ werden lassen\n        double result = price - amount;\n        return (result < 0.0) ? 0.0 : result;\n    }\n    const char* name() const override {\n        return \"FixedDiscount\";\n    }\n};\n\n// Context: nutzt eine Strategy, kennt aber keine Details der Implementierung.\nclass Checkout {\n    std::unique_ptr<DiscountStrategy> strategy;\n\npublic:\n    explicit Checkout(std::unique_ptr<DiscountStrategy> s)\n        : strategy(std::move(s)) {}\n\n    // Strategie zur Laufzeit austauschbar\n    void setStrategy(std::unique_ptr<DiscountStrategy> s) {\n        strategy = std::move(s);\n    }\n\n    double finalPrice(double basePrice) const {\n        // Checkout delegiert die Rabattlogik an die Strategy\n        return strategy->apply(basePrice);\n    }\n\n    const char* currentStrategyName() const {\n        return strategy->name();\n    }\n};\n\nint main() {\n    double price = 100.0;\n\n    // Start: keine Rabatte\n    Checkout checkout(std::make_unique<NoDiscount>());\n    std::cout << checkout.currentStrategyName() << \": \"\n              << checkout.finalPrice(price) << '\\n';\n    // Ausgabe: NoDiscount: 100\n\n    // Wechsel zur Laufzeit: 10% Rabatt\n    checkout.setStrategy(std::make_unique<PercentageDiscount>(10.0));\n    std::cout << checkout.currentStrategyName() << \": \"\n              << checkout.finalPrice(price) << '\\n';\n    // Ausgabe: PercentageDiscount: 90\n\n    // Wechsel zur Laufzeit: 15 EUR Rabatt\n    checkout.setStrategy(std::make_unique<FixedDiscount>(15.0));\n    std::cout << checkout.currentStrategyName() << \": \"\n              << checkout.finalPrice(price) << '\\n';\n    // Ausgabe: FixedDiscount: 85\n}\n"
            },
            {
              "type": "explanation",
              "title": "Laufzeit Wechsel der Strategie",
              "text": [
                "Der Kontext kann jederzeit eine neue Strategie erhalten.",
                "Der aufrufende Code entscheidet, welche Strategie aktuell verwendet wird.",
                "Der Kontext bleibt dabei unver√§ndert und stabil."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzf√§lle",
              "items": [
                "Austauschbare Algorithmen",
                "Gesch√§ftsregeln und Policies",
                "Berechnungslogik wie Preise, Rabatte oder Bewertungen",
                "Unterschiedliche Sortier oder Suchstrategien"
              ]
            },
            {
              "type": "comparison",
              "title": "Strategy Pattern vs if else Ketten",
              "columns": ["Strategy Pattern", "if else"],
              "rows": [
                {
                  "aspect": "Erweiterbarkeit",
                  "values": ["Neue Strategie ohne √Ñnderung des Kontexts", "Code muss angepasst werden"]
                },
                {
                  "aspect": "√úbersichtlichkeit",
                  "values": ["Klare Trennung der Verantwortlichkeiten", "Schnell un√ºbersichtlich"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Strategien isoliert testbar", "Tests oft komplex"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "H√§ufige Fehler",
              "text": "Zu viele sehr kleine Strategie Klassen oder eine falsche Granularit√§t f√ºhren zu unn√∂tiger Komplexit√§t. Das Pattern sollte nur eingesetzt werden, wenn sich Verhalten tats√§chlich √§ndert."
            },
            {
              "type": "important",
              "text": "Das Strategy Pattern ersetzt keine einfache Bedingung. Es lohnt sich erst, wenn Verhalten h√§ufig wechselt oder erweitert wird."
            },
            {
              "type": "summary",
              "points": [
                "Kapselt austauschbares Verhalten",
                "Vermeidet lange if else Ketten",
                "Kontext arbeitet nur mit einem Interface",
                "Strategie kann zur Laufzeit gewechselt werden",
                "Mit Ma√ü einsetzen, um √úberdesign zu vermeiden"
              ]
            }
          ]
        },


        {
          "title": "Factory Pattern",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Factory Pattern",
              "text": "Das Factory Pattern trennt Objekterzeugung von der Nutzung, indem ein Erzeuger Objekt Instanzen √ºber einen Basistyp oder ein Interface zur√ºckgibt."
            },
            {
              "type": "explanation",
              "title": "Problem und Ziel",
              "text": [
                "Wenn Code √ºberall direkt mit new oder konkreten Klassen arbeitet, entsteht starke Kopplung.",
                "Eine Factory kapselt die Erzeugungslogik an einer Stelle.",
                "Der aufrufende Code kennt nur den Basistyp oder ein Interface und bleibt stabil bei Erweiterungen."
              ]
            },
            {
              "type": "explanation",
              "title": "Kernidee",
              "text": [
                "R√ºckgabe erfolgt typischerweise als Basistyp, Interface oder Smart Pointer darauf.",
                "Die Factory entscheidet anhand von Parametern oder Konfiguration, welche konkrete Klasse instanziiert wird.",
                "Damit werden Abh√§ngigkeiten auf konkrete Typen aus dem restlichen Code entfernt."
              ]
            },
            {
              "type": "code",
              "title": "Factory Pattern: Produkt-Interface und konkrete Logger",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n#include <memory>\n#include <string>\n\n// Produkt-Interface\nstruct Logger {\n    virtual ~Logger() = default;\n    virtual void log(const std::string& msg) = 0;\n};\n\n// Konkretes Produkt 1: Konsole\nclass ConsoleLogger : public Logger {\npublic:\n    void log(const std::string& msg) override {\n        std::cout << \"[console] \" << msg << '\\n';\n    }\n};\n\n// Konkretes Produkt 2: Datei\nclass FileLogger : public Logger {\n    std::ofstream file; // Ressource: Datei-Handle\n\npublic:\n    explicit FileLogger(const std::string& path)\n        : file(path, std::ios::app) {\n        // In echter Software w√ºrdest du hier pr√ºfen, ob file ge√∂ffnet ist.\n    }\n\n    void log(const std::string& msg) override {\n        file << \"[file] \" << msg << '\\n';\n        file.flush();\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Einfache Factory: Erzeugung zentral an einer Stelle",
              "language": "cpp",
              "code": "#include <memory>\n#include <stdexcept>\n#include <string>\n\nenum class LoggerType { Console, File };\n\n// Factory nimmt nicht nur \"welcher Typ\", sondern auch Konfiguration entgegen.\n// Genau hier liegt der Praxisnutzen: Erzeugungsdetails bleiben aus dem restlichen Code raus.\nstd::unique_ptr<Logger> makeLogger(LoggerType type, const std::string& filePath = \"\") {\n    switch (type) {\n        case LoggerType::Console:\n            return std::make_unique<ConsoleLogger>();\n\n        case LoggerType::File:\n            if (filePath.empty()) {\n                throw std::runtime_error(\"FileLogger braucht einen Dateipfad\");\n            }\n            return std::make_unique<FileLogger>(filePath);\n\n        default:\n            throw std::runtime_error(\"Unbekannter LoggerType\");\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Factory nutzen: Rest des Codes kennt keine konkreten Logger",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n#include <string>\n\n// Beispiel: Service h√§ngt nur vom Interface Logger ab (DIP kompatibel)\nclass Service {\n    Logger& logger;\n\npublic:\n    explicit Service(Logger& l) : logger(l) {}\n\n    void doWork() {\n        logger.log(\"Service startet\");\n        logger.log(\"Service erledigt Arbeit\");\n    }\n};\n\nint main() {\n    // Entscheidung √ºber konkrete Klasse passiert an EINER Stelle\n    // (z.B. Konfiguration, CLI-Argumente, Build-Mode, Env Vars)\n    auto logger = makeLogger(LoggerType::Console);\n\n    Service s(*logger);\n    s.doWork();\n\n    // Wechsel: ohne Service anzufassen\n    auto fileLogger = makeLogger(LoggerType::File, \"app.log\");\n    Service s2(*fileLogger);\n    s2.doWork();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einfache Factory vs Factory Method",
              "text": [
                "Einfache Factory ist oft nur eine Funktion oder Klasse mit einer create Methode, die basierend auf Parametern konkrete Typen erzeugt.",
                "Factory Method ist ein GoF Pattern: Eine Basisklasse definiert eine virtuelle create Methode, Subklassen entscheiden welche Produkte erzeugt werden.",
                "Factory Method passt besonders, wenn die Erzeugung Teil einer erweiterbaren Klassenhierarchie ist."
              ]
            },
            {
              "type": "code",
              "title": "Factory Method als Muster",
              "language": "cpp",
              "code": "#include <memory>\n\nstruct Creator {\n    virtual ~Creator() = default;\n    virtual std::unique_ptr<Logger> createLogger() const = 0;\n};\n\nstruct ConsoleCreator : Creator {\n    std::unique_ptr<Logger> createLogger() const override {\n        return std::make_unique<ConsoleLogger>();\n    }\n};\n\nstruct FileCreator : Creator {\n    std::unique_ptr<Logger> createLogger() const override {\n        return std::make_unique<FileLogger>();\n    }\n};"
            },
            {
              "type": "list",
              "title": "Wann eine Factory sinnvoll ist",
              "items": [
                "Wenn der konkrete Typ je nach Konfiguration oder Laufzeit Entscheidung variiert",
                "Wenn du den aufrufenden Code von konkreten Klassen entkoppeln willst",
                "Wenn die Erzeugung komplex ist, zum Beispiel mit Validierung oder Abh√§ngigkeiten",
                "Wenn du neue Varianten hinzuf√ºgen willst, ohne √ºberall Aufrufer anzupassen"
              ]
            },
            {
              "type": "list",
              "title": "Wann eine Factory oft overkill ist",
              "items": [
                "Wenn es nur einen konkreten Typ gibt und das vermutlich so bleibt",
                "Wenn die Erzeugung trivial ist und keine Varianten zu erwarten sind",
                "Wenn du nur eine Abk√ºrzung f√ºr make_unique bauen w√ºrdest",
                "Wenn die Factory keine echte Entkopplung bringt, sondern nur Umweg erzeugt"
              ]
            },
            {
              "type": "comparison",
              "title": "Einfache Factory vs Factory Method",
              "columns": ["Einfache Factory", "Factory Method"],
              "rows": [
                {
                  "aspect": "Form",
                  "values": ["Funktion oder Klasse mit create", "Vererbung mit virtueller create Methode"]
                },
                {
                  "aspect": "Erweiterung",
                  "values": ["Meist switch oder Lookup", "Neue Creator Subklasse"]
                },
                {
                  "aspect": "Komplexit√§t",
                  "values": ["Gering", "H√∂her"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Factory wird zur God Function",
              "text": "Eine Factory, die immer weiter w√§chst und alle Entscheidungen und Sonderf√§lle enth√§lt, wird schnell unwartbar. Dann ist sie nur eine gro√üe switch Sammelstelle ohne klare Struktur."
            },
            {
              "type": "important",
              "text": "Wenn die Factory viele Bedingungen enth√§lt, ist das ein Signal f√ºr bessere Struktur, zum Beispiel Registrierung √ºber Map, getrennte Creator Klassen oder klare Produktfamilien."
            },
            {
              "type": "summary",
              "points": [
                "Trennt Objekterzeugung von Nutzung",
                "R√ºckgabe √ºber Basistyp oder Interface",
                "Einfache Factory ist oft genug, Factory Method ist das GoF Pattern mit Vererbung",
                "Sinnvoll bei Varianten und komplexer Erzeugung",
                "Achte darauf, dass die Factory nicht zur God Function wird"
              ]
            }
          ]
        },


        {
          "title": "Adapter Pattern",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Adapter Pattern",
              "text": "Das Adapter Pattern passt eine bestehende, inkompatible Schnittstelle an eine erwartete API an, ohne den bestehenden Code zu ver√§ndern."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Vorhandene Klassen oder externe Libraries passen oft nicht zur eigenen Schnittstelle.",
                "Statt fremden oder alten Code umzubauen, wird ein Adapter als Wrapper dazwischen gesetzt.",
                "Der Adapter √ºbersetzt Aufrufe von der gew√ºnschten Schnittstelle zur vorhandenen Implementierung."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Struktur",
              "text": [
                "Target Interface: Die Schnittstelle, die der eigene Code erwartet.",
                "Adaptee: Die bestehende Klasse mit inkompatibler API.",
                "Adapter: Implementiert das Target Interface und delegiert intern an den Adaptee."
              ]
            },
            {
              "type": "code",
              "title": "Adapter Pattern: Target Interface (was der Client erwartet)",
              "language": "cpp",
              "code": "#include <string>\n\n// Target: so m√∂chte dein neuer Code arbeiten\nstruct Printer {\n    virtual ~Printer() = default;\n\n    // Erwartet: eine einfache print Methode\n    virtual void print(const std::string& text) = 0;\n};\n"
            },
            {
              "type": "code",
              "title": "Adapter Pattern: Legacy Klasse (Adaptee) mit inkompatibler API",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\n// Legacy: existiert schon, darf oder willst du nicht √§ndern\nclass LegacyPrinter {\npublic:\n    // Inkompatibel:\n    // - anderer Name\n    // - erwartet ein Prefix separat\n    // - gibt bool zur√ºck (Erfolg)\n    bool outputText(const std::string& prefix, const std::string& text) {\n        std::cout << prefix << text << '\\n';\n        return true;\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Adapter Pattern: Objekt-Adapter (Komposition) √ºbersetzt die Schnittstelle",
              "language": "cpp",
              "code": "#include <memory>\n#include <stdexcept>\n#include <string>\n\n// Adapter: implementiert Target (Printer)\n// und nutzt intern den LegacyPrinter (Adaptee)\nclass PrinterAdapter : public Printer {\n    LegacyPrinter legacy;          // der alte Drucker\n    std::string fixedPrefix;       // Adapter kann zus√§tzlich konfigurieren\n\npublic:\n    explicit PrinterAdapter(std::string prefix)\n        : fixedPrefix(std::move(prefix)) {}\n\n    void print(const std::string& text) override {\n        // √úbersetzung:\n        // Target: print(text)\n        // Legacy: outputText(prefix, text) -> bool\n        bool ok = legacy.outputText(fixedPrefix, text);\n\n        // Optional: Legacy R√ºckgabewert in moderne Fehlerbehandlung √ºbersetzen\n        if (!ok) {\n            throw std::runtime_error(\"LegacyPrinter konnte nicht drucken\");\n        }\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Adapter Pattern: Client benutzt nur das Target Interface",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\n// Client Funktion: erwartet nur Printer\nvoid runPrintJob(Printer& printer) {\n    printer.print(\"Hello Adapter\");\n}\n\nint main() {\n    // Wir nehmen Legacy Code, ohne ihn anzufassen,\n    // und machen ihn kompatibel zum Target Interface.\n    PrinterAdapter adapter(\"[legacy] \");\n\n    runPrintJob(adapter);\n\n    // Ausgabe:\n    // [legacy] Hello Adapter\n}\n"
            },
            {
              "type": "explanation",
              "title": "Warum Adapter statt Umbau",
              "text": [
                "Externe Libraries d√ºrfen oder k√∂nnen oft nicht ver√§ndert werden.",
                "Legacy Code ist h√§ufig riskant anzupassen.",
                "Der Adapter kapselt die Abweichung und h√§lt den Rest des Systems sauber."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzf√§lle",
              "items": [
                "Integration externer Libraries",
                "Anbindung von Legacy Code",
                "Migration alter APIs auf neue Schnittstellen",
                "Vereinheitlichung unterschiedlicher Schnittstellen"
              ]
            },
            {
              "type": "comparison",
              "title": "Adapter vs direkter Umbau",
              "columns": ["Adapter Pattern", "Direkter Umbau"],
              "rows": [
                {
                  "aspect": "Risiko",
                  "values": ["Gering", "Hoch bei Legacy Code"]
                },
                {
                  "aspect": "√Ñnderungen",
                  "values": ["Isoliert im Adapter", "√úberall im Code"]
                },
                {
                  "aspect": "Wartbarkeit",
                  "values": ["Klare Trennung", "Oft schlechter"]
                }
              ]
            },
            {
              "type": "important",
              "text": "Ein Adapter sollte m√∂glichst d√ºnn sein und nur √ºbersetzen, nicht selbst Entscheidungen treffen."
            },
            {
              "type": "pitfall",
              "title": "Logik im Adapter verstecken",
              "text": "Wenn Gesch√§ftslogik im Adapter landet, wird er schwer verst√§ndlich und verletzt die Trennung der Verantwortlichkeiten. Der Adapter ist keine Ersatz Implementierung."
            },
            {
              "type": "summary",
              "points": [
                "Passt fremde Schnittstellen an eigene APIs an",
                "Wrapper statt √Ñnderungen am bestehenden Code",
                "Besonders n√ºtzlich bei Libraries und Legacy Code",
                "Adapter als d√ºnne √úbersetzungsschicht halten",
                "Keine Gesch√§ftslogik im Adapter verstecken"
              ]
            }
          ]
        },


        {
          "title": "RAII als Design Pattern",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "RAII",
              "text": "RAII bindet den Besitz einer Ressource strikt an die Lebensdauer eines Objekts. Wird das Objekt erzeugt, wird die Ressource erworben. Wird es zerst√∂rt, wird die Ressource freigegeben."
            },
            {
              "type": "explanation",
              "title": "Kernprinzip",
              "text": [
                "Der Konstruktor ist f√ºr den Erwerb der Ressource zust√§ndig.",
                "Der Destruktor gibt die Ressource garantiert frei.",
                "Freigabe erfolgt deterministisch beim Verlassen des G√ºltigkeitsbereichs."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum RAII funktioniert",
              "text": [
                "Objektlebensdauer ist klar definiert und wird vom Compiler verwaltet.",
                "Destruktoren werden auch bei Exceptions zuverl√§ssig aufgerufen.",
                "Ressourcenlecks werden strukturell verhindert, nicht nur konventionell."
              ]
            },
            {
              "type": "code",
              "title": "RAII mit Speicher",
              "language": "cpp",
              "code": "#include <memory>\n\nvoid example() {\n    auto ptr = std::make_unique<int>(42);\n    // Speicher wird automatisch freigegeben\n}"
            },
            {
              "type": "code",
              "title": "Ohne eigenes RAII: Datei-Logik und Ablauf vermischt",
              "language": "cpp",
              "code": "#include <fstream>\n#include <stdexcept>\n\nvoid badExample(bool fail) {\n    std::ofstream file(\"log.txt\");\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Datei konnte nicht ge√∂ffnet werden\");\n    }\n\n    file << \"Start\" << '\\n';\n\n    if (fail) {\n        // Early return / throw\n        // Datei wird zwar von ofstream geschlossen,\n        // aber die Logik ist √ºberall verstreut\n        return;\n    }\n\n    file << \"Ende\" << '\\n';\n}\n"
            },
            {
              "type": "code",
              "title": "RAII: Eigener Logger kapselt std::ofstream sauber",
              "language": "cpp",
              "code": "#include <fstream>\n#include <stdexcept>\n#include <string>\n\nclass FileLogger {\n    std::ofstream file; // Ressource geh√∂rt dieser Klasse\n\npublic:\n    // Konstruktor: Ressource erwerben\n    explicit FileLogger(const std::string& path)\n        : file(path, std::ios::app) {\n        if (!file.is_open()) {\n            throw std::runtime_error(\"Datei konnte nicht ge√∂ffnet werden\");\n        }\n    }\n\n    // Destruktor: Ressource automatisch freigeben\n    // std::ofstream schlie√üt die Datei selbstst√§ndig\n    ~FileLogger() = default;\n\n    // Kopieren verbieten (eine Datei, ein Besitzer)\n    FileLogger(const FileLogger&) = delete;\n    FileLogger& operator=(const FileLogger&) = delete;\n\n    // Move erlauben (Besitz√ºbertragung)\n    FileLogger(FileLogger&&) = default;\n    FileLogger& operator=(FileLogger&&) = default;\n\n    void log(const std::string& msg) {\n        file << msg << '\\n';\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "RAII Vorteil: Datei wird auch bei Exception korrekt geschlossen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        FileLogger logger(\"log.txt\");\n        logger.log(\"Start\");\n\n        // Fehler mitten im Ablauf\n        throw std::runtime_error(\"Fehler w√§hrend der Verarbeitung\");\n\n        logger.log(\"Ende\"); // wird nie erreicht\n    } catch (const std::exception& e) {\n        std::cout << \"Fehler: \" << e.what() << '\\n';\n    }\n\n    // Datei ist hier garantiert geschlossen,\n    // weil der Destruktor von FileLogger beim Scope-Ende l√§uft\n}\n"
            },
            {
              "type": "explanation",
              "title": "RAII statt try catch Cleanup",
              "text": [
                "Manuelles Cleanup mit try catch ist fehleranf√§llig und schwer wartbar.",
                "RAII verschiebt Cleanup Logik in Destruktoren.",
                "Der Code bleibt linear und √ºbersichtlich, ohne doppelte Freigaben."
              ]
            },
            {
              "type": "comparison",
              "title": "RAII vs manuelles Cleanup",
              "columns": ["RAII", "Manuelles Cleanup"],
              "rows": [
                {
                  "aspect": "Exception Sicherheit",
                  "values": ["Garantiert", "Oft fehlerhaft"]
                },
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Klarer Kontrollfluss", "Viele Sonderf√§lle"]
                },
                {
                  "aspect": "Wartbarkeit",
                  "values": ["Hoch", "Niedrig"]
                }
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzbereiche",
              "items": [
                "Dynamischer Speicher",
                "Datei und Stream Verwaltung",
                "Mutexe und Locks",
                "Datenbank Verbindungen und Statements",
                "Netzwerk Sockets"
              ]
            },
            {
              "type": "pitfall",
              "title": "Unklare Ownership",
              "text": "Rohe Pointer ohne klaren Besitz f√ºhren dazu, dass RAII ausgehebelt wird. Ownership muss eindeutig sein, zum Beispiel √ºber unique_ptr oder klar dokumentierte Wrapper."
            },
            {
              "type": "important",
              "text": "RAII ist kein Feature, sondern ein zentrales Entwurfsprinzip von C++. Ohne RAII ist moderner C++ Code kaum robust."
            },
            {
              "type": "summary",
              "points": [
                "Ressourcen sind an Objektlebensdauer gebunden",
                "Konstruktor erwirbt, Destruktor gibt frei",
                "Funktioniert f√ºr Speicher, Dateien, Locks und Datenbanken",
                "Besser als manuelles try catch Cleanup",
                "Klare Ownership ist zwingend notwendig"
              ]
            }
          ]
        }



        ]
      },


      {
        "name": "GRASPS",
        "icon": "üß≠",
        "topics": [
        {
          "title": "Responsibilities sinnvoll zuordnen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Responsibility Assignment",
              "text": "Responsibilities sinnvoll zuordnen bedeutet, jeder Klasse genau die Verantwortlichkeiten zu geben, die fachlich und semantisch zu ihr passen, ohne sie zu √ºberladen oder beliebig zu schneiden."
            },
            {
              "type": "explanation",
              "title": "Bezug zu GRASP",
              "text": [
                "GRASP beschreibt grundlegende Regeln zur Zuweisung von Verantwortlichkeiten in objektorientierten Systemen.",
                "Ziel ist hohe Koh√§sion und geringe Kopplung.",
                "Jede Klasse soll einen klaren Zweck erf√ºllen, der aus der Dom√§ne ableitbar ist."
              ]
            },
            {
              "type": "explanation",
              "title": "Semantische Passung von Methoden",
              "text": [
                "Methoden geh√∂ren in die Klasse, zu der sie inhaltlich passen.",
                "Die Klasse sollte √ºber die n√∂tigen Daten verf√ºgen, um ihre Aufgaben selbst zu erf√ºllen.",
                "Fremdzugriffe und Datendurchreicherei sind oft ein Zeichen falscher Zuordnung."
              ]
            },
            {
              "type": "explanation",
              "title": "Nach Verantwortung statt nach Technik schneiden",
              "text": [
                "Klassen sollten fachliche Konzepte repr√§sentieren, nicht technische Sammelstellen.",
                "Technikbezogene Schnitte f√ºhren oft zu Klassen, die alles wissen, aber nichts wirklich verantworten.",
                "Verantwortungsbasierter Zuschnitt erleichtert Wartung und Erweiterung."
              ]
            },
            {
              "type": "code",
              "title": "Schlechte Verantwortungszuordnung: God Class mischt Domain, DB und E-Mail",
              "language": "cpp",
              "code": "#include <string>\n\n// Problem: Eine Klasse tut alles.\n// - Regeln (validate)\n// - Daten speichern (save)\n// - Kommunikation (sendEmail)\n//\n// Folgen:\n// - √Ñnderungen an DB oder Mail √§ndern UserManager\n// - schwer testbar (IO √ºberall)\n// - schlecht erweiterbar\nclass UserManager {\npublic:\n    void validateUser();\n    void saveUser();\n    void sendEmail();\n};\n"
            },
            {
              "type": "code",
              "title": "Bessere Verantwortungsaufteilung: Domain, Repository, Service + Orchestrierung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n#include <string>\n\n// 1) Domain: Daten + Regeln\nclass User {\n    std::string name;\n    std::string email;\n\npublic:\n    User(std::string n, std::string e)\n        : name(std::move(n)), email(std::move(e)) {}\n\n    bool isValid() const {\n        // Domain-Regeln: sehr vereinfacht\n        return !name.empty() && email.find('@') != std::string::npos;\n    }\n\n    const std::string& getName() const { return name; }\n    const std::string& getEmail() const { return email; }\n};\n\n// 2) Persistenz: k√ºmmert sich nur um Speichern (DB Details hier nicht gezeigt)\nclass UserRepository {\npublic:\n    void save(const User& user) {\n        // hier w√§re z.B. SQLite insert\n        std::cout << \"[DB] speichere user: \" << user.getEmail() << '\\n';\n    }\n};\n\n// 3) Kommunikation: k√ºmmert sich nur um E-Mail\nclass EmailService {\npublic:\n    void sendWelcomeMail(const User& user) {\n        std::cout << \"[MAIL] Willkommen \" << user.getName()\n                  << \" an \" << user.getEmail() << '\\n';\n    }\n};\n\n// 4) Application Service (Use Case): koordiniert nur\n// Wichtig: Diese Klasse enth√§lt keine DB Logik und keine Mail Logik.\nclass UserRegistrationService {\n    UserRepository& repo;\n    EmailService& mail;\n\npublic:\n    UserRegistrationService(UserRepository& r, EmailService& m)\n        : repo(r), mail(m) {}\n\n    void registerUser(const User& user) {\n        // Orchestrierung: Reihenfolge + Ablauf\n        if (!user.isValid()) {\n            throw std::runtime_error(\"User ist ung√ºltig\");\n        }\n\n        repo.save(user);\n        mail.sendWelcomeMail(user);\n    }\n};\n\nint main() {\n    UserRepository repo;\n    EmailService mail;\n    UserRegistrationService registration(repo, mail);\n\n    User user(\"Kilian\", \"kilian@example.com\");\n    registration.registerUser(user);\n\n    // Ausgabe (Beispiel):\n    // [DB] speichere user: kilian@example.com\n    // [MAIL] Willkommen Kilian an kilian@example.com\n}\n"
            },
            {
              "type": "list",
              "title": "Typische Warnzeichen",
              "items": [
                "Klassen mit Namen wie Utils, Helper oder Manager",
                "Sehr viele Methoden mit v√∂llig unterschiedlichen Aufgaben",
                "Methoden greifen √ºberwiegend auf fremde Objekte zu",
                "H√§ufige √Ñnderungen an einer zentralen Klasse"
              ]
            },
            {
              "type": "comparison",
              "title": "Gute vs schlechte Verantwortungszuordnung",
              "columns": ["Gute Zuordnung", "Schlechte Zuordnung"],
              "rows": [
                {
                  "aspect": "Koh√§sion",
                  "values": ["Hoch", "Niedrig"]
                },
                {
                  "aspect": "Erweiterbarkeit",
                  "values": ["Lokal", "Global"]
                },
                {
                  "aspect": "Verst√§ndlichkeit",
                  "values": ["Klare Zust√§ndigkeiten", "Unklare Sammelklassen"]
                }
              ]
            },
            {
              "type": "important",
              "text": "Wenn du einer Klasse nicht in einem Satz erkl√§ren kannst, wof√ºr sie verantwortlich ist, ist sie wahrscheinlich falsch geschnitten."
            },
            {
              "type": "summary",
              "points": [
                "Responsibilities bewusst und fachlich zuordnen",
                "GRASP hilft bei der Entscheidungsfindung",
                "Methoden m√ºssen semantisch zur Klasse passen",
                "Nach Verantwortung schneiden, nicht nach Technik",
                "Utils und Manager sind meist Warnsignale"
              ]
            }
          ]
        },


        {
          "title": "Information Expert",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Information Expert",
              "text": "Information Expert ist ein GRASP Prinzip, bei dem die Verantwortung f√ºr eine Aufgabe der Klasse zugewiesen wird, die √ºber die meisten relevanten Informationen daf√ºr verf√ºgt."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Daten und das dazugeh√∂rige Verhalten sollen zusammenliegen.",
                "Eine Klasse, die die ben√∂tigten Informationen besitzt, kann Aufgaben selbstst√§ndig erf√ºllen.",
                "Dadurch werden Abh√§ngigkeiten reduziert und der Code bleibt koh√§rent."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum das Prinzip wichtig ist",
              "text": [
                "Externe Logik ben√∂tigt oft viele Getter, um an notwendige Daten zu kommen.",
                "Getter Orgie ist ein Hinweis auf falsch verteilte Verantwortlichkeiten.",
                "Information Expert verhindert anemische Dom√§nenmodelle."
              ]
            },
            {
              "type": "code",
              "title": "Schlechte Anwendung: Rechner zieht Infos von au√üen zusammen",
              "language": "cpp",
              "code": "#include <vector>\n\nclass LineItem {\n    double unitPrice;\n    int quantity;\n\npublic:\n    double getUnitPrice() const { return unitPrice; }\n    int getQuantity() const { return quantity; }\n};\n\nclass Order {\n    std::vector<LineItem> items;\n\npublic:\n    const std::vector<LineItem>& getItems() const { return items; }\n};\n\n// Problem:\n// PriceCalculator muss wissen, wie man aus LineItems die Summe baut.\n// Wenn sich die Preislogik √§ndert (Rabatt, Rundung, Steuer),\n// muss diese externe Klasse angepasst werden.\nclass PriceCalculator {\npublic:\n    double total(const Order& order) const {\n        double sum = 0.0;\n        for (const auto& item : order.getItems()) {\n            sum += item.getUnitPrice() * item.getQuantity();\n        }\n        return sum;\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Information Expert: LineItem berechnet Subtotal, Order berechnet Total",
              "language": "cpp",
              "code": "#include <vector>\n\nclass LineItem {\n    double unitPrice;\n    int quantity;\n\npublic:\n    LineItem(double price, int qty)\n        : unitPrice(price), quantity(qty) {}\n\n    // Information Expert:\n    // LineItem hat alle Infos, um seinen eigenen Teilbetrag zu berechnen.\n    double subtotal() const {\n        return unitPrice * quantity;\n    }\n};\n\nclass Order {\n    std::vector<LineItem> items;\n\npublic:\n    void addItem(double unitPrice, int quantity) {\n        items.emplace_back(unitPrice, quantity);\n    }\n\n    // Information Expert:\n    // Order hat die Items und kann daher den Gesamtpreis berechnen.\n    double total() const {\n        double sum = 0.0;\n        for (const auto& item : items) {\n            sum += item.subtotal();\n        }\n        return sum;\n    }\n};\n"
            },
            {
              "type": "explanation",
              "title": "Auswirkungen auf das Design",
              "text": [
                "Klassen werden selbstverantwortlich statt datenhaltend.",
                "Logik bleibt nahe an den Daten, die sie ben√∂tigt.",
                "√Ñnderungen betreffen weniger Klassen gleichzeitig."
              ]
            },
            {
              "type": "list",
              "title": "Typische Anwendungsf√§lle",
              "items": [
                "Berechnungen auf eigenen Attributen",
                "Validierungen interner Zust√§nde",
                "Ableitung von Zust√§nden oder Statuswerten",
                "Dom√§nenlogik in Fachobjekten"
              ]
            },
            {
              "type": "comparison",
              "title": "Information Expert vs externer Rechner",
              "columns": ["Information Expert", "Externe Logik"],
              "rows": [
                {
                  "aspect": "Datenzugriff",
                  "values": ["Direkt intern", "√úber viele Getter"]
                },
                {
                  "aspect": "Kopplung",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "√Ñnderungsaufwand",
                  "values": ["Lokal", "√úber mehrere Klassen"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Logik im falschen Objekt",
              "text": "Wenn Berechnungen oder Regeln in Klassen landen, die die zugrunde liegenden Daten nicht besitzen, entsteht unn√∂tige Kopplung und schlechtere Wartbarkeit."
            },
            {
              "type": "important",
              "text": "Information Expert bedeutet nicht, dass jede Klasse alles selbst macht. Wenn Daten verteilt sind, kann ein Koordinator sinnvoll sein."
            },
            {
              "type": "summary",
              "points": [
                "Verantwortung zur Klasse mit den meisten relevanten Informationen",
                "Daten und Verhalten geh√∂ren zusammen",
                "Vermeidet Getter Orgie",
                "St√§rkt Dom√§nenlogik in Fachklassen",
                "Logik im falschen Objekt ist ein klares Warnsignal"
              ]
            }
          ]
        },


        {
          "title": "Low Coupling",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Low Coupling",
              "text": "Low Coupling beschreibt das Ziel, Klassen so zu entwerfen, dass sie m√∂glichst wenig √ºber andere Klassen wissen und nur minimale, stabile Abh√§ngigkeiten besitzen."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Je weniger Abh√§ngigkeiten eine Klasse hat, desto einfacher ist sie zu √§ndern.",
                "Geringe Kopplung reduziert Kettenreaktionen bei Anpassungen.",
                "Klassen sollen nur das wissen, was sie wirklich brauchen."
              ]
            },
            {
              "type": "explanation",
              "title": "Abh√§ngigkeiten richtig gestalten",
              "text": [
                "Abh√§ngigkeiten sollten √ºber Interfaces oder abstrakte Basistypen erfolgen.",
                "Konkrete Implementierungen werden idealerweise von au√üen injiziert.",
                "So bleibt der Code offen f√ºr Erweiterung, aber stabil bei √Ñnderungen."
              ]
            },
            {
              "type": "explanation",
              "title": "Header Abh√§ngigkeiten reduzieren",
              "text": [
                "Jeder Include im Header erh√∂ht die Kopplung und die Compile Zeit.",
                "Vorw√§rtsdeklarationen reichen oft aus.",
                "Includes geh√∂ren m√∂glichst in die cpp Datei."
              ]
            },
            {
              "type": "code",
              "title": "Low Coupling verletzt: Service h√§ngt direkt von FileLogger Details ab",
              "language": "cpp",
              "code": "#include <string>\n#include \"FileLogger.hpp\" // harter Include: Service kennt das Detail\n\n// Problem:\n// - Service ist an FileLogger gebunden (Detail)\n// - FileLogger braucht evtl. Dateipfad, IO, Format usw.\n// - Austausch (ConsoleLogger, TestLogger) bedeutet Code √§ndern\nclass Service {\n    FileLogger logger; // konkrete Abh√§ngigkeit\n\npublic:\n    explicit Service(const std::string& path)\n        : logger(path) {}\n\n    void run() {\n        logger.log(\"Service startet\");\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Low Coupling: Service h√§ngt nur von ILogger ab (Constructor Injection)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n#include <string>\n\n// Abstraktion: Service kennt nur das\nstruct ILogger {\n    virtual ~ILogger() = default;\n    virtual void log(const std::string& msg) = 0;\n};\n\n// Konkrete Details: austauschbar\nclass ConsoleLogger : public ILogger {\npublic:\n    void log(const std::string& msg) override {\n        std::cout << \"[console] \" << msg << '\\n';\n    }\n};\n\nclass Service {\n    ILogger& logger; // keine Ownership-Frage, kein nullptr\n\npublic:\n    explicit Service(ILogger& l) : logger(l) {}\n\n    void run() {\n        logger.log(\"Service startet\");\n        logger.log(\"Service arbeitet\");\n    }\n};\n\nint main() {\n    ConsoleLogger logger;\n    Service s(logger); // Abh√§ngigkeit von au√üen rein\n    s.run();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Auswirkungen auf Wartbarkeit",
              "text": [
                "√Ñnderungen an einer Klasse erzwingen weniger Rebuilds.",
                "Klassen lassen sich isoliert testen.",
                "Architekturen bleiben l√§nger stabil."
              ]
            },
            {
              "type": "comparison",
              "title": "Low Coupling vs High Coupling",
              "columns": ["Low Coupling", "High Coupling"],
              "rows": [
                {
                  "aspect": "√Ñnderungsfolgen",
                  "values": ["Lokal begrenzt", "Weitreichend"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Einfach", "Schwierig"]
                },
                {
                  "aspect": "Flexibilit√§t",
                  "values": ["Hoch", "Gering"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Harte Abh√§ngigkeiten",
              "text": "Direkte Abh√§ngigkeiten von konkreten Typen zementieren die Architektur. Jede √Ñnderung zwingt zur Anpassung vieler Stellen."
            },
            {
              "type": "important",
              "text": "Low Coupling bedeutet nicht keine Abh√§ngigkeiten. Es geht um wenige, stabile und bewusst gew√§hlte Abh√§ngigkeiten."
            },
            {
              "type": "summary",
              "points": [
                "Klassen wissen so wenig wie m√∂glich voneinander",
                "Abh√§ngigkeiten √ºber Interfaces statt konkrete Typen",
                "Includes im Header minimieren",
                "Bessere Testbarkeit und Wartbarkeit",
                "Harte Abh√§ngigkeiten sind ein zentrales Warnsignal"
              ]
            }
          ]
        },

        {
          "title": "High Cohesion",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "High Cohesion",
              "text": "High Cohesion beschreibt das Ziel, dass eine Klasse eine klar abgegrenzte Aufgabe hat und ihre Methoden inhaltlich eng zusammengeh√∂ren."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Eine Klasse sollte eine Sache gut machen, nicht viele Dinge halb.",
                "Methoden einer koh√§siven Klasse arbeiten auf denselben oder eng verwandten Daten.",
                "Hohe Koh√§sion verbessert Verst√§ndlichkeit und Wartbarkeit."
              ]
            },
            {
              "type": "explanation",
              "title": "Zusammenhang von Methoden und Daten",
              "text": [
                "Wenn Methoden √ºberwiegend dieselben Member nutzen, ist das ein gutes Zeichen.",
                "Methoden, die nichts miteinander zu tun haben, geh√∂ren meist nicht in dieselbe Klasse.",
                "Getrennte Verantwortlichkeiten f√ºhren zu klareren Klassen."
              ]
            },
            {
              "type": "explanation",
              "title": "Lange Klassen als Warnsignal",
              "text": [
                "Sehr lange Klassen erf√ºllen oft mehrere unterschiedliche Aufgaben.",
                "Viele private Helfermethoden deuten auf versteckte Verantwortlichkeiten hin.",
                "Solche Klassen lassen sich meist sinnvoll zerlegen."
              ]
            },
            {
              "type": "code",
              "title": "Niedrige Koh√§sion: Utils mischt unzusammenh√§ngende Aufgaben",
              "language": "cpp",
              "code": "#include <string>\n\n// Problem:\n// - Methoden haben nichts miteinander zu tun\n// - keine gemeinsame Datenbasis\n// - Klasse wird zum M√ºllplatz f√ºr \"irgendwas\"\n// - √Ñnderungen √ºberall: Logging, Datei, Checksummen\nclass Utils {\npublic:\n    void log(const std::string& msg);\n    int calculateChecksum(const std::string& data);\n    void saveToFile(const std::string& path, const std::string& data);\n};\n"
            },
            {
              "type": "code",
              "title": "Hohe Koh√§sion: Klasse hat einen klaren Fokus und gemeinsame Daten",
              "language": "cpp",
              "code": "#include <fstream>\n#include <stdexcept>\n#include <string>\n\n// Diese Klasse hat genau einen Zweck: Text in eine bestimmte Datei schreiben.\n// Alle Methoden arbeiten auf demselben Zustand: path.\nclass FileWriter {\n    std::string path;\n\npublic:\n    explicit FileWriter(std::string p)\n        : path(std::move(p)) {}\n\n    // Schreibt den gesamten Inhalt neu\n    void write(const std::string& data) const {\n        std::ofstream out(path, std::ios::trunc);\n        if (!out.is_open()) {\n            throw std::runtime_error(\"Datei konnte nicht ge√∂ffnet werden\");\n        }\n        out << data;\n    }\n\n    // H√§ngt Text an bestehende Datei an\n    void append(const std::string& data) const {\n        std::ofstream out(path, std::ios::app);\n        if (!out.is_open()) {\n            throw std::runtime_error(\"Datei konnte nicht ge√∂ffnet werden\");\n        }\n        out << data;\n    }\n\n    // Hilfsfunktion, die zum Thema passt: liefert den Pfad\n    const std::string& getPath() const {\n        return path;\n    }\n};\n"
            },
            {
              "type": "list",
              "title": "Typische Warnzeichen",
              "items": [
                "Klassen mit sehr vielen, thematisch unterschiedlichen Methoden",
                "Methoden nutzen kaum gemeinsame Member",
                "Namen wie Utils, Helper oder Common",
                "H√§ufige √Ñnderungen aus unterschiedlichen Gr√ºnden"
              ]
            },
            {
              "type": "comparison",
              "title": "High vs Low Cohesion",
              "columns": ["High Cohesion", "Low Cohesion"],
              "rows": [
                {
                  "aspect": "Verantwortung",
                  "values": ["Klar abgegrenzt", "Diffus"]
                },
                {
                  "aspect": "Wartbarkeit",
                  "values": ["Hoch", "Niedrig"]
                },
                {
                  "aspect": "Erweiterbarkeit",
                  "values": ["Gezielt", "Unkontrolliert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Sammelklassen",
              "text": "Klassen, die f√ºr alles zust√§ndig sind, verlieren schnell ihre innere Struktur. Sie werden schwer verst√§ndlich und bremsen jede Weiterentwicklung."
            },
            {
              "type": "important",
              "text": "Hohe Koh√§sion und Low Coupling verst√§rken sich gegenseitig. Eine gute Klasse erf√ºllt meist beide Prinzipien gleichzeitig."
            },
            {
              "type": "summary",
              "points": [
                "Eine Klasse macht eine Sache gut",
                "Methoden arbeiten auf gemeinsamen Daten",
                "Lange Klassen sind oft niedrig koh√§siv",
                "Sammelklassen sind ein Warnsignal",
                "High Cohesion ist zentral f√ºr sauberes Design"
              ]
            }
          ]
        },


        {
          "title": "Pure Fabrication",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Pure Fabrication",
              "text": "Pure Fabrication ist ein GRASP Prinzip, bei dem k√ºnstliche Klassen eingef√ºhrt werden, um Verantwortung sinnvoll zu verteilen und Kopplung zu reduzieren, obwohl sie kein direktes Fachkonzept repr√§sentieren."
            },
            {
              "type": "explanation",
              "title": "Warum k√ºnstliche Klassen sinnvoll sind",
              "text": [
                "Nicht jede Verantwortung passt sauber in ein Fachobjekt.",
                "Technische Aufgaben w√ºrden Fachklassen √ºberladen.",
                "Pure Fabrication schafft saubere Trennung zwischen Dom√§ne und Technik."
              ]
            },
            {
              "type": "explanation",
              "title": "Trennung von Fachlogik und Technik",
              "text": [
                "Fachklassen enthalten Gesch√§ftsregeln und Zust√§nde.",
                "Technische Details werden in separate Klassen ausgelagert.",
                "Dadurch bleiben Fachmodelle verst√§ndlich und testbar."
              ]
            },
            {
              "type": "code",
              "title": "Ohne Pure Fabrication: Domain Objekt kennt Datenbank Details",
              "language": "cpp",
              "code": "#include <string>\n\n// Problem:\n// - Patient (Domain) kennt SQL/DB (Technik)\n// - Bei DB Wechsel oder Schema √Ñnderung muss Domain ge√§ndert werden\n// - Testen wird schwer (IO h√§ngt an Domain)\nclass Patient {\n    int id;\n    std::string name;\n\npublic:\n    bool isValid() const {\n        return !name.empty();\n    }\n\n    void saveToDatabase();     // Technik in Domain\n    void loadFromDatabase();   // Technik in Domain\n};\n"
            },
            {
              "type": "code",
              "title": "Pure Fabrication: Repository kapselt Persistenz, Domain bleibt IO frei",
              "language": "cpp",
              "code": "#include <optional>\n#include <string>\n\n// 1) Domain Objekt: nur Daten + Regeln\nclass Patient {\n    int id;\n    std::string name;\n\npublic:\n    Patient(int i, std::string n)\n        : id(i), name(std::move(n)) {}\n\n    bool isValid() const {\n        return !name.empty();\n    }\n\n    int getId() const { return id; }\n    const std::string& getName() const { return name; }\n};\n\n// 2) Pure Fabrication: technische Klasse, nicht Teil der Fachdom√§ne\n// Sie existiert nur, um Kopplung zu reduzieren und Koh√§sion zu erh√∂hen.\nclass PatientRepository {\npublic:\n    void save(const Patient& patient) {\n        // hier w√§re DB Code (SQLite prepare/bind/step)\n        // Domain bleibt davon komplett unber√ºhrt\n    }\n\n    std::optional<Patient> findById(int id) {\n        // hier w√§re DB Code\n        // optional: kein Patient gefunden\n        return std::nullopt;\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "Pure Fabrication (Erweiterung): Mapper trennt DB Darstellung von Domain",
              "language": "cpp",
              "code": "#include <string>\n\n// Technische Darstellung einer DB Zeile (vereinfacht)\nstruct PatientRow {\n    int id;\n    std::string name;\n};\n\n// Pure Fabrication: √ºbersetzt technische DB Struktur in Domain Objekt\nclass PatientMapper {\npublic:\n    Patient toDomain(const PatientRow& row) const {\n        return Patient(row.id, row.name);\n    }\n};\n"
            },
            {
              "type": "list",
              "title": "Typische Beispiele",
              "items": [
                "Repository Klassen f√ºr Persistenz",
                "Service Klassen f√ºr Anwendungslogik",
                "Adapter und Mapper",
                "Gateways zu externen Systemen"
              ]
            },
            {
              "type": "explanation",
              "title": "Abgrenzung zu Information Expert",
              "text": [
                "Information Expert platziert Logik bei den Daten.",
                "Pure Fabrication lagert technische oder koordinierende Aufgaben aus.",
                "Beide Prinzipien erg√§nzen sich, statt sich zu widersprechen."
              ]
            },
            {
              "type": "comparison",
              "title": "Pure Fabrication vs Fachklasse",
              "columns": ["Pure Fabrication", "Fachklasse"],
              "rows": [
                {
                  "aspect": "Bezug zur Dom√§ne",
                  "values": ["Kein direktes Fachkonzept", "Klares Fachkonzept"]
                },
                {
                  "aspect": "Verantwortung",
                  "values": ["Technisch oder koordinierend", "Gesch√§ftslogik"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Oft gut isolierbar", "Abh√§ngig von Technik"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zu viele Abstraktionen",
              "text": "Wenn f√ºr jede Kleinigkeit eine neue Service oder Repository Klasse entsteht, wird das System unn√∂tig komplex. Pure Fabrication darf Struktur schaffen, nicht aufblasen."
            },
            {
              "type": "important",
              "text": "Pure Fabrication ist ein Mittel zur Strukturierung, kein Selbstzweck. Jede k√ºnstliche Klasse braucht eine klare Verantwortung."
            },
            {
              "type": "summary",
              "points": [
                "K√ºnstliche Klassen zur besseren Strukturierung",
                "Trennung von Fachlogik und Technik",
                "Typische Beispiele sind Repository und Service",
                "Erg√§nzt Information Expert sinnvoll",
                "Zu viele leere Abstraktionen vermeiden"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "SOLID und Prinzipien",
        "icon": "üìè",
        "topics": [
        {
          "title": "Single Responsibility Principle",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Single Responsibility Principle",
              "text": "Das Single Responsibility Principle besagt, dass eine Klasse genau einen Grund zur √Ñnderung haben sollte, also f√ºr genau eine fachliche Verantwortung zust√§ndig ist."
            },
            {
              "type": "explanation",
              "title": "Was SRP wirklich meint",
              "text": [
                "SRP bezieht sich auf Gr√ºnde f√ºr √Ñnderungen, nicht auf die Anzahl der Methoden.",
                "Eine Klasse darf viele Methoden haben, solange sie alle demselben Zweck dienen.",
                "Unterschiedliche √Ñnderungsgr√ºnde deuten auf mehrere Verantwortlichkeiten hin."
              ]
            },
            {
              "type": "explanation",
              "title": "Fachliche Verantwortung im Fokus",
              "text": [
                "Verantwortlichkeiten sollten aus der Dom√§ne ableitbar sein.",
                "Technische und fachliche Gr√ºnde zur √Ñnderung sollten getrennt werden.",
                "SRP unterst√ºtzt stabile und verst√§ndliche Klassen."
              ]
            },
            {
              "type": "code",
              "title": "SRP verletzt: Eine Klasse, mehrere √Ñnderungsgr√ºnde",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\n// Diese Klasse hat MEHRERE Verantwortlichkeiten:\n// 1) Fachliche Logik (Report erstellen)\n// 2) Darstellung (Drucken)\n// 3) Persistenz (Speichern)\n//\n// √Ñnderungen an Ausgabeformat, Speicherort oder Fachlogik\n// f√ºhren ALLE zu √Ñnderungen an dieser einen Klasse.\nclass Report {\npublic:\n    void generate() {\n        std::cout << \"Report wird generiert\" << '\\n';\n    }\n\n    void print() {\n        std::cout << \"Report wird gedruckt\" << '\\n';\n    }\n\n    void saveToFile(const std::string& path) {\n        std::cout << \"Report wird gespeichert nach: \" << path << '\\n';\n    }\n};\n"
            },
            {
              "type": "code",
              "title": "SRP eingehalten: Eine Verantwortung pro Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\n// 1) Fachliche Verantwortung: Report erzeugen\nclass Report {\npublic:\n    void generate() {\n        std::cout << \"Report wird generiert\" << '\\n';\n    }\n};\n\n// 2) Verantwortung: Darstellung / Ausgabe\nclass ReportPrinter {\npublic:\n    void print(const Report& report) {\n        std::cout << \"Report wird gedruckt\" << '\\n';\n    }\n};\n\n// 3) Verantwortung: Persistenz / Speicherung\nclass ReportRepository {\npublic:\n    void save(const Report& report, const std::string& path) {\n        std::cout << \"Report wird gespeichert nach: \" << path << '\\n';\n    }\n};\n\nint main() {\n    Report report;\n    report.generate();\n\n    ReportPrinter printer;\n    printer.print(report);\n\n    ReportRepository repo;\n    repo.save(report, \"report.txt\");\n}\n"
            },
            {
              "type": "explanation",
              "title": "√Ñnderungsgr√ºnde erkennen",
              "text": [
                "Frage: Wer fordert diese √Ñnderung und warum",
                "Wenn verschiedene Stakeholder unterschiedliche √Ñnderungen ausl√∂sen, ist SRP verletzt.",
                "SRP hilft, Auswirkungen von √Ñnderungen klein zu halten."
              ]
            },
            {
              "type": "comparison",
              "title": "SRP korrekt vs falsch verstanden",
              "columns": ["SRP korrekt", "SRP falsch verstanden"],
              "rows": [
                {
                  "aspect": "Kriterium",
                  "values": ["√Ñnderungsgrund", "Methodenanzahl"]
                },
                {
                  "aspect": "Ziel",
                  "values": ["Stabile Verantwortung", "Kleine Klassen um jeden Preis"]
                },
                {
                  "aspect": "Ergebnis",
                  "values": ["Wartbarer Code", "Zersplittertes Design"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Eine Methode pro Klasse",
              "text": "SRP bedeutet nicht, dass jede Klasse nur eine Methode haben darf. Diese Fehlinterpretation f√ºhrt zu unn√∂tig vielen Klassen ohne echten Mehrwert."
            },
            {
              "type": "important",
              "text": "Wenn du eine Klasse aus mehreren fachlichen Gr√ºnden √§ndern m√ºsstest, verletzt sie sehr wahrscheinlich das SRP."
            },
            {
              "type": "summary",
              "points": [
                "Eine Klasse hat genau einen Grund zur √Ñnderung",
                "SRP bezieht sich auf Verantwortung, nicht auf Methodenanzahl",
                "Fachliche Gr√ºnde sind entscheidend",
                "Technik und Fachlogik sauber trennen",
                "SRP nicht mit Mini Klassen verwechseln"
              ]
            }
          ]
        },


        {
          "title": "Dependency Inversion Principle",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Dependency Inversion Principle",
              "text": "Das Dependency Inversion Principle besagt, dass High Level Module nicht von Low Level Modulen abh√§ngen sollen, sondern beide von Abstraktionen."
            },
            {
              "type": "explanation",
              "title": "Kernidee",
              "text": [
                "Gesch√§ftslogik darf keine konkreten Implementierungsdetails kennen.",
                "Details wie Datenbanken, Dateien oder Netzwerke h√§ngen von Interfaces ab.",
                "Abh√§ngigkeiten zeigen nach innen zur Abstraktion, nicht nach au√üen zu Details."
              ]
            },
            {
              "type": "explanation",
              "title": "High Level vs Low Level",
              "text": [
                "High Level Code beschreibt, was das System tut.",
                "Low Level Code beschreibt, wie es technisch umgesetzt wird.",
                "DIP entkoppelt diese Ebenen sauber."
              ]
            },
            {
              "type": "code",
              "title": "DIP verletzt: Service h√§ngt direkt von konkreten Details ab",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\n// Detail: konkrete Implementierung\nclass FileLogger {\npublic:\n    void log(const std::string& msg) {\n        // Stell dir vor: schreibt in eine Datei\n        std::cout << \"[file] \" << msg << '\\n';\n    }\n};\n\n// High-Level: Business-Logik\n// Problem: Service ist fest an FileLogger gekoppelt.\n// - Keine Alternative (Console, Netzwerk, Test)\n// - Schwer testbar (echte Datei / echtes IO)\nclass OrderService {\n    FileLogger logger; // direkte Abh√§ngigkeit auf Detail\n\npublic:\n    void createOrder() {\n        // Business-Logik ...\n        logger.log(\"Order erstellt\");\n    }\n};\n"
            },
            {
              "type": "explanation",
              "title": "Konstruktor Injection",
              "text": [
                "Abh√§ngigkeiten werden von au√üen √ºber den Konstruktor √ºbergeben.",
                "Der Code enth√§lt kein new und entscheidet nicht √ºber konkrete Typen.",
                "Tests k√∂nnen einfache Mocks oder Stubs verwenden."
              ]
            },
            {
              "type": "code",
              "title": "DIP korrekt: Service h√§ngt von einer Abstraktion ab (Constructor Injection)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n// 1) Abstraktion: High-Level Code kennt nur dieses Interface\nstruct ILogger {\n    virtual ~ILogger() = default;\n    virtual void log(const std::string& msg) = 0;\n};\n\n// 2) Details: konkrete Implementierungen h√§ngen von der Abstraktion ab\nclass ConsoleLogger : public ILogger {\npublic:\n    void log(const std::string& msg) override {\n        std::cout << \"[console] \" << msg << '\\n';\n    }\n};\n\nclass FileLogger : public ILogger {\npublic:\n    void log(const std::string& msg) override {\n        // Stell dir vor: schreibt in eine Datei\n        std::cout << \"[file] \" << msg << '\\n';\n    }\n};\n\n// 3) High-Level Modul: Business-Logik\n// H√§ngt nur von ILogger ab, nicht von ConsoleLogger/FileLogger.\nclass OrderService {\n    ILogger& logger; // Abh√§ngigkeit auf Abstraktion\n\npublic:\n    explicit OrderService(ILogger& l) : logger(l) {}\n\n    void createOrder() {\n        // Business-Logik ...\n        logger.log(\"Order erstellt\");\n    }\n};\n\n// 4) Test-Double: Fake Logger f√ºr Tests (kein IO)\nclass FakeLogger : public ILogger {\npublic:\n    std::vector<std::string> messages;\n\n    void log(const std::string& msg) override {\n        messages.push_back(msg);\n    }\n};\n\nint main() {\n    // \"Composition Root\": Hier wird entschieden, welche Details benutzt werden.\n    ConsoleLogger console;\n    OrderService service(console);\n    service.createOrder();\n\n    // Test-Szenario: Service bleibt unver√§ndert, nur Logger wird ersetzt\n    FakeLogger fake;\n    OrderService testService(fake);\n    testService.createOrder();\n\n    // Im Test k√∂nntest du jetzt pr√ºfen:\n    // fake.messages[0] == \"Order erstellt\"\n    std::cout << \"FakeLogger hat \" << fake.messages.size() << \" Nachricht(en)\" << '\\n';\n}\n"
            },
            {
              "type": "comparison",
              "title": "Dependency Inversion vs direkte Abh√§ngigkeit",
              "columns": ["DIP", "Direkte Abh√§ngigkeit"],
              "rows": [
                {
                  "aspect": "Kopplung",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Einfach", "Schwierig"]
                },
                {
                  "aspect": "Austauschbarkeit",
                  "values": ["Hoch", "Gering"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Interfaces ohne Nutzen",
              "text": "Interfaces nur f√ºr die Form einzuf√ºhren bringt keinen Mehrwert. Wenn es keine echten Varianten gibt oder geben wird, ist DIP oft unn√∂tig."
            },
            {
              "type": "important",
              "text": "DIP ist ein Werkzeug zur Entkopplung, kein Dogma. Es lohnt sich dort, wo sich Details √§ndern oder austauschen lassen."
            },
            {
              "type": "summary",
              "points": [
                "Abh√§ngigkeiten auf Abstraktionen statt konkrete Typen",
                "High Level Code kennt keine Details",
                "Konstruktor Injection statt new im Code",
                "Verbessert Testbarkeit und Erweiterbarkeit",
                "Interfaces ohne echten Nutzen vermeiden"
              ]
            }
          ]
        },


        {
          "title": "Composition over Inheritance",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Composition over Inheritance",
              "text": "Composition over Inheritance bedeutet, Verhalten durch das Kombinieren von Objekten zu erweitern, statt es √ºber Vererbung zu erzwingen."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Verhalten wird √ºber enthaltene Objekte zusammengesetzt.",
                "Klassen nutzen andere Klassen, statt von ihnen zu erben.",
                "Erweiterungen bleiben flexibel und lokal."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum Komposition oft besser ist",
              "text": [
                "Vererbung koppelt stark an eine Basisklasse.",
                "√Ñnderungen an der Basisklasse wirken sich auf alle Ableitungen aus.",
                "Komposition erlaubt es, Verhalten zur Laufzeit auszutauschen."
              ]
            },
            {
              "type": "code",
              "title": "Problem: Vererbung skaliert schlecht bei kombinierbaren Features",
              "language": "cpp",
              "code": "#include <string>\n\n// Du willst Logging mit Features wie:\n// - Ausgabe: Konsole oder Datei\n// - Extras: Timestamp, Level, Prefix, Filter\n//\n// Mit Vererbung brauchst du f√ºr jede Kombination eine eigene Klasse:\n// ConsoleLogger\n// FileLogger\n// TimestampConsoleLogger\n// TimestampFileLogger\n// LevelTimestampFileLogger\n// PrefixLevelTimestampFileLogger\n// ... Klassenexplosion\n\nstruct Logger {\n    virtual ~Logger() = default;\n    virtual void log(const std::string& msg) = 0;\n};\n\nstruct ConsoleLogger : Logger {\n    void log(const std::string& msg) override;\n};\n\nstruct FileLogger : Logger {\n    void log(const std::string& msg) override;\n};\n\n// Jetzt willst du Timestamp + File ‚Üí neue Klasse n√∂tig\nstruct TimestampFileLogger : FileLogger {\n    void log(const std::string& msg) override;\n};\n\n// Willst du zus√§tzlich Level + Timestamp + File ‚Üí nochmal eine neue Klasse\nstruct LevelTimestampFileLogger : FileLogger {\n    void log(const std::string& msg) override;\n};\n"
            },
            {
              "type": "code",
              "title": "Komposition: Logger Features frei kombinieren (Decorator √ºber Komposition)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n#include <string>\n\n// 1) Gemeinsames Interface\nstruct ILogger {\n    virtual ~ILogger() = default;\n    virtual void log(const std::string& msg) = 0;\n};\n\n// 2) Konkrete \"Basis\" Logger (machen nur eine Sache)\nclass ConsoleLogger : public ILogger {\npublic:\n    void log(const std::string& msg) override {\n        std::cout << msg << '\\n';\n    }\n};\n\n// 3) Decorator Basisklasse\n// H√§lt einen anderen Logger \"inner\" und delegiert.\nclass LoggerDecorator : public ILogger {\nprotected:\n    std::unique_ptr<ILogger> inner;\n\npublic:\n    explicit LoggerDecorator(std::unique_ptr<ILogger> l)\n        : inner(std::move(l)) {}\n};\n\n// 4) Feature: Prefix\nclass PrefixLogger : public LoggerDecorator {\n    std::string prefix;\n\npublic:\n    PrefixLogger(std::unique_ptr<ILogger> l, std::string p)\n        : LoggerDecorator(std::move(l)), prefix(std::move(p)) {}\n\n    void log(const std::string& msg) override {\n        // erweitert Nachricht, delegiert dann\n        inner->log(prefix + msg);\n    }\n};\n\n// 5) Feature: \"Level\" (vereinfacht)\nclass LevelLogger : public LoggerDecorator {\npublic:\n    using LoggerDecorator::LoggerDecorator;\n\n    void log(const std::string& msg) override {\n        // In echt w√ºrdest du hier ein enum LogLevel haben.\n        inner->log(\"[INFO] \" + msg);\n    }\n};\n\n// 6) Feature: Timestamp (vereinfacht)\nclass TimestampLogger : public LoggerDecorator {\npublic:\n    using LoggerDecorator::LoggerDecorator;\n\n    void log(const std::string& msg) override {\n        // F√ºr ein Lernbeispiel reicht ein Platzhalter.\n        // In echt: std::chrono und formatieren.\n        inner->log(\"[ts] \" + msg);\n    }\n};\n\nint main() {\n    // Basis: schreibt nur zur Konsole\n    std::unique_ptr<ILogger> logger = std::make_unique<ConsoleLogger>();\n\n    // Jetzt bauen wir die Features per Komposition zusammen.\n    // Reihenfolge ist sichtbar und bewusst:\n    // Erst Prefix, dann Level, dann Timestamp (oder andersherum, je nachdem was du willst).\n    logger = std::make_unique<PrefixLogger>(std::move(logger), \"[App] \");\n    logger = std::make_unique<LevelLogger>(std::move(logger));\n    logger = std::make_unique<TimestampLogger>(std::move(logger));\n\n    // Ergebnis: frei kombinierbar, ohne neue Klassen pro Kombination.\n    logger->log(\"Start\");\n\n    // Typische Ausgabe:\n    // [ts] [INFO] [App] Start\n}\n"
            },
            {
              "type": "explanation",
              "title": "Echte is a Beziehung",
              "text": [
                "Vererbung ist sinnvoll, wenn eine echte is a Beziehung besteht.",
                "Die abgeleitete Klasse muss √ºberall einsetzbar sein, wo die Basisklasse erwartet wird.",
                "Wenn diese Bedingung nicht klar erf√ºllt ist, ist Komposition meist die bessere Wahl."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzf√§lle f√ºr Komposition",
              "items": [
                "Erweiterbares Verhalten",
                "Optionale Features",
                "Kombination mehrerer Verantwortlichkeiten",
                "Austauschbare Implementierungen"
              ]
            },
            {
              "type": "comparison",
              "title": "Komposition vs Vererbung",
              "columns": ["Komposition", "Vererbung"],
              "rows": [
                {
                  "aspect": "Flexibilit√§t",
                  "values": ["Hoch", "Gering"]
                },
                {
                  "aspect": "Kopplung",
                  "values": ["Locker", "Stark"]
                },
                {
                  "aspect": "Erweiterbarkeit",
                  "values": ["Zur Laufzeit m√∂glich", "Zur Compile Zeit fest"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Tiefe Vererbungshierarchien",
              "text": "Viele Vererbungsebenen f√ºhren zu schwer verst√§ndlichem Code, versteckten Abh√§ngigkeiten und fragilem Design. Kleine √Ñnderungen haben oft gro√üe Auswirkungen."
            },
            {
              "type": "important",
              "text": "Vererbung ist kein Standardwerkzeug zur Wiederverwendung von Code. Bevorzuge Komposition, au√üer eine klare is a Beziehung ist gegeben."
            },
            {
              "type": "summary",
              "points": [
                "Verhalten kombinieren statt vererben",
                "Komposition erm√∂glicht flexible Erweiterung",
                "Vererbung nur bei echter is a Beziehung",
                "Tiefe Hierarchien vermeiden",
                "Robusteres Design durch geringe Kopplung"
              ]
            }
          ]
        },


        {
          "title": "Separation of Concerns",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Separation of Concerns",
              "text": "Separation of Concerns bedeutet, dass unterschiedliche Aufgabenbereiche klar voneinander getrennt werden, sodass jede Schicht einen klaren und abgegrenzten Fokus besitzt."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Jede Schicht ist f√ºr genau eine Art von Aufgabe zust√§ndig.",
                "Fachlogik darf nicht von Ein und Ausgabe abh√§ngen.",
                "Trennung reduziert Komplexit√§t und Seiteneffekte."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Schichten",
              "text": [
                "Domain: Enth√§lt Fachlogik und Regeln.",
                "Application: Koordiniert Abl√§ufe und Use Cases.",
                "Infrastructure: K√ºmmert sich um Datenbanken, Dateien und externe Systeme.",
                "Presentation: UI, CLI oder API Schicht."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum √Ñnderungen lokal bleiben",
              "text": [
                "√Ñnderungen an der Datenbank betreffen nur die Infrastruktur.",
                "UI √Ñnderungen wirken sich nicht auf die Fachlogik aus.",
                "Klare Grenzen verhindern Kettenreaktionen."
              ]
            },
            {
              "type": "code",
              "title": "SoC verletzt: Domain, Datenbank und Ausgabe vermischt",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n// Problem: Diese Klasse mischt mehrere Concerns (Belange):\n// - Domain: Order Daten + Gesamtpreis\n// - Persistenz: SQL/DB Zugriff\n// - Pr√§sentation: Console-Ausgabe\n//\n// Folge:\n// - √Ñnderungen an SQL/DB √§ndern Domain-Code\n// - √Ñnderungen an Ausgabeformat √§ndern Domain-Code\n// - Testing wird schwer (IO √ºberall)\nclass Order {\npublic:\n    void addItem(double price) {\n        prices.push_back(price);\n    }\n\n    double totalPrice() const {\n        double sum = 0.0;\n        for (double p : prices) {\n            sum += p;\n        }\n        return sum;\n    }\n\n    void saveToDatabase() {\n        // Vermischung: Domain kennt SQL\n        std::cout << \"INSERT INTO orders(total) VALUES(\" << totalPrice() << \");\" << '\\n';\n    }\n\n    void printToConsole() const {\n        // Vermischung: Domain macht UI\n        std::cout << \"Order total: \" << totalPrice() << \" EUR\" << '\\n';\n    }\n\nprivate:\n    std::vector<double> prices;\n};\n"
            },
            {
              "type": "code",
              "title": "SoC eingehalten: Domain getrennt von Persistenz und Darstellung (Schichten)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n// 1) Domain Layer: Nur Fachlogik und Daten\n// Keine SQL Strings, kein std::cout, keine Datei-IO.\nclass Order {\npublic:\n    void addItem(double price) {\n        prices.push_back(price);\n    }\n\n    double totalPrice() const {\n        double sum = 0.0;\n        for (double p : prices) {\n            sum += p;\n        }\n        return sum;\n    }\n\nprivate:\n    std::vector<double> prices;\n};\n\n// 2) Persistenz Layer: k√ºmmert sich um Speichern (hier als Demo nur Text)\nclass OrderRepository {\npublic:\n    void save(const Order& order) {\n        // Hier w√§re echte DB Logik (SQLite prepare/bind/step)\n        // Domain bleibt davon unber√ºhrt.\n        std::cout << \"[DB] Speichere Order mit total=\" << order.totalPrice() << '\\n';\n    }\n};\n\n// 3) Pr√§sentation Layer: k√ºmmert sich um Ausgabe/Rendering\nclass OrderView {\npublic:\n    void render(const Order& order) const {\n        std::cout << \"Order total: \" << order.totalPrice() << \" EUR\" << '\\n';\n    }\n};\n\n// 4) Application Layer: Orchestrierung (wer ruft was wann auf)\n// Auch hier: keine Fachlogik, nur Ablauf.\nclass OrderService {\n    OrderRepository& repo;\n\npublic:\n    explicit OrderService(OrderRepository& r) : repo(r) {}\n\n    void checkout(const Order& order) {\n        repo.save(order);\n    }\n};\n\nint main() {\n    Order order;\n    order.addItem(9.99);\n    order.addItem(5.00);\n\n    OrderView view;\n    view.render(order);\n\n    OrderRepository repo;\n    OrderService service(repo);\n    service.checkout(order);\n\n    // Typische Ausgabe:\n    // Order total: 14.99 EUR\n    // [DB] Speichere Order mit total=14.99\n}\n"
            },
            {
              "type": "list",
              "title": "Typische Vorteile",
              "items": [
                "Bessere Wartbarkeit",
                "Einfachere Tests",
                "Klare Zust√§ndigkeiten",
                "Unabh√§ngige Weiterentwicklung der Schichten"
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Separation of Concerns",
              "columns": ["Mit SoC", "Ohne SoC"],
              "rows": [
                {
                  "aspect": "√Ñnderungsaufwand",
                  "values": ["Lokal begrenzt", "Systemweit"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Hoch", "Niedrig"]
                },
                {
                  "aspect": "Verst√§ndlichkeit",
                  "values": ["Klar strukturiert", "Vermischt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vermischte Verantwortlichkeiten",
              "text": "Wenn UI oder Datenbank Code in der Domain landet, wird die Fachlogik schwer testbar und von technischen Details abh√§ngig."
            },
            {
              "type": "important",
              "text": "Separation of Concerns ist die Grundlage f√ºr saubere Architektur. Ohne klare Trennung skaliert Code schlecht."
            },
            {
              "type": "summary",
              "points": [
                "Jede Schicht hat einen klaren Fokus",
                "Fachlogik ist unabh√§ngig von IO",
                "√Ñnderungen bleiben lokal",
                "UI und DB Code geh√∂ren nicht in die Domain",
                "Zentrales Prinzip sauberer Architektur"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "Architektur und Schichten",
        "icon": "üèóÔ∏è",
        "topics": [
        {
          "title": "Projektstruktur in C++",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Projektstruktur",
              "text": "Eine gute Projektstruktur organisiert C++ Code nach fachlichen Modulen und Verantwortlichkeiten, nicht nach Dateitypen oder Zufall."
            },
            {
              "type": "explanation",
              "title": "Ordner nach Modulen statt nach Dateityp",
              "text": [
                "Ordner sollten fachliche oder funktionale Einheiten widerspiegeln.",
                "Ein Modul enth√§lt seine Header und Implementierungen gemeinsam.",
                "Strukturen wie include und src ohne weitere Unterteilung skalieren schlecht."
              ]
            },
            {
              "type": "code",
              "title": "Schlechte Struktur",
              "language": "text",
              "code": "project/\n  src/\n    main.cpp\n    user.cpp\n    order.cpp\n    database.cpp\n    utils.cpp"
            },
            {
              "type": "code",
              "title": "Modular aufgebaute Struktur",
              "language": "text",
              "code": "project/\n  src/\n    app/\n      main.cpp\n    user/\n      User.hpp\n      User.cpp\n    order/\n      Order.hpp\n      Order.cpp\n    infrastructure/\n      Database.hpp\n      Database.cpp"
            },
            {
              "type": "explanation",
              "title": "Header und Implementierung trennen",
              "text": [
                "Header enthalten Deklarationen und √∂ffentliche Schnittstellen.",
                "Implementierungen geh√∂ren in cpp Dateien.",
                "Das reduziert Kompilierabh√§ngigkeiten und h√§lt Schnittstellen klar."
              ]
            },
            {
              "type": "explanation",
              "title": "Klare Einstiegspunkte",
              "text": [
                "Es sollte klar sein, wo das Programm startet, meist in main.",
                "Gro√üe Projekte haben oft eine Application oder App Klasse als Koordinator.",
                "Der Einstiegspunkt darf keine Gesch√§ftslogik enthalten."
              ]
            },
            {
              "type": "list",
              "title": "Typische Module",
              "items": [
                "Domain f√ºr Fachmodelle",
                "Application f√ºr Use Cases",
                "Infrastructure f√ºr Datenbank und IO",
                "Tests in separatem Ordner"
              ]
            },
            {
              "type": "comparison",
              "title": "Strukturierte vs unstrukturierte Projekte",
              "columns": ["Strukturiert", "Unstrukturiert"],
              "rows": [
                {
                  "aspect": "Orientierung",
                  "values": ["Schnell verst√§ndlich", "Un√ºbersichtlich"]
                },
                {
                  "aspect": "Erweiterbarkeit",
                  "values": ["Skalierbar", "Chaotisch"]
                },
                {
                  "aspect": "Kopplung",
                  "values": ["Modular", "Vermischt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Alles in src",
              "text": "Wenn alle Dateien direkt im src Ordner liegen, verliert das Projekt schnell jede Struktur. Abh√§ngigkeiten wachsen unkontrolliert."
            },
            {
              "type": "important",
              "text": "Projektstruktur ist Architektur auf Dateisystem Ebene. Wenn sie schlecht ist, wird auch das Design im Code meist schlecht."
            },
            {
              "type": "summary",
              "points": [
                "Ordner nach Modulen statt nach Dateityp",
                "Header und Implementierung sauber trennen",
                "Klare Einstiegspunkte definieren",
                "Skalierbare Struktur von Anfang an",
                "Chaos im src vermeiden"
              ]
            }
          ]
        },


        {
          "title": "Domain Logik von IO trennen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Domain und IO Trennung",
              "text": "Domain Logik von IO zu trennen bedeutet, dass Fachklassen keinerlei Wissen √ºber Dateien, Datenbanken oder Konsolenausgabe besitzen."
            },
            {
              "type": "explanation",
              "title": "Grundprinzip",
              "text": [
                "Die Domain verarbeitet Daten und enth√§lt Gesch√§ftsregeln.",
                "IO Schichten liefern Daten an die Domain oder speichern deren Ergebnisse.",
                "Die Domain kennt keine technischen Details wie std::cout oder SQL."
              ]
            },
            {
              "type": "explanation",
              "title": "Rollenverteilung",
              "text": [
                "IO liest Daten aus Datei, Datenbank oder Netzwerk.",
                "Die Domain validiert, berechnet und entscheidet.",
                "IO pr√§sentiert oder persistiert die Ergebnisse."
              ]
            },
            {
              "type": "code",
              "title": "Falsche Vermischung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Order {\npublic:\n    double totalPrice() const {\n        double price = 100.0;\n        std::cout << \"Preis berechnet\" << std::endl;\n        return price;\n    }\n};"
            },
            {
              "type": "code",
              "title": "Saubere Trennung",
              "language": "cpp",
              "code": "class Order {\npublic:\n    double totalPrice() const {\n        return 100.0;\n    }\n};\n\nvoid printOrder(const Order& order) {\n    std::cout << order.totalPrice() << std::endl;\n}"
            },
            {
              "type": "explanation",
              "title": "Warum das Tests erleichtert",
              "text": [
                "Reine Domain Klassen ben√∂tigen keine Datei oder Datenbank.",
                "Unit Tests k√∂nnen Logik isoliert pr√ºfen.",
                "Keine Seiteneffekte durch Ausgabe oder externe Systeme."
              ]
            },
            {
              "type": "list",
              "title": "Typische IO Quellen",
              "items": [
                "Dateien",
                "Datenbanken",
                "Netzwerk",
                "Konsoleneingabe und Ausgabe",
                "GUI oder Web Schnittstellen"
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Trennung",
              "columns": ["Getrennt", "Vermischt"],
              "rows": [
                {
                  "aspect": "Testbarkeit",
                  "values": ["Sehr gut", "Schwierig"]
                },
                {
                  "aspect": "Wiederverwendbarkeit",
                  "values": ["Hoch", "Gering"]
                },
                {
                  "aspect": "Komplexit√§t",
                  "values": ["Beherrschbar", "Schnell chaotisch"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "std cout in der Domain",
              "text": "Sobald Fachklassen direkt auf std::cout, Dateien oder Datenbanken zugreifen, sind sie technisch gekoppelt und verlieren ihre Unabh√§ngigkeit."
            },
            {
              "type": "important",
              "text": "Eine saubere Domain sollte rein logisch sein. Alles, was mit Ein oder Ausgabe zu tun hat, geh√∂rt in eine andere Schicht."
            },
            {
              "type": "summary",
              "points": [
                "Domain kennt keine Dateien, Datenbanken oder Konsolen",
                "IO liefert Daten, Domain verarbeitet",
                "Massiv bessere Testbarkeit",
                "Keine Seiteneffekte in der Fachlogik",
                "std cout geh√∂rt nicht in die Domain"
              ]
            }
          ]
        },


        {
          "title": "Datenbank Code von Fachlogik trennen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "DB Trennung",
              "text": "Datenbank Code von Fachlogik zu trennen bedeutet, dass SQL und Datenbankzugriffe nicht im Business Code stehen, sondern in einer eigenen Schicht gekapselt werden."
            },
            {
              "type": "explanation",
              "title": "Warum SQL nicht in Business Code geh√∂rt",
              "text": [
                "Fachlogik soll unabh√§ngig von einer konkreten Datenbank sein.",
                "SQL im Business Code erzeugt Kopplung und macht √Ñnderungen teuer.",
                "Tests werden kompliziert, weil pl√∂tzlich eine Datenbank n√∂tig ist."
              ]
            },
            {
              "type": "explanation",
              "title": "Repository als Kapsel",
              "text": [
                "Ein Repository ist eine technische Klasse f√ºr Persistenzzugriffe.",
                "Es enth√§lt SQL Statements, Mapping und Fehlerbehandlung f√ºr die DB.",
                "Der Rest des Systems nutzt nur Methoden wie save, findById oder listAll."
              ]
            },
            {
              "type": "explanation",
              "title": "Domain arbeitet mit Objekten",
              "text": [
                "Die Domain kennt nur Fachobjekte wie Patient, Order oder Appointment.",
                "Repository √ºbersetzt zwischen Datenbankzeilen und Objekten.",
                "Domain Entscheidungen basieren auf Objekten, nicht auf SQL Abfragen."
              ]
            },
            {
              "type": "code",
              "title": "Schlechte Vermischung",
              "language": "cpp",
              "code": "#include <string>\n\nclass PatientService {\npublic:\n    void registerPatient(const std::string& name) {\n        const char* sql = \"INSERT INTO patients(name) VALUES(?)\";\n        // prepare, bind, step\n    }\n};"
            },
            {
              "type": "code",
              "title": "Saubere Trennung mit Repository",
              "language": "cpp",
              "code": "#include <string>\n\nstruct Patient {\n    int id;\n    std::string name;\n};\n\nclass PatientRepository {\npublic:\n    void save(const Patient& patient);\n    Patient loadById(int id);\n};\n\nclass PatientService {\n    PatientRepository& repo;\n\npublic:\n    explicit PatientService(PatientRepository& r) : repo(r) {}\n\n    void registerPatient(const std::string& name) {\n        Patient p{0, name};\n        repo.save(p);\n    }\n};"
            },
            {
              "type": "comparison",
              "title": "Domain Objekte vs SQL im Business Code",
              "columns": ["Domain Objekte", "SQL im Business Code"],
              "rows": [
                {
                  "aspect": "Kopplung",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Gut", "Schlecht"]
                },
                {
                  "aspect": "√Ñnderungen",
                  "values": ["Lokal im Repository", "√úberall verteilt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Datenbank als Domain Model",
              "text": "Wenn Tabellenstruktur direkt das Domain Model bestimmt, wird das Fachmodell von technischen Details dominiert. Domain sollte der Fachlichkeit folgen, nicht der DB."
            },
            {
              "type": "important",
              "text": "Repository kapselt SQL, Mapping und DB Fehler. Domain und Services sollten keine DB APIs kennen."
            },
            {
              "type": "summary",
              "points": [
                "SQL geh√∂rt nicht in Business Code",
                "Repository kapselt den Datenbankzugriff",
                "Domain arbeitet mit Objekten statt SQL",
                "√Ñnderungen bleiben lokal in der Persistenzschicht",
                "Datenbank darf nicht das Domain Model diktieren"
              ]
            }
          ]
        },

        {
          "title": "Abh√§ngigkeiten kontrollieren",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Dependency Control",
              "text": "Abh√§ngigkeiten kontrollieren bedeutet, Abh√§ngigkeitsrichtungen bewusst zu gestalten, Zyklen zu vermeiden und unn√∂tige Includes zu reduzieren, damit das System modular bleibt."
            },
            {
              "type": "explanation",
              "title": "Abh√§ngigkeiten zeigen nach innen",
              "text": [
                "Fachlogik und Kernmodule sollen unabh√§ngig von technischen Details sein.",
                "Technische Schichten h√§ngen vom Kern ab, nicht umgekehrt.",
                "So bleiben zentrale Teile stabil, auch wenn sich Details √§ndern."
              ]
            },
            {
              "type": "explanation",
              "title": "Keine zyklischen Abh√§ngigkeiten",
              "text": [
                "Zyklen machen √Ñnderungen riskant und verhindern saubere Modularit√§t.",
                "Sie f√ºhren oft zu Include Problemen und schwer nachvollziehbaren Kopplungen.",
                "Wenn A B braucht und B A braucht, ist meist die Verantwortlichkeit falsch geschnitten."
              ]
            },
            {
              "type": "explanation",
              "title": "Includes minimieren",
              "text": [
                "Jeder Include im Header zieht weitere Abh√§ngigkeiten nach sich.",
                "Forward Declarations reichen h√§ufig f√ºr Zeiger oder Referenzen.",
                "Includes geh√∂ren m√∂glichst in cpp Dateien."
              ]
            },
            {
              "type": "code",
              "title": "Zyklische Abh√§ngigkeit als Problem",
              "language": "cpp",
              "code": "// A.hpp\n#include \"B.hpp\"\nclass A { B b; };\n\n// B.hpp\n#include \"A.hpp\"\nclass B { A a; };"
            },
            {
              "type": "code",
              "title": "Zyklus aufl√∂sen mit Forward Declaration",
              "language": "cpp",
              "code": "// A.hpp\nclass B;\nclass A { B* b; };\n\n// B.hpp\nclass A;\nclass B { A* a; };"
            },
            {
              "type": "list",
              "title": "Typische Ma√ünahmen",
              "items": [
                "Abh√§ngigkeitsrichtungen pro Schicht definieren",
                "Zyklische Abh√§ngigkeiten sofort aufl√∂sen",
                "Schnittstellen nutzen statt konkrete Typen",
                "Header nur das n√∂tigste includen",
                "Implementierungsdetails in cpp verschieben"
              ]
            },
            {
              "type": "comparison",
              "title": "Kontrollierte vs unkontrollierte Abh√§ngigkeiten",
              "columns": ["Kontrolliert", "Unkontrolliert"],
              "rows": [
                {
                  "aspect": "√Ñnderungsfolgen",
                  "values": ["Lokal", "Systemweit"]
                },
                {
                  "aspect": "Build Zeit",
                  "values": ["Besser", "Schlechter"]
                },
                {
                  "aspect": "Verst√§ndlichkeit",
                  "values": ["Modular", "Alles kennt alles"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Alles kennt alles",
              "text": "Wenn jede Klasse jede andere direkt kennt, entsteht ein Netz aus Abh√§ngigkeiten. Das macht Refactoring teuer und Fehler schwer zu isolieren."
            },
            {
              "type": "important",
              "text": "Wenn du Abh√§ngigkeiten nicht aktiv steuerst, steuern sie dich. Sp√§testens bei Wachstum wird das Projekt sonst unwartbar."
            },
            {
              "type": "summary",
              "points": [
                "Abh√§ngigkeiten zeigen nach innen zum Kern",
                "Zyklische Abh√§ngigkeiten vermeiden",
                "Includes im Header minimieren",
                "Schnittstellen statt konkrete Typen",
                "Alles kennt alles ist ein massives Warnsignal"
              ]
            }
          ]
        },


        {
          "title": "Composition Root",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Composition Root",
              "text": "Ein Composition Root ist die zentrale Stelle im Programm, an der Objekte erstellt und ihre Abh√§ngigkeiten verdrahtet werden, typischerweise im main oder in einem App Einstiegspunkt."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Objekterzeugung und Verdrahtung sollen nicht im Fachcode verteilt sein.",
                "Im Composition Root wird festgelegt, welche konkreten Implementierungen verwendet werden.",
                "Dadurch sind Abh√§ngigkeiten an einem Ort sichtbar und kontrollierbar."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum das sinnvoll ist",
              "text": [
                "Fachlogik bleibt frei von new und konkreten Typen.",
                "Abh√§ngigkeitsrichtung bleibt sauber nach innen zum Kern.",
                "Tests k√∂nnen leichter andere Implementierungen einsetzen."
              ]
            },
            {
              "type": "explanation",
              "title": "Typischer Ort",
              "text": [
                "Kleine Projekte nutzen main als Composition Root.",
                "Gr√∂√üere Projekte nutzen eine App oder Bootstrap Funktion.",
                "Die Verdrahtung sollte dort konzentriert bleiben."
              ]
            },
            {
              "type": "code",
              "title": "Composition Root im main",
              "language": "cpp",
              "code": "int main() {\n    Database db(\"data/app.db\");\n    PatientRepository repo(db);\n    PatientService service(repo);\n\n    App app(service);\n    return app.run();\n}"
            },
            {
              "type": "code",
              "title": "Schlechtes Gegenbeispiel",
              "language": "cpp",
              "code": "class PatientService {\npublic:\n    void registerPatient() {\n        Database db(\"data/app.db\");\n        PatientRepository repo(db);\n        // ...\n    }\n};"
            },
            {
              "type": "list",
              "title": "Typische Aufgaben im Composition Root",
              "items": [
                "Konkrete Implementierungen ausw√§hlen",
                "Abh√§ngigkeiten √ºbergeben, zum Beispiel via Konstruktor",
                "Konfiguration laden und verteilen",
                "App Start und Shutdown koordinieren"
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Composition Root",
              "columns": ["Mit Composition Root", "Ohne Composition Root"],
              "rows": [
                {
                  "aspect": "Sichtbarkeit der Abh√§ngigkeiten",
                  "values": ["Zentral", "Verstreut"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Gut", "Schlecht"]
                },
                {
                  "aspect": "√Ñnderungsaufwand",
                  "values": ["Lokal", "√úberall"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Objekte √ºberall erzeugen",
              "text": "Wenn Objekte an vielen Stellen erzeugt werden, ist unklar, wer wof√ºr verantwortlich ist. Abh√§ngigkeiten werden unsichtbar und schwer austauschbar."
            },
            {
              "type": "important",
              "text": "Der Composition Root darf ruhig wissen, welche konkreten Typen existieren. Diese Kenntnis geh√∂rt genau dorthin und nicht in die Domain."
            },
            {
              "type": "summary",
              "points": [
                "Zentrale Stelle f√ºr Objekterzeugung und Verdrahtung",
                "Abh√§ngigkeiten an einem Ort sichtbar",
                "Typisch in main oder App Einstiegspunkt",
                "Fachlogik bleibt frei von new und Details",
                "Objekte nicht √ºberall im Code erzeugen"
              ]
            }
          ]
        }



        ]
      },




      {
        "name": "Code Style und Namenskonventionen",
        "icon": "‚úíÔ∏è",
        "topics": [
        {
          "title": "Naming Konventionen in C++",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Naming Konventionen",
              "text": "Naming Konventionen legen fest, wie Klassen, Funktionen, Variablen und Konstanten benannt werden, damit Code lesbar, verst√§ndlich und konsistent bleibt."
            },
            {
              "type": "explanation",
              "title": "Namen beschreiben Absicht",
              "text": [
                "Ein guter Name erkl√§rt, warum etwas existiert, nicht nur was es ist.",
                "Lesbarkeit ist wichtiger als K√ºrze.",
                "Code wird h√§ufiger gelesen als geschrieben."
              ]
            },
            {
              "type": "explanation",
              "title": "Klassen sind Nomen",
              "text": [
                "Klassen repr√§sentieren Dinge oder Konzepte.",
                "Typische Namen sind User, Order, DatabaseConnection.",
                "Der Name sollte ein fachliches oder technisches Objekt ausdr√ºcken."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Klassenname",
              "language": "cpp",
              "code": "class PatientRecord {\n};"
            },
            {
              "type": "explanation",
              "title": "Funktionen sind Verben",
              "text": [
                "Funktionen beschreiben Aktionen.",
                "Typische Namen sind calculateTotal, save, loadById.",
                "Der Name sollte klar machen, was passiert."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Funktionsname",
              "language": "cpp",
              "code": "double calculateTotal() const;\nvoid save(const Patient& patient);"
            },
            {
              "type": "explanation",
              "title": "Einheitlicher Stil im Projekt",
              "text": [
                "Ob camelCase oder snake_case genutzt wird, ist weniger wichtig als Konsistenz.",
                "Ein Projekt sollte einen klaren Stil definieren und durchziehen.",
                "Inkonsistenz erzeugt Reibung beim Lesen."
              ]
            },
            {
              "type": "list",
              "title": "Typische Stilregeln",
              "items": [
                "Klassen in PascalCase",
                "Funktionen in camelCase",
                "Member Variablen mit klar erkennbarem Schema",
                "Konstanten deutlich kennzeichnen",
                "Keine Mischformen im selben Projekt"
              ]
            },
            {
              "type": "comparison",
              "title": "Gute vs schlechte Namen",
              "columns": ["Gut", "Schlecht"],
              "rows": [
                {
                  "aspect": "Aussagekraft",
                  "values": ["describeOrderTotal", "calc"]
                },
                {
                  "aspect": "Kontextklarheit",
                  "values": ["PatientRepository", "PR"]
                },
                {
                  "aspect": "Lesbarkeit",
                  "values": ["maxRetryCount", "mrc"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Abk√ºrzungen ohne Kontext",
              "text": "Unklare Abk√ºrzungen sparen wenige Zeichen, kosten aber Verst√§ndnis. Wenn ein Name erkl√§rt werden muss, ist er meist schlecht gew√§hlt."
            },
            {
              "type": "important",
              "text": "Einheitliche und sprechende Namen sind ein zentrales Qualit√§tsmerkmal von professionellem C++ Code."
            },
            {
              "type": "summary",
              "points": [
                "Namen beschreiben Absicht",
                "Klassen sind Nomen",
                "Funktionen sind Verben",
                "Stil im Projekt einheitlich halten",
                "Abk√ºrzungen ohne Kontext vermeiden"
              ]
            }
          ]
        },


        {
          "title": "CamelCase vs snake_case",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Naming Style",
              "text": "CamelCase und snake_case sind unterschiedliche Schreibweisen f√ºr Bezeichner. Entscheidend ist nicht welcher Stil gew√§hlt wird, sondern dass er im gesamten Projekt konsistent angewendet wird."
            },
            {
              "type": "explanation",
              "title": "Grundprinzip",
              "text": [
                "Ein Projekt sollte sich f√ºr einen klaren Stil entscheiden.",
                "Inkonsistenz erschwert Lesen und Wartung.",
                "Konventionen sind Team Entscheidungen, keine Geschmacksfrage einzelner Entwickler."
              ]
            },
            {
              "type": "explanation",
              "title": "CamelCase",
              "text": [
                "W√∂rter werden ohne Unterstrich geschrieben.",
                "Bei PascalCase beginnen alle W√∂rter mit Gro√übuchstaben.",
                "Bei camelCase beginnt nur das erste Wort klein."
              ]
            },
            {
              "type": "code",
              "title": "CamelCase Beispiele",
              "language": "cpp",
              "code": "class PatientRecord;\nvoid calculateTotalPrice();\nint maxRetryCount;"
            },
            {
              "type": "explanation",
              "title": "snake_case",
              "text": [
                "W√∂rter werden durch Unterstriche getrennt.",
                "Alle Buchstaben sind meist klein geschrieben.",
                "Dieser Stil ist stark durch die Standard Library gepr√§gt."
              ]
            },
            {
              "type": "code",
              "title": "snake_case Beispiele",
              "language": "cpp",
              "code": "class patient_record;\nvoid calculate_total_price();\nint max_retry_count;"
            },
            {
              "type": "explanation",
              "title": "Unterschiedliche Stile f√ºr verschiedene Elemente",
              "text": [
                "Typen k√∂nnen in PascalCase benannt werden.",
                "Funktionen und Variablen k√∂nnen in snake_case oder camelCase stehen.",
                "Viele Projekte kombinieren bewusst unterschiedliche Stile je nach Kategorie."
              ]
            },
            {
              "type": "explanation",
              "title": "Orientierung an STL oder Team Style",
              "text": [
                "Die C++ Standard Library verwendet snake_case f√ºr Funktionen und Typen wie std::vector.",
                "Gro√üe Codebasen definieren meist eigene Style Guides.",
                "Entscheidend ist, dass sich alle Entwickler daran halten."
              ]
            },
            {
              "type": "comparison",
              "title": "CamelCase vs snake_case",
              "columns": ["CamelCase", "snake_case"],
              "rows": [
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Optisch kompakt", "Klare Worttrennung"]
                },
                {
                  "aspect": "Verbreitung",
                  "values": ["Oft in Klassen", "Stark in STL und vielen Projekten"]
                },
                {
                  "aspect": "Kombination",
                  "values": ["Typen h√§ufig PascalCase", "Funktionen h√§ufig snake_case"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Mischformen",
              "text": "Wenn im selben Projekt calculateTotal, calculate_total und Calculate_Total nebeneinander existieren, wirkt der Code unprofessionell und inkonsistent."
            },
            {
              "type": "important",
              "text": "Konsistenz schl√§gt pers√∂nliche Pr√§ferenz. Ein klar definierter Stil erh√∂ht die Qualit√§t des gesamten Projekts."
            },
            {
              "type": "summary",
              "points": [
                "Konsistente Entscheidung im Projekt ist entscheidend",
                "Unterschiedliche Stile f√ºr Typen und Funktionen m√∂glich",
                "Orientierung an STL oder Team Style sinnvoll",
                "Mischformen vermeiden",
                "Konsistenz ist wichtiger als Stilwahl"
              ]
            }
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },

        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        }



        ]
      }

      
    ]
  },




  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
        {
          "title": "Fehlerbehandlung (try, catch und Exceptions)",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Exception",
              "text": "Eine Exception ist ein Mechanismus zur Behandlung von Laufzeitfehlern durch Werfen und Abfangen von Fehlerobjekten."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Fehlerbehandlung",
              "text": [
                "Exceptions trennen Fehlerbehandlung vom normalen Programmablauf.",
                "Fehler werden nicht √ºber R√ºckgabewerte signalisiert, sondern explizit geworfen."
              ]
            },
            {
              "type": "explanation",
              "title": "try, throw und catch",
              "text": [
                "try umschlie√üt Code, in dem Fehler auftreten k√∂nnen.",
                "throw l√∂st eine Exception aus.",
                "catch f√§ngt eine geworfene Exception ab und behandelt sie."
              ]
            },
            {
              "type": "list",
              "title": "Vorteile von Exceptions",
              "items": [
                "Saubere Trennung von Logik und Fehlerbehandlung",
                "Keine Fehlercodes n√∂tig",
                "Fehler k√∂nnen √ºber Funktionsgrenzen hinweg propagiert werden",
                "Zentrale Behandlung m√∂glich"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches try catch Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nint teilen(int a, int b) {\n    if (b == 0) {\n        throw std::runtime_error(\"Division durch null\");\n    }\n    return a / b;\n}\n\nint main() {\n    try {\n        std::cout << teilen(10, 2) << std::endl;\n        std::cout << teilen(10, 0) << std::endl; // wirft Exception\n    }\n    catch (const std::runtime_error& e) {\n        std::cout << \"Fehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Ablauf bei einer Exception",
              "text": [
                "Beim throw wird der normale Kontrollfluss sofort verlassen.",
                "Der Stack wird abgebaut, bis ein passender catch-Block gefunden wird."
              ]
            },
            {
              "type": "explanation",
              "title": "Standard-Exception-Hierarchie",
              "text": [
                "C++ stellt eine Hierarchie von Exception-Typen bereit.",
                "std::exception ist die Basisklasse vieler Standard-Exceptions."
              ]
            },
            {
              "type": "list",
              "title": "H√§ufige Exception-Typen",
              "items": [
                "std::runtime_error",
                "std::logic_error",
                "std::out_of_range",
                "std::invalid_argument"
              ]
            },
            {
              "type": "code",
              "title": "Mehrere catch-Bl√∂cke",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Index au√üerhalb des Bereichs\");\n    }\n    catch (const std::out_of_range& e) {\n        std::cout << \"Out of range: \" << e.what() << std::endl;\n    }\n    catch (const std::exception& e) {\n        std::cout << \"Allgemeiner Fehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "catch Reihenfolge",
              "text": [
                "Spezifische Exceptions m√ºssen vor allgemeineren gefangen werden.",
                "Andernfalls werden sie nie erreicht."
              ]
            },
            {
              "type": "code",
              "title": "Eigene Exception-Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nclass DateiFehler : public std::runtime_error {\npublic:\n    explicit DateiFehler(const std::string& msg)\n        : std::runtime_error(msg) {}\n};\n\nint main() {\n    try {\n        throw DateiFehler(\"Datei konnte nicht ge√∂ffnet werden\");\n    }\n    catch (const DateiFehler& e) {\n        std::cout << \"Dateifehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Exceptions und RAII",
              "text": [
                "Beim Stack-Unwinding werden lokale Objekte korrekt zerst√∂rt.",
                "RAII stellt sicher, dass Ressourcen auch bei Fehlern freigegeben werden."
              ]
            },
            {
              "type": "pitfall",
              "title": "Exceptions f√ºr normale Kontrolle",
              "text": "Exceptions sollten nicht f√ºr normalen Programmfluss oder h√§ufige F√§lle verwendet werden."
            },
            {
              "type": "important",
              "text": "Exceptions signalisieren au√üergew√∂hnliche Fehlerzust√§nde und keine regul√§ren Ergebnisse."
            },
            {
              "type": "summary",
              "points": [
                "try umschlie√üt fehleranf√§lligen Code",
                "throw l√∂st eine Exception aus",
                "catch behandelt den Fehler",
                "Exceptions propagieren √ºber Funktionsgrenzen",
                "RAII sorgt f√ºr sichere Ressourcenfreigabe"
              ]
            }
          ]
        },
        {
          "title": "Pr√§prozessor und #define",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "#define",
              "text": "#define ist eine Pr√§prozessor-Anweisung zur Ersetzung von Text vor der eigentlichen Kompilierung."
            },
            {
              "type": "explanation",
              "title": "Grundidee des Pr√§prozessors",
              "text": [
                "Der Pr√§prozessor arbeitet vor dem Compiler und ver√§ndert den Quelltext.",
                "#define ersetzt symbolische Namen rein textuell, ohne Typpr√ºfung."
              ]
            },
            {
              "type": "explanation",
              "title": "Einfache Makros",
              "text": [
                "Konstanten k√∂nnen mit #define definiert werden.",
                "Die Ersetzung erfolgt √ºberall im Code, wo der Name vorkommt."
              ]
            },
            {
              "type": "code",
              "title": "Konstantes Makro",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define PI 3.14159\n\nint main() {\n    std::cout << PI << std::endl; // wird durch 3.14159 ersetzt\n}\n"
            },
            {
              "type": "explanation",
              "title": "Funktions√§hnliche Makros",
              "text": [
                "Makros k√∂nnen Parameter besitzen und wie Funktionen aussehen.",
                "Es findet keine Typpr√ºfung statt."
              ]
            },
            {
              "type": "code",
              "title": "Funktions√§hnliches Makro",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define QUADRAT(x) ((x) * (x))\n\nint main() {\n    int a = 3;\n    std::cout << QUADRAT(a + 1) << std::endl; // (a + 1) * (a + 1)\n}\n"
            },
            {
              "type": "explanation",
              "title": "Typische Probleme von Makros",
              "text": [
                "Mehrfachauswertung von Argumenten kann zu Fehlern f√ºhren.",
                "Debugging ist erschwert, da Makros keine echten Funktionen sind."
              ]
            },
            {
              "type": "list",
              "title": "Weitere Pr√§prozessor-Anweisungen",
              "items": [
                "#undef zum Entfernen eines Makros",
                "#ifdef / #ifndef f√ºr bedingte Kompilierung",
                "#if / #else / #endif f√ºr Bedingungen"
              ]
            },
            {
              "type": "code",
              "title": "Bedingte Kompilierung",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define DEBUG\n\nint main() {\n#ifdef DEBUG\n    std::cout << \"Debug-Modus aktiv\" << std::endl;\n#endif\n}\n"
            },
            {
              "type": "comparison",
              "title": "#define vs const",
              "columns": ["#define", "const"],
              "rows": [
                {
                  "aspect": "Typpr√ºfung",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Sichtbarkeit",
                  "values": ["Textuell", "G√ºltigkeitsbereich"]
                },
                {
                  "aspect": "Debugging",
                  "values": ["Schwierig", "Einfach"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Makros statt moderner Alternativen",
              "text": "#define sollte nicht f√ºr Konstanten oder Funktionen verwendet werden, wenn constexpr oder inline m√∂glich sind."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten constexpr, const und inline Funktionen #define weitgehend ersetzen."
            },
            {
              "type": "summary",
              "points": [
                "#define f√ºhrt textuelle Ersetzung durch",
                "Keine Typpr√ºfung",
                "Funktions√§hnliche Makros sind fehleranf√§llig",
                "Bedingte Kompilierung ist ein Hauptanwendungsfall",
                "Moderne Alternativen bevorzugen"
              ]
            }
          ]
        },
        {
          "title": "CMake Grundlagen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "CMake",
              "text": "CMake ist ein plattformunabh√§ngiges Build-System zur Generierung von Projektdateien f√ºr Compiler und IDEs."
            },
            {
              "type": "explanation",
              "title": "Grundidee von CMake",
              "text": [
                "CMake beschreibt, wie ein Projekt gebaut wird, nicht wie es konkret kompiliert wird.",
                "Aus einer CMakeLists.txt erzeugt CMake Build-Dateien f√ºr Make, Ninja oder IDEs wie CLion oder Visual Studio."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum CMake verwenden",
              "text": [
                "Ein Projekt kann auf Windows, Linux und macOS gleich konfiguriert werden.",
                "Compiler, Flags und Abh√§ngigkeiten werden zentral definiert."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "C++ Projekte mit mehreren Quelldateien",
                "Plattform√ºbergreifende Builds",
                "Bibliotheken und ausf√ºhrbare Programme",
                "Integration externer Abh√§ngigkeiten"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Datei: CMakeLists.txt",
              "text": [
                "Jedes CMake-Projekt besitzt mindestens eine CMakeLists.txt.",
                "Sie beschreibt Projektname, Sprache, Targets und Build-Regeln."
              ]
            },
            {
              "type": "code",
              "title": "Minimale CMakeLists.txt",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(MeinProjekt LANGUAGES CXX)\n\nadd_executable(MeinProgramm main.cpp)\n"
            },
            {
              "type": "explanation",
              "title": "Wichtige Grundbefehle",
              "text": [
                "cmake_minimum_required legt die ben√∂tigte CMake-Version fest.",
                "project definiert Projektname und verwendete Sprachen.",
                "add_executable erzeugt ein ausf√ºhrbares Target.",
                "add_library erzeugt eine Bibliothek."
              ]
            },
            {
              "type": "code",
              "title": "Projekt mit mehreren Quelldateien",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(MehrDateien LANGUAGES CXX)\n\nadd_executable(App\n    main.cpp\n    util.cpp\n    util.h\n)\n"
            },
            {
              "type": "explanation",
              "title": "Target-basierter Ansatz",
              "text": [
                "In modernem CMake wird fast alles an Targets gebunden.",
                "Compiler-Optionen und Includes gelten nur f√ºr das jeweilige Target."
              ]
            },
            {
              "type": "code",
              "title": "Compiler-Standard setzen",
              "language": "cpp",
              "code": "add_executable(App main.cpp)\n\ntarget_compile_features(App PRIVATE cxx_std_20)\n"
            },
            {
              "type": "explanation",
              "title": "Include-Verzeichnisse",
              "text": [
                "Include-Pfade werden pro Target definiert.",
                "PRIVATE, PUBLIC und INTERFACE steuern die Sichtbarkeit."
              ]
            },
            {
              "type": "code",
              "title": "Include-Verzeichnisse setzen",
              "language": "cpp",
              "code": "target_include_directories(App\n    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include\n)\n"
            },
            {
              "type": "explanation",
              "title": "Bibliotheken einbinden",
              "text": [
                "Eigene Bibliotheken werden mit add_library definiert.",
                "Verkn√ºpfung erfolgt mit target_link_libraries."
              ]
            },
            {
              "type": "code",
              "title": "Eigene Bibliothek verwenden",
              "language": "cpp",
              "code": "add_library(util util.cpp util.h)\nadd_executable(App main.cpp)\n\ntarget_link_libraries(App PRIVATE util)\n"
            },
            {
              "type": "explanation",
              "title": "Build-Verzeichnis",
              "text": [
                "CMake trennt Quellcode und Build-Dateien.",
                "Der Build erfolgt in einem separaten Ordner."
              ]
            },
            {
              "type": "code",
              "title": "Typischer Build-Ablauf",
              "language": "cpp",
              "code": "mkdir build\ncd build\ncmake ..\ncmake --build .\n"
            },
            {
              "type": "pitfall",
              "title": "Globale Einstellungen",
              "text": "Globale Compiler-Flags und include_directories f√ºhren zu un√ºbersichtlichem und fehleranf√§lligem Build-Code."
            },
            {
              "type": "important",
              "text": "Modernes CMake arbeitet target-basiert und vermeidet globale Einstellungen."
            },
            {
              "type": "summary",
              "points": [
                "CMake ist ein plattformunabh√§ngiges Build-System",
                "Zentrale Datei ist die CMakeLists.txt",
                "Targets stehen im Mittelpunkt",
                "Trennung von Source- und Build-Verzeichnis",
                "Grundlage moderner C++ Projekte"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "Utility Types",
        "icon": "üß∞",
        "topics": [
        {
          "title": "std::optional",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::optional",
              "text": "std::optional ist ein Wrapper-Typ, der entweder einen g√ºltigen Wert oder keinen Wert enth√§lt."
            },
            {
              "type": "explanation",
              "title": "Grundidee von std::optional",
              "text": [
                "std::optional modelliert das bewusste Vorhandensein oder Fehlen eines Werts.",
                "Es ersetzt unsichere Konstrukte wie nullptr, magische R√ºckgabewerte oder separate Fehlerflags."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "Funktionen, die m√∂glicherweise keinen sinnvollen R√ºckgabewert haben.",
                "Datenbankabfragen mit optionalem Ergebnis.",
                "Konfigurationen oder optionale Parameter."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<optional>"
              ]
            },
            {
              "type": "explanation",
              "title": "Erzeugen eines std::optional",
              "text": [
                "Ein optional kann leer oder mit einem Wert initialisiert werden.",
                "Der leere Zustand wird explizit dargestellt."
              ]
            },
            {
              "type": "code",
              "title": "Leeres und initialisiertes optional",
              "language": "cpp",
              "code": "#include <optional>\n\nint main() {\n    std::optional<int> a;            // leer\n    std::optional<int> b = 42;        // enth√§lt Wert\n    std::optional<int> c = std::nullopt; // explizit leer\n}\n"
            },
            {
              "type": "explanation",
              "title": "Pr√ºfen auf Vorhandensein",
              "text": [
                "has_value zeigt an, ob ein Wert vorhanden ist.",
                "optional kann direkt im if verwendet werden."
              ]
            },
            {
              "type": "code",
              "title": "has_value und bool-Kontext",
              "language": "cpp",
              "code": "#include <optional>\n#include <iostream>\n\nint main() {\n    std::optional<int> value = 10;\n\n    if (value.has_value()) {\n        std::cout << *value << std::endl;\n    }\n\n    if (value) {\n        std::cout << value.value() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf den Wert",
              "text": [
                "operator* und operator-> greifen direkt auf den enthaltenen Wert zu.",
                "value wirft eine Exception, wenn kein Wert vorhanden ist."
              ]
            },
            {
              "type": "code",
              "title": "operator* vs value",
              "language": "cpp",
              "code": "#include <optional>\n#include <iostream>\n\nint main() {\n    std::optional<int> x = 5;\n\n    int a = *x;          // undefiniertes Verhalten, wenn leer\n    int b = x.value();   // wirft std::bad_optional_access, wenn leer\n\n    std::cout << a << \" \" << b << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Default-Werte mit value_or",
              "text": [
                "value_or liefert einen Ersatzwert, falls kein Wert vorhanden ist.",
                "Ideal f√ºr sichere Fallbacks."
              ]
            },
            {
              "type": "code",
              "title": "value_or verwenden",
              "language": "cpp",
              "code": "#include <optional>\n#include <iostream>\n\nint main() {\n    std::optional<int> leer;\n    std::optional<int> gesetzt = 7;\n\n    std::cout << leer.value_or(0) << std::endl;    // 0\n    std::cout << gesetzt.value_or(0) << std::endl; // 7\n}\n"
            },
            {
              "type": "explanation",
              "title": "std::optional als R√ºckgabewert",
              "text": [
                "Funktionen k√∂nnen optional zur√ºckgeben, um Nicht-Finden auszudr√ºcken.",
                "Der Aufrufer muss den Fall explizit behandeln."
              ]
            },
            {
              "type": "code",
              "title": "optional als Funktionsr√ºckgabe",
              "language": "cpp",
              "code": "#include <optional>\n#include <string>\n\nstd::optional<std::string> findeNutzer(bool gefunden) {\n    if (!gefunden) {\n        return std::nullopt;\n    }\n    return \"Kilian\";\n}\n"
            },
            {
              "type": "explanation",
              "title": "optional mit eigenen Typen",
              "text": [
                "std::optional kann beliebige Typen enthalten.",
                "Auch komplexe Strukturen oder Klassen sind m√∂glich."
              ]
            },
            {
              "type": "code",
              "title": "optional mit struct",
              "language": "cpp",
              "code": "#include <optional>\n#include <string>\n\nstruct User {\n    int id;\n    std::string name;\n};\n\nstd::optional<User> getUser(bool ok) {\n    if (!ok) {\n        return std::nullopt;\n    }\n    return User{1, \"Anna\"};\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::optional vs nullptr",
              "columns": ["std::optional", "nullptr"],
              "rows": [
                {
                  "aspect": "Typsicherheit",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Ausdruckskraft",
                  "values": ["Explizit kein Wert", "Implizit kein Objekt"]
                },
                {
                  "aspect": "F√ºr Werttypen",
                  "values": ["Ja", "Nein"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "value ohne Pr√ºfung",
              "text": "value ohne vorherige Pr√ºfung kann eine Exception ausl√∂sen und sollte nur bei garantierter Existenz verwendet werden."
            },
            {
              "type": "important",
              "text": "std::optional zwingt den Nutzer, den Fall \"kein Wert\" explizit zu behandeln."
            },
            {
              "type": "summary",
              "points": [
                "std::optional repr√§sentiert optional vorhandene Werte",
                "Kein Ersatz f√ºr Fehlerbehandlung, sondern f√ºr fehlende Ergebnisse",
                "Sicherer als nullptr oder magische Werte",
                "Sehr h√§ufig bei Datenbank- und Suchfunktionen",
                "F√∂rdert explizite und saubere Schnittstellen"
              ]
            }
          ]
        },
        {
          "title": "std::variant",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::variant",
              "text": "std::variant ist ein typsicherer Union-Typ, der zu jedem Zeitpunkt genau einen von mehreren fest definierten Typen enth√§lt."
            },
            {
              "type": "explanation",
              "title": "Grundidee von std::variant",
              "text": [
                "std::variant modelliert eine Entweder-oder-Beziehung zwischen mehreren Typen.",
                "Im Gegensatz zu klassischen Unions ist std::variant vollst√§ndig typsicher."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "R√ºckgabewerte mit mehreren m√∂glichen Typen.",
                "Ersetzen von Vererbungs-Hierarchien f√ºr einfache F√§lle.",
                "Zust√§nde oder Ergebnisse mit klar abgegrenzten Typen."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<variant>"
              ]
            },
            {
              "type": "explanation",
              "title": "Erzeugen eines std::variant",
              "text": [
                "Ein variant wird mit einer festen Typmenge definiert.",
                "Der aktuell gespeicherte Typ wird automatisch verwaltet."
              ]
            },
            {
              "type": "code",
              "title": "std::variant Grundbeispiel",
              "language": "cpp",
              "code": "#include <variant>\n#include <string>\n\nint main() {\n    std::variant<int, double, std::string> v;\n\n    v = 10;\n    v = 3.14;\n    v = \"Hallo\";\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf den Wert",
              "text": [
                "std::get greift auf den aktuell gespeicherten Typ zu.",
                "Ein falscher Zugriff l√∂st eine Exception aus."
              ]
            },
            {
              "type": "code",
              "title": "std::get verwenden",
              "language": "cpp",
              "code": "#include <variant>\n#include <iostream>\n#include <string>\n\nint main() {\n    std::variant<int, std::string> v = \"Text\";\n\n    std::cout << std::get<std::string>(v) << std::endl;\n    // std::get<int>(v); // wirft std::bad_variant_access\n}\n"
            },
            {
              "type": "explanation",
              "title": "Sicheren Zugriff pr√ºfen",
              "text": [
                "holds_alternative pr√ºft, welcher Typ aktuell aktiv ist.",
                "get_if liefert einen Zeiger oder nullptr zur√ºck."
              ]
            },
            {
              "type": "code",
              "title": "holds_alternative und get_if",
              "language": "cpp",
              "code": "#include <variant>\n#include <iostream>\n\nint main() {\n    std::variant<int, double> v = 2.5;\n\n    if (std::holds_alternative<double>(v)) {\n        std::cout << *std::get_if<double>(&v) << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "std::visit",
              "text": [
                "std::visit ist der empfohlene Weg, um variant-Werte zu verarbeiten.",
                "Alle m√∂glichen Typen m√ºssen behandelt werden."
              ]
            },
            {
              "type": "code",
              "title": "std::visit mit Lambda",
              "language": "cpp",
              "code": "#include <variant>\n#include <iostream>\n#include <string>\n\nint main() {\n    std::variant<int, double, std::string> v = 42;\n\n    std::visit([](auto&& value) {\n        std::cout << value << std::endl;\n    }, v);\n}\n"
            },
            {
              "type": "explanation",
              "title": "Mehrere Typen explizit behandeln",
              "text": [
                "√úberladene Lambdas erlauben typabh√§ngige Logik.",
                "Dies ersetzt h√§ufig klassische switch-Konstrukte."
              ]
            },
            {
              "type": "code",
              "title": "std::visit mit √ºberladenen Lambdas",
              "language": "cpp",
              "code": "#include <variant>\n#include <iostream>\n#include <string>\n\nstruct Visitor {\n    void operator()(int x) const { std::cout << \"int: \" << x << std::endl; }\n    void operator()(double d) const { std::cout << \"double: \" << d << std::endl; }\n    void operator()(const std::string& s) const { std::cout << \"string: \" << s << std::endl; }\n};\n\nint main() {\n    std::variant<int, double, std::string> v = \"Hallo\";\n    std::visit(Visitor{}, v);\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::variant vs Vererbung",
              "columns": ["std::variant", "Vererbung"],
              "rows": [
                {
                  "aspect": "Typen zur Laufzeit",
                  "values": ["Begrenzt und bekannt", "Beliebig"]
                },
                {
                  "aspect": "Typsicherheit",
                  "values": ["Sehr hoch", "Abh√§ngig vom Design"]
                },
                {
                  "aspect": "Overhead",
                  "values": ["Gering", "H√∂her"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "std::get ohne Pr√ºfung",
              "text": "std::get ohne vorherige Typpr√ºfung kann std::bad_variant_access ausl√∂sen."
            },
            {
              "type": "important",
              "text": "std::visit ist der empfohlene und sicherste Weg, um mit std::variant zu arbeiten."
            },
            {
              "type": "summary",
              "points": [
                "std::variant speichert genau einen von mehreren Typen",
                "Typsicherer Ersatz f√ºr Union und einfache Vererbung",
                "std::visit ist Best Practice",
                "get_if und holds_alternative f√ºr sicheren Zugriff",
                "Sehr n√ºtzlich f√ºr klar definierte Alternativen"
              ]
            }
          ]
        },
        {
          "title": "std::any",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::any",
              "text": "std::any ist ein Typ, der einen beliebigen Wert beliebigen Typs zur Laufzeit speichern kann."
            },
            {
              "type": "explanation",
              "title": "Grundidee von std::any",
              "text": [
                "std::any speichert einen Wert ohne dessen Typ zur Compile-Zeit festzulegen.",
                "Der konkrete Typ ist erst zur Laufzeit bekannt und muss explizit abgefragt werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Abgrenzung zu std::variant",
              "text": [
                "std::any kennt seine m√∂glichen Typen nicht im Voraus.",
                "Im Gegensatz zu std::variant gibt es keine feste Typmenge."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<any>"
              ]
            },
            {
              "type": "explanation",
              "title": "Erzeugen und Zuweisen",
              "text": [
                "Ein std::any kann leer oder mit einem beliebigen Typ belegt sein.",
                "Der vorherige Inhalt wird beim Zuweisen √ºberschrieben."
              ]
            },
            {
              "type": "code",
              "title": "std::any Grundbeispiel",
              "language": "cpp",
              "code": "#include <any>\n#include <string>\n\nint main() {\n    std::any a;\n\n    a = 10;\n    a = 3.14;\n    a = std::string(\"Hallo\");\n}\n"
            },
            {
              "type": "explanation",
              "title": "Pr√ºfen auf Inhalt",
              "text": [
                "has_value zeigt an, ob ein Wert gespeichert ist.",
                "Ein leeres any enth√§lt keinen Typ."
              ]
            },
            {
              "type": "code",
              "title": "has_value verwenden",
              "language": "cpp",
              "code": "#include <any>\n#include <iostream>\n\nint main() {\n    std::any a;\n\n    if (!a.has_value()) {\n        std::cout << \"Kein Wert gespeichert\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff mit any_cast",
              "text": [
                "any_cast liest den gespeicherten Wert mit einem konkreten Typ aus.",
                "Der Typ muss exakt √ºbereinstimmen."
              ]
            },
            {
              "type": "code",
              "title": "any_cast erfolgreich",
              "language": "cpp",
              "code": "#include <any>\n#include <iostream>\n\nint main() {\n    std::any a = 42;\n\n    int value = std::any_cast<int>(a);\n    std::cout << value << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Fehler bei falschem Typ",
              "text": [
                "Ein falscher Typ bei any_cast l√∂st eine Exception aus.",
                "Alternativ kann eine sichere Zeiger-Variante genutzt werden."
              ]
            },
            {
              "type": "code",
              "title": "any_cast mit Exception",
              "language": "cpp",
              "code": "#include <any>\n#include <iostream>\n\nint main() {\n    std::any a = 3.14;\n\n    try {\n        int x = std::any_cast<int>(a); // wirft std::bad_any_cast\n        std::cout << x << std::endl;\n    }\n    catch (const std::bad_any_cast&) {\n        std::cout << \"Falscher Typ\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Sicherer Zugriff mit Zeiger",
              "language": "cpp",
              "code": "#include <any>\n#include <iostream>\n\nint main() {\n    std::any a = 5;\n\n    if (int* p = std::any_cast<int>(&a)) {\n        std::cout << *p << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Typinformationen zur Laufzeit",
              "text": [
                "type liefert type_info des gespeicherten Typs.",
                "Dies ist vor allem f√ºr Debugging hilfreich."
              ]
            },
            {
              "type": "code",
              "title": "Typ abfragen",
              "language": "cpp",
              "code": "#include <any>\n#include <typeinfo>\n#include <iostream>\n\nint main() {\n    std::any a = 10;\n    std::cout << a.type().name() << std::endl;\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::any vs std::variant",
              "columns": ["std::any", "std::variant"],
              "rows": [
                {
                  "aspect": "Typmenge",
                  "values": ["Unbegrenzt", "Fest definiert"]
                },
                {
                  "aspect": "Typsicherheit",
                  "values": ["Zur Laufzeit", "Zur Compile-Zeit"]
                },
                {
                  "aspect": "Empfohlener Einsatz",
                  "values": ["Sehr flexibel", "Strukturiert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Missbrauch als Universaltyp",
              "text": "std::any kann zu un√ºbersichtlichem Code f√ºhren, wenn Typinformationen nicht klar dokumentiert sind."
            },
            {
              "type": "important",
              "text": "std::any sollte nur eingesetzt werden, wenn die m√∂glichen Typen nicht sinnvoll vorab festgelegt werden k√∂nnen."
            },
            {
              "type": "summary",
              "points": [
                "std::any speichert beliebige Typen",
                "Typpr√ºfung erfolgt zur Laufzeit",
                "any_cast ist Pflicht f√ºr sicheren Zugriff",
                "Flexibel, aber weniger strukturiert als std::variant",
                "Mit Vorsicht und gezielt einsetzen"
              ]
            }
          ]
        },
        {
          "title": "std::pair",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::pair",
              "text": "std::pair ist ein einfacher Container, der genau zwei zusammengeh√∂rige Werte m√∂glicherweise unterschiedlicher Typen speichert."
            },
            {
              "type": "explanation",
              "title": "Grundidee von std::pair",
              "text": [
                "std::pair wird verwendet, um zwei Werte logisch zu koppeln.",
                "Die Werte werden als first und second angesprochen."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<utility>"
              ]
            },
            {
              "type": "explanation",
              "title": "Erzeugen eines std::pair",
              "text": [
                "Ein pair kann direkt oder mit Hilfsfunktionen erstellt werden.",
                "Die Typen werden explizit oder automatisch bestimmt."
              ]
            },
            {
              "type": "code",
              "title": "Direkte Initialisierung",
              "language": "cpp",
              "code": "#include <utility>\n#include <string>\n\nint main() {\n    std::pair<int, std::string> p(1, \"Anna\");\n}\n"
            },
            {
              "type": "code",
              "title": "Initialisierung mit geschweiften Klammern",
              "language": "cpp",
              "code": "#include <utility>\n#include <string>\n\nint main() {\n    std::pair<int, std::string> p{2, \"Max\"};\n}\n"
            },
            {
              "type": "explanation",
              "title": "std::make_pair",
              "text": [
                "std::make_pair erzeugt ein pair mit automatischer Typableitung.",
                "Explizite Typangaben sind nicht n√∂tig."
              ]
            },
            {
              "type": "code",
              "title": "make_pair verwenden",
              "language": "cpp",
              "code": "#include <utility>\n#include <string>\n\nint main() {\n    auto p = std::make_pair(3, \"Lisa\");\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf Elemente",
              "text": [
                "Die Elemente werden √ºber first und second angesprochen.",
                "Es gibt keine sprechenden Namen, nur Positionszugriff."
              ]
            },
            {
              "type": "code",
              "title": "Zugriff auf first und second",
              "language": "cpp",
              "code": "#include <utility>\n#include <iostream>\n\nint main() {\n    std::pair<int, int> p{10, 20};\n\n    std::cout << p.first << std::endl;\n    std::cout << p.second << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Vergleich von std::pair",
              "text": [
                "std::pair unterst√ºtzt Vergleichsoperatoren.",
                "Der Vergleich erfolgt lexikografisch: zuerst first, dann second."
              ]
            },
            {
              "type": "code",
              "title": "Vergleichsoperatoren",
              "language": "cpp",
              "code": "#include <utility>\n#include <iostream>\n\nint main() {\n    std::pair<int, int> a{1, 5};\n    std::pair<int, int> b{2, 0};\n\n    if (a < b) {\n        std::cout << \"a ist kleiner als b\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "R√ºckgabe von zwei Werten aus einer Funktion.",
                "Schl√ºssel-Wert-Paare, zum Beispiel in map.",
                "Zwischenergebnisse ohne eigene Struktur."
              ]
            },
            {
              "type": "code",
              "title": "pair als R√ºckgabewert",
              "language": "cpp",
              "code": "#include <utility>\n\nstd::pair<int, bool> parse(int x) {\n    if (x > 0) {\n        return {x, true};\n    }\n    return {0, false};\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::pair vs struct",
              "columns": ["std::pair", "struct"],
              "rows": [
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Geringer (first/second)", "H√∂her (sprechende Namen)"]
                },
                {
                  "aspect": "Aufwand",
                  "values": ["Sehr gering", "Etwas h√∂her"]
                },
                {
                  "aspect": "Flexibilit√§t",
                  "values": ["Begrenzt auf zwei Werte", "Beliebig erweiterbar"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unklare Bedeutung von first und second",
              "text": "Ohne Kontext ist oft unklar, wof√ºr first und second stehen, was die Lesbarkeit verschlechtert."
            },
            {
              "type": "important",
              "text": "std::pair ist ideal f√ºr einfache R√ºckgaben, aber kein Ersatz f√ºr gut benannte Strukturen."
            },
            {
              "type": "summary",
              "points": [
                "std::pair speichert genau zwei Werte",
                "Zugriff √ºber first und second",
                "make_pair erm√∂glicht Typableitung",
                "Vergleich erfolgt lexikografisch",
                "F√ºr einfache, kurzlebige Daten geeignet"
              ]
            }
          ]
        },
        {
          "title": "std::tuple",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::tuple",
              "text": "std::tuple ist ein Container, der eine feste Anzahl von Werten unterschiedlicher Typen in einer geordneten Struktur speichert."
            },
            {
              "type": "explanation",
              "title": "Grundidee von std::tuple",
              "text": [
                "std::tuple erweitert das Konzept von std::pair auf beliebig viele Elemente.",
                "Die Elemente werden positionsbasiert gespeichert und typisiert."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<tuple>"
              ]
            },
            {
              "type": "explanation",
              "title": "Erzeugen eines std::tuple",
              "text": [
                "Ein tuple wird mit festen Typen definiert.",
                "Die Anzahl und Reihenfolge der Typen ist Teil des Typs."
              ]
            },
            {
              "type": "code",
              "title": "Direkte Initialisierung",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nint main() {\n    std::tuple<int, double, std::string> t(1, 3.14, \"Hallo\");\n}\n"
            },
            {
              "type": "code",
              "title": "Initialisierung mit make_tuple",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nint main() {\n    auto t = std::make_tuple(2, 2.71, \"Welt\");\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf Elemente mit std::get",
              "text": [
                "Der Zugriff erfolgt √ºber den Index zur Compile-Zeit.",
                "Der Index muss ein Konstantenausdruck sein."
              ]
            },
            {
              "type": "code",
              "title": "Zugriff per Index",
              "language": "cpp",
              "code": "#include <tuple>\n#include <iostream>\n\nint main() {\n    auto t = std::make_tuple(10, 20.5, 'A');\n\n    std::cout << std::get<0>(t) << std::endl;\n    std::cout << std::get<1>(t) << std::endl;\n    std::cout << std::get<2>(t) << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff per Typ",
              "text": [
                "std::get kann auch mit einem Typ verwendet werden.",
                "Der Typ darf im tuple nur einmal vorkommen."
              ]
            },
            {
              "type": "code",
              "title": "Zugriff per Typ",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::tuple<int, std::string, double> t{1, \"Text\", 4.2};\n\n    std::cout << std::get<std::string>(t) << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "std::tie und Destrukturierung",
              "text": [
                "std::tie erlaubt das Entpacken eines tuple in einzelne Variablen.",
                "Nicht ben√∂tigte Werte k√∂nnen mit std::ignore √ºbersprungen werden."
              ]
            },
            {
              "type": "code",
              "title": "std::tie verwenden",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nint main() {\n    std::tuple<int, std::string, bool> t{5, \"OK\", true};\n\n    int id;\n    std::string text;\n    bool flag;\n\n    std::tie(id, text, flag) = t;\n}\n"
            },
            {
              "type": "code",
              "title": "std::ignore nutzen",
              "language": "cpp",
              "code": "#include <tuple>\n\nint main() {\n    std::tuple<int, double, int> t{1, 3.5, 9};\n\n    int a;\n    int c;\n    std::tie(a, std::ignore, c) = t;\n}\n"
            },
            {
              "type": "explanation",
              "title": "tuple als R√ºckgabewert",
              "text": [
                "Funktionen k√∂nnen mehrere Werte als tuple zur√ºckgeben.",
                "Dies vermeidet Hilfsstrukturen f√ºr einfache F√§lle."
              ]
            },
            {
              "type": "code",
              "title": "tuple als Funktionsr√ºckgabe",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nstd::tuple<int, std::string> parse(bool ok) {\n    if (ok) {\n        return {1, \"Erfolg\"};\n    }\n    return {0, \"Fehler\"};\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::tuple vs std::pair",
              "columns": ["std::tuple", "std::pair"],
              "rows": [
                {
                  "aspect": "Anzahl Elemente",
                  "values": ["Beliebig", "Genau zwei"]
                },
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Gering bei vielen Elementen", "Besser bei zwei Werten"]
                },
                {
                  "aspect": "Einsatzgebiet",
                  "values": ["Mehrere R√ºckgabewerte", "Einfache Paare"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Schlechte Lesbarkeit",
              "text": "tuple mit vielen Elementen und Positionszugriff kann schnell un√ºbersichtlich werden."
            },
            {
              "type": "important",
              "text": "std::tuple ist sinnvoll f√ºr technische R√ºckgaben, aber kein Ersatz f√ºr gut benannte Strukturen."
            },
            {
              "type": "summary",
              "points": [
                "std::tuple speichert mehrere typisierte Werte",
                "Zugriff erfolgt zur Compile-Zeit",
                "std::tie erm√∂glicht sauberes Entpacken",
                "Geeignet f√ºr mehrere R√ºckgabewerte",
                "Bei vielen Elementen leidet die Lesbarkeit"
              ]
            }
          ]
        }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
        {
          "title": "main.cpp Grundger√ºst",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Minimaler Einstiegspunkt",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Standardstruktur mit Ausgabe",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    std::cout << \"Programm gestartet\" << std::endl;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "main mit Argumenten",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main(int argc, char* argv[]) {\n    std::cout << \"Anzahl Argumente: \" << argc << std::endl;\n\n    for (int i = 0; i < argc; ++i) {\n        std::cout << \"Arg \" << i << \": \" << argv[i] << std::endl;\n    }\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Hello World",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    std::cout << \"Hello World\" << std::endl;\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Einfache Ein- und Ausgabe",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string name;\n    int alter;\n\n    std::cout << \"Name eingeben: \";\n    std::cin >> name;\n\n    std::cout << \"Alter eingeben: \";\n    std::cin >> alter;\n\n    std::cout << \"Hallo \" << name << \", du bist \" << alter << \" Jahre alt.\" << std::endl;\n\n    return 0;\n}\n"
            }
          ]
        }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
        {
          "title": "Header- und cpp-Datei Vorlage (.hpp mit Header-Guard)",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Klassen-Header (MyClass.hpp)",
              "language": "cpp",
              "code": "#ifndef MYCLASS_HPP\n#define MYCLASS_HPP\n\n#include <string>\n\nclass MyClass {\npublic:\n    MyClass();\n    explicit MyClass(const std::string& name);\n    ~MyClass();\n\n    void setName(const std::string& name);\n    std::string getName() const;\n\nprivate:\n    std::string name;\n};\n\n#endif // MYCLASS_HPP\n"
            },
            {
              "type": "code",
              "title": "Klassen-Implementierung (MyClass.cpp)",
              "language": "cpp",
              "code": "#include \"MyClass.hpp\"\n\nMyClass::MyClass() : name(\"default\") {}\n\nMyClass::MyClass(const std::string& name) : name(name) {}\n\nMyClass::~MyClass() {}\n\nvoid MyClass::setName(const std::string& name) {\n    this->name = name;\n}\n\nstd::string MyClass::getName() const {\n    return name;\n}\n"
            }
          ]
        },
        {
          "title": "Konstruktoren",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Konstruktor mit Initialisierungsliste (:)",
              "language": "cpp",
              "code": "#include <string>\n\nclass Person {\npublic:\n    Person(const std::string& name, int alter)\n        : name(name), alter(alter) // Initialisierungsliste\n    {}\n\nprivate:\n    std::string name;\n    int alter;\n};\n"
            },
            {
              "type": "code",
              "title": "Konstruktor mit mehreren Attributen und Defaultwerten",
              "language": "cpp",
              "code": "#include <string>\n\nclass Fahrzeug {\npublic:\n    Fahrzeug(const std::string& marke, int baujahr, double preis)\n        : marke(marke), baujahr(baujahr), preis(preis)\n    {}\n\nprivate:\n    std::string marke;\n    int baujahr;\n    double preis;\n};\n"
            },
            {
              "type": "code",
              "title": "Initialisierung im Konstruktor-Rumpf ({ })",
              "language": "cpp",
              "code": "#include <string>\n\nclass Benutzer {\npublic:\n    Benutzer(const std::string& name, int alter) {\n        this->name = name;   // Zuweisung im Rumpf\n        this->alter = alter;\n    }\n\nprivate:\n    std::string name;\n    int alter;\n};\n"
            },
            {
              "type": "code",
              "title": "Kombination aus Initialisierungsliste und Rumpf",
              "language": "cpp",
              "code": "#include <string>\n#include <iostream>\n\nclass Konto {\npublic:\n    Konto(const std::string& inhaber, double startGuthaben)\n        : inhaber(inhaber), guthaben(startGuthaben)\n    {\n        // Zus√§tzliche Logik im Rumpf\n        std::cout << \"Konto erstellt\" << std::endl;\n    }\n\nprivate:\n    std::string inhaber;\n    double guthaben;\n};\n"
            },
            {
              "type": "code",
              "title": "Konstruktor mit Defaultwerten in der Signatur",
              "language": "cpp",
              "code": "#include <string>\n\nclass Benutzer {\npublic:\n    Benutzer(const std::string& name = \"Unbekannt\", int alter = 0)\n        : name(name), alter(alter)\n    {}\n\nprivate:\n    std::string name;\n    int alter;\n};\n"
            },
            {
              "type": "code",
              "title": "Konstruktor mit Defaultwerten und zus√§tzlicher Logik",
              "language": "cpp",
              "code": "#include <string>\n#include <iostream>\n\nclass Konto {\npublic:\n    Konto(const std::string& inhaber = \"Gast\", double guthaben = 0.0)\n        : inhaber(inhaber), guthaben(guthaben)\n    {\n        // Zus√§tzliche Initialisierungslogik\n        std::cout << \"Konto erstellt\" << std::endl;\n    }\n\nprivate:\n    std::string inhaber;\n    double guthaben;\n};\n"
            }
          ]
        }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
        {
          "title": "std::vector Vorlage",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Vector Grundger√ºst",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Vector mit Initialisierung",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Elemente hinzuf√ºgen und entfernen",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v;\n\n    v.push_back(1);\n    v.push_back(2);\n    v.emplace_back(3);\n\n    v.pop_back();\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Iteration √ºber vector",
              "language": "cpp",
              "code": "#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> v = {1, 2, 3};\n\n    for (int x : v) {\n        std::cout << x << std::endl;\n    }\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Zugriff auf Elemente",
              "language": "cpp",
              "code": "#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> v = {10, 20, 30};\n\n    int a = v[0];      // kein Bounds-Check\n    int b = v.at(1);   // mit Bounds-Check\n\n    std::cout << a << \" \" << b << std::endl;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Vector reservieren",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v;\n\n    v.reserve(100); // Speicher vorab reservieren\n\n    return 0;\n}\n"
            }
          ]
        },
        {
          "title": "std::map Vorlage",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "map Grundger√ºst",
              "language": "cpp",
              "code": "#include <map>\n\nint main() {\n    std::map<int, int> m;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "map mit Initialisierung",
              "language": "cpp",
              "code": "#include <map>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m = {\n        {1, \"eins\"},\n        {2, \"zwei\"},\n        {3, \"drei\"}\n    };\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Elemente einf√ºgen",
              "language": "cpp",
              "code": "#include <map>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m;\n\n    m.insert({1, \"eins\"});\n    m[2] = \"zwei\"; // erzeugt Eintrag falls nicht vorhanden\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Zugriff und Suche",
              "language": "cpp",
              "code": "#include <map>\n#include <iostream>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m = {{1, \"eins\"}, {2, \"zwei\"}};\n\n    if (m.count(1)) {\n        std::cout << m[1] << std::endl;\n    }\n\n    auto it = m.find(2);\n    if (it != m.end()) {\n        std::cout << it->second << std::endl;\n    }\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Iteration √ºber map",
              "language": "cpp",
              "code": "#include <map>\n#include <iostream>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m = {{2, \"zwei\"}, {1, \"eins\"}};\n\n    for (const auto& pair : m) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Elemente entfernen",
              "language": "cpp",
              "code": "#include <map>\n\nint main() {\n    std::map<int, int> m = {{1, 10}, {2, 20}, {3, 30}};\n\n    m.erase(2); // entfernt Schl√ºssel 2\n    m.clear();  // entfernt alle Elemente\n\n    return 0;\n}\n"
            }
          ]
        },
        {
          "title": "std::pair und std::tuple Vorlage",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "std::pair Grundger√ºst",
              "language": "cpp",
              "code": "#include <utility>\n\nint main() {\n    std::pair<int, double> p;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "std::pair mit Initialisierung",
              "language": "cpp",
              "code": "#include <utility>\n#include <string>\n\nint main() {\n    std::pair<int, std::string> p1(1, \"eins\");\n    std::pair<int, std::string> p2 = {2, \"zwei\"};\n    auto p3 = std::make_pair(3, \"drei\");\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Zugriff auf pair",
              "language": "cpp",
              "code": "#include <utility>\n#include <iostream>\n\nint main() {\n    std::pair<int, int> p = {10, 20};\n\n    std::cout << p.first << std::endl;\n    std::cout << p.second << std::endl;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "std::tuple Grundger√ºst",
              "language": "cpp",
              "code": "#include <tuple>\n\nint main() {\n    std::tuple<int, double, char> t;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "std::tuple mit Initialisierung",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nint main() {\n    std::tuple<int, std::string, double> t1(1, \"eins\", 1.5);\n    auto t2 = std::make_tuple(2, \"zwei\", 2.5);\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Zugriff auf tuple",
              "language": "cpp",
              "code": "#include <tuple>\n#include <iostream>\n\nint main() {\n    std::tuple<int, int, int> t = {1, 2, 3};\n\n    std::cout << std::get<0>(t) << std::endl;\n    std::cout << std::get<1>(t) << std::endl;\n    std::cout << std::get<2>(t) << std::endl;\n\n    return 0;\n}\n"
            },
            {
              "type": "code",
              "title": "Strukturierte Bindung mit tuple",
              "language": "cpp",
              "code": "#include <tuple>\n#include <string>\n\nint main() {\n    std::tuple<int, std::string, double> t = {1, \"eins\", 3.14};\n\n    auto [id, name, wert] = t;\n\n    return 0;\n}\n"
            }
          ]
        }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
        {
          "title": "CMakeLists.txt Vorlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Minimale CMakeLists.txt",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(MeinProjekt LANGUAGES CXX)\n\nadd_executable(MeinProgramm main.cpp)\n"
            },
            {
              "type": "code",
              "title": "CMakeLists.txt mit C++ Standard",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(MeinProjekt LANGUAGES CXX)\n\nadd_executable(MeinProgramm main.cpp)\n\ntarget_compile_features(MeinProgramm PRIVATE cxx_std_20)\n"
            },
            {
              "type": "code",
              "title": "Projekt mit mehreren Quelldateien",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(MehrDateien LANGUAGES CXX)\n\nadd_executable(App\n    main.cpp\n    foo.cpp\n    foo.hpp\n)\n\ntarget_compile_features(App PRIVATE cxx_std_20)\n"
            },
            {
              "type": "code",
              "title": "Projekt mit Bibliothek",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(BibliotheksProjekt LANGUAGES CXX)\n\nadd_library(util util.cpp util.hpp)\nadd_executable(App main.cpp)\n\ntarget_compile_features(util PUBLIC cxx_std_20)\n\ntarget_link_libraries(App PRIVATE util)\n"
            },
            {
              "type": "code",
              "title": "Include-Verzeichnisse pro Target",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(IncludeBeispiel LANGUAGES CXX)\n\nadd_executable(App main.cpp)\n\ntarget_include_directories(App\n    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include\n)\n"
            },
            {
              "type": "code",
              "title": "Build-Typ und Compiler-Optionen",
              "language": "cpp",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nproject(BuildTyp LANGUAGES CXX)\n\nadd_executable(App main.cpp)\n\ntarget_compile_features(App PRIVATE cxx_std_20)\n\ntarget_compile_options(App PRIVATE -Wall -Wextra -Wpedantic)\n"
            }
          ]
        },
        {
          "title": "Projektvorlagen - Ordnerstruktur",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "code",
              "title": "Ordnerstruktur Vorlage",
              "language": "cpp",
              "code": "// Projektname/\n// ‚îú‚îÄ CMakeLists.txt\n// ‚îú‚îÄ src/\n// ‚îÇ  ‚îú‚îÄ main.cpp\n// ‚îÇ  ‚îú‚îÄ app.cpp\n// ‚îÇ  ‚îî‚îÄ app.hpp\n// ‚îú‚îÄ include/\n// ‚îÇ  ‚îî‚îÄ app.hpp\n// ‚îú‚îÄ tests/\n// ‚îÇ  ‚îî‚îÄ test_app.cpp\n// ‚îî‚îÄ build/\n//    ‚îî‚îÄ (Build-Ausgabe)\n"
            },
            {
              "type": "code",
              "title": "Modulares Projekt Setup",
              "language": "cpp",
              "code": "// Projektname/\n// ‚îú‚îÄ CMakeLists.txt\n// ‚îú‚îÄ src/\n// ‚îÇ  ‚îú‚îÄ main.cpp\n// ‚îÇ  ‚îî‚îÄ CMakeLists.txt\n// ‚îú‚îÄ core/\n// ‚îÇ  ‚îú‚îÄ core.cpp\n// ‚îÇ  ‚îú‚îÄ core.hpp\n// ‚îÇ  ‚îî‚îÄ CMakeLists.txt\n// ‚îú‚îÄ utils/\n// ‚îÇ  ‚îú‚îÄ utils.cpp\n// ‚îÇ  ‚îú‚îÄ utils.hpp\n// ‚îÇ  ‚îî‚îÄ CMakeLists.txt\n// ‚îú‚îÄ include/\n// ‚îÇ  ‚îú‚îÄ core.hpp\n// ‚îÇ  ‚îî‚îÄ utils.hpp\n// ‚îî‚îÄ build/\n//    ‚îî‚îÄ (Build-Ausgabe)\n"
            }
          ]
        }
        ]
      }
    ]
  },






  {
    "category": "SQL",
    "icon": "</>",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üìò",
        "topics": [
        {
          "title": "Was ist SQL",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "SQL",
              "text": "SQL ist eine deklarative Sprache zur Definition, Abfrage und √Ñnderung von Daten in relationalen Datenbanken."
            },
            {
              "type": "explanation",
              "title": "SQL als Sprache",
              "text": [
                "SQL beschreibt, was mit den Daten passieren soll.",
                "Der konkrete Ausf√ºhrungsplan wird von der Datenbank bestimmt.",
                "SQL ist unabh√§ngig von der Programmiersprache."
              ]
            },
            {
              "type": "explanation",
              "title": "Was man mit SQL macht",
              "text": [
                "Tabellen und Strukturen definieren.",
                "Daten speichern, √§ndern und l√∂schen.",
                "Daten gezielt abfragen."
              ]
            },
            {
              "type": "list",
              "title": "Typische SQL Aufgaben",
              "items": [
                "Tabellen anlegen",
                "Datens√§tze einf√ºgen",
                "Datens√§tze abfragen",
                "Datens√§tze aktualisieren",
                "Datens√§tze l√∂schen"
              ]
            },
            {
              "type": "explanation",
              "title": "Abfrage vs √Ñnderung",
              "text": [
                "Abfragen lesen Daten aus der Datenbank.",
                "√Ñnderungen ver√§ndern den Zustand der Datenbank.",
                "Beide Kategorien haben unterschiedliche R√ºckgabewerte."
              ]
            },
            {
              "type": "comparison",
              "title": "Abfrage vs √Ñnderung",
              "columns": ["Abfrage", "√Ñnderung"],
              "rows": [
                {
                  "aspect": "Ziel",
                  "values": ["Daten lesen", "Daten ver√§ndern"]
                },
                {
                  "aspect": "Typische Befehle",
                  "values": ["SELECT", "INSERT, UPDATE, DELETE"]
                },
                {
                  "aspect": "Ergebnis",
                  "values": ["Ergebniszeilen", "SQLITE_DONE"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "SQL als Programmiersprache verstehen",
              "text": "SQL beschreibt Datenoperationen, ist aber keine allgemeine Programmiersprache mit Schleifen oder Variablen."
            },
            {
              "type": "important",
              "text": "SQL definiert den Datenzugriff, nicht die Gesch√§ftslogik der Anwendung."
            },
            {
              "type": "summary",
              "points": [
                "SQL ist eine deklarative Datenbanksprache",
                "SQL ist unabh√§ngig von C++ oder SQLite",
                "Mit SQL werden Daten gelesen und ver√§ndert",
                "SELECT ist Abfrage, INSERT UPDATE DELETE sind √Ñnderungen",
                "Abfragen und √Ñnderungen haben unterschiedliche Ergebnisse"
              ]
            }
          ]
        },


        {
          "title": "Tabellen und Zeilen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Tabelle",
              "text": "Eine Tabelle ist eine strukturierte Sammlung von Daten, organisiert in Spalten und Zeilen."
            },
            {
              "type": "explanation",
              "title": "Tabelle als Raster",
              "text": [
                "Eine Tabelle kann als zweidimensionales Raster verstanden werden.",
                "Spalten definieren die Struktur der Daten.",
                "Zeilen enthalten die konkreten Datens√§tze."
              ]
            },
            {
              "type": "explanation",
              "title": "Spalten",
              "text": [
                "Spalten legen fest, welche Art von Daten gespeichert wird.",
                "Jede Spalte hat einen Namen und einen Datentyp.",
                "Alle Zeilen einer Tabelle folgen derselben Spaltenstruktur."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: Tabelle mit Spalten",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    age INTEGER\n);\n"
            },
            {
              "type": "explanation",
              "title": "Zeilen und Datens√§tze",
              "text": [
                "Eine Zeile repr√§sentiert genau einen Datensatz.",
                "Alle Spalten der Tabelle haben in jeder Zeile einen Wert oder NULL.",
                "Mehrere Zeilen bilden die eigentlichen Inhalte der Tabelle."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: Datens√§tze einf√ºgen",
              "language": "sql",
              "code": "INSERT INTO users (id, name, age) VALUES (1, 'Max', 30);\nINSERT INTO users (id, name, age) VALUES (2, 'Anna', 25);\n"
            },
            {
              "type": "comparison",
              "title": "Spalte vs Zeile",
              "columns": ["Spalte", "Zeile"],
              "rows": [
                {
                  "aspect": "Bedeutung",
                  "values": ["Struktur", "Datensatz"]
                },
                {
                  "aspect": "Anzahl",
                  "values": ["Fest definiert", "Beliebig viele"]
                },
                {
                  "aspect": "Inhalt",
                  "values": ["Datentyp", "Konkrete Werte"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Spaltenstruktur √§ndern",
              "text": "Eine nachtr√§gliche √Ñnderung der Spaltenstruktur kann bestehende Datens√§tze ung√ºltig machen oder Migrationsaufwand erzeugen."
            },
            {
              "type": "important",
              "text": "Die Tabellenstruktur sollte vor der Dateneingabe sorgf√§ltig geplant werden."
            },
            {
              "type": "summary",
              "points": [
                "Tabellen sind Raster aus Spalten und Zeilen",
                "Spalten definieren die Struktur",
                "Zeilen sind einzelne Datens√§tze",
                "Alle Zeilen folgen derselben Struktur",
                "Gute Tabellenstruktur ist entscheidend f√ºr saubere Daten"
              ]
            }
          ]
        },


        {
          "title": "Einfache CREATE TABLE",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Minimalbeispiel",
              "text": [
                "Eine Tabelle wird mit CREATE TABLE angelegt.",
                "Spaltenname und Typ reichen f√ºr den Anfang.",
                "IF NOT EXISTS verhindert Fehler bei erneutem Ausf√ºhren."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches CREATE TABLE",
              "language": "sql",
              "code": "CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    age INTEGER\n);\n"
            },
            {
              "type": "explanation",
              "title": "In C++ ausf√ºhren",
              "text": [
                "Das SQL wird einmal ausgef√ºhrt, meist beim Programmstart.",
                "Keine Parameter, kein Ergebnis.",
                "Erfolg bedeutet SQLITE_DONE."
              ]
            },
            {
              "type": "code",
              "title": "CREATE TABLE mit Database::execute",
              "language": "cpp",
              "code": "Database db(\"data.db\");\n\ndb.execute(\n    \"CREATE TABLE IF NOT EXISTS users (\"\n    \"id INTEGER PRIMARY KEY,\"\n    \"name TEXT,\"\n    \"age INTEGER\"\n    \");\"\n);\n"
            },
            {
              "type": "important",
              "text": "CREATE TABLE wird typischerweise beim Initialisieren der Datenbank ausgef√ºhrt."
            },
            {
              "type": "summary",
              "points": [
                "CREATE TABLE legt eine Tabelle an",
                "IF NOT EXISTS vermeidet Fehler",
                "Keine Parameter notwendig",
                "Kein Ergebnis, nur Ausf√ºhrung",
                "Ideal f√ºr den Einstieg"
              ]
            }
          ]
        },




        {
          "title": "CREATE TABLE Parameter",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Spaltenparameter in der Praxis",
              "text": [
                "CREATE TABLE definiert Spalten mit Typen und einfachen Eigenschaften.",
                "Die Parameter stehen direkt hinter dem Spaltennamen.",
                "SQLite ist flexibel, aber saubere Definitionen sind wichtig."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Beispiel mit Parametern",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    age INTEGER,\n    weight REAL,\n    note TEXT NULL\n);\n"
            },
            {
              "type": "explanation",
              "title": "INTEGER PRIMARY KEY",
              "text": [
                "INTEGER PRIMARY KEY macht die Spalte zur eindeutigen ID.",
                "Der Wert identifiziert jede Zeile eindeutig.",
                "In SQLite ist diese Spalte intern mit der RowID verkn√ºpft."
              ]
            },
            {
              "type": "explanation",
              "title": "AUTOINCREMENT",
              "text": [
                "AUTOINCREMENT sorgt daf√ºr, dass IDs strikt monoton steigen.",
                "Ohne AUTOINCREMENT vergibt SQLite ebenfalls automatisch IDs.",
                "AUTOINCREMENT wird nur ben√∂tigt, wenn alte IDs niemals wiederverwendet werden d√ºrfen."
              ]
            },
            {
              "type": "explanation",
              "title": "TEXT",
              "text": [
                "TEXT speichert Zeichenketten.",
                "Die L√§nge ist nicht fest begrenzt.",
                "Geeignet f√ºr Namen, Beschreibungen und freie Texte."
              ]
            },
            {
              "type": "explanation",
              "title": "INTEGER",
              "text": [
                "INTEGER speichert Ganzzahlen.",
                "Typisch f√ºr Z√§hler, Alterswerte oder Flags.",
                "Kann auch f√ºr Booleans genutzt werden (0 oder 1)."
              ]
            },
            {
              "type": "explanation",
              "title": "REAL (DOUBLE)",
              "text": [
                "REAL speichert Gleitkommazahlen.",
                "SQLite verwendet intern 64 Bit Floating Point.",
                "DOUBLE ist kein eigener SQLite Typ, wird aber auf REAL abgebildet."
              ]
            },
            {
              "type": "explanation",
              "title": "NULL und NOT NULL",
              "text": [
                "NULL bedeutet, dass kein Wert vorhanden ist.",
                "NOT NULL erzwingt, dass immer ein Wert gesetzt sein muss.",
                "NOT NULL sch√ºtzt vor unvollst√§ndigen Datens√§tzen."
              ]
            },
            {
              "type": "comparison",
              "title": "Typische Spaltentypen",
              "columns": ["Typ", "Verwendung"],
              "rows": [
                {
                  "aspect": "INTEGER",
                  "values": ["IDs, Z√§hler", "Ganzzahlen"]
                },
                {
                  "aspect": "TEXT",
                  "values": ["Namen, Strings", "Beschreibungen"]
                },
                {
                  "aspect": "REAL",
                  "values": ["Messwerte", "Dezimalzahlen"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "UNIQUE",
              "text": [
                "UNIQUE erzwingt, dass ein Wert in einer Spalte eindeutig ist.",
                "Doppelte Werte sind nicht erlaubt.",
                "NULL Werte sind bei UNIQUE erlaubt, da NULL kein Wert ist."
              ]
            },
            {
              "type": "code",
              "title": "UNIQUE Spalte",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    email TEXT UNIQUE,\n    name TEXT\n);\n"
            },
            {
              "type": "explanation",
              "title": "UNIQUE Verhalten",
              "text": [
                "Beim INSERT oder UPDATE pr√ºft SQLite die Eindeutigkeit.",
                "Ein Versto√ü f√ºhrt zu SQLITE_CONSTRAINT.",
                "Die Operation wird abgebrochen."
              ]
            },
            {
              "type": "explanation",
              "title": "Mehrere Spalten eindeutig machen",
              "text": [
                "UNIQUE kann sich √ºber mehrere Spalten erstrecken.",
                "Die Kombination der Werte muss eindeutig sein.",
                "Einzelne Werte d√ºrfen sich wiederholen."
              ]
            },
            {
              "type": "code",
              "title": "Zusammengesetztes UNIQUE",
              "language": "sql",
              "code": "CREATE TABLE appointments (\n    user_id INTEGER,\n    date TEXT,\n    UNIQUE (user_id, date)\n);\n"
            },
            {
              "type": "comparison",
              "title": "UNIQUE vs PRIMARY KEY",
              "columns": ["UNIQUE", "PRIMARY KEY"],
              "rows": [
                {
                  "aspect": "Eindeutigkeit",
                  "values": ["Ja", "Ja"]
                },
                {
                  "aspect": "NULL erlaubt",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Anzahl pro Tabelle",
                  "values": ["Mehrere m√∂glich", "Genau einer"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "UNIQUE als Ersatz f√ºr Primary Key",
              "text": "UNIQUE garantiert Eindeutigkeit, ersetzt aber keinen Primary Key f√ºr eindeutige Identifikation."
            },
            {
              "type": "important",
              "text": "UNIQUE wird f√ºr fachlich eindeutige Werte wie E Mail Adressen verwendet."
            },
            {
              "type": "pitfall",
              "title": "AUTOINCREMENT blind verwenden",
              "text": "AUTOINCREMENT ist meist unn√∂tig und kann Performance kosten. INTEGER PRIMARY KEY reicht in den meisten F√§llen aus."
            },
            {
              "type": "important",
              "text": "SQLite Typen sind flexibel, aber klare Spaltenparameter verhindern sp√§tere Datenprobleme."
            },
            {
              "type": "summary",
              "points": [
                "Spaltenparameter stehen direkt im CREATE TABLE",
                "INTEGER PRIMARY KEY definiert die ID",
                "AUTOINCREMENT nur bei echtem Bedarf",
                "TEXT f√ºr Strings, INTEGER f√ºr Ganzzahlen, REAL f√ºr Gleitkomma",
                "NOT NULL erzwingt vollst√§ndige Datens√§tze"
              ]
            }
          ]
        }




        ]
      },


      {
        "name": "Daten abfragen",
        "icon": "üîç",
        "topics": [
        {
          "title": "SELECT Grundform",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Grundstruktur",
              "text": [
                "SELECT liest Daten aus einer Tabelle.",
                "Die Spalten werden explizit angegeben.",
                "FROM definiert die Tabelle."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches SELECT",
              "language": "sql",
              "code": "SELECT id, name, age FROM users;\n"
            },
            {
              "type": "explanation",
              "title": "Spalten ausw√§hlen",
              "text": [
                "Es k√∂nnen einzelne oder mehrere Spalten ausgew√§hlt werden.",
                "Die Reihenfolge der Spalten bestimmt die Reihenfolge im Ergebnis.",
                "Die Spaltennamen m√ºssen in der Tabelle existieren."
              ]
            },
            {
              "type": "code",
              "title": "Nur bestimmte Spalten",
              "language": "sql",
              "code": "SELECT name FROM users;\n"
            },
            {
              "type": "explanation",
              "title": "Alle Spalten ausw√§hlen",
              "text": [
                "Mit * werden alle Spalten ausgew√§hlt.",
                "Die Reihenfolge entspricht der Tabellendefinition.",
                "* ist praktisch zum Testen, aber ungeeignet f√ºr Produktivcode."
              ]
            },
            {
              "type": "code",
              "title": "SELECT mit *",
              "language": "sql",
              "code": "SELECT * FROM users;\n"
            },
            {
              "type": "pitfall",
              "title": "SELECT * im Code verwenden",
              "text": "SELECT * bricht leicht, wenn sich die Tabellenstruktur √§ndert. Spalten sollten immer explizit angegeben werden."
            },
            {
              "type": "important",
              "text": "Die Spaltenreihenfolge im SELECT muss zum sp√§teren Spaltenlesen passen."
            },
            {
              "type": "explanation",
              "title": "DISTINCT",
              "text": [
                "DISTINCT entfernt doppelte Zeilen im Ergebnis.",
                "Es bezieht sich auf die gesamte ausgew√§hlte Spaltenkombination.",
                "Nur eindeutige Werte werden zur√ºckgegeben."
              ]
            },
            {
              "type": "code",
              "title": "DISTINCT Beispiel",
              "language": "sql",
              "code": "SELECT DISTINCT age FROM users;\n"
            },
            {
              "type": "explanation",
              "title": "DISTINCT mit mehreren Spalten",
              "text": [
                "Bei mehreren Spalten gilt DISTINCT f√ºr die Kombination aller Spalten.",
                "Nur identische Kombinationen werden entfernt.",
                "Einzelne Spaltenwerte k√∂nnen sich weiterhin wiederholen."
              ]
            },
            {
              "type": "code",
              "title": "DISTINCT mit mehreren Spalten",
              "language": "sql",
              "code": "SELECT DISTINCT age, name FROM users;\n"
            },
            {
              "type": "pitfall",
              "title": "DISTINCT als Ersatz f√ºr saubere Modellierung",
              "text": "DISTINCT sollte nicht verwendet werden, um fehlerhafte oder doppelte Daten im Schema zu kaschieren."
            },
            {
              "type": "important",
              "text": "DISTINCT ver√§ndert nur das Ergebnis einer Abfrage, nicht die gespeicherten Daten."
            },
            {
              "type": "summary",
              "points": [
                "SELECT liest Daten aus Tabellen",
                "Spalten werden vor FROM angegeben",
                "FROM definiert die Tabelle",
                "SELECT * ist nur f√ºr schnelle Tests geeignet",
                "Explizite Spalten sind robuster",
                "DISTINCT entfernt doppelte Ergebniszeilen"
              ]
            }
          ]
        },


        {
          "title": "WHERE filtern",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "WHERE Grundidee",
              "text": [
                "WHERE filtert Zeilen nach Bedingungen.",
                "Nur Zeilen, die die Bedingung erf√ºllen, werden ausgew√§hlt.",
                "Ohne WHERE werden alle Zeilen gelesen."
              ]
            },
            {
              "type": "explanation",
              "title": "Vergleichsoperatoren",
              "text": [
                "= pr√ºft auf Gleichheit.",
                "< und > vergleichen numerische Werte.",
                "<= und >= sind ebenfalls m√∂glich."
              ]
            },
            {
              "type": "code",
              "title": "Vergleiche mit WHERE",
              "language": "sql",
              "code": "SELECT * FROM users WHERE age = 30;\nSELECT * FROM users WHERE age > 18;\nSELECT * FROM users WHERE age < 65;\n"
            },
            {
              "type": "explanation",
              "title": "Ungleich Operatoren (!= und <>)",
              "text": [
                "!= pr√ºft auf Ungleichheit.",
                "<> ist die Standard SQL Schreibweise f√ºr Ungleichheit.",
                "Beide Varianten funktionieren in SQLite."
              ]
            },
            {
              "type": "code",
              "title": "Ungleich Vergleich",
              "language": "sql",
              "code": "SELECT * FROM users WHERE age != 30;\nSELECT * FROM users WHERE age <> 30;\n"
            },
            {
              "type": "explanation",
              "title": "AND und OR",
              "text": [
                "AND verkn√ºpft mehrere Bedingungen, die alle erf√ºllt sein m√ºssen.",
                "OR verkn√ºpft Bedingungen, von denen mindestens eine erf√ºllt sein muss.",
                "Klammern steuern die Auswertungsreihenfolge."
              ]
            },
            {
              "type": "code",
              "title": "Mehrere Bedingungen",
              "language": "sql",
              "code": "SELECT * FROM users WHERE age > 18 AND age < 65;\nSELECT * FROM users WHERE age < 18 OR age > 65;\n"
            },
            {
              "type": "explanation",
              "title": "LIKE",
              "text": [
                "LIKE erm√∂glicht einfache Textmuster.",
                "% steht f√ºr beliebig viele Zeichen.",
                "_ steht f√ºr genau ein Zeichen."
              ]
            },
            {
              "type": "code",
              "title": "LIKE Beispiele",
              "language": "sql",
              "code": "SELECT * FROM users WHERE name LIKE 'Max%';\nSELECT * FROM users WHERE name LIKE '%mann';\nSELECT * FROM users WHERE name LIKE 'M_x';\n"
            },
            {
              "type": "pitfall",
              "title": "LIKE und Gro√ü Kleinschreibung",
              "text": "LIKE ist in SQLite standardm√§√üig nicht case sensitiv, abh√§ngig von Collation."
            },
            {
              "type": "explanation",
              "title": "NOT",
              "text": [
                "NOT negiert eine Bedingung.",
                "Die logische Aussage wird umgedreht.",
                "Kann mit LIKE, IN, BETWEEN und anderen Bedingungen kombiniert werden."
              ]
            },
            {
              "type": "code",
              "title": "NOT Beispiele",
              "language": "sql",
              "code": "SELECT * FROM users WHERE NOT age = 30;\nSELECT * FROM users WHERE NOT name LIKE 'M%';\n"
            },
            {
              "type": "explanation",
              "title": "IN",
              "text": [
                "IN pr√ºft, ob ein Wert in einer Liste enthalten ist.",
                "Mehrere OR Bedingungen werden kompakt zusammengefasst.",
                "Sehr n√ºtzlich bei ID Listen."
              ]
            },
            {
              "type": "code",
              "title": "IN Beispiel",
              "language": "sql",
              "code": "SELECT * FROM users WHERE age IN (18, 21, 25);\n"
            },
            {
              "type": "explanation",
              "title": "BETWEEN",
              "text": [
                "BETWEEN pr√ºft, ob ein Wert in einem Bereich liegt.",
                "Die Grenzwerte sind inklusive.",
                "Entspricht >= und <= Kombination."
              ]
            },
            {
              "type": "code",
              "title": "BETWEEN Beispiel",
              "language": "sql",
              "code": "SELECT * FROM users WHERE age BETWEEN 18 AND 30;\n"
            },
            {
              "type": "explanation",
              "title": "Klammern ( )",
              "text": [
                "Klammern steuern die logische Auswertung.",
                "Sie sind wichtig bei Kombination von AND und OR.",
                "Ohne Klammern kann die Logik falsch interpretiert werden."
              ]
            },
            {
              "type": "code",
              "title": "Klammern Beispiel",
              "language": "sql",
              "code": "SELECT * FROM users\nWHERE (age > 18 AND age < 65)\n   OR name LIKE 'M%';\n"
            },
            {
              "type": "pitfall",
              "title": "Operator Priorit√§t ignorieren",
              "text": "AND wird vor OR ausgewertet. Ohne Klammern entstehen oft falsche Ergebnisse."
            },
            {
              "type": "important",
              "text": "Komplexe WHERE Bedingungen sollten immer mit Klammern strukturiert werden."
            },
            {
              "type": "important",
              "text": "Filter sollten so spezifisch wie n√∂tig sein, um unn√∂tige Daten zu vermeiden."
            },
            {
              "type": "summary",
              "points": [
                "WHERE filtert Zeilen",
                "Vergleichsoperatoren = < > sind Standard",
                "!= und <> pr√ºfen auf Ungleichheit",
                "AND und OR verkn√ºpfen Bedingungen",
                "LIKE filtert nach Textmustern",
                "Klammern sorgen f√ºr klare Logik",
                "NOT negiert Bedingungen",
                "IN ersetzt mehrere OR Vergleiche",
                "BETWEEN pr√ºft Wertebereiche"
              ]
            }
          ]
        },


        {
          "title": "ORDER BY",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Sortieren mit ORDER BY",
              "text": [
                "ORDER BY sortiert das Ergebnis einer SELECT Abfrage.",
                "Die Sortierung erfolgt nach einer oder mehreren Spalten.",
                "Ohne ORDER BY ist die Reihenfolge nicht definiert."
              ]
            },
            {
              "type": "explanation",
              "title": "ASC und DESC",
              "text": [
                "ASC sortiert aufsteigend.",
                "DESC sortiert absteigend.",
                "ASC ist der Standard und kann weggelassen werden."
              ]
            },
            {
              "type": "code",
              "title": "ORDER BY Beispiele",
              "language": "sql",
              "code": "SELECT * FROM users ORDER BY age ASC;\nSELECT * FROM users ORDER BY age DESC;\n"
            },
            {
              "type": "explanation",
              "title": "Mehrere Spalten sortieren",
              "text": [
                "ORDER BY kann mehrere Spalten enthalten.",
                "Die Sortierung erfolgt von links nach rechts.",
                "Sekund√§re Sortierungen greifen bei gleichen Werten."
              ]
            },
            {
              "type": "code",
              "title": "Sortieren nach mehreren Spalten",
              "language": "sql",
              "code": "SELECT * FROM users ORDER BY age DESC, name ASC;\n"
            },
            {
              "type": "pitfall",
              "title": "ORDER BY vergessen",
              "text": "Ohne ORDER BY darf man sich niemals auf eine bestimmte Reihenfolge verlassen."
            },
            {
              "type": "important",
              "text": "Die gew√ºnschte Reihenfolge muss immer explizit mit ORDER BY angegeben werden."
            },
            {
              "type": "summary",
              "points": [
                "ORDER BY sortiert SELECT Ergebnisse",
                "ASC bedeutet aufsteigend",
                "DESC bedeutet absteigend",
                "Mehrere Spalten sind m√∂glich",
                "Ohne ORDER BY ist die Reihenfolge undefiniert"
              ]
            }
          ]
        },

        {
          "title": "LIMIT",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Ergebnisanzahl begrenzen",
              "text": [
                "LIMIT begrenzt die Anzahl der zur√ºckgegebenen Zeilen.",
                "Die Abfrage liefert h√∂chstens die angegebene Anzahl.",
                "Besonders n√ºtzlich bei gro√üen Tabellen."
              ]
            },
            {
              "type": "code",
              "title": "LIMIT Beispiel",
              "language": "sql",
              "code": "SELECT * FROM users LIMIT 5;\n"
            },
            {
              "type": "explanation",
              "title": "LIMIT mit ORDER BY",
              "text": [
                "LIMIT wird h√§ufig mit ORDER BY kombiniert.",
                "So werden die ersten oder letzten Eintr√§ge gezielt ausgew√§hlt.",
                "Die Sortierung wird vor dem LIMIT angewendet."
              ]
            },
            {
              "type": "code",
              "title": "ORDER BY und LIMIT",
              "language": "sql",
              "code": "SELECT * FROM users ORDER BY age DESC LIMIT 3;\n"
            },
            {
              "type": "explanation",
              "title": "LIMIT und OFFSET",
              "text": [
                "OFFSET √ºberspringt eine bestimmte Anzahl von Zeilen.",
                "Wird h√§ufig f√ºr Pagination verwendet.",
                "LIMIT und OFFSET arbeiten zusammen."
              ]
            },
            {
              "type": "code",
              "title": "LIMIT mit OFFSET",
              "language": "sql",
              "code": "SELECT * FROM users ORDER BY id LIMIT 5 OFFSET 10;\n"
            },
            {
              "type": "pitfall",
              "title": "LIMIT ohne ORDER BY",
              "text": "LIMIT ohne ORDER BY liefert beliebige Zeilen und ist meist nicht sinnvoll."
            },
            {
              "type": "important",
              "text": "LIMIT bestimmt nur die Anzahl, nicht welche Zeilen gew√§hlt werden."
            },
            {
              "type": "summary",
              "points": [
                "LIMIT begrenzt die Anzahl der Ergebnisse",
                "ORDER BY bestimmt welche Zeilen ausgew√§hlt werden",
                "OFFSET √ºberspringt Zeilen",
                "Typisch f√ºr Listen und Pagination",
                "Ohne ORDER BY ist LIMIT nicht deterministisch"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "Daten √§ndern",
        "icon": "‚úèÔ∏è",
        "topics": [
        {
          "title": "INSERT",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Neue Zeile einf√ºgen",
              "text": [
                "INSERT f√ºgt einen neuen Datensatz in eine Tabelle ein.",
                "Es wird genau eine neue Zeile erzeugt.",
                "Die angegebenen Spalten erhalten die √ºbergebenen Werte."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches INSERT",
              "language": "sql",
              "code": "INSERT INTO users (name, age) VALUES ('Max', 30);\n"
            },
            {
              "type": "explanation",
              "title": "Spalten explizit angeben",
              "text": [
                "Die Spaltenliste sollte immer explizit angegeben werden.",
                "Die Reihenfolge der Werte muss zur Spaltenliste passen.",
                "Nicht genannte Spalten erhalten NULL oder Default Werte."
              ]
            },
            {
              "type": "code",
              "title": "INSERT mit allen Spalten",
              "language": "sql",
              "code": "INSERT INTO users (id, name, age) VALUES (1, 'Anna', 25);\n"
            },
            {
              "type": "explanation",
              "title": "Mehrere Zeilen einf√ºgen",
              "text": [
                "INSERT kann mehrere Datens√§tze auf einmal einf√ºgen.",
                "Alle Zeilen werden in einer Anweisung verarbeitet.",
                "Das ist meist schneller als einzelne INSERTs."
              ]
            },
            {
              "type": "code",
              "title": "Mehrere Datens√§tze",
              "language": "sql",
              "code": "INSERT INTO users (name, age) VALUES\n  ('Max', 30),\n  ('Anna', 25),\n  ('Tom', 40);\n"
            },
            {
              "type": "explanation",
              "title": "AUTO INCREMENT IDs",
              "text": [
                "Bei INTEGER PRIMARY KEY wird die ID automatisch vergeben.",
                "Die ID muss nicht im INSERT angegeben werden.",
                "SQLite vergibt einen neuen eindeutigen Wert."
              ]
            },
            {
              "type": "pitfall",
              "title": "INSERT ohne Spaltenliste",
              "text": "INSERT ohne explizite Spaltenliste ist fehleranf√§llig, wenn sich die Tabellenstruktur √§ndert."
            },
            {
              "type": "important",
              "text": "INSERT f√ºgt Daten hinzu, ver√§ndert aber keine bestehenden Zeilen."
            },
            {
              "type": "summary",
              "points": [
                "INSERT f√ºgt eine neue Zeile ein",
                "Spalten sollten immer explizit angegeben werden",
                "Mehrere Zeilen k√∂nnen in einem INSERT eingef√ºgt werden",
                "IDs werden oft automatisch vergeben",
                "Saubere INSERTs sind robust gegen√ºber Schema √Ñnderungen"
              ]
            }
          ]
        },


        {
          "title": "UPDATE",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Bestehende Daten √§ndern",
              "text": [
                "UPDATE ver√§ndert bestehende Datens√§tze in einer Tabelle.",
                "Es werden keine neuen Zeilen erzeugt.",
                "Nur die angegebenen Spalten werden ge√§ndert."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches UPDATE",
              "language": "sql",
              "code": "UPDATE users SET age = 31 WHERE id = 1;\n"
            },
            {
              "type": "explanation",
              "title": "Mehrere Spalten √§ndern",
              "text": [
                "Mehrere Spalten k√∂nnen in einem UPDATE gesetzt werden.",
                "Die Zuweisungen werden durch Kommas getrennt.",
                "Alle √Ñnderungen passieren atomar."
              ]
            },
            {
              "type": "code",
              "title": "UPDATE mit mehreren Spalten",
              "language": "sql",
              "code": "UPDATE users SET name = 'Max M.', age = 32 WHERE id = 1;\n"
            },
            {
              "type": "explanation",
              "title": "UPDATE mit WHERE",
              "text": [
                "WHERE begrenzt, welche Zeilen ge√§ndert werden.",
                "Ohne WHERE werden alle Zeilen der Tabelle ge√§ndert.",
                "WHERE ist fast immer notwendig."
              ]
            },
            {
              "type": "pitfall",
              "title": "UPDATE ohne WHERE",
              "text": "UPDATE ohne WHERE √§ndert alle Datens√§tze und ist eine der h√§ufigsten Fehlerquellen."
            },
            {
              "type": "important",
              "text": "UPDATE ver√§ndert Daten dauerhaft. WHERE sollte immer bewusst gesetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "UPDATE √§ndert bestehende Datens√§tze",
                "SET definiert die neuen Werte",
                "WHERE begrenzt die betroffenen Zeilen",
                "Mehrere Spalten k√∂nnen gleichzeitig ge√§ndert werden",
                "UPDATE ohne WHERE ist gef√§hrlich"
              ]
            }
          ]
        },


        {
          "title": "DELETE",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Daten l√∂schen",
              "text": [
                "DELETE entfernt Datens√§tze aus einer Tabelle.",
                "Die gel√∂schten Zeilen sind dauerhaft entfernt.",
                "Es werden keine Spalten oder Tabellen ver√§ndert."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches DELETE",
              "language": "sql",
              "code": "DELETE FROM users WHERE id = 1;\n"
            },
            {
              "type": "explanation",
              "title": "Warum WHERE wichtig ist",
              "text": [
                "WHERE bestimmt, welche Zeilen gel√∂scht werden.",
                "Ohne WHERE werden alle Zeilen der Tabelle gel√∂scht.",
                "WHERE sch√ºtzt vor unbeabsichtigtem Datenverlust."
              ]
            },
            {
              "type": "pitfall",
              "title": "DELETE ohne WHERE",
              "text": "DELETE ohne WHERE l√∂scht den gesamten Tabelleninhalt und ist ein h√§ufiger und gef√§hrlicher Fehler."
            },
            {
              "type": "explanation",
              "title": "Mehrere Zeilen l√∂schen",
              "text": [
                "DELETE kann mehrere Zeilen auf einmal entfernen.",
                "Alle Zeilen, die die WHERE Bedingung erf√ºllen, werden gel√∂scht.",
                "Die Operation ist idempotent."
              ]
            },
            {
              "type": "code",
              "title": "Mehrere Zeilen l√∂schen",
              "language": "sql",
              "code": "DELETE FROM users WHERE age < 18;\n"
            },
            {
              "type": "important",
              "text": "DELETE sollte immer mit WHERE verwendet werden, au√üer der komplette Tabelleninhalt soll bewusst gel√∂scht werden."
            },
            {
              "type": "explanation",
              "title": "ON DELETE CASCADE",
              "text": [
                "ON DELETE CASCADE ist eine Foreign Key Option.",
                "Beim L√∂schen einer Zeile werden abh√§ngige Zeilen automatisch mitgel√∂scht.",
                "Die L√∂schlogik liegt in der Datenbank, nicht im Code."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel mit ON DELETE CASCADE",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    product TEXT,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n"
            },
            {
              "type": "explanation",
              "title": "Was beim DELETE passiert",
              "text": [
                "DELETE FROM users l√∂scht den User.",
                "Alle orders mit passender user_id werden automatisch gel√∂scht.",
                "Es bleiben keine verwaisten Datens√§tze zur√ºck."
              ]
            },
            {
              "type": "explanation",
              "title": "Voraussetzung",
              "text": [
                "Foreign Keys m√ºssen aktiviert sein.",
                "PRAGMA foreign_keys = ON ist zwingend notwendig.",
                "Ohne dieses PRAGMA hat ON DELETE CASCADE keine Wirkung."
              ]
            },
            {
              "type": "comparison",
              "title": "DELETE mit und ohne CASCADE",
              "columns": ["Ohne CASCADE", "Mit CASCADE"],
              "rows": [
                {
                  "aspect": "Abh√§ngige Zeilen",
                  "values": ["Bleiben bestehen", "Werden automatisch gel√∂scht"]
                },
                {
                  "aspect": "Code Aufwand",
                  "values": ["Manuelles L√∂schen", "Kein Zusatzcode"]
                },
                {
                  "aspect": "Konsistenz",
                  "values": ["Fehleranf√§llig", "Automatisch gesichert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unerwartete L√∂schkaskaden",
              "text": "ON DELETE CASCADE kann gro√üe Datenmengen l√∂schen, wenn Beziehungen nicht sauber modelliert sind."
            },
            {
              "type": "important",
              "text": "ON DELETE CASCADE ist m√§chtig und sollte bewusst und sparsam eingesetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "DELETE entfernt Datens√§tze aus Tabellen",
                "WHERE begrenzt die betroffenen Zeilen",
                "DELETE ohne WHERE l√∂scht alle Daten",
                "Mehrere Zeilen k√∂nnen gleichzeitig gel√∂scht werden",
                "DELETE ist dauerhaft"
              ]
            }
          ]
        }



        ]
      },




      {
        "name": "Mehrere Tabellen",
        "icon": "üîó",
        "topics": [
        {
          "title": "Warum mehrere Tabellen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Mehrere Tabellen",
              "text": "Mehrere Tabellen teilen Daten logisch auf und verhindern, dass unterschiedliche Informationen vermischt oder doppelt gespeichert werden."
            },
            {
              "type": "explanation",
              "title": "Daten trennen",
              "text": [
                "Unterschiedliche Konzepte geh√∂ren in unterschiedliche Tabellen.",
                "Eine Tabelle sollte genau eine Verantwortung haben.",
                "Klare Trennung macht Daten verst√§ndlicher und wartbarer."
              ]
            },
            {
              "type": "code",
              "title": "Schlechtes Beispiel: Alles in einer Tabelle",
              "language": "sql",
              "code": "CREATE TABLE orders (\n    order_id INTEGER PRIMARY KEY,\n    user_name TEXT,\n    user_email TEXT,\n    product_name TEXT,\n    product_price REAL\n);\n"
            },
            {
              "type": "explanation",
              "title": "Redundanz vermeiden",
              "text": [
                "Gleiche Informationen w√ºrden mehrfach gespeichert.",
                "√Ñnderungen m√ºssen an vielen Stellen nachgezogen werden.",
                "Inkonsistenzen entstehen leicht."
              ]
            },
            {
              "type": "code",
              "title": "Besser: Daten aufteilen",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    email TEXT\n);\n\nCREATE TABLE products (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    price REAL\n);\n\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    product_id INTEGER\n);\n"
            },
            {
              "type": "explanation",
              "title": "Vorteile mehrerer Tabellen",
              "text": [
                "Jede Information existiert nur einmal.",
                "√Ñnderungen sind eindeutig und konsistent.",
                "Beziehungen zwischen Daten sind klar modelliert."
              ]
            },
            {
              "type": "comparison",
              "title": "Eine Tabelle vs mehrere Tabellen",
              "columns": ["Eine Tabelle", "Mehrere Tabellen"],
              "rows": [
                {
                  "aspect": "Redundanz",
                  "values": ["Hoch", "Gering"]
                },
                {
                  "aspect": "√Ñnderbarkeit",
                  "values": ["Fehleranf√§llig", "Sauber"]
                },
                {
                  "aspect": "Datenqualit√§t",
                  "values": ["Gef√§hrdet", "Stabil"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Alles in eine Tabelle packen",
              "text": "Gro√üe Tabellen mit gemischten Daten wirken am Anfang einfach, werden aber schnell unwartbar."
            },
            {
              "type": "important",
              "text": "Mehrere Tabellen sind kein Overengineering, sondern Grundlage sauberer Datenmodelle."
            },
            {
              "type": "summary",
              "points": [
                "Daten logisch trennen",
                "Redundanz vermeiden",
                "√Ñnderungen werden einfacher",
                "Daten bleiben konsistent",
                "Mehrere Tabellen sind Best Practice"
              ]
            }
          ]
        },

        {
          "title": "INNER JOIN",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Tabellen verbinden",
              "text": [
                "INNER JOIN verbindet Zeilen aus zwei Tabellen.",
                "Nur passende Zeilen aus beiden Tabellen erscheinen im Ergebnis.",
                "Die Verbindung erfolgt √ºber eine gemeinsame Spalte."
              ]
            },
            {
              "type": "explanation",
              "title": "Einfaches JOIN Prinzip",
              "text": [
                "Eine Tabelle enth√§lt eine Referenz auf die andere.",
                "Die Referenz wird mit dem Prim√§rschl√ºssel verbunden.",
                "Das Ergebnis kombiniert Spalten beider Tabellen."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Tabellen",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    product TEXT\n);\n"
            },
            {
              "type": "code",
              "title": "Einfaches INNER JOIN",
              "language": "sql",
              "code": "SELECT users.name, orders.product\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n"
            },
            {
              "type": "explanation",
              "title": "Was das Ergebnis bedeutet",
              "text": [
                "Nur Orders mit einem existierenden User erscheinen.",
                "Users ohne Orders erscheinen nicht.",
                "Orders ohne passenden User erscheinen ebenfalls nicht."
              ]
            },
            {
              "type": "pitfall",
              "title": "JOIN Bedingung vergessen",
              "text": "Ohne ON Bedingung entsteht ein kartesisches Produkt mit extrem vielen Zeilen."
            },
            {
              "type": "important",
              "text": "INNER JOIN liefert nur Datens√§tze, die in beiden Tabellen existieren."
            },
            {
              "type": "summary",
              "points": [
                "INNER JOIN verbindet zwei Tabellen",
                "Nur passende Zeilen erscheinen",
                "Verbindung erfolgt √ºber Schl√ºssel",
                "Einfaches und h√§ufig genutztes JOIN",
                "JOIN Bedingung ist zwingend notwendig"
              ]
            }
          ]
        },


        {
          "title": "LEFT JOIN",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "explanation",
              "title": "Unterschied zu INNER JOIN",
              "text": [
                "LEFT JOIN liefert alle Zeilen der linken Tabelle.",
                "Passende Zeilen der rechten Tabelle werden erg√§nzt.",
                "Fehlende Treffer werden mit NULL aufgef√ºllt."
              ]
            },
            {
              "type": "explanation",
              "title": "Grundprinzip",
              "text": [
                "Die linke Tabelle ist die erste Tabelle nach FROM.",
                "Diese Tabelle bestimmt die Anzahl der Ergebniszeilen.",
                "Die rechte Tabelle ist optional."
              ]
            },
            {
              "type": "code",
              "title": "LEFT JOIN Beispiel",
              "language": "sql",
              "code": "SELECT users.name, orders.product\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id;\n"
            },
            {
              "type": "explanation",
              "title": "Ergebnisverhalten",
              "text": [
                "Alle Users erscheinen im Ergebnis.",
                "Users ohne Orders haben NULL in den Order Spalten.",
                "Im Gegensatz zu INNER JOIN gehen keine linken Zeilen verloren."
              ]
            },
            {
              "type": "comparison",
              "title": "INNER JOIN vs LEFT JOIN",
              "columns": ["INNER JOIN", "LEFT JOIN"],
              "rows": [
                {
                  "aspect": "Linke Tabelle vollst√§ndig",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Rechte Tabelle erforderlich",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "NULL Werte m√∂glich",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "WHERE auf rechter Tabelle",
              "text": "Eine WHERE Bedingung auf Spalten der rechten Tabelle kann den LEFT JOIN ungewollt in einen INNER JOIN verwandeln."
            },
            {
              "type": "important",
              "text": "LEFT JOIN wird genutzt, wenn auch Datens√§tze ohne Beziehung sichtbar bleiben sollen."
            },
            {
              "type": "summary",
              "points": [
                "LEFT JOIN liefert alle Zeilen der linken Tabelle",
                "Rechte Tabelle ist optional",
                "Nicht gefundene Werte werden NULL",
                "Unterschied zu INNER JOIN ist das Ergebnisverhalten",
                "LEFT JOIN ist wichtig f√ºr vollst√§ndige Listen"
              ]
            }
          ]
        }



        ]
      },




      {
        "name": "Design",
        "icon": "üìê",
        "topics": [
        {
          "title": "Primary Key",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Primary Key",
              "text": "Ein Primary Key ist eine Spalte oder Kombination von Spalten, die jede Zeile einer Tabelle eindeutig identifiziert."
            },
            {
              "type": "explanation",
              "title": "Wof√ºr ein Primary Key da ist",
              "text": [
                "Jede Zeile muss eindeutig identifizierbar sein.",
                "Der Primary Key verhindert doppelte Datens√§tze.",
                "Andere Tabellen k√∂nnen zuverl√§ssig auf diese Zeile verweisen."
              ]
            },
            {
              "type": "code",
              "title": "Einfacher Primary Key",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    age INTEGER\n);\n"
            },
            {
              "type": "explanation",
              "title": "INTEGER PRIMARY KEY in SQLite",
              "text": [
                "INTEGER PRIMARY KEY ist in SQLite besonders.",
                "Die Spalte ist intern mit der RowID verkn√ºpft.",
                "Der Wert wird automatisch vergeben, wenn nichts eingesetzt wird."
              ]
            },
            {
              "type": "code",
              "title": "Automatische ID Vergabe",
              "language": "sql",
              "code": "INSERT INTO users (name, age) VALUES ('Max', 30);\n"
            },
            {
              "type": "explanation",
              "title": "Composite Primary Key",
              "text": [
                "Ein Primary Key kann aus mehreren Spalten bestehen.",
                "Die Kombination der Werte muss eindeutig sein.",
                "Typisch bei Zuordnungstabellen."
              ]
            },
            {
              "type": "code",
              "title": "Zusammengesetzter Primary Key",
              "language": "sql",
              "code": "CREATE TABLE enrollments (\n    student_id INTEGER,\n    course_id INTEGER,\n    PRIMARY KEY (student_id, course_id)\n);\n"
            },
            {
              "type": "pitfall",
              "title": "Kein Primary Key",
              "text": "Tabellen ohne Primary Key lassen doppelte oder nicht eindeutig adressierbare Zeilen zu."
            },
            {
              "type": "important",
              "text": "Jede Tabelle sollte einen Primary Key besitzen."
            },
            {
              "type": "summary",
              "points": [
                "Primary Key identifiziert Zeilen eindeutig",
                "INTEGER PRIMARY KEY ist Standard in SQLite",
                "IDs werden automatisch vergeben",
                "Composite Keys sind m√∂glich",
                "Tabellen ohne Primary Key sind fehleranf√§llig"
              ]
            }
          ]
        },


        {
          "title": "Foreign Key",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Foreign Key",
              "text": "Ein Foreign Key ist eine Spalte, die auf den Primary Key einer anderen Tabelle verweist und Beziehungen zwischen Tabellen herstellt."
            },
            {
              "type": "explanation",
              "title": "Warum Foreign Keys",
              "text": [
                "Foreign Keys verbinden logisch zusammengeh√∂rige Daten.",
                "Sie verhindern ung√ºltige Referenzen.",
                "Die Datenbank hilft, Konsistenz zu erzwingen."
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Foreign Key Beispiel",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\nCREATE TABLE orders (\n    id INTEGER PRIMARY KEY,\n    user_id INTEGER,\n    product TEXT,\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n"
            },
            {
              "type": "explanation",
              "title": "Was der Foreign Key bewirkt",
              "text": [
                "user_id muss auf einen existierenden users.id Wert zeigen.",
                "Orders mit nicht existierendem User sind nicht erlaubt.",
                "Die Beziehung wird von SQLite gepr√ºft."
              ]
            },
            {
              "type": "explanation",
              "title": "FOREIGN KEYS aktivieren",
              "text": [
                "In SQLite sind Foreign Keys standardm√§√üig deaktiviert.",
                "PRAGMA foreign_keys = ON aktiviert die Pr√ºfung.",
                "Ohne dieses PRAGMA werden Regeln nicht erzwungen."
              ]
            },
            {
              "type": "code",
              "title": "Foreign Keys aktivieren",
              "language": "sql",
              "code": "PRAGMA foreign_keys = ON;\n"
            },
            {
              "type": "pitfall",
              "title": "Foreign Keys vergessen zu aktivieren",
              "text": "Ohne PRAGMA foreign_keys = ON werden ung√ºltige Referenzen still akzeptiert."
            },
            {
              "type": "important",
              "text": "Foreign Keys sind zentral f√ºr Datenkonsistenz und sollten immer aktiviert sein."
            },
            {
              "type": "summary",
              "points": [
                "Foreign Keys verbinden Tabellen",
                "Sie verweisen auf Primary Keys",
                "SQLite pr√ºft Beziehungen nur mit PRAGMA foreign_keys",
                "Ung√ºltige Referenzen werden verhindert",
                "Wichtig f√ºr saubere Datenmodelle"
              ]
            }
          ]
        },


        {
          "title": "NULL",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "NULL",
              "text": "NULL bedeutet, dass kein Wert vorhanden ist. Es ist weder 0, noch ein leerer String, noch false."
            },
            {
              "type": "explanation",
              "title": "Was NULL ist und was nicht",
              "text": [
                "NULL steht f√ºr Abwesenheit eines Werts.",
                "0 ist ein g√ºltiger numerischer Wert.",
                "Ein leerer String ' ' ist ein g√ºltiger Textwert."
              ]
            },
            {
              "type": "comparison",
              "title": "NULL vs andere Werte",
              "columns": ["NULL", "0", "Leerer String"],
              "rows": [
                {
                  "aspect": "Bedeutung",
                  "values": ["Kein Wert", "Numerischer Wert", "Textwert vorhanden"]
                },
                {
                  "aspect": "Vergleichbar mit =",
                  "values": ["Nein", "Ja", "Ja"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "NULL in Tabellen",
              "text": [
                "Spalten k√∂nnen NULL erlauben oder verbieten.",
                "NULL ist der Standard, wenn nichts anderes angegeben ist.",
                "NOT NULL erzwingt einen gesetzten Wert."
              ]
            },
            {
              "type": "code",
              "title": "NULL erlauben und verbieten",
              "language": "sql",
              "code": "CREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    nickname TEXT NULL\n);\n"
            },
            {
              "type": "explanation",
              "title": "NULL pr√ºfen",
              "text": [
                "NULL kann nicht mit = verglichen werden.",
                "IS NULL und IS NOT NULL werden verwendet.",
                "Vergleiche mit = liefern bei NULL kein true."
              ]
            },
            {
              "type": "code",
              "title": "NULL abfragen",
              "language": "sql",
              "code": "SELECT * FROM users WHERE nickname IS NULL;\nSELECT * FROM users WHERE nickname IS NOT NULL;\n"
            },
            {
              "type": "explanation",
              "title": "NULL in SQLite und C++",
              "text": [
                "Beim Lesen kann sqlite3_column_text nullptr liefern.",
                "column_type kann SQLITE_NULL zur√ºckgeben.",
                "NULL sollte in C++ √ºber std::optional modelliert werden."
              ]
            },
            {
              "type": "pitfall",
              "title": "NULL wie einen normalen Wert behandeln",
              "text": "Vergleiche mit = NULL funktionieren nicht und f√ºhren zu falschen Ergebnissen."
            },
            {
              "type": "important",
              "text": "NULL ist ein eigener Zustand und muss explizit behandelt werden."
            },
            {
              "type": "summary",
              "points": [
                "NULL bedeutet kein Wert",
                "NULL ist nicht 0 und nicht leer",
                "NULL wird mit IS NULL gepr√ºft",
                "NOT NULL erzwingt Werte",
                "In C++ sollte NULL √ºber optional abgebildet werden"
              ]
            }
          ]
        },


        {
          "title": "Index",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Index",
              "text": "Ein Index ist eine zus√§tzliche Datenstruktur, die den schnellen Zugriff auf Zeilen einer Tabelle erm√∂glicht."
            },
            {
              "type": "explanation",
              "title": "Das Grundproblem ohne Index",
              "text": [
                "Ohne Index muss die Datenbank jede Zeile der Tabelle pr√ºfen.",
                "Dieser vollst√§ndige Durchlauf wird Full Table Scan genannt.",
                "Bei gro√üen Tabellen wird das schnell langsam."
              ]
            },
            {
              "type": "explanation",
              "title": "Was ein Index macht",
              "text": [
                "Ein Index speichert sortierte Verweise auf Zeilen.",
                "Die Datenbank findet passende Zeilen deutlich schneller.",
                "Der Zugriff √§hnelt einem Inhaltsverzeichnis statt dem Lesen eines ganzen Buches."
              ]
            },
            {
              "type": "explanation",
              "title": "Wann Indizes helfen",
              "text": [
                "Bei WHERE Bedingungen auf bestimmten Spalten.",
                "Bei JOIN Operationen √ºber Foreign Keys.",
                "Bei ORDER BY auf gro√üen Tabellen."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: Abfrage ohne und mit Index",
              "language": "sql",
              "code": "-- ohne Index (langsam bei vielen Zeilen)\nSELECT * FROM users WHERE email = 'max@example.com';\n\n-- Index anlegen\nCREATE INDEX idx_users_email ON users(email);\n\n-- gleiche Abfrage, jetzt mit Index\nSELECT * FROM users WHERE email = 'max@example.com';\n"
            },
            {
              "type": "explanation",
              "title": "Kosten von Indizes",
              "text": [
                "Indizes ben√∂tigen zus√§tzlichen Speicherplatz.",
                "INSERT, UPDATE und DELETE werden etwas langsamer.",
                "Zu viele Indizes schaden der Performance."
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Index",
              "columns": ["Ohne Index", "Mit Index"],
              "rows": [
                {
                  "aspect": "SELECT mit WHERE",
                  "values": ["Langsam", "Schnell"]
                },
                {
                  "aspect": "INSERT UPDATE DELETE",
                  "values": ["Schneller", "Langsamer"]
                },
                {
                  "aspect": "Speicherbedarf",
                  "values": ["Gering", "H√∂her"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Index auf jede Spalte",
              "text": "Indizes auf jeder Spalte wirken logisch, verschlechtern aber Schreibperformance und Wartbarkeit."
            },
            {
              "type": "important",
              "text": "Indizes sollten gezielt f√ºr h√§ufige Abfragen eingesetzt werden, nicht pauschal."
            },
            {
              "type": "summary",
              "points": [
                "Indizes beschleunigen Datenzugriffe",
                "Ohne Index erfolgt ein Full Table Scan",
                "Besonders wichtig f√ºr WHERE, JOIN und ORDER BY",
                "Indizes kosten Speicher und Schreibperformance",
                "Gezielter Einsatz ist entscheidend"
              ]
            }
          ]
        }



        ]
      }




    ]
  },















  {
    "category": "SQLite",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üìò",
        "topics": [
        {
          "title": "Was ist SQLite?",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "SQLite",
              "text": "SQLite ist eine leichtgewichtige, eingebettete relationale Datenbank, die direkt in die Anwendung integriert ist und ihre Daten in einer einzelnen Datei speichert."
            },
            {
              "type": "explanation",
              "title": "Embedded Datenbank",
              "text": [
                "SQLite l√§uft nicht als separater Datenbank Server.",
                "Die Datenbank Engine ist Teil der Anwendung und wird als Bibliothek eingebunden.",
                "Die Anwendung greift direkt auf die Datenbank Datei zu."
              ]
            },
            {
              "type": "explanation",
              "title": "Dateibasierte Speicherung",
              "text": [
                "Alle Daten befinden sich in einer einzigen Datei auf dem Dateisystem.",
                "Diese Datei kann einfach kopiert, gesichert oder versioniert werden.",
                "Es sind keine zus√§tzlichen Konfigurationsdateien oder Dienste notwendig."
              ]
            },
            {
              "type": "list",
              "title": "Wann SQLite sinnvoll ist",
              "items": [
                "Desktop Anwendungen",
                "Mobile Apps",
                "Kleine bis mittlere Projekte",
                "Lokale Tools und Utilities",
                "Prototypen und Lernprojekte",
                "Embedded Systeme"
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzszenarien",
              "text": [
                "SQLite eignet sich besonders, wenn eine einfache Persistenz ben√∂tigt wird.",
                "Es ist ideal, wenn nur wenige gleichzeitige Zugriffe stattfinden.",
                "Die Datenbank soll ohne Installation sofort funktionieren."
              ]
            },
            {
              "type": "comparison",
              "title": "SQLite vs Server Datenbanken",
              "columns": ["SQLite", "Server Datenbank"],
              "rows": [
                {
                  "aspect": "Architektur",
                  "values": ["Embedded in der Anwendung", "Separater Server Prozess"]
                },
                {
                  "aspect": "Installation",
                  "values": ["Keine", "Erforderlich"]
                },
                {
                  "aspect": "Datenhaltung",
                  "values": ["Eine Datei", "Mehrere Dateien / Speicherstrukturen"]
                },
                {
                  "aspect": "Mehrbenutzer Betrieb",
                  "values": ["Eingeschr√§nkt", "Voll unterst√ºtzt"]
                },
                {
                  "aspect": "Administration",
                  "values": ["Nicht notwendig", "Notwendig"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Grenzen von SQLite",
              "text": "SQLite ist nicht f√ºr hohe parallele Schreibzugriffe oder gro√üe Server Anwendungen mit vielen Clients gedacht."
            },
            {
              "type": "important",
              "text": "SQLite ist keine abgespeckte Spielzeug Datenbank, sondern eine vollwertige SQL Datenbank mit klar definiertem Einsatzzweck."
            },
            {
              "type": "summary",
              "points": [
                "SQLite ist eine embedded, dateibasierte Datenbank",
                "Kein Server, keine Installation",
                "Ideal f√ºr lokale und kleine Anwendungen",
                "Eingeschr√§nkt bei vielen gleichzeitigen Zugriffen",
                "Klare Abgrenzung zu klassischen Server Datenbanken"
              ]
            }
          ]
        },


        {
          "title": "SQLite einbinden",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Einbinden von SQLite",
              "text": "SQLite kann in C++ Projekten direkt als Quellcode eingebunden werden, indem die SQLite Dateien in einen externen Ordner gelegt und als eigenes Library Target in CMake gebaut werden."
            },
            {
              "type": "explanation",
              "title": "Externer Ordner im Projekt",
              "text": [
                "SQLite wird in einem separaten Ordner abgelegt, zum Beispiel external/sqlite oder vendor/sqlite.",
                "Eigener Code bleibt dadurch klar vom Fremdcode getrennt.",
                "Ein Update oder Austausch von SQLite ist m√∂glich, ohne den src Ordner zu vermischen."
              ]
            },
            {
              "type": "list",
              "title": "Typische SQLite Dateien im Ordner",
              "items": [
                "sqlite3.c als Implementierung",
                "sqlite3.h als √∂ffentlicher Header",
                "sqlite3ext.h f√ºr Erweiterungen, optional"
              ]
            },
            {
              "type": "explanation",
              "title": "Warum .c und .h direkt eingebunden werden",
              "text": [
                "SQLite wird h√§ufig als Single File Library verwendet.",
                "Die Datei sqlite3.c wird ganz normal mit dem Projekt kompiliert.",
                "Externe Abh√§ngigkeiten oder Installationen entfallen vollst√§ndig."
              ]
            },
            {
              "type": "explanation",
              "title": "CMake: SQLite als eigenes Library Target",
              "text": [
                "F√ºr SQLite wird ein eigenes Library Target erstellt.",
                "Dieses Target kapselt Quellcode, Include Pfade und Compiler Optionen.",
                "Andere Targets greifen ausschlie√ülich √ºber target_link_libraries darauf zu."
              ]
            },
            {
              "type": "code",
              "title": "CMakeLists.txt im SQLite Ordner",
              "language": "cmake",
              "code": "cmake_minimum_required(VERSION 3.20)\n\nadd_library(sqlite3 STATIC sqlite3.c)\n\ntarget_include_directories(sqlite3 PUBLIC ${CMAKE_CURRENT_LIST_DIR})\n\ntarget_compile_definitions(sqlite3 PUBLIC SQLITE_THREADSAFE=1)\n"
            },
            {
              "type": "explanation",
              "title": "Haupt CMakeLists.txt: Einbinden der Library",
              "text": [
                "Der SQLite Ordner wird mit add_subdirectory eingebunden.",
                "Dadurch steht das sqlite3 Target im gesamten Projekt zur Verf√ºgung.",
                "Das Executable linkt anschlie√üend nur noch gegen sqlite3."
              ]
            },
            {
              "type": "code",
              "title": "SQLite im Hauptprojekt einbinden",
              "language": "cmake",
              "code": "cmake_minimum_required(VERSION 3.20)\nproject(MeinProjekt LANGUAGES CXX C)\n\nadd_subdirectory(external/sqlite)\n\nadd_executable(MeinProgramm\n    src/main.cpp\n)\n\ntarget_compile_features(MeinProgramm PRIVATE cxx_std_20)\n\ntarget_link_libraries(MeinProgramm PRIVATE sqlite3)\n"
            },
            {
              "type": "comparison",
              "title": "Quellcode Einbindung vs System SQLite",
              "columns": ["SQLite im Projekt", "SQLite vom System"],
              "rows": [
                {
                  "aspect": "Setup",
                  "values": ["Direkt im Repository", "Abh√§ngig vom Betriebssystem"]
                },
                {
                  "aspect": "Version",
                  "values": ["Volle Kontrolle", "Vom System vorgegeben"]
                },
                {
                  "aspect": "Portabilit√§t",
                  "values": ["Sehr hoch", "Nicht immer verf√ºgbar"]
                },
                {
                  "aspect": "Build Reproduzierbarkeit",
                  "values": ["Immer identisch", "Kann variieren"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Doppelte Kompilierung von sqlite3.c",
              "text": "Wenn sqlite3.c sowohl im sqlite3 Target als auch direkt im Executable eingebunden wird, entstehen Duplicate Symbol Errors beim Linken."
            },
            {
              "type": "important",
              "text": "SQLite sollte immer als eigene Dependency mit eigenem CMake Target behandelt werden und niemals direkt im Executable landen."
            },
            {
              "type": "summary",
              "points": [
                "SQLite kann direkt als Quellcode ins Projekt integriert werden",
                "Externer Ordner sorgt f√ºr saubere Trennung von Fremdcode",
                "Eigenes sqlite3 Library Target in CMake erstellen",
                "Einbindung √ºber add_subdirectory",
                "Verwendung ausschlie√ülich √ºber target_link_libraries"
              ]
            }
          ]
        },


        {
          "title": "sqlite3 Handle und Lebensdauer",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "sqlite3 Handle",
              "text": "Ein sqlite3 Handle ist ein Zeiger auf eine ge√∂ffnete SQLite Datenbank und repr√§sentiert die gesamte Verbindung zu einer Datenbank Datei."
            },
            {
              "type": "explanation",
              "title": "√ñffnen und Schlie√üen der Datenbank",
              "text": [
                "Eine SQLite Datenbank wird mit sqlite3_open oder sqlite3_open_v2 ge√∂ffnet.",
                "Das √ñffnen liefert ein sqlite3* Handle zur√ºck.",
                "Die Datenbank muss mit sqlite3_close oder sqlite3_close_v2 wieder geschlossen werden."
              ]
            },
            {
              "type": "code",
              "title": "Datenbank √∂ffnen und schlie√üen",
              "language": "cpp",
              "code": "#include <sqlite3.h>\n#include <iostream>\n\nint main() {\n    sqlite3* db = nullptr;\n\n    if (sqlite3_open(\"test.db\", &db) != SQLITE_OK) {\n        std::cerr << \"Fehler beim √ñffnen der Datenbank\" << std::endl;\n        return 1;\n    }\n\n    sqlite3_close(db);\n    return 0;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Lebensdauer des sqlite3 Handles",
              "text": [
                "Das sqlite3 Handle ist g√ºltig, solange die Datenbank ge√∂ffnet ist.",
                "Alle Statements und Transaktionen h√§ngen an diesem Handle.",
                "Ein vorzeitiges Schlie√üen macht alle zugeh√∂rigen Ressourcen ung√ºltig."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum RAII notwendig ist",
              "text": [
                "Vergessene sqlite3_close Aufrufe f√ºhren zu Ressourcen Leaks.",
                "Fehlerpfade und Exceptions machen manuelles Schlie√üen fehleranf√§llig.",
                "RAII koppelt die Lebensdauer des Handles an ein Objekt."
              ]
            },
            {
              "type": "code",
              "title": "Grundidee von RAII f√ºr sqlite3",
              "language": "cpp",
              "code": "#include <sqlite3.h>\n\nclass Database {\npublic:\n    explicit Database(const char* path) {\n        if (sqlite3_open(path, &db_) != SQLITE_OK) {\n            throw std::runtime_error(\"Datenbank konnte nicht ge√∂ffnet werden\");\n        }\n    }\n\n    ~Database() {\n        sqlite3_close(db_);\n    }\n\n    sqlite3* get() const { return db_; }\n\nprivate:\n    sqlite3* db_ = nullptr;\n};\n"
            },
            {
              "type": "explanation",
              "title": "Fehler beim √ñffnen korrekt behandeln",
              "text": [
                "Der R√ºckgabewert von sqlite3_open muss immer gepr√ºft werden.",
                "Bei Fehlern liefert sqlite3_errmsg eine Beschreibung.",
                "Ein teilweise ge√∂ffnetes Handle muss trotzdem geschlossen werden."
              ]
            },
            {
              "type": "code",
              "title": "Fehlermeldung beim √ñffnen ausgeben",
              "language": "cpp",
              "code": "#include <sqlite3.h>\n#include <iostream>\n\nint main() {\n    sqlite3* db = nullptr;\n\n    int rc = sqlite3_open(\"test.db\", &db);\n    if (rc != SQLITE_OK) {\n        std::string fehler = sqlite3_errmsg(db);\n        throw std::runtime_error(\"Datenbank konnte nicht ge√∂ffnet werden: \" + fehler);\n        sqlite3_close(db);\n        return 1;\n    }\n\n    sqlite3_close(db);\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Ungeschlossene Handles",
              "text": "Ein nicht geschlossenes sqlite3 Handle kann Dateisperren hinterlassen und sp√§tere Zugriffe blockieren."
            },
            {
              "type": "important",
              "text": "Die Verwaltung des sqlite3 Handles geh√∂rt immer in eine eigene Klasse und niemals direkt in main oder Business Logik."
            },
            {
              "type": "summary",
              "points": [
                "sqlite3* repr√§sentiert die Verbindung zur Datenbank",
                "√ñffnen mit sqlite3_open, schlie√üen mit sqlite3_close",
                "Handle ist zentral f√ºr alle Datenbank Operationen",
                "RAII verhindert Leaks und Fehlerpfade",
                "Fehler beim √ñffnen m√ºssen immer gepr√ºft werden"
              ]
            }
          ]
        }

        



        ]
      },





      {
        "name": "Database Klasse",
        "icon": "üèóÔ∏è",
        "topics": [
        {
          "title": "Database Klasse Grundstruktur",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Database Klasse",
              "text": "Die Database Klasse kapselt das sqlite3 Handle und ist verantwortlich f√ºr das √ñffnen, Schlie√üen und die zentrale Verwaltung der Datenbank Verbindung."
            },
            {
              "type": "explanation",
              "title": "Aufgabe der Database Klasse",
              "text": [
                "Zentrale Stelle f√ºr den Zugriff auf die SQLite Datenbank.",
                "Kapselung des sqlite3 Handles und der Lebensdauer.",
                "Trennung von Datenbank Infrastruktur und Anwendungslogik."
              ]
            },
            {
              "type": "explanation",
              "title": "Konstruktor und Destruktor",
              "text": [
                "Der Konstruktor √∂ffnet die Datenbank Datei.",
                "Der Destruktor schlie√üt die Datenbank automatisch.",
                "Die Lebensdauer der Datenbank ist klar an das Objekt gebunden."
              ]
            },
            {
              "type": "explanation",
              "title": "Copy verboten, Move erlaubt",
              "text": [
                "Ein sqlite3 Handle darf nicht kopiert werden.",
                "Mehrere Objekte d√ºrfen nicht dasselbe Handle besitzen.",
                "Move Semantik erlaubt das sichere √úbertragen der Ownership."
              ]
            },
            {
              "type": "code",
              "title": "Database.hpp",
              "language": "cpp",
              "code": "#pragma once\n\n#include <sqlite3.h>\n#include <string>\n\n#include \"statement.hpp\"\n\nclass Database {\npublic:\n    // √ñffnet bestehende Datenbank oder erstellt neue Datei\n    explicit Database(const std::string& dbPfad);\n\n    // Schlie√üt die Datenbank automatisch\n    ~Database();\n\n    // Zugriff auf rohe SQLite Verbindung\n    [[nodiscard]] sqlite3* get() const;\n\n    // Kopieren verbieten\n    Database(const Database&) = delete;\n    Database& operator=(const Database&) = delete;\n\n    // Verschieben erlauben\n    Database(Database&& other) noexcept;\n    Database& operator=(Database&& other) noexcept;\n\n    Statement prepare(const char* sql);\n\n    void execute(const char* sql);\n\nprivate:\n    sqlite3* db_;\n};\n"

            },
            {
              "type": "code",
              "title": "Database.cpp",
              "language": "cpp",
              "code": "#include \"database.hpp\"\n#include <stdexcept>\n\nDatabase::Database(const std::string& dbPfad) : db_(nullptr) {\n    if (sqlite3_open(dbPfad.c_str(), &db_) != SQLITE_OK) {\n        std::string fehler = sqlite3_errmsg(db_);\n        sqlite3_close(db_);\n        db_ = nullptr;\n        throw std::runtime_error(\"Datenbank konnte nicht ge√∂ffnet werden: \" + fehler);\n    }\n}\n\nDatabase::~Database() {\n    if (db_) {\n        sqlite3_close(db_);\n        db_ = nullptr;\n    }\n}\n\n[[nodiscard]] sqlite3* Database::get() const {\n    return db_;\n}\n\nDatabase::Database(Database&& other) noexcept : db_(other.db_) {\n    other.db_ = nullptr;\n}\n\nDatabase& Database::operator=(Database&& other) noexcept {\n    if (this != &other) {\n        if (db_) {\n            sqlite3_close(db_);\n        }\n        db_ = other.db_;\n        other.db_ = nullptr;\n    }\n    return *this;\n}\n"


            },
            {
              "type": "explanation",
              "title": "prepare Funktion",
              "text": [
                "prepare erstellt ein vorbereitetes SQLite Statement aus einem SQL String.",
                "Vor dem Vorbereiten wird gepr√ºft, ob die Datenbank ge√∂ffnet ist.",
                "Bei Fehlern wird eine aussagekr√§ftige Exception mit sqlite3_errmsg geworfen.",
                "Das rohe sqlite3_stmt Handle wird in ein eigenes Statement Objekt verpackt."
              ]
            },
            {
              "type": "code",
              "title": "prepare Implementierung Database.cpp",
              "language": "cpp",
              "code": "Statement Database::prepare(const char* sql) {\n    sqlite3_stmt* stmt = nullptr;\n\n    if (!db_) {\n        throw std::logic_error(\"Datenbank nicht ge√∂ffnet.\");\n    }\n\n    const int rc = sqlite3_prepare_v2(db_, sql, -1, &stmt, nullptr);\n    if (rc != SQLITE_OK) {\n        const std::string fehler = sqlite3_errmsg(db_);\n        throw std::runtime_error(\"Prepare fehlgeschlagen: \" + fehler);\n    }\n\n    return Statement(stmt);\n}\n"
            },
            {
              "type": "explanation",
              "title": "execute Funktion",
              "text": [
                "execute f√ºhrt ein SQL Statement direkt √ºber sqlite3_exec aus.",
                "Die Funktion ist f√ºr einfache Befehle ohne Parameter gedacht.",
                "Fehlermeldungen werden entweder aus errMsg oder direkt aus der Datenbank gelesen.",
                "Der Aufrufer erh√§lt bei Fehlern immer eine Exception mit genauer Ursache."
              ]
            },
            {
              "type": "code",
              "title": "execute Implementierung Database.cpp",
              "language": "cpp",
              "code": "void Database::execute(const char* sql) {\n    if (db_ == nullptr) {\n        throw std::logic_error(\"Datenbank nicht ge√∂ffnet.\");\n    }\n\n    char* errMsg = nullptr;\n    int rc = sqlite3_exec(db_, sql, nullptr, nullptr, &errMsg);\n\n    if (rc != SQLITE_OK) {\n        std::string fehler;\n\n        if (errMsg != nullptr) {\n            fehler = errMsg;\n            sqlite3_free(errMsg);\n        } else {\n            fehler = sqlite3_errmsg(db_);\n        }\n\n        throw std::runtime_error(\"Execute fehlgeschlagen: \" + fehler);\n    }\n}\n"
            },
            {
              "type": "pitfall",
              "title": "prepare und execute falsch einsetzen",
              "text": "execute sollte nicht f√ºr Statements mit Parametern oder Ergebnissen verwendet werden. prepare ist die Grundlage f√ºr alle sicheren CRUD Operationen."
            },
            {
              "type": "important",
              "text": "prepare kapselt sqlite3_prepare_v2 sauber und liefert ein eigenes Statement Objekt zur√ºck. execute ist nur f√ºr einfache, einmalige SQL Befehle gedacht."
            },
            {
              "type": "pitfall",
              "title": "Zu viel Logik in der Database Klasse",
              "text": "Die Database Klasse sollte keine Business Logik enthalten, sondern nur Infrastruktur Code f√ºr SQLite bereitstellen."
            },
            {
              "type": "important",
              "text": "Die Database Klasse ist der Eigent√ºmer des sqlite3 Handles und darf niemals kopiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Database kapselt das sqlite3 Handle",
                "Konstruktor √∂ffnet, Destruktor schlie√üt die Datenbank",
                "Copy ist verboten, Move erlaubt"
              ]
            }
          ]
        },


        {
          "title": "Fehlerbehandlung in der Database Klasse",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Fehlerbehandlung",
              "text": "Fehlerbehandlung in der Database Klasse beschreibt den Umgang mit SQLite Fehlercodes und Fehlermeldungen sowie die Entscheidung, ob Fehler per Exception oder √ºber R√ºckgabewerte signalisiert werden."
            },
            {
              "type": "explanation",
              "title": "sqlite3_errmsg",
              "text": [
                "sqlite3_errmsg liefert eine menschenlesbare Beschreibung des letzten Fehlers.",
                "Die Fehlermeldung ist immer an ein sqlite3 Handle gebunden.",
                "Sie sollte direkt nach dem fehlerhaften SQLite Aufruf ausgewertet werden."
              ]
            },
            {
              "type": "code",
              "title": "Fehlermeldung aus SQLite lesen",
              "language": "cpp",
              "code": "#include <sqlite3.h>\n#include <iostream>\n\nvoid openDb(sqlite3* db) {\n    std::cerr << sqlite3_errmsg(db) << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Exception vs Status R√ºckgabe",
              "text": [
                "Exceptions eignen sich f√ºr technische Fehler, die den normalen Ablauf verhindern.",
                "Status R√ºckgaben sind sinnvoll bei erwartbaren Ergebnissen wie Nicht gefunden.",
                "Eine Mischung aus beiden Ans√§tzen f√ºhrt schnell zu un√ºbersichtlichem Code."
              ]
            },
            {
              "type": "comparison",
              "title": "Exception oder R√ºckgabewert",
              "columns": ["Exception", "Status R√ºckgabe"],
              "rows": [
                {
                  "aspect": "Fehlerart",
                  "values": ["Technisch, kritisch", "Fachlich, erwartbar"]
                },
                {
                  "aspect": "Kontrollfluss",
                  "values": ["Unterbricht sofort", "Wird explizit gepr√ºft"]
                },
                {
                  "aspect": "Code Lesbarkeit",
                  "values": ["Sauber bei Infrastruktur Code", "Sauber bei Business Logik"]
                },
                {
                  "aspect": "Typische Nutzung",
                  "values": ["Datenbank √∂ffnen, Prepare Fehler", "Datensatz nicht gefunden"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "Wann throw sinnvoll ist",
              "text": [
                "Beim √ñffnen der Datenbank, da ohne Verbindung nichts funktioniert.",
                "Bei Prepare Fehlern, da SQL Syntax oder Struktur fehlerhaft ist.",
                "Bei internen SQLite Fehlern, die nicht sinnvoll behandelt werden k√∂nnen."
              ]
            },
            {
              "type": "list",
              "title": "Typische Stellen f√ºr Exceptions",
              "items": [
                "sqlite3_open schl√§gt fehl",
                "sqlite3_prepare_v2 liefert Fehler",
                "sqlite3_exec bricht ab",
                "Ung√ºltiger interner Zustand der Database Klasse"
              ]
            },
            {
              "type": "pitfall",
              "title": "Zu viele Exceptions",
              "text": "Exceptions f√ºr normale Kontrollfl√ºsse wie leere Ergebnisse machen den Code schwer lesbar und unflexibel."
            },
            {
              "type": "important",
              "text": "In der Database Klasse sollten Exceptions f√ºr Infrastruktur Fehler genutzt werden. Fachliche Zust√§nde geh√∂ren in h√∂here Schichten."
            },
            {
              "type": "summary",
              "points": [
                "sqlite3_errmsg liefert die konkrete SQLite Fehlermeldung",
                "Exceptions sind f√ºr technische, nicht erwartbare Fehler",
                "Status R√ºckgaben eignen sich f√ºr fachliche Ergebnisse",
                "Konsistenz im Fehlerkonzept ist entscheidend",
                "Database Klassen sollten Fehler fr√ºh und klar melden"
              ]
            }
          ]
        },


        {
          "title": "PRAGMA Einstellungen beim Start",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "PRAGMA",
              "text": "PRAGMA Anweisungen konfigurieren das Verhalten der SQLite Engine zur Laufzeit und gelten immer f√ºr die aktuell ge√∂ffnete Datenbank Verbindung."
            },
            {
              "type": "explanation",
              "title": "PRAGMA beim Start setzen",
              "text": [
                "PRAGMA Einstellungen sollten direkt nach dem √ñffnen der Datenbank gesetzt werden.",
                "Sie gelten nur f√ºr die aktuelle Verbindung und nicht global.",
                "Eine zentrale Initialisierung sorgt f√ºr konsistentes Verhalten."
              ]
            },
            {
              "type": "explanation",
              "title": "foreign_keys = ON",
              "text": [
                "SQLite erzwingt Fremdschl√ºssel standardm√§√üig nicht.",
                "PRAGMA foreign_keys = ON aktiviert die √úberpr√ºfung von Foreign Keys.",
                "Referentielle Integrit√§t wird dadurch tats√§chlich sichergestellt."
              ]
            },
            {
              "type": "code",
              "title": "Foreign Keys aktivieren",
              "language": "cpp",
              "code": "db.execute(\"PRAGMA foreign_keys = ON;\");\n"
            },
            {
              "type": "explanation",
              "title": "Warum foreign_keys = ON wichtig ist",
              "text": [
                "SQLite unterst√ºtzt Fremdschl√ºssel zwar syntaktisch, erzwingt sie aber standardm√§√üig nicht.",
                "Ohne foreign_keys = ON werden Beziehungen zwischen Tabellen nicht √ºberpr√ºft.",
                "Die Datenbank erlaubt dadurch inkonsistente und logisch falsche Daten."
              ]
            },
            {
              "type": "explanation",
              "title": "Was foreign_keys = ON konkret bewirkt",
              "text": [
                "INSERT schl√§gt fehl, wenn eine referenzierte ID nicht existiert.",
                "DELETE und UPDATE beachten Regeln wie ON DELETE CASCADE oder ON UPDATE CASCADE.",
                "Referentielle Integrit√§t wird von der Datenbank selbst garantiert."
              ]
            },
            {
              "type": "explanation",
              "title": "Praktischer Nutzen im Projekt",
              "text": [
                "Weniger Pr√ºfungen in der Business Logik notwendig.",
                "Inkonsistente Zust√§nde werden fr√ºh erkannt.",
                "Beziehungen zwischen Tabellen sind zuverl√§ssig und wartbar."
              ]
            },
            {
              "type": "pitfall",
              "title": "Tr√ºgerische Sicherheit",
              "text": "Foreign Keys im Schema zu definieren, aber foreign_keys nicht zu aktivieren, f√ºhrt dazu, dass die Regeln niemals greifen."
            },
            {
              "type": "important",
              "text": "foreign_keys = ON sollte immer Teil der zentralen Datenbank Initialisierung sein."
            },
            {
              "type": "explanation",
              "title": "busy_timeout",
              "text": [
                "busy_timeout legt fest, wie lange SQLite bei gesperrter Datenbank wartet.",
                "Ohne Timeout schlagen Schreibzugriffe sofort fehl.",
                "Ein kurzer Timeout verbessert die Stabilit√§t bei parallelen Zugriffen."
              ]
            },
            {
              "type": "code",
              "title": "Busy Timeout setzen",
              "language": "cpp",
              "code": "db.execute(\"PRAGMA busy_timeout = 5000;\");\n"
            },
            {
              "type": "explanation",
              "title": "journal_mode = WAL",
              "text": [
                "WAL steht f√ºr Write Ahead Logging.",
                "Leser und Schreiber blockieren sich weniger stark.",
                "Besonders sinnvoll bei mehreren parallelen Zugriffen.",
                "Nicht jede Umgebung profitiert automatisch davon."
              ]
            },
            {
              "type": "important",
              "text": "journal_mode = WAL sollte verstanden werden, bevor es produktiv eingesetzt wird. Es ist eine bewusste Architektur Entscheidung."
            },
            {
              "type": "pitfall",
              "title": "PRAGMA als globale Einstellung verstehen",
              "text": "PRAGMA Einstellungen gelten immer nur f√ºr die aktuelle Verbindung und m√ºssen bei jedem Start erneut gesetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "PRAGMA konfiguriert das Verhalten von SQLite zur Laufzeit",
                "foreign_keys = ON erzwingt referentielle Integrit√§t",
                "busy_timeout verhindert sofortige Lock Fehler",
                "journal_mode = WAL verbessert Parallelit√§t",
                "PRAGMA Einstellungen geh√∂ren in die Initialisierung"
              ]
            }
          ]
        }

 



        ]
      },







      {
        "name": "Statements",
        "icon": "üßæ",
        "topics": [
        {
          "title": "Warum Prepared Statements",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Prepared Statement",
              "text": "Ein Prepared Statement ist ein vorbereitetes SQL Statement, bei dem SQL Struktur und Daten strikt voneinander getrennt sind."
            },
            {
              "type": "explanation",
              "title": "Schutz vor SQL Injection",
              "text": [
                "SQL Code und Benutzerdaten werden getrennt behandelt.",
                "Eingabewerte werden nicht in den SQL String eingebaut.",
                "Sch√§dlicher SQL Code kann nicht eingeschleust werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Performance Vorteile",
              "text": [
                "Das SQL Statement wird nur einmal geparst und kompiliert.",
                "Mehrfache Ausf√ºhrungen mit unterschiedlichen Werten sind effizient.",
                "Besonders bei Schleifen oder Batch Operationen relevant."
              ]
            },
            {
              "type": "explanation",
              "title": "Saubere Trennung von SQL und Daten",
              "text": [
                "SQL beschreibt nur die Struktur der Abfrage.",
                "Daten werden √ºber Bind Parameter gesetzt.",
                "Der Code bleibt √ºbersichtlich und wartbar."
              ]
            },
            {
              "type": "code",
              "title": "Prepared Statement mit Platzhaltern",
              "language": "cpp",
              "code": "auto stmt = db.prepare(\"INSERT INTO users (name, age) VALUES (?, ?);\");\n\nstmt.bindText(1, name);\nstmt.bindInt(2, age);\nstmt.step();\n"
            },
            {
              "type": "comparison",
              "title": "Prepared Statement vs String SQL",
              "columns": ["Prepared Statement", "SQL String"],
              "rows": [
                {
                  "aspect": "SQL Injection",
                  "values": ["Gesch√ºtzt", "Anf√§llig"]
                },
                {
                  "aspect": "Performance",
                  "values": ["Besser bei Wiederholung", "Jedes Mal neu parsen"]
                },
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Klar getrennt", "Oft un√ºbersichtlich"]
                },
                {
                  "aspect": "Wartbarkeit",
                  "values": ["Hoch", "Fehleranf√§llig"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Prepared Statements nur teilweise nutzen",
              "text": "Prepared Statements bringen keinen Vorteil, wenn Werte trotzdem per String Konkatenation eingebaut werden."
            },
            {
              "type": "important",
              "text": "Prepared Statements sind der Standard f√ºr alle SQL Zugriffe mit externen Daten."
            },
            {
              "type": "summary",
              "points": [
                "Prepared Statements trennen SQL und Daten",
                "Schutz vor SQL Injection",
                "Bessere Performance bei Wiederverwendung",
                "Klarer und wartbarer Code",
                "Grundlage f√ºr saubere Datenbank Architektur"
              ]
            }
          ]
        },


        {
          "title": "Statement Lebenszyklus",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Statement Lebenszyklus",
              "text": "Der Statement Lebenszyklus beschreibt die feste Abfolge von Schritten, die ein vorbereitetes SQLite Statement von der Erstellung bis zur Freigabe durchl√§uft."
            },
            {
              "type": "explanation",
              "title": "1. prepare",
              "text": [
                "prepare erstellt ein sqlite3_stmt Objekt aus einem SQL String.",
                "Das SQL Statement wird geparst und validiert.",
                "Fehler in der SQL Syntax werden hier erkannt."
              ]
            },
            {
              "type": "explanation",
              "title": "2. bind",
              "text": [
                "bind setzt Werte f√ºr Platzhalter im Statement.",
                "SQL Struktur und Daten bleiben strikt getrennt.",
                "Indizes der Platzhalter beginnen bei 1."
              ]
            },
            {
              "type": "explanation",
              "title": "3. step",
              "text": [
                "step f√ºhrt das Statement aus.",
                "Bei SELECT liefert step Zeilen nacheinander.",
                "Bei INSERT, UPDATE oder DELETE wird die Ausf√ºhrung abgeschlossen."
              ]
            },
            {
              "type": "explanation",
              "title": "4. reset",
              "text": [
                "reset setzt das Statement in den Anfangszustand zur√ºck.",
                "Gebundene Parameter bleiben erhalten.",
                "Das Statement kann erneut ausgef√ºhrt werden."
              ]
            },
            {
              "type": "explanation",
              "title": "5. finalize",
              "text": [
                "finalize gibt alle Ressourcen des Statements frei.",
                "Das Statement darf danach nicht mehr verwendet werden.",
                "finalize muss genau einmal aufgerufen werden."
              ]
            },
            {
              "type": "code",
              "title": "Typischer Statement Ablauf",
              "language": "cpp",
              "code": "auto stmt = db.prepare(\"INSERT INTO users (name, age) VALUES (?, ?);\");\n\nstmt.bindText(1, \"Max\");\nstmt.bindInt(2, 30);\n\nstmt.step();\nstmt.reset();\n\n// erneute Nutzung m√∂glich\nstmt.bindText(1, \"Anna\");\nstmt.bindInt(2, 25);\nstmt.step();\n"
            },
            {
              "type": "list",
              "title": "Kurz√ºberblick Lebenszyklus",
              "items": [
                "prepare: Statement erzeugen",
                "bind: Werte setzen",
                "step: Ausf√ºhren",
                "reset: Wiederverwenden",
                "finalize: Ressourcen freigeben"
              ]
            },
            {
              "type": "pitfall",
              "title": "finalize vergessen",
              "text": "Nicht finalisierte Statements halten Ressourcen und k√∂nnen Datenbank Locks verursachen."
            },
            {
              "type": "important",
              "text": "Statement Objekte sollten RAII verwenden, damit finalize automatisch im Destruktor erfolgt."
            },
            {
              "type": "summary",
              "points": [
                "Statements haben einen klaren Lebenszyklus",
                "prepare und finalize bilden den Rahmen",
                "bind und step geh√∂ren zur Ausf√ºhrung",
                "reset erlaubt Wiederverwendung",
                "RAII verhindert Ressourcenlecks"
              ]
            }
          ]
        },


        {
          "title": "Statement Klasse (RAII)",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Statement Klasse",
              "text": "Die Statement Klasse kapselt ein sqlite3_stmt Handle und √ºbernimmt dessen Lebensdauerverwaltung nach dem RAII Prinzip."
            },
            {
              "type": "explanation",
              "title": "Besitz des sqlite3_stmt Handles",
              "text": [
                "Die Statement Klasse ist der eindeutige Besitzer des sqlite3_stmt Handles.",
                "Das rohe Handle wird au√üerhalb der Klasse nicht verwaltet.",
                "Mehrere Besitzer eines Statements sind nicht erlaubt."
              ]
            },
            {
              "type": "explanation",
              "title": "RAII und finalize im Destruktor",
              "text": [
                "Das Statement wird im Konstruktor √ºbernommen.",
                "Der Destruktor ruft sqlite3_finalize auf.",
                "Ressourcen werden automatisch freigegeben, auch bei Exceptions."
              ]
            },
            {
              "type": "code",
              "title": "Statement.hpp",
              "language": "cpp",
              "code": "#pragma once\n\n#include <sqlite3.h>\n\nclass Statement {\npublic:\n    explicit Statement(sqlite3_stmt* stmt = nullptr);\n    ~Statement();\n\n    Statement(const Statement&) = delete;\n    Statement& operator=(const Statement&) = delete;\n\n    Statement(Statement&& other) noexcept;\n    Statement& operator=(Statement&& other) noexcept;\n\n    [[nodiscard]] sqlite3_stmt* get() const;\n    [[nodiscard]] int stepRaw();\n\n    void reset();\n\nprivate:\n    sqlite3_stmt* stmt_;\n};\n"
            },
            {
              "type": "explanation",
              "title": "Move Semantik",
              "text": [
                "Copy ist verboten, da ein Statement nur einen Besitzer haben darf.",
                "Move √ºbertr√§gt das Handle sicher auf ein neues Objekt.",
                "Das alte Objekt verliert den Besitz und wird leer."
              ]
            },
            {
              "type": "code",
              "title": "Statement.cpp",
              "language": "cpp",
              "code": "#include \"statement.hpp\"\n#include <stdexcept>\n\nStatement::Statement(sqlite3_stmt* stmt)\n    : stmt_(stmt) {\n}\n\nStatement::~Statement() {\n    if (stmt_) {\n        sqlite3_finalize(stmt_);\n        stmt_ = nullptr;\n    }\n}\n\nStatement::Statement(Statement&& other) noexcept\n    : stmt_(other.stmt_) {\n    other.stmt_ = nullptr;\n}\n\nStatement& Statement::operator=(Statement&& other) noexcept {\n    if (this != &other) {\n        if (stmt_) {\n            sqlite3_finalize(stmt_);\n        }\n        stmt_ = other.stmt_;\n        other.stmt_ = nullptr;\n    }\n    return *this;\n}\n"

            },
            {
              "type": "explanation",
              "title": "get Methode",
              "text": [
                "get gibt das rohe sqlite3_stmt Handle zur√ºck.",
                "Die Ownership bleibt weiterhin bei der Statement Klasse.",
                "Die Methode ist const, da sie den internen Zustand nicht ver√§ndert.",
                "[[nodiscard]] erzwingt, dass der R√ºckgabewert bewusst genutzt wird."
              ]
            },
            {
              "type": "code",
              "title": "get Implementierung",
              "language": "cpp",
              "code": "[[nodiscard]] sqlite3_stmt* Statement::get() const {\n    return stmt_;\n}\n"
            },
            {
              "type": "explanation",
              "title": "stepRaw Methode",
              "text": [
                "stepRaw f√ºhrt sqlite3_step direkt auf dem Statement aus.",
                "Vor der Ausf√ºhrung wird gepr√ºft, ob ein g√ºltiges Statement existiert.",
                "Bei einem ung√ºltigen Zustand wird eine logic_error Exception geworfen.",
                "Der R√ºckgabewert von sqlite3_step wird unver√§ndert weitergegeben."
              ]
            },
            {
              "type": "code",
              "title": "stepRaw Implementierung",
              "language": "cpp",
              "code": "int Statement::stepRaw() {\n    if (stmt_ == nullptr) {\n        throw std::logic_error(\"Step fehlgeschlagen.\");\n    }\n    return sqlite3_step(stmt_);\n}\n"
            },
            {
              "type": "explanation",
              "title": "reset Methode",
              "text": [
                "reset setzt ein vorbereitetes Statement in den Anfangszustand zur√ºck.",
                "Das Statement kann danach erneut ausgef√ºhrt werden.",
                "Bereits gebundene Parameter bleiben erhalten."
              ]
            },
            {
              "type": "code",
              "title": "reset Implementierung",
              "language": "cpp",
              "code": "void Statement::reset() {\n    if (stmt_ == nullptr) {\n        throw std::logic_error(\"Reset fehlgeschlagen.\");\n    }\n\n    sqlite3_reset(stmt_);\n}\n"
            },
            {
              "type": "explanation",
              "title": "Typische Nutzung von reset",
              "text": [
                "reset wird nach sqlite3_step verwendet.",
                "Das gleiche Statement kann mehrfach mit unterschiedlichen Daten ausgef√ºhrt werden.",
                "Besonders sinnvoll bei Inserts oder Updates in Schleifen."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Wiederverwendung eines Statements",
              "language": "cpp",
              "code": "auto stmt = db.prepare(\"INSERT INTO users (name, age) VALUES (?, ?);\");\n\nstmt.bindText(1, \"Max\");\nstmt.bindInt(2, 30);\nstmt.stepRaw();\n\nstmt.reset();\n\nstmt.bindText(1, \"Anna\");\nstmt.bindInt(2, 25);\nstmt.stepRaw();\n"
            },
            {
              "type": "important",
              "text": "reset ersetzt nicht finalize. Das Statement bleibt g√ºltig und wird erst im Destruktor freigegeben."
            },
            {
              "type": "pitfall",
              "title": "Statement ohne RAII",
              "text": "Manuelles sqlite3_finalize wird leicht vergessen und f√ºhrt zu Speicherlecks oder Datenbank Locks."
            },
            {
              "type": "important",
              "text": "Ein Statement Objekt sollte niemals kopiert, sondern ausschlie√ülich bewegt werden."
            },
            {
              "type": "summary",
              "points": [
                "Statement kapselt sqlite3_stmt nach RAII",
                "finalize erfolgt im Destruktor",
                "Copy verboten, Move erlaubt",
                "reset erm√∂glicht Wiederverwendung",
                "stepRaw bildet die Basis f√ºr h√∂here APIs"
              ]
            }
          ]
        },

        {
          "title": "Parameter binden",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Parameter binden",
              "text": "Parameter binden bedeutet, Platzhalter in einem vorbereiteten SQL Statement mit konkreten Werten zu belegen, ohne den SQL String selbst zu ver√§ndern."
            },
            {
              "type": "explanation",
              "title": "Grundprinzip",
              "text": [
                "Prepared Statements verwenden Platzhalter statt konkreter Werte.",
                "Werte werden separat an das Statement gebunden.",
                "SQL Struktur und Daten bleiben strikt getrennt."
              ]
            },
            {
              "type": "explanation",
              "title": "Index beginnt bei 1",
              "text": [
                "SQLite nummeriert Platzhalter beginnend bei 1.",
                "Der erste Platzhalter ? hat den Index 1.",
                "Index 0 ist ung√ºltig und f√ºhrt zu Fehlern."
              ]
            },
            {
              "type": "code",
              "title": "SQL mit Platzhaltern",
              "language": "sql",
              "code": "INSERT INTO users (name, weight, age, email) VALUES (?, ?, ?, ?);"
            },
            {
              "type": "explanation",
              "title": "bindInt",
              "text": [
                "bindInt bindet einen Ganzzahlwert an einen Platzhalter.",
                "Typpr√ºfung erfolgt intern durch SQLite.",
                "Geeignet f√ºr INTEGER Spalten."
              ]
            },
            {
              "type": "code",
              "title": "Integer binden",
              "language": "cpp",
              "code": "stmt.bindInt(1, 42);"
            },
            {
              "type": "explanation",
              "title": "bindDouble",
              "text": [
                "bindDouble bindet einen Gleitkommawert an einen Platzhalter.",
                "SQLite speichert Gleitkommazahlen intern als REAL.",
                "Geeignet f√ºr Messwerte, Gewichte, Preise oder Zeitdauern."
              ]
            },
            {
              "type": "code",
              "title": "Double binden",
              "language": "cpp",
              "code": "stmt.bindDouble(2, 72.5);"
            },
            {
              "type": "explanation",
              "title": "bindText",
              "text": [
                "bindText bindet einen Textwert an einen Platzhalter.",
                "SQLite kopiert oder referenziert den Text abh√§ngig von der Implementierung.",
                "Geeignet f√ºr TEXT Spalten."
              ]
            },
            {
              "type": "code",
              "title": "Text binden",
              "language": "cpp",
              "code": "stmt.bindText(3, \"Max Mustermann\");"
            },
            {
              "type": "explanation",
              "title": "bindNull",
              "text": [
                "bindNull setzt einen Platzhalter explizit auf NULL.",
                "Unterscheidung zwischen leerem String und NULL bleibt erhalten.",
                "Wichtig f√ºr optionale Felder."
              ]
            },
            {
              "type": "code",
              "title": "NULL binden",
              "language": "cpp",
              "code": "stmt.bindNull(4);"
            },
            {
              "type": "comparison",
              "title": "NULL vs leerer Wert",
              "columns": ["NULL", "Leerer Wert"],
              "rows": [
                {
                  "aspect": "Bedeutung",
                  "values": ["Kein Wert vorhanden", "Wert vorhanden, aber leer"]
                },
                {
                  "aspect": "SQL Vergleich",
                  "values": ["IS NULL", "= '' oder = 0"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Falsche Indexe",
              "text": "Ein falscher Parameter Index f√ºhrt zu schwer auffindbaren Fehlern oder falsch zugeordneten Werten."
            },
            {
              "type": "important",
              "text": "Parameter m√ºssen immer √ºber bind Funktionen gesetzt werden, niemals per String Konkatenation."
            },
            {
              "type": "summary",
              "points": [
                "Parameter binden trennt SQL und Daten",
                "Platzhalter Indizes beginnen bei 1",
                "bindInt f√ºr Ganzzahlen",
                "bindDouble f√ºr Gleitkommazahlen",
                "bindText f√ºr Texte",
                "bindNull f√ºr optionale Werte"
              ]
            }
          ]
        },


        {
          "title": "Text Lifetime und SQLITE_TRANSIENT",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Text Lifetime",
              "text": "Text Lifetime beschreibt, wie lange ein √ºbergebener Text im Speicher g√ºltig bleibt, nachdem er an SQLite gebunden wurde."
            },
            {
              "type": "explanation",
              "title": "Warum C Strings gef√§hrlich sind",
              "text": [
                "SQLite speichert Text nicht automatisch sofort.",
                "Beim Binden von Texten kann SQLite nur einen Zeiger merken.",
                "Wenn der Speicher danach ung√ºltig wird, entstehen undefinierte Fehler."
              ]
            },
            {
              "type": "explanation",
              "title": "STATIC vs TRANSIENT",
              "text": [
                "STATIC bedeutet, dass SQLite den Text nicht kopiert.",
                "TRANSIENT bedeutet, dass SQLite den Text intern kopiert.",
                "Die Entscheidung beeinflusst direkt die Lebensdauer des Speichers."
              ]
            },
            {
              "type": "comparison",
              "title": "SQLITE_STATIC vs SQLITE_TRANSIENT",
              "columns": ["SQLITE_STATIC", "SQLITE_TRANSIENT"],
              "rows": [
                {
                  "aspect": "Speicherverwaltung",
                  "values": ["Kein Kopieren", "Text wird kopiert"]
                },
                {
                  "aspect": "Lifetime Verantwortung",
                  "values": ["Aufrufer", "SQLite"]
                },
                {
                  "aspect": "Sicherheit",
                  "values": ["Fehleranf√§llig", "Sicher"]
                }
              ]
            },
            {
              "type": "code",
              "title": "Typischer Fehler beim Binden von Text",
              "language": "cpp",
              "code": "std::string name = getName();\nstmt.bindText(1, name.c_str());\n// name wird sp√§ter zerst√∂rt, Statement nutzt ung√ºltigen Speicher\n"
            },
            {
              "type": "explanation",
              "title": "Korrekte Nutzung mit SQLITE_TRANSIENT",
              "text": [
                "SQLITE_TRANSIENT zwingt SQLite, den Text zu kopieren.",
                "Die urspr√ºngliche Speicherquelle darf danach zerst√∂rt werden.",
                "Dies ist der sichere Standardfall."
              ]
            },
            {
              "type": "code",
              "title": "Sicheres Binden von Text",
              "language": "cpp",
              "code": "stmt.bindText(1, name.c_str(), SQLITE_TRANSIENT);\n"
            },
            {
              "type": "pitfall",
              "title": "Unbewusste Nutzung von SQLITE_STATIC",
              "text": "SQLITE_STATIC darf nur verwendet werden, wenn garantiert ist, dass der Speicher bis nach sqlite3_step g√ºltig bleibt."
            },
            {
              "type": "important",
              "text": "Wenn Unsicherheit √ºber die Lebensdauer besteht, immer SQLITE_TRANSIENT verwenden."
            },
            {
              "type": "summary",
              "points": [
                "Text Lifetime ist kritisch bei Prepared Statements",
                "C Strings k√∂nnen fr√ºhzeitig ung√ºltig werden",
                "SQLITE_STATIC kopiert nicht",
                "SQLITE_TRANSIENT kopiert sicher",
                "Falsche Nutzung f√ºhrt zu schwer auffindbaren Fehlern"
              ]
            }
          ]
        }




        ]
      },







      {
        "name": "Ergebnisse lesen",
        "icon": "üì§",
        "topics": [
        {
          "title": "sqlite3_step R√ºckgabewerte",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "sqlite3_step",
              "text": "sqlite3_step f√ºhrt ein vorbereitetes Statement aus und liefert einen Statuscode zur√ºck, der den aktuellen Zustand der Ausf√ºhrung beschreibt."
            },
            {
              "type": "explanation",
              "title": "SQLITE_ROW",
              "text": [
                "SQLITE_ROW bedeutet, dass eine Ergebniszeile verf√ºgbar ist.",
                "Der R√ºckgabewert tritt bei SELECT Statements auf.",
                "Die Spaltenwerte k√∂nnen jetzt ausgelesen werden."
              ]
            },
            {
              "type": "explanation",
              "title": "SQLITE_DONE",
              "text": [
                "SQLITE_DONE signalisiert das Ende der Ausf√ºhrung.",
                "Bei SELECT bedeutet es, dass keine weiteren Zeilen vorhanden sind.",
                "Bei INSERT, UPDATE oder DELETE ist die Operation abgeschlossen."
              ]
            },
            {
              "type": "code",
              "title": "Typische Nutzung von sqlite3_step",
              "language": "cpp",
              "code": "while (stmt.stepRaw() == SQLITE_ROW) {\n    // Spalten auslesen\n}\n\n// SQLITE_DONE erreicht\n"
            },
            {
              "type": "explanation",
              "title": "Typische Fehlercodes",
              "text": [
                "sqlite3_step kann auch Fehlercodes zur√ºckgeben.",
                "Diese signalisieren Abbruch oder ung√ºltige Zust√§nde.",
                "Fehler m√ºssen immer explizit behandelt werden."
              ]
            },
            {
              "type": "list",
              "title": "H√§ufige Fehlercodes",
              "items": [
                "SQLITE_ERROR: Allgemeiner SQL Fehler",
                "SQLITE_BUSY: Datenbank ist gesperrt",
                "SQLITE_MISUSE: Falsche API Nutzung",
                "SQLITE_CONSTRAINT: Constraint verletzt"
              ]
            },
            {
              "type": "explanation",
              "title": "Fehlerbehandlung bei step",
              "text": [
                "Alles au√üer SQLITE_ROW und SQLITE_DONE ist ein Fehler.",
                "Fehler sollten in Exceptions oder Statusobjekte √ºbersetzt werden.",
                "Die genaue Ursache kann √ºber sqlite3_errmsg ermittelt werden."
              ]
            },
            {
              "type": "pitfall",
              "title": "SQLITE_DONE falsch interpretieren",
              "text": "SQLITE_DONE ist kein Fehler, sondern ein normales Ende der Ausf√ºhrung."
            },
            {
              "type": "important",
              "text": "Die R√ºckgabewerte von sqlite3_step bestimmen den gesamten Kontrollfluss beim Lesen von Ergebnissen."
            },
            {
              "type": "summary",
              "points": [
                "sqlite3_step steuert die Ausf√ºhrung von Statements",
                "SQLITE_ROW liefert eine Ergebniszeile",
                "SQLITE_DONE beendet die Ausf√ºhrung",
                "Alle anderen R√ºckgabewerte sind Fehler",
                "Fehlercodes m√ºssen sauber behandelt werden"
              ]
            }
          ]
        },


        {
          "title": "Spalten lesen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Spalten lesen",
              "text": "Spalten lesen bedeutet, nach einem erfolgreichen sqlite3_step die Werte der aktuellen Ergebniszeile aus einem Statement auszulesen."
            },
            {
              "type": "explanation",
              "title": "Grundprinzip",
              "text": [
                "Spalten k√∂nnen nur gelesen werden, wenn sqlite3_step SQLITE_ROW geliefert hat.",
                "Der Zugriff erfolgt √ºber Spalten Indizes.",
                "Der erste Spaltenindex beginnt bei 0."
              ]
            },
            {
              "type": "explanation",
              "title": "columnInt",
              "text": [
                "columnInt liest einen INTEGER Wert aus der aktuellen Zeile.",
                "Nicht passende Typen werden von SQLite implizit konvertiert.",
                "Geeignet f√ºr IDs und Ganzzahlen."
              ]
            },
            {
              "type": "code",
              "title": "Integer Spalte lesen",
              "language": "cpp",
              "code": "int id = sqlite3_column_int(stmt.get(), 0);"
            },
            {
              "type": "explanation",
              "title": "columnDouble",
              "text": [
                "columnDouble liest einen REAL Wert aus der aktuellen Ergebniszeile.",
                "Der R√ºckgabewert ist ein double.",
                "Geeignet f√ºr Messwerte, Dezimalzahlen oder Zeitdauern."
              ]
            },
            {
              "type": "code",
              "title": "Double Spalte lesen",
              "language": "cpp",
              "code": "double weight = sqlite3_column_double(stmt.get(), 3);"
            },
            {
              "type": "explanation",
              "title": "columnText",
              "text": [
                "columnText liest eine TEXT Spalte als const unsigned char*. ",
                "Der R√ºckgabewert geh√∂rt SQLite und darf nicht freigegeben werden.",
                "Der Inhalt ist nur bis zum n√§chsten step oder reset g√ºltig."
              ]
            },
            {
              "type": "code",
              "title": "Text Spalte lesen",
              "language": "cpp",
              "code": "const char* name = reinterpret_cast<const char*>(\n    sqlite3_column_text(stmt.get(), 1)\n);"
            },
            {
              "type": "explanation",
              "title": "Text Spalte sicher speichern",
              "text": [
                "sqlite3_column_text liefert einen Zeiger auf SQLite internen Speicher.",
                "Dieser Speicher ist nur bis zum n√§chsten step oder reset g√ºltig.",
                "Der Text sollte daher sofort in einen std::string kopiert werden."
              ]
            },
            {
              "type": "code",
              "title": "Text ohne Zeiger speichern",
              "language": "cpp",
              "code": "const unsigned char* text = sqlite3_column_text(stmt.get(), 1);\n\nstd::string name;\nif (text != nullptr) {\n    name = reinterpret_cast<const char*>(text);\n}\n"
            },
            {
              "type": "explanation",
              "title": "NULL Handling",
              "text": [
                "Spalten k√∂nnen NULL sein.",
                "Beim Lesen von NULL liefert sqlite3_column_text einen Null Zeiger.",
                "NULL muss explizit gepr√ºft werden."
              ]
            },
            {
              "type": "code",
              "title": "NULL sicher behandeln",
              "language": "cpp",
              "code": "const unsigned char* text = sqlite3_column_text(stmt.get(), 2);\n\nif (text == nullptr) {\n    // Wert ist NULL\n}\n"
            },
            {
              "type": "explanation",
              "title": "columnType",
              "text": [
                "sqlite3_column_type liefert den tats√§chlichen Typ der Spalte.",
                "Der Typ kann zur Laufzeit variieren.",
                "Besonders wichtig bei optionalen oder dynamischen Spalten."
              ]
            },
            {
              "type": "code",
              "title": "Spaltentyp pr√ºfen",
              "language": "cpp",
              "code": "int type = sqlite3_column_type(stmt.get(), 2);\n\nif (type == SQLITE_NULL) {\n    // NULL Wert\n}\n"
            },
            {
              "type": "comparison",
              "title": "Spaltenindizes",
              "columns": ["Parameter binden", "Spalten lesen"],
              "rows": [
                {
                  "aspect": "Index Start",
                  "values": ["Beginnt bei 1", "Beginnt bei 0"]
                },
                {
                  "aspect": "Kontext",
                  "values": ["Vor step", "Nach SQLITE_ROW"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Lifetime von columnText",
              "text": "Der von sqlite3_column_text gelieferte Zeiger wird ung√ºltig nach step oder reset."
            },
            {
              "type": "important",
              "text": "Vor dem Lesen von Spalten muss immer gepr√ºft werden, dass sqlite3_step SQLITE_ROW geliefert hat."
            },
            {
              "type": "summary",
              "points": [
                "Spalten lesen ist nur bei SQLITE_ROW erlaubt",
                "Spaltenindizes beginnen bei 0",
                "columnInt f√ºr INTEGER Werte",
                "columnText liefert SQLite verwalteten Speicher",
                "NULL und Typen m√ºssen explizit gepr√ºft werden"
              ]
            }
          ]
        },


        {
          "title": "Row to Struct Mapping",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Row to Struct Mapping",
              "text": "Row to Struct Mapping ist das Umwandeln einer Ergebniszeile aus einem SELECT Statement in ein C++ Struct oder Objekt mit klarer Feldzuordnung."
            },
            {
              "type": "explanation",
              "title": "Warum nicht direkt im Loop arbeiten",
              "text": [
                "Direktes Auslesen im while Loop f√ºhrt schnell zu Copy Paste Code.",
                "Spaltenindizes und Typkonvertierungen werden √ºberall verteilt.",
                "√Ñnderungen an der SELECT Spaltenliste brechen den Code an mehreren Stellen."
              ]
            },
            {
              "type": "explanation",
              "title": "Saubere Mapping Funktion",
              "text": [
                "Eine Mapping Funktion kapselt das Auslesen der Spalten in einem einzigen Ort.",
                "Die Funktion nimmt ein Statement im aktuellen SQLITE_ROW Zustand.",
                "Das Ergebnis ist ein vollst√§ndig gef√ºlltes Struct."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: Struct und Mapping Funktion",
              "language": "cpp",
              "code": "struct User {\n    int id;\n    std::string name;\n    int age;\n};\n\nstatic User mapUser(sqlite3_stmt* stmt) {\n    User u;\n    u.id = sqlite3_column_int(stmt, 0);\n\n    const unsigned char* text = sqlite3_column_text(stmt, 1);\n    if (text != nullptr) {\n        u.name = reinterpret_cast<const char*>(text);\n    }\n\n    u.age = sqlite3_column_int(stmt, 2);\n    return u;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Konstante Spalten Indizes",
              "text": [
                "Spaltenindizes sollten als Konstanten festgelegt werden.",
                "Damit ist die Zuordnung zwischen SELECT und Mapping explizit.",
                "Ein Index Wechsel ist dann eine √Ñnderung an einer Stelle."
              ]
            },
            {
              "type": "code",
              "title": "Spalten Indizes als Konstanten",
              "language": "cpp",
              "code": "namespace user_cols {\n    constexpr int id = 0;\n    constexpr int name = 1;\n    constexpr int age = 2;\n}\n"
            },
            {
              "type": "code",
              "title": "Mapping mit konstanten Indizes",
              "language": "cpp",
              "code": "static User mapUser(sqlite3_stmt* stmt) {\n    User u;\n    u.id = sqlite3_column_int(stmt, user_cols::id);\n\n    const unsigned char* text = sqlite3_column_text(stmt, user_cols::name);\n    if (text != nullptr) {\n        u.name = reinterpret_cast<const char*>(text);\n    }\n\n    u.age = sqlite3_column_int(stmt, user_cols::age);\n    return u;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "SELECT Liste und Mapping passen nicht zusammen",
              "text": "Wenn die Reihenfolge der SELECT Spalten ge√§ndert wird, aber die Indizes im Mapping gleich bleiben, entstehen stille Datenfehler."
            },
            {
              "type": "important",
              "text": "Mapping Funktionen sind ein zentraler Baustein f√ºr saubere Repositories und verhindern duplizierte Ausleselogik."
            },
            {
              "type": "summary",
              "points": [
                "Mapping wandelt eine Ergebniszeile in ein Struct um",
                "Direktes Auslesen im Loop f√ºhrt zu dupliziertem Code",
                "Mapping geh√∂rt in eine eigene Funktion",
                "Spaltenindizes als Konstanten halten die Zuordnung stabil",
                "SELECT Reihenfolge und Mapping m√ºssen immer zusammenpassen"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "CRUD",
        "icon": "üîÑ",
        "topics": [
        {
          "title": "CREATE TABLE mit prepare step finalize",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "DDL in SQLite",
              "text": "CREATE TABLE ist ein DDL Statement und ver√§ndert das Schema der Datenbank. Es liefert keine Ergebniszeilen und endet bei erfolgreicher Ausf√ºhrung mit SQLITE_DONE."
            },
            {
              "type": "explanation",
              "title": "Warum prepare und step f√ºr DDL",
              "text": [
                "prepare parst und validiert das SQL Statement vor der Ausf√ºhrung.",
                "step f√ºhrt das Statement aus.",
                "finalize gibt das Statement Handle wieder frei."
              ]
            },
            {
              "type": "explanation",
              "title": "R√ºckgabecode bei DDL",
              "text": [
                "DDL Statements liefern keine SQLITE_ROW Zeilen.",
                "Bei Erfolg kommt SQLITE_DONE.",
                "Alles andere ist ein Fehlercode."
              ]
            },
            {
              "type": "code",
              "title": "CREATE TABLE √ºber Database::prepare und Statement::stepRaw",
              "language": "cpp",
              "code": "void createUsersTable(Database& db) {\n    const char* sql = R\"(\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            age INTEGER\n        );\n    )\";\n\n    // prepare wirft bereits eine Exception mit sqlite3_errmsg(db_)\n    Statement stmt = db.prepare(sql);\n\n    // DDL liefert bei Erfolg SQLITE_DONE\n    const int rc = stmt.stepRaw();\n    if (rc != SQLITE_DONE) {\n        // Hinweis: daf√ºr braucht Database einen Getter auf das sqlite3 Handle, z.B. sqlite3* Database::get() const\n        throw std::runtime_error(std::string(\"CREATE TABLE fehlgeschlagen: \") + sqlite3_errmsg(db.get()));\n    }\n\n    // finalize passiert automatisch im Statement Destruktor (RAII)\n}\n"
            },
            {
              "type": "explanation",
              "title": "Was hier wichtig ist",
              "text": [
                "prepare liefert ein Statement Objekt, das das sqlite3_stmt besitzt.",
                "stepRaw liefert bei DDL im Erfolgsfall SQLITE_DONE.",
                "finalize wird nicht manuell aufgerufen, weil der Statement Destruktor das √ºbernimmt.",
                "Fehler beim prepare kommen als Exception direkt aus Database::prepare, Fehler beim step werden √ºber den R√ºckgabecode erkannt."
              ]
            },
            {
              "type": "explanation",
              "title": "Fehlerbehandlung",
              "text": [
                "Nach jedem SQLite Aufruf wird der R√ºckgabecode gepr√ºft.",
                "Bei Fehlern wird sqlite3_errmsg genutzt, um die Ursache zu liefern.",
                "finalize muss auch im Fehlerfall aufgerufen werden."
              ]
            },
            {
              "type": "pitfall",
              "title": "finalize im Fehlerpfad vergessen",
              "text": "Wenn finalize im Fehlerfall fehlt, bleiben Ressourcen offen und es k√∂nnen Locks oder Leaks entstehen."
            },
            {
              "type": "important",
              "text": "F√ºr DDL ist SQLITE_DONE der Erfolgsfall. sqlite3_finalize muss immer ausgef√ºhrt werden, auch bei Fehlern."
            },
            {
              "type": "summary",
              "points": [
                "CREATE TABLE ist DDL und liefert keine Zeilen",
                "Erfolg bei step ist SQLITE_DONE",
                "prepare pr√ºft SQL, step f√ºhrt aus, finalize r√§umt auf",
                "R√ºckgabecodes immer pr√ºfen",
                "finalize auch im Fehlerfall nicht vergessen"
              ]
            }
          ]
        },


        {
          "title": "INSERT mit Prepared Statements",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "INSERT mit Prepared Statement",
              "text": "INSERT mit Prepared Statements bedeutet, Daten √ºber Platzhalter zu binden und das Statement per step auszuf√ºhren, statt Werte in einen SQL String einzubauen."
            },
            {
              "type": "explanation",
              "title": "Ablauf",
              "text": [
                "prepare erstellt das Statement mit Platzhaltern.",
                "bind setzt die Parameterwerte.",
                "step f√ºhrt den INSERT aus und liefert bei Erfolg SQLITE_DONE."
              ]
            },
            {
              "type": "code",
              "title": "INSERT mit bind und stepRaw",
              "language": "cpp",
              "code": "void insertUser(Database& db, const std::string& name, int age) {\n    const char* sql = \"INSERT INTO users (name, age) VALUES (?, ?);\";\n\n    Statement stmt = db.prepare(sql);\n\n    \n    stmt.bindText(1, name);\n    stmt.bindInt(2, age);\n\n    const int rc = stmt.stepRaw();\n    if (rc != SQLITE_DONE) {\n        throw std::runtime_error(\"INSERT fehlgeschlagen.\");\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "last_insert_rowid",
              "text": [
                "Nach einem erfolgreichen INSERT kann die zuletzt vergebene ID abgefragt werden.",
                "Das funktioniert nur zuverl√§ssig auf derselben Datenbank Verbindung.",
                "In SQLite liefert sqlite3_last_insert_rowid die RowID des letzten Inserts."
              ]
            },
            {
              "type": "code",
              "title": "Letzte Insert ID lesen",
              "language": "cpp",
              "code": "int insertUserAndGetId(Database& db, const std::string& name, int age) {\n    const char* sql = \"INSERT INTO users (name, age) VALUES (?, ?);\";\n\n    Statement stmt = db.prepare(sql);\n    stmt.bindText(1, name);\n    stmt.bindInt(2, age);\n\n    const int rc = stmt.stepRaw();\n    if (rc != SQLITE_DONE) {\n        throw std::runtime_error(\"INSERT fehlgeschlagen.\");\n    }\n\n    // ben√∂tigt Database::get() -> sqlite3*\n    return static_cast<int>(sqlite3_last_insert_rowid(db.get()));\n}\n"
            },
            {
              "type": "pitfall",
              "title": "last_insert_rowid auf falscher Verbindung",
              "text": "last_insert_rowid ist nur f√ºr die Verbindung g√ºltig, die den INSERT ausgef√ºhrt hat. Bei mehreren Verbindungen entstehen falsche IDs."
            },
            {
              "type": "important",
              "text": "INSERT immer √ºber Prepared Statements und bind durchf√ºhren. Nach Erfolg ist SQLITE_DONE der erwartete R√ºckgabecode."
            },
            {
              "type": "summary",
              "points": [
                "prepare, bind, stepRaw ist der Standardablauf f√ºr INSERT",
                "Erfolg bei INSERT ist SQLITE_DONE",
                "last_insert_rowid liefert die letzte vergebene ID der aktuellen Verbindung",
                "ID sofort nach dem INSERT lesen",
                "Keine String Konkatenation f√ºr Werte"
              ]
            }
          ]
        },


        {
          "title": "SELECT eine Zeile lesen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Single Row SELECT",
              "text": "Ein Single Row SELECT liest h√∂chstens eine Ergebniszeile aus der Datenbank und gibt sie optional zur√ºck."
            },
            {
              "type": "explanation",
              "title": "Warum optional R√ºckgabe",
              "text": [
                "Ein SELECT kann g√ºltig sein, aber kein Ergebnis liefern.",
                "Nicht gefunden ist kein technischer Fehler.",
                "std::optional modelliert diesen Zustand sauber."
              ]
            },
            {
              "type": "explanation",
              "title": "not found vs error",
              "text": [
                "not found bedeutet: SQL korrekt, aber keine passende Zeile.",
                "error bedeutet: technischer Fehler bei prepare oder step.",
                "Diese Zust√§nde m√ºssen klar getrennt behandelt werden."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: SELECT eine Zeile mit optional",
              "language": "cpp",
              "code": "#include <optional>\n\nstd::optional<User> findUserById(Database& db, int id) {\n    const char* sql = \"SELECT id, name, age FROM users WHERE id = ?;\";\n\n    Statement stmt = db.prepare(sql);\n    stmt.bindInt(1, id);\n\n    const int rc = stmt.stepRaw();\n\n    if (rc == SQLITE_ROW) {\n        return mapUser(stmt.get());\n    }\n\n    if (rc == SQLITE_DONE) {\n        return std::nullopt; // not found\n    }\n\n    throw std::runtime_error(\"SELECT fehlgeschlagen.\");\n}\n"
            },
            {
              "type": "explanation",
              "title": "Ablauf im Detail",
              "text": [
                "prepare und bind werden wie gewohnt ausgef√ºhrt.",
                "Der erste step entscheidet √ºber das Ergebnis.",
                "SQLITE_ROW bedeutet Treffer.",
                "SQLITE_DONE bedeutet keine Zeile vorhanden."
              ]
            },
            {
              "type": "comparison",
              "title": "R√ºckgabearten",
              "columns": ["optional", "Exception"],
              "rows": [
                {
                  "aspect": "Nicht gefunden",
                  "values": ["std::nullopt", "Ungeeignet"]
                },
                {
                  "aspect": "Technischer Fehler",
                  "values": ["Ungeeignet", "Exception"]
                },
                {
                  "aspect": "Lesbarkeit",
                  "values": ["Klar", "Unklar bei Kontrollfluss"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Nicht gefunden als Fehler behandeln",
              "text": "Ein fehlender Datensatz ist kein Ausnahmefall und sollte nicht √ºber Exceptions signalisiert werden."
            },
            {
              "type": "important",
              "text": "optional steht f√ºr fachliche Abwesenheit, Exceptions f√ºr technische Fehler."
            },
            {
              "type": "summary",
              "points": [
                "Single Row SELECT liefert h√∂chstens eine Zeile",
                "std::optional modelliert not found sauber",
                "SQLITE_ROW bedeutet Treffer",
                "SQLITE_DONE bedeutet keine Zeile",
                "Technische Fehler werden per Exception behandelt"
              ]
            }
          ]
        },

        {
          "title": "SELECT mehrere Zeilen lesen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Multi Row SELECT",
              "text": "Ein Multi Row SELECT liest beliebig viele Ergebniszeilen aus der Datenbank und gibt sie gesammelt als std::vector zur√ºck."
            },
            {
              "type": "explanation",
              "title": "Warum vector R√ºckgabe",
              "text": [
                "Ein SELECT kann mehrere Zeilen liefern.",
                "Die Anzahl der Ergebnisse ist vorher nicht bekannt.",
                "std::vector modelliert diese Situation nat√ºrlich."
              ]
            },
            {
              "type": "explanation",
              "title": "step Schleife",
              "text": [
                "sqlite3_step wird wiederholt aufgerufen.",
                "Jeder SQLITE_ROW Durchlauf liefert genau eine Zeile.",
                "Die Schleife endet bei SQLITE_DONE."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel: SELECT mehrere Zeilen",
              "language": "cpp",
              "code": "#include <vector>\n\nstd::vector<User> findAllUsers(Database& db) {\n    const char* sql = \"SELECT id, name, age FROM users ORDER BY id;\";\n\n    Statement stmt = db.prepare(sql);\n    std::vector<User> result;\n\n    while (true) {\n        const int rc = stmt.stepRaw();\n\n        if (rc == SQLITE_ROW) {\n            result.push_back(mapUser(stmt.get()));\n            continue;\n        }\n\n        if (rc == SQLITE_DONE) {\n            break;\n        }\n\n        throw std::runtime_error(\"SELECT fehlgeschlagen.\");\n    }\n\n    return result;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Ablauf im Detail",
              "text": [
                "prepare erstellt das Statement.",
                "stepRaw wird in einer Schleife aufgerufen.",
                "Jede Zeile wird gemappt und in den Vector eingef√ºgt.",
                "Bei SQLITE_DONE ist das Ergebnis vollst√§ndig."
              ]
            },
            {
              "type": "comparison",
              "title": "Single Row vs Multi Row SELECT",
              "columns": ["Single Row", "Multi Row"],
              "rows": [
                {
                  "aspect": "R√ºckgabe",
                  "values": ["optional<T>", "std::vector<T>"]
                },
                {
                  "aspect": "Schleife",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "not found",
                  "values": ["std::nullopt", "Leerer Vector"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "SQLITE_DONE vergessen",
              "text": "Wenn SQLITE_DONE nicht korrekt behandelt wird, entsteht eine Endlosschleife."
            },
            {
              "type": "important",
              "text": "Ein leerer Vector ist ein g√ºltiges Ergebnis und kein Fehler."
            },
            {
              "type": "summary",
              "points": [
                "Multi Row SELECT liefert mehrere Zeilen",
                "R√ºckgabe erfolgt als std::vector",
                "sqlite3_step wird in einer Schleife verwendet",
                "SQLITE_ROW f√ºgt ein Element hinzu",
                "SQLITE_DONE beendet die Schleife"
              ]
            }
          ]
        },


        {
          "title": "UPDATE mit Ergebnispr√ºfung",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "UPDATE mit Ergebnispr√ºfung",
              "text": "Ein UPDATE mit Ergebnispr√ºfung unterscheidet zwischen erfolgreicher Ausf√ºhrung ohne Treffer und einem technischen Fehler."
            },
            {
              "type": "explanation",
              "title": "Warum sqlite3_changes",
              "text": [
                "sqlite3_changes liefert die Anzahl der tats√§chlich ge√§nderten Zeilen.",
                "Ein UPDATE kann korrekt ausgef√ºhrt werden, aber keine Zeile betreffen.",
                "Dieser Unterschied ist fachlich relevant."
              ]
            },
            {
              "type": "explanation",
              "title": "Kein Treffer vs Fehler",
              "text": [
                "Kein Treffer bedeutet: SQL korrekt, aber WHERE Bedingung passt auf keine Zeile.",
                "Fehler bedeutet: technischer Fehler bei prepare oder step.",
                "Beide Zust√§nde m√ºssen klar getrennt behandelt werden."
              ]
            },
            {
              "type": "code",
              "title": "UPDATE mit changes Pr√ºfung",
              "language": "cpp",
              "code": "#include <optional>\n\nbool updateUserAge(Database& db, int id, int newAge) {\n    const char* sql = \"UPDATE users SET age = ? WHERE id = ?;\";\n\n    Statement stmt = db.prepare(sql);\n    stmt.bindInt(1, newAge);\n    stmt.bindInt(2, id);\n\n    const int rc = stmt.stepRaw();\n    if (rc != SQLITE_DONE) {\n        throw std::runtime_error(\"UPDATE fehlgeschlagen.\");\n    }\n\n    const int changed = sqlite3_changes(db.get());\n\n    // false bedeutet: kein Treffer\n    return changed > 0;\n}\n"
            },
            {
              "type": "explanation",
              "title": "R√ºckgabekonzept",
              "text": [
                "true signalisiert, dass mindestens eine Zeile ge√§ndert wurde.",
                "false signalisiert einen g√ºltigen, aber wirkungslosen UPDATE.",
                "Technische Fehler werden weiterhin per Exception signalisiert."
              ]
            },
            {
              "type": "comparison",
              "title": "UPDATE Ergebnisse",
              "columns": ["Fall", "Bedeutung"],
              "rows": [
                {
                  "aspect": "SQLITE_DONE + changes > 0",
                  "values": ["Erfolgreich ge√§ndert", "OK"]
                },
                {
                  "aspect": "SQLITE_DONE + changes = 0",
                  "values": ["Kein Treffer", "Kein Fehler"]
                },
                {
                  "aspect": "rc != SQLITE_DONE",
                  "values": ["Technischer Fehler", "Exception"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Kein Treffer als Fehler werten",
              "text": "Ein UPDATE ohne betroffene Zeilen ist kein technischer Fehler und sollte nicht per Exception behandelt werden."
            },
            {
              "type": "important",
              "text": "UPDATE Erfolg und fachlicher Effekt sind zwei verschiedene Dinge und m√ºssen getrennt gepr√ºft werden."
            },
            {
              "type": "summary",
              "points": [
                "UPDATE endet bei Erfolg mit SQLITE_DONE",
                "sqlite3_changes zeigt die Anzahl ge√§nderter Zeilen",
                "Kein Treffer ist kein Fehler",
                "Technische Fehler werden per Exception signalisiert",
                "R√ºckgabewert modelliert den fachlichen Effekt"
              ]
            }
          ]
        },


        {
          "title": "DELETE mit Ergebnispr√ºfung",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "DELETE mit Ergebnispr√ºfung",
              "text": "Ein DELETE mit Ergebnispr√ºfung unterscheidet zwischen einer erfolgreichen L√∂schung, keinem Treffer und einem technischen Fehler."
            },
            {
              "type": "explanation",
              "title": "sqlite3_changes bei DELETE",
              "text": [
                "sqlite3_changes liefert die Anzahl der gel√∂schten Zeilen.",
                "Ein DELETE kann korrekt ausgef√ºhrt werden, aber keine Zeile betreffen.",
                "Dieser Zustand ist fachlich relevant."
              ]
            },
            {
              "type": "explanation",
              "title": "Idempotentes Verhalten",
              "text": [
                "DELETE ist idempotent.",
                "Mehrfaches L√∂schen derselben ID ver√§ndert den Zustand nicht weiter.",
                "Ein zweiter DELETE ohne Treffer ist kein Fehler."
              ]
            },
            {
              "type": "code",
              "title": "DELETE mit changes Pr√ºfung",
              "language": "cpp",
              "code": "bool deleteUserById(Database& db, int id) {\n    const char* sql = \"DELETE FROM users WHERE id = ?;\";\n\n    Statement stmt = db.prepare(sql);\n    stmt.bindInt(1, id);\n\n    const int rc = stmt.stepRaw();\n    if (rc != SQLITE_DONE) {\n        throw std::runtime_error(\"DELETE fehlgeschlagen.\");\n    }\n\n    const int changed = sqlite3_changes(db.get());\n\n    // true: Zeile wurde gel√∂scht, false: nichts zu l√∂schen\n    return changed > 0;\n}\n"
            },
            {
              "type": "explanation",
              "title": "R√ºckgabekonzept",
              "text": [
                "true signalisiert, dass eine Zeile gel√∂scht wurde.",
                "false signalisiert, dass keine passende Zeile existierte.",
                "Technische Fehler werden weiterhin √ºber Exceptions gemeldet."
              ]
            },
            {
              "type": "comparison",
              "title": "DELETE Ergebnisf√§lle",
              "columns": ["Fall", "Bedeutung"],
              "rows": [
                {
                  "aspect": "SQLITE_DONE + changes > 0",
                  "values": ["Gel√∂scht", "OK"]
                },
                {
                  "aspect": "SQLITE_DONE + changes = 0",
                  "values": ["Kein Treffer", "Idempotent"]
                },
                {
                  "aspect": "rc != SQLITE_DONE",
                  "values": ["Technischer Fehler", "Exception"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "DELETE als Fehler behandeln",
              "text": "Ein DELETE ohne Treffer ist kein Fehler, sondern normales idempotentes Verhalten."
            },
            {
              "type": "important",
              "text": "DELETE Operationen sollten idempotent sein und fachlich zwischen gel√∂scht und nicht vorhanden unterscheiden."
            },
            {
              "type": "summary",
              "points": [
                "DELETE endet bei Erfolg mit SQLITE_DONE",
                "sqlite3_changes zeigt die Anzahl gel√∂schter Zeilen",
                "Kein Treffer ist kein Fehler",
                "DELETE ist idempotent",
                "R√ºckgabewert modelliert den fachlichen Effekt"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "Architektur Patterns",
        "icon": "üß©",
        "topics": [
        {
          "title": "Repository Pattern mit SQLite",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Repository Pattern",
              "text": "Das Repository Pattern kapselt Datenbankzugriffe hinter einer klaren Schnittstelle und trennt Fachlogik vollst√§ndig von SQLite spezifischem Code."
            },
            {
              "type": "explanation",
              "title": "Trennung von DB und Fachlogik",
              "text": [
                "SQLite Code geh√∂rt nicht in die Fachlogik.",
                "SQL, Statements und Fehlercodes w√ºrden sonst √ºberall auftauchen.",
                "Die Anwendung arbeitet stattdessen mit fachlichen Methoden."
              ]
            },
            {
              "type": "explanation",
              "title": "Klare Schnittstellen",
              "text": [
                "Repositories bieten klar benannte Methoden wie findById oder save.",
                "Die R√ºckgabetypen spiegeln fachliche Zust√§nde.",
                "Details wie SQL oder sqlite3_step bleiben intern."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Repository Interface",
              "language": "cpp",
              "code": "struct UserRepository {\n    virtual ~UserRepository() = default;\n\n    virtual std::optional<User> findById(int id) = 0;\n    virtual std::vector<User> findAll() = 0;\n    virtual int insert(const User& user) = 0;\n    virtual bool update(const User& user) = 0;\n    virtual bool remove(int id) = 0;\n};\n"
            },
            {
              "type": "explanation",
              "title": "SQLite Implementierung",
              "text": [
                "Die konkrete Implementierung kennt SQLite Details.",
                "Database und Statement Klassen werden intern genutzt.",
                "Nach au√üen bleibt nur das fachliche Interface sichtbar."
              ]
            },
            {
              "type": "code",
              "title": "SQLite User Repository (Ausschnitt)",
              "language": "cpp",
              "code": "class SqliteUserRepository : public UserRepository {\npublic:\n    explicit SqliteUserRepository(Database& db) : db_(db) {}\n\n    std::optional<User> findById(int id) override;\n    std::vector<User> findAll() override;\n    int insert(const User& user) override;\n    bool update(const User& user) override;\n    bool remove(int id) override;\n\nprivate:\n    Database& db_;\n};\n"
            },
            {
              "type": "explanation",
              "title": "Warum das wichtig ist",
              "text": [
                "Fachlogik bleibt testbar ohne echte Datenbank.",
                "SQLite kann sp√§ter ausgetauscht werden.",
                "√Ñnderungen am Schema betreffen nur das Repository."
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Repository Pattern",
              "columns": ["Ohne Repository", "Mit Repository"],
              "rows": [
                {
                  "aspect": "SQL im Code",
                  "values": ["√úberall verteilt", "Gekapselt"]
                },
                {
                  "aspect": "Testbarkeit",
                  "values": ["Schlecht", "Gut"]
                },
                {
                  "aspect": "√Ñnderbarkeit",
                  "values": ["Fehleranf√§llig", "Gezielt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Repository mit Business Logik",
              "text": "Repositories sollten keine fachlichen Entscheidungen treffen, sondern nur Datenzugriff kapseln."
            },
            {
              "type": "important",
              "text": "Das Repository Pattern ist der zentrale Baustein f√ºr saubere Trennung zwischen Datenbank und Anwendung."
            },
            {
              "type": "summary",
              "points": [
                "Repository kapselt SQLite Zugriffe",
                "Fachlogik kennt kein SQL",
                "Klare, fachliche Schnittstellen",
                "Bessere Testbarkeit",
                "Grundlage f√ºr wartbare Architektur"
              ]
            }
          ]
        },


        {
          "title": "Result Typen f√ºr DB Operationen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Result Typ",
              "text": "Ein Result Typ kapselt das Ergebnis einer Datenbank Operation inklusive Status, optionalem Payload und optionalem Fehlertext."
            },
            {
              "type": "explanation",
              "title": "Warum Result Typen",
              "text": [
                "Nicht jede DB Operation ist entweder Erfolg oder technischer Fehler.",
                "Zust√§nde wie NotFound sind fachlich korrekt.",
                "Result Typen machen diese Zust√§nde explizit und typsicher."
              ]
            },
            {
              "type": "explanation",
              "title": "enum Status",
              "text": [
                "Ein enum beschreibt den Ausgang der Operation.",
                "Typische Zust√§nde sind OK, NotFound und Error.",
                "Der Status steuert den weiteren Kontrollfluss."
              ]
            },
            {
              "type": "code",
              "title": "Status Enum",
              "language": "cpp",
              "code": "enum class DBStatus {\n    OK,\n    NotFound,\n    Error\n};\n"
            },
            {
              "type": "explanation",
              "title": "Optionaler Payload",
              "text": [
                "Bei erfolgreichen Operationen kann ein Ergebnisobjekt vorhanden sein.",
                "Bei NotFound oder Error existiert kein Payload.",
                "std::optional modelliert diese Abwesenheit sauber."
              ]
            },
            {
              "type": "code",
              "title": "Result Struct mit Payload",
              "language": "cpp",
              "code": "template <typename T>\nstruct DBResult {\n    DBStatus status;\n    std::optional<T> value;\n    std::string error;\n};\n"
            },
            {
              "type": "explanation",
              "title": "Fehlertext mitgeben",
              "text": [
                "Bei technischen Fehlern sollte ein erkl√§render Text mitgegeben werden.",
                "sqlite3_errmsg kann direkt in den Result Typ √ºbernommen werden.",
                "Die aufrufende Schicht entscheidet, wie der Fehler behandelt wird."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Nutzung bei SELECT",
              "language": "cpp",
              "code": "DBResult<User> findUserById(Database& db, int id) {\n    const char* sql = \"SELECT id, name FROM users WHERE id = ?;\";\n\n    try {\n        Statement stmt = db.prepare(sql);\n        stmt.bindInt(1, id);\n\n        const int rc = stmt.stepRaw();\n\n        if (rc == SQLITE_ROW) {\n            return { DBStatus::OK, mapUser(stmt.get()), \"\" };\n        }\n\n        if (rc == SQLITE_DONE) {\n            return { DBStatus::NotFound, std::nullopt, \"\" };\n        }\n\n        return { DBStatus::Error, std::nullopt, \"Unerwarteter R√ºckgabecode\" };\n    }\n    catch (const std::exception& e) {\n        return { DBStatus::Error, std::nullopt, e.what() };\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "Result Typ vs Exception",
              "columns": ["Result Typ", "Exception"],
              "rows": [
                {
                  "aspect": "NotFound",
                  "values": ["Explizit modelliert", "Ungeeignet"]
                },
                {
                  "aspect": "Kontrollfluss",
                  "values": ["Explizit", "Implizit"]
                },
                {
                  "aspect": "API Klarheit",
                  "values": ["Hoch", "Schwer nachvollziehbar"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Status und Payload inkonsistent",
              "text": "Ein gesetzter Payload bei Error oder NotFound f√ºhrt zu unklarer Semantik."
            },
            {
              "type": "important",
              "text": "Result Typen eignen sich f√ºr Repository APIs, Exceptions f√ºr Infrastruktur Fehler."
            },
            {
              "type": "summary",
              "points": [
                "Result Typen modellieren DB Ergebnisse explizit",
                "enum Status beschreibt den Ausgang",
                "Payload ist optional",
                "Fehlertexte liefern Kontext",
                "Saubere Alternative zu Exceptions in Repositories"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "Transaktionen",
        "icon": "üîí",
        "topics": [
        {
          "title": "Transaktionen Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Transaktion",
              "text": "Eine Transaktion fasst mehrere Datenbank Operationen zu einer unteilbaren Einheit zusammen, die entweder vollst√§ndig ausgef√ºhrt oder vollst√§ndig verworfen wird."
            },
            {
              "type": "explanation",
              "title": "BEGIN",
              "text": [
                "BEGIN startet eine neue Transaktion.",
                "Alle folgenden √Ñnderungen geh√∂ren zur selben Einheit.",
                "Ohne BEGIN arbeitet SQLite im Auto Commit Modus."
              ]
            },
            {
              "type": "explanation",
              "title": "COMMIT",
              "text": [
                "COMMIT best√§tigt alle √Ñnderungen der Transaktion.",
                "Die Daten werden dauerhaft gespeichert.",
                "Die Transaktion wird abgeschlossen."
              ]
            },
            {
              "type": "explanation",
              "title": "ROLLBACK",
              "text": [
                "ROLLBACK verwirft alle √Ñnderungen der laufenden Transaktion.",
                "Die Datenbank kehrt in den Zustand vor BEGIN zur√ºck.",
                "Die Transaktion wird abgebrochen."
              ]
            },
            {
              "type": "code",
              "title": "Einfache Transaktion",
              "language": "cpp",
              "code": "db.execute(\"BEGIN;\");\n\ndb.execute(\"INSERT INTO users (name) VALUES ('Max');\");\ndb.execute(\"INSERT INTO users (name) VALUES ('Anna');\");\n\ndb.execute(\"COMMIT;\");\n"
            },
            {
              "type": "explanation",
              "title": "Warum Transaktionen wichtig sind",
              "text": [
                "Mehrere zusammengeh√∂rige √Ñnderungen m√ºssen konsistent bleiben.",
                "Ein Fehler darf keinen halbfertigen Zustand hinterlassen.",
                "Transaktionen garantieren atomare √Ñnderungen."
              ]
            },
            {
              "type": "comparison",
              "title": "Mit vs ohne Transaktion",
              "columns": ["Ohne Transaktion", "Mit Transaktion"],
              "rows": [
                {
                  "aspect": "Fehler mitten im Ablauf",
                  "values": ["Inkonsistenter Zustand", "Rollback auf alten Zustand"]
                },
                {
                  "aspect": "Performance",
                  "values": ["Langsam bei vielen Writes", "Deutlich schneller"]
                },
                {
                  "aspect": "Konsistenz",
                  "values": ["Nicht garantiert", "Garantiert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "BEGIN ohne COMMIT oder ROLLBACK",
              "text": "Offene Transaktionen k√∂nnen Locks verursachen und sp√§tere Operationen blockieren."
            },
            {
              "type": "important",
              "text": "Jede Transaktion muss mit COMMIT oder ROLLBACK abgeschlossen werden."
            },
            {
              "type": "summary",
              "points": [
                "Transaktionen b√ºndeln mehrere Operationen",
                "BEGIN startet die Transaktion",
                "COMMIT best√§tigt alle √Ñnderungen",
                "ROLLBACK verwirft alle √Ñnderungen",
                "Unverzichtbar f√ºr Konsistenz und Performance"
              ]
            }
          ]
        },



        {
          "title": "Transaction Guard Klasse",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Transaction Guard",
              "text": "Eine Transaction Guard Klasse kapselt eine SQLite Transaktion nach dem RAII Prinzip und sorgt daf√ºr, dass √Ñnderungen entweder committed oder automatisch zur√ºckgerollt werden."
            },
            {
              "type": "explanation",
              "title": "RAII Prinzip",
              "text": [
                "Die Transaktion startet im Konstruktor.",
                "commit wird explizit bei Erfolg aufgerufen.",
                "Im Destruktor erfolgt automatisch ein rollback, falls kein commit stattfand."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum eine Guard Klasse",
              "text": [
                "Vergessene COMMIT oder ROLLBACK Aufrufe f√ºhren zu Locks.",
                "Exceptions k√∂nnen den normalen Kontrollfluss abbrechen.",
                "RAII garantiert sauberes Aufr√§umen in jedem Fall."
              ]
            },
            {
              "type": "code",
              "title": "TransactionGuard Grundstruktur",
              "language": "cpp",
              "code": "class TransactionGuard {\npublic:\n    explicit TransactionGuard(Database& db)\n        : db_(db), committed_(false) {\n        db_.execute(\"BEGIN;\");\n    }\n\n    void commit() {\n        db_.execute(\"COMMIT;\");\n        committed_ = true;\n    }\n\n    ~TransactionGuard() {\n        if (!committed_) {\n            try {\n                db_.execute(\"ROLLBACK;\");\n            } catch (...) {\n                // Destruktor darf keine Exception werfen\n            }\n        }\n    }\n\nprivate:\n    Database& db_;\n    bool committed_;\n};\n"
            },
            {
              "type": "explanation",
              "title": "Typische Nutzung",
              "text": [
                "Die Guard wird am Anfang eines Blocks erstellt.",
                "Mehrere Datenbank Operationen folgen.",
                "commit wird nur bei vollst√§ndigem Erfolg aufgerufen."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Nutzung",
              "language": "cpp",
              "code": "void createUsers(Database& db) {\n    TransactionGuard tx(db);\n\n    insertUser(db, \"Max\", 30);\n    insertUser(db, \"Anna\", 25);\n\n    tx.commit();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Fehlerfall",
              "text": [
                "Wirft eine Operation eine Exception, wird commit nicht erreicht.",
                "Der Destruktor der Guard wird aufgerufen.",
                "ROLLBACK stellt den alten Zustand wieder her."
              ]
            },
            {
              "type": "pitfall",
              "title": "commit vergessen",
              "text": "Wird commit nicht aufgerufen, werden alle √Ñnderungen bewusst verworfen."
            },
            {
              "type": "important",
              "text": "Transaction Guards d√ºrfen im Destruktor niemals Exceptions weiterwerfen."
            },
            {
              "type": "summary",
              "points": [
                "Transaction Guard nutzt RAII",
                "BEGIN im Konstruktor",
                "COMMIT bei Erfolg",
                "ROLLBACK automatisch im Fehlerfall",
                "Sichere und konsistente Transaktionen"
              ]
            }
          ]
        }



        ]
      },



      {
        "name": "Tests",
        "icon": "üß™",
        "topics": [
        {
          "title": "SQLite In Memory Datenbank",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": ":memory:",
              "text": "Eine In Memory Datenbank ist eine SQLite Datenbank, die vollst√§ndig im Arbeitsspeicher liegt und keine Datei auf dem Dateisystem erzeugt."
            },
            {
              "type": "explanation",
              "title": "Wie :memory: funktioniert",
              "text": [
                "Statt eines Dateipfads wird \":memory:\" beim √ñffnen der Datenbank verwendet.",
                "Die Datenbank existiert nur f√ºr die Lebensdauer der Verbindung.",
                "Nach dem Schlie√üen der Verbindung gehen alle Daten verloren."
              ]
            },
            {
              "type": "code",
              "title": "In Memory Datenbank √∂ffnen",
              "language": "cpp",
              "code": "Database db(\":memory:\");\n"
            },
            {
              "type": "explanation",
              "title": "Schnelles Testen",
              "text": [
                "Keine Datei I/O notwendig.",
                "Sehr schnelle CREATE, INSERT und SELECT Operationen.",
                "Ideal f√ºr Unit Tests und lokale Experimente."
              ]
            },
            {
              "type": "explanation",
              "title": "Schema pro Test",
              "text": [
                "Jeder Test kann seine eigene Datenbank erzeugen.",
                "Das Schema wird zu Beginn des Tests erstellt.",
                "Tests beeinflussen sich nicht gegenseitig."
              ]
            },
            {
              "type": "code",
              "title": "Schema im Test aufbauen",
              "language": "cpp",
              "code": "void setupTestDb(Database& db) {\n    db.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);\");\n}\n"
            },
            {
              "type": "comparison",
              "title": "In Memory vs Datei Datenbank",
              "columns": ["In Memory", "Datei"],
              "rows": [
                {
                  "aspect": "Geschwindigkeit",
                  "values": ["Sehr hoch", "Langsamer"]
                },
                {
                  "aspect": "Persistenz",
                  "values": ["Keine", "Dauerhaft"]
                },
                {
                  "aspect": "Test Isolation",
                  "values": ["Perfekt", "Aufwendig"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrere Verbindungen",
              "text": "Jede Verbindung zu :memory: erzeugt eine eigene Datenbank. Daten werden nicht geteilt."
            },
            {
              "type": "important",
              "text": "In Memory Datenbanken sind ideal f√ºr Tests, aber ungeeignet f√ºr persistente Anwendungdaten."
            },
            {
              "type": "summary",
              "points": [
                ":memory: erzeugt eine tempor√§re SQLite Datenbank",
                "Existiert nur f√ºr die Lebensdauer der Verbindung",
                "Extrem schnell f√ºr Tests",
                "Schema kann pro Test neu erstellt werden",
                "Keine Persistenz"
              ]
            }
          ]
        },


        {
          "title": "Typische Fehlerf√§lle testen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Fehlerf√§lle",
              "text": "Typische Fehlerf√§lle sind erwartbare Zust√§nde oder technische Probleme, die bei Datenbank Operationen auftreten k√∂nnen und gezielt getestet werden sollten."
            },
            {
              "type": "explanation",
              "title": "Warum Fehlerf√§lle testen",
              "text": [
                "Erfolgsf√§lle allein decken reale Nutzung nicht ab.",
                "Fehlerf√§lle bestimmen die Stabilit√§t der Anwendung.",
                "Gezielte Tests verhindern stille Datenfehler."
              ]
            },
            {
              "type": "explanation",
              "title": "Constraint Violation",
              "text": [
                "Constraints erzwingen Regeln wie NOT NULL, UNIQUE oder FOREIGN KEY.",
                "Verletzungen f√ºhren zu SQLITE_CONSTRAINT.",
                "Dieser Fehler ist fachlich erwartbar."
              ]
            },
            {
              "type": "code",
              "title": "Constraint Violation testen",
              "language": "cpp",
              "code": "TEST(insert_user_unique_name) {\n    Database db(\":memory:\");\n    db.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT UNIQUE);\");\n\n    insertUser(db, \"Max\", 30);\n\n    // gleicher Name verletzt UNIQUE Constraint\n    EXPECT_THROW(insertUser(db, \"Max\", 25), std::runtime_error);\n}\n"
            },
            {
              "type": "explanation",
              "title": "Not Found",
              "text": [
                "Ein SELECT kann korrekt sein, aber kein Ergebnis liefern.",
                "Dieser Zustand ist kein Fehler.",
                "Er sollte explizit getestet werden."
              ]
            },
            {
              "type": "code",
              "title": "Not Found testen",
              "language": "cpp",
              "code": "TEST(select_user_not_found) {\n    Database db(\":memory:\");\n    db.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);\");\n\n    auto result = findUserById(db, 42);\n    EXPECT_FALSE(result.has_value());\n}\n"
            },
            {
              "type": "explanation",
              "title": "BUSY Zustand",
              "text": [
                "SQLITE_BUSY tritt auf, wenn die Datenbank gesperrt ist.",
                "Typisch bei parallelen Zugriffen oder offenen Transaktionen.",
                "Der Zustand ist tempor√§r."
              ]
            },
            {
              "type": "code",
              "title": "BUSY simulieren",
              "language": "cpp",
              "code": "TEST(busy_database) {\n    Database db1(\":memory:\");\n    Database db2(\":memory:\");\n\n    db1.execute(\"BEGIN;\");\n\n    // paralleler Zugriff kann SQLITE_BUSY ausl√∂sen\n    EXPECT_THROW(db2.execute(\"CREATE TABLE test (id INTEGER);\"), std::runtime_error);\n\n    db1.execute(\"ROLLBACK;\");\n}\n"
            },
            {
              "type": "comparison",
              "title": "Fehlerarten",
              "columns": ["Fehlerfall", "Bedeutung"],
              "rows": [
                {
                  "aspect": "Constraint Violation",
                  "values": ["Fachlich erwartet", "Datenregel verletzt"]
                },
                {
                  "aspect": "Not Found",
                  "values": ["Kein Fehler", "Kein Datensatz"]
                },
                {
                  "aspect": "BUSY",
                  "values": ["Tempor√§r", "Lock oder Parallelzugriff"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Fehlerf√§lle ignorieren",
              "text": "Nicht getestete Fehlerf√§lle f√ºhren oft zu instabilem Verhalten in Produktion."
            },
            {
              "type": "important",
              "text": "Fehlerf√§lle sollten bewusst getestet und nicht nur implizit akzeptiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Constraint Violations sind erwartbare Fehler",
                "Not Found ist kein technischer Fehler",
                "BUSY ist ein tempor√§rer Zustand",
                "Alle drei F√§lle sollten getestet werden",
                "Stabile Software entsteht durch Fehlerfall Tests"
              ]
            }
          ]
        },




        {
          "title": "Tests in C++ anwenden (SQLite und :memory:)",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Unit Tests",
              "text": "Unit Tests sind automatisierte Tests, die einzelne Funktionen oder Klassen isoliert pr√ºfen, zum Beispiel Repository Methoden mit einer In Memory SQLite Datenbank."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Tests laufen in einem separaten Programm, nicht im normalen main.",
                "Der Test Runner f√ºhrt alle Testf√§lle aus und gibt ein Ergebnis zur√ºck.",
                "Eine In Memory Datenbank sorgt f√ºr schnelle und isolierte Tests."
              ]
            },
            {
              "type": "explanation",
              "title": "Projektstruktur f√ºr Tests",
              "text": [
                "Produktivcode bleibt in src.",
                "Tests liegen in einem eigenen tests Ordner.",
                "Ein eigenes Test Executable baut und linkt denselben Code wie die App."
              ]
            },
            {
              "type": "code",
              "title": "Beispiel Ordnerstruktur",
              "language": "text",
              "code": "project/\n  src/\n    main.cpp\n    database/\n    repository/\n  tests/\n    test_main.cpp\n    test_users.cpp\n  external/\n    sqlite/\n  CMakeLists.txt\n"
            },
            {
              "type": "explanation",
              "title": "Testframework: doctest als leichter Einstieg",
              "text": [
                "doctest ist leichtgewichtig und schnell aufzusetzen.",
                "Ein Test Runner wird √ºber eine einzige Datei erzeugt.",
                "Tests sind normale C++ Dateien, die mit dem Test Runner gelinkt werden."
              ]
            },
            {
              "type": "code",
              "title": "test_main.cpp (Test Runner)",
              "language": "cpp",
              "code": "#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include <doctest/doctest.h>\n"
            },
            {
              "type": "explanation",
              "title": "Beispiel Test: Not Found mit :memory:",
              "text": [
                "Jeder Test erstellt seine eigene In Memory Datenbank.",
                "Schema wird im Test gesetzt.",
                "Not Found wird √ºber optional gepr√ºft."
              ]
            },
            {
              "type": "code",
              "title": "test_users.cpp (Not Found Test)",
              "language": "cpp",
              "code": "#include <doctest/doctest.h>\n\nTEST_CASE(\"select_user_not_found\") {\n    Database db(\":memory:\");\n    db.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);\");\n\n    auto result = findUserById(db, 42);\n    CHECK_FALSE(result.has_value());\n}\n"
            },
            {
              "type": "explanation",
              "title": "CMake: Test Executable bauen",
              "text": [
                "Ein eigenes Executable tests wird angelegt.",
                "Die Test Dateien werden hinzugef√ºgt.",
                "SQLite Target wird gelinkt.",
                "Der gleiche Standard wie im Projekt wird verwendet."
              ]
            },
            {
              "type": "code",
              "title": "CMakeLists.txt (Tests Target)",
              "language": "cmake",
              "code": "add_executable(tests\n    tests/test_main.cpp\n    tests/test_users.cpp\n)\n\ntarget_link_libraries(tests PRIVATE\n    sqlite3\n)\n\ntarget_compile_features(tests PRIVATE cxx_std_20)\n"
            },
            {
              "type": "explanation",
              "title": "Tests ausf√ºhren",
              "text": [
                "Nach dem Build wird das tests Executable gestartet.",
                "Ein Exit Code von 0 bedeutet alle Tests erfolgreich.",
                "Bei Fehlern wird ein nicht null Exit Code zur√ºckgegeben."
              ]
            },
            {
              "type": "code",
              "title": "Tests starten",
              "language": "text",
              "code": "cmake --build .\n./tests\n"
            },
            {
              "type": "pitfall",
              "title": "Tests sind nicht isoliert",
              "text": "Wenn mehrere Tests dieselbe Datei Datenbank nutzen oder kein eigenes Schema aufbauen, beeinflussen sich Tests gegenseitig."
            },
            {
              "type": "important",
              "text": "Jeder Test sollte eine eigene :memory: Datenbank und ein eigenes Schema erstellen, damit Tests reproduzierbar und unabh√§ngig sind."
            },
            {
              "type": "summary",
              "points": [
                "Tests laufen in einem separaten Executable",
                "doctest ist ein einfacher Einstieg",
                "test_main.cpp erzeugt den Test Runner",
                "Jeder Test nutzt :memory: und baut sein Schema",
                "CMake erstellt ein eigenes tests Target",
                "Tests werden wie ein normales Programm gestartet"
              ]
            }
          ]
        }




        ]
      }


      
    ]
  },









  {
    "category": "PostgreSQL",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SUBCATEGORIE1",
        "icon": "üß±",
        "topics": [
        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },

        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        }



        ]
      },


      {
        "name": "SUBCATEGORIE2",
        "icon": "üß±",
        "topics": [
        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },

        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        },


        {
          "title": "---",
          "difficulty": "basic",
          "blocks": [
          ]
        }



        ]
      }

      
    ]
  }




  

]
