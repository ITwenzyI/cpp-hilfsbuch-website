[
  {
    "category": "Grundlagen",
    "subtopics": [
      {
        "title": "Console Ausgabe UTF-8 Windows",
        "content": {
          "text": [
            "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
            "In Clion auf Windows, zeigt die Console keine Ãœ,Ã„,Ã– usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
            "### FONT Einstellen:",
            "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
            "In Clion: Einstellungen/Editor/General/Font dort Font: Consolar Size: 13.0 Line height: 1.2\n\n\n",
            "### CODE in main.lua:"
          ],
          "code": [
            "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
          ]
        }
      },
      {
  "title": "Working Directory in CLion",
  "content": {
    "text": [
      "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
      "StandardmÃ¤ÃŸig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen mÃ¶chtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.â€¯B. `data/info.txt`), musst du das Arbeitsverzeichnis (â€žWorking Directoryâ€œ) Ã¤ndern.\n",
      "\n",
      "### ðŸ”¹ Zielstruktur\n",
      "```\n",
      "Projektordner/\n",
      "â”œâ”€â”€ CMakeLists.txt\n",
      "â”œâ”€â”€ data/\n",
      "â””â”€â”€ cmake-build-debug/\n",
      "```\n",
      "\n",
      "### ðŸ”¹ Einstellung in CLion\n",
      "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
      "2. WÃ¤hle **â€žEdit Configurationsâ€¦â€œ**.\n",
      "3. WÃ¤hle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
      "4. Im Feld **â€žWorking directoryâ€œ** trÃ¤gst du ein: `$ProjectFileDir$`\n",
      "   â†’ Das sorgt dafÃ¼r, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
      "\n",
      "### ðŸ”¹ PrÃ¼fen im Code\n",
      "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:\n",
      "\n",
      "```cpp\n",
      "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n",
      "```\n",
      "\n",
      "### ðŸ”¹ Hinweis\n",
      "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:\n",
      "```cpp\n",
      "std::filesystem::create_directories(\"data\");\n",
      "```\n"
    ],
    "code": [
      "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Begriffe",
        "content": {
          "text": [
          "### === Wichtige Begriffe in C++ erklÃ¤rt ===\n",
          "Hier findest du eine Ãœbersicht zentraler Begriffe in der C++-Programmierung, kompakt erklÃ¤rt.\n",
          "\n",
          "#### Compiler\n",
          "- Ãœbersetzt C++-Code in Maschinenprogramm, das dein Computer ausfÃ¼hren kann\n",
          "\n",
          "#### PrÃ¤prozessor\n",
          "- FÃ¼hrt Anweisungen wie `#include` und `#define` vor dem Kompilieren aus\n",
          "\n",
          "#### Header-Datei\n",
          "- Datei mit Deklarationen von Funktionen, Klassen oder Konstanten (meist `.h` oder `.hpp`)\n",
          "\n",
          "#### Deklaration vs. Definition\n",
          "- Deklaration: Nur AnkÃ¼ndigung (z.B. `int x;`)\n",
          "- Definition: Speicher wird wirklich zugewiesen (z.B. `int x = 5;`)\n",
          "\n",
          "#### Variable\n",
          "- Speicherstelle mit Namen, die Daten aufnehmen kann (z.B. `int zahl = 10;`)\n",
          "\n",
          "#### Funktion\n",
          "- Codeblock, der mehrfach ausfÃ¼hrbar ist â€“ mit `return`-Wert und Parametern\n",
          "\n",
          "#### RÃ¼ckgabewert\n",
          "- Der Wert, den eine Funktion mit `return` zurÃ¼ckliefert\n",
          "\n",
          "#### Parameter vs. Argument\n",
          "- Parameter: Platzhalter in der Funktionsdefinition (`int add(int a, int b)`)\n",
          "- Argument: Konkreter Wert beim Aufruf (`add(5, 7)` â†’ 5 und 7)\n",
          "\n",
          "#### Block / Scope\n",
          "- Bereich mit `{}` â€“ darin gelten lokale Variablen\n",
          "\n",
          "#### GÃ¼ltigkeitsbereich (Scope)\n",
          "- Gibt an, wo im Code eine Variable sichtbar/nutzbar ist (z.B. lokal vs. global)\n",
          "\n",
          "#### Initialisierung\n",
          "- Erstmalige Zuweisung eines Werts an eine Variable (`int x = 5;`)\n",
          "\n",
          "#### Operatoren\n",
          "- Rechenzeichen oder Symbole zur Verarbeitung (`+`, `-`, `==`, `&&`, `++`, `<<`)\n",
          "\n",
          "#### Kontrollstrukturen\n",
          "- Anweisungen zur Ablaufsteuerung: `if`, `while`, `for`, `switch`\n",
          "\n",
          "#### Schleife\n",
          "- Wiederholt Anweisungen: `while`, `for`, `do-while`\n",
          "\n",
          "#### Bedingung\n",
          "- Ausdruck, der `true` oder `false` ergibt (z.B. `x > 5`)\n",
          "\n",
          "#### Klasse / Objekt\n",
          "- Klasse: Bauplan fÃ¼r Objekte (enthÃ¤lt Daten + Funktionen)\n",
          "- Objekt: Konkrete Instanz einer Klasse\n",
          "\n",
          "#### Konstruktor / Destruktor\n",
          "- Konstruktor: Wird beim Erzeugen eines Objekts automatisch aufgerufen\n",
          "- Destruktor: Wird beim LÃ¶schen automatisch aufgerufen (`~Klassenname()`)\n",
          "\n",
          "#### this-Zeiger\n",
          "- Zeigt innerhalb einer Klasse auf das aktuelle Objekt (`this->variable`)\n",
          "\n",
          "#### new / delete\n",
          "- `new`: Reserviert Speicher auf dem Heap (`int* p = new int;`)\n",
          "- `delete`: Gibt diesen Speicher wieder frei\n",
          "\n",
          "#### Referenz (&)\n",
          "- Alias auf eine bestehende Variable (z.B. `int& r = x;`)\n",
          "\n",
          "#### Zeiger (*)\n",
          "- Variable, die eine Speicheradresse speichert (`int* p = &x;`)\n",
          "\n",
          "#### nullptr\n",
          "- Null-Zeiger, zeigt auf â€žnichtsâ€œ (`int* p = nullptr;`)\n",
          "\n",
          "#### Ãœberladung\n",
          "- Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Signatur\n",
          "\n",
          "#### Vererbung\n",
          "- Eine Klasse Ã¼bernimmt Eigenschaften einer anderen Klasse\n",
          "\n",
          "#### Polymorphie\n",
          "- FÃ¤higkeit, Objekte Ã¼ber gemeinsame Schnittstellen unterschiedlich zu behandeln\n",
          "\n",
          "#### Template\n",
          "- ErmÃ¶glicht generischen Code (z.B. Funktionen fÃ¼r beliebige Typen)\n",
          "\n",
          "#### Lambda\n",
          "- Anonyme Funktion, oft fÃ¼r kurze Aktionen in `std::for_each`, `sort`, ...\n",
          "\n",
          "#### Iterator\n",
          "- Zeiger-Ã¤hnliches Objekt zum Durchlaufen von Containern (`v.begin()`, `v.end()`)\n"
        ],
          "code": [
            "#include <iostream>\n\n\nint main() {\n  std::cout << \"NICHTS ZU KOPIEREN :C\" << std::endl;\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Typen",
        "content": {
          "text": [
            "### === Datentypen in C++ ===\n",
            "C++ kennt viele eingebaute Typen und erlaubt die Definition eigener Typen.\n",
            "\n",
            "### Standard-Datentypen\n",
            "- `int`: Ganzzahl (z.B. `int x = 5;`)\n",
            "- `float`: FlieÃŸkommazahl mit einfacher Genauigkeit\n",
            "- `double`: FlieÃŸkommazahl mit doppelter Genauigkeit\n",
            "- `char`: Einzelnes Zeichen (z.B. `'A'`)\n",
            "- `bool`: Wahrheitswert (`true` / `false`)\n",
            "- `void`: Kein RÃ¼ckgabewert (z.B. bei `void funktion()`)\n",
            "\n",
            "### Erweiterte Grundtypen\n",
            "- `long`, `long long`, `unsigned`, `short`: Varianten von `int`\n",
            "- `wchar_t`, `char16_t`, `char32_t`: Unicode-Zeichentypen\n",
            "- `std::string`: String-Klasse (aus `<string>`)\n",
            "- `std::size_t`: Unsigned Ganzzahl fÃ¼r GrÃ¶ÃŸen (z.B. `v.size()`)\n",
            "- `nullptr_t`: Typ des Literals `nullptr`\n",
            "\n",
            "### Automatische Typableitung\n",
            "- `auto`: Typ wird automatisch aus dem Ausdruck ermittelt\n",
            "- `decltype(...)`: Liefert den Typ eines Ausdrucks\n",
            "- Beispiel:\n",
            "```cpp\nint x = 5;\nauto y = x * 2;         // y ist int\ndecltype(y) z = 10;      // z ist auch int\n```\n",
            "\n",
            "### Eigene Typen\n",
            "- `struct`: FÃ¼r einfache Strukturen mit mehreren Feldern\n",
            "- `class`: FÃ¼r Klassen mit Methoden und Zugriffskontrolle (public/private)\n",
            "- `enum`: FÃ¼r aufzÃ¤hlbare Werte\n",
            "\n",
            "#### `enum` ErklÃ¤rung:\n",
            "- `enum` erstellt eigene ganzzahlige Werte (standardmÃ¤ÃŸig beginnend bei 0)\n",
            "- Beispiel:\n",
            "```cpp\nenum Farbe { Rot, Gruen, Blau };  // Rot = 0, Gruen = 1, Blau = 2\n```\n",
            "- Man kann Werte auch selbst zuweisen:\n",
            "```cpp\nenum Status { OK = 1, FEHLER = 404, NICHT_GEFUNDEN = 4040 };\n```\n",
            "- Zugriff auf Zahlwert mit `static_cast<int>(enumWert)`:\n",
            "```cpp\nStatus s = FEHLER;\nstd::cout << static_cast<int>(s);  // Ausgabe: 404\n```\n",
            "- `enum class` (modernes C++): Streng typisiert, Zugriff nur mit `Status::FEHLER`\n",
            "\n",
            "- `typedef` (alt) und `using` (modern): Eigene Namen fÃ¼r bestehende Typen\n",
            "- Beispiel:\n",
            "```cpp\ntypedef unsigned int uint;\nusing Score = double;\n```",
            "\n",
            "### Typumwandlung (Casting)\n",
            "- `static_cast<T>(wert)`: Sicherer Cast zwischen kompatiblen Typen\n",
            "- `reinterpret_cast<T>`: FÃ¼r Low-Level-Zugriff (meist vermeiden!)\n",
            "- `const_cast<T>`: Entfernt `const`\n",
            "- `dynamic_cast<T>`: FÃ¼r Vererbung und Polymorphie (mit RTTI)\n",
            "\n",
            "ðŸ‘‰ FÃ¼r sichere TypprÃ¼fung: `typeid(variable).name()` (aus `<typeinfo>`) oder `std::is_same<T, U>()` (aus `<type_traits>`)\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <typeinfo>\n\n// Eigene Struktur\nstruct Person {\n    std::string name;\n    int alter;\n};\n\n// Typalias\nusing Zahl = unsigned int;\n\nenum Farbe { Rot, Gruen, Blau };           // Rot = 0, Gruen = 1, Blau = 2\nenum Status { OK = 1, FEHLER = 404 };      // eigene Werte\n\nint main() {\n    int a = 10;\n    auto b = 3.14;                          // automatisch double\n    decltype(a) c = 5;                      // ebenfalls int\n\n    Person p = {\"Kilian\", 21};\n    Zahl punkte = 150;\n\n    Farbe f = Gruen;\n    Status s = FEHLER;\n\n    std::cout << \"Name: \" << p.name << \", Alter: \" << p.alter << std::endl;         // Ausgabe: Name: Kilian, Alter: 21\n    std::cout << \"Punkte: \" << punkte << std::endl;                                  // Ausgabe: Punkte: 150\n    std::cout << \"Typ von b: \" << typeid(b).name() << std::endl;                     // Ausgabe: Typ von b: double (compilerabhÃ¤ngig)\n    std::cout << \"Fehlercode: \" << static_cast<int>(s) << std::endl;                // Ausgabe: Fehlercode: 404\n\n    return 0;\n}"
          ]
        }
      },
      {
        "title": "Header",
        "content": {
          "text": [
            "### === Wichtige Header-Dateien in C++ ===\n",
            "Header-Dateien enthalten Deklarationen von Funktionen, Klassen und Datentypen. Standard-Header kommen aus der C++-Standardbibliothek, eigene erstellt man selbst.\n",
            "\n",
            "### Arten von `#include`\n",
            "- `#include <...>`: FÃ¼r Standardbibliothek (z.B. `<iostream>`, `<vector>`, ...)\n",
            "- `#include \"...\"`: FÃ¼r eigene Dateien (z.B. `\"meinmodul.hpp\"`)\n",
            "\n",
            "### Eigene Header-Dateien\n",
            "- Eigene Header enden meist auf `.h` oder `.hpp`\n",
            "- Sie enthalten **Deklarationen**, keine Implementierungen\n",
            "- Die zugehÃ¶rige `.cpp`-Datei enthÃ¤lt dann die **Definitionen**\n",
            "\n",
            "#### Beispiel â€“ Header-Datei: `meinmodul.h`\n",
            "```cpp\n#ifndef MEINMODUL_H\n#define MEINMODUL_H\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n```\n",
            "\n",
            "#### Beispiel â€“ Implementierung: `meinmodul.cpp`\n",
            "```cpp\n#include <iostream>\n#include \"meinmodul.h\"\n\nvoid begruessung() {\n    std::cout << \"Hallo!\";\n}\n```\n",
            "\n",
            "#### In `main.cpp` verwenden:\n",
            "```cpp\n#include \"meinmodul.h\"\n\nint main() {\n    begruessung();\n    return 0;\n}\n```\n",
            "\n",
            "ðŸ‘‰ Vorteil: strukturierter Code, Wiederverwendbarkeit und Trennung von Schnittstelle & Implementierung\n",
            "\n",
            "### Include Guards (Schutz vor Mehrfacheinbindung)\n",
            "- Jeder eigene Header sollte mit einem **Include Guard** versehen werden:\n",
            "```cpp\n#ifndef MEIN_HEADER_H\n#define MEIN_HEADER_H\n\n// Inhalte des Headers\n\n#endif\n```\n",
            "- Verhindert doppelte Definitionen beim mehrfachen Einbinden\n",
            "\n",
            "### Ãœbersicht wichtiger Standard-Header:\n",
            "\n",
            "#### Ein- und Ausgabe\n",
            "- `<iostream>`: `std::cin`, `std::cout`, `std::cerr`\n",
            "- `<iomanip>`: `std::setw`, `std::setprecision`, `std::fixed`, `std::put_time`\n",
            "- `<fstream>`: Datei-I/O mit `ifstream`, `ofstream`, `fstream`\n",
            "\n",
            "#### Strings und Streams\n",
            "- `<string>`: `std::string`\n",
            "- `<sstream>`: `std::stringstream` fÃ¼r String-Parsing und Umwandlungen\n",
            "\n",
            "#### Mathematisches\n",
            "- `<cmath>`: `sqrt`, `pow`, `abs`, `round`, `sin`, `log`\n",
            "- `<cstdlib>`: `rand`, `srand`, `atoi`, `atof`\n",
            "- `<limits>`: `numeric_limits<T>::max()` / `min()`\n",
            "\n",
            "#### Zeit und Threads\n",
            "- `<ctime>`: `std::time`, `std::localtime`\n",
            "- `<chrono>`: Zeitmessung (z.B. `high_resolution_clock`)\n",
            "- `<thread>`: `std::this_thread::sleep_for()`\n",
            "\n",
            "#### Container & Algorithmen\n",
            "- `<vector>`, `<array>`, `<set>`, `<map>`\n",
            "- `<stack>`, `<queue>`\n",
            "- `<algorithm>`: `sort`, `find`, `remove`, `for_each`, ...\n",
            "- `<iterator>`: Iteratorfunktionen wie `begin()`/`end()`\n",
            "\n",
            "#### Weitere nÃ¼tzliche Header\n",
            "- `<exception>`: `std::exception`, `std::runtime_error`\n",
            "- `<functional>`: Funktionsobjekte, Lambdas, `std::function`\n",
            "- `<typeinfo>`: Laufzeittypinfo (`typeid`)\n",
            "- `<cassert>`: `assert()` fÃ¼r Debug-Checks\n",
            "- `<bitset>`: binÃ¤re Felder\n",
            "- `<utility>`: `std::pair`, `std::swap`, `std::move`\n",
            "- `<memory>`: Smart Pointers wie `unique_ptr`, `shared_ptr`\n"
          ],
          "code": [
            "#ifndef MEINMODUL_H\n#define MEINMODUL_H\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n\n// -----------------------------\n#include <iostream>\n#include \"meinmodul.h\"\n\nvoid begruessung() {\n  std::cout << \"Hallo!\";\n}\n\nint main() {\n  begruessung(); // Ausgabe: Hallo!\n  return 0;\n}"

          ]
        }
      },
      {
  "title": "Initialisierung  : vs. {}",
  "content": {
    "text": [
      "### === Initialisierung mit `:` vs. `{}` in C++ ===\n",
      "C++ bietet verschiedene MÃ¶glichkeiten, wie Variablen und Klassenmitglieder initialisiert werden kÃ¶nnen. Besonders wichtig sind:\n",
      "- `:` â†’ Initialisierungsliste bei Konstruktoren\n",
      "- `{}` â†’ Einheitliche Initialisierung (Brace-Initialization / Uniform Initialization)\n",
      "\n",
      "### Initialisierungsliste mit `:`\n",
      "- Wird in Konstruktoren verwendet, um Member **direkt zu initialisieren**, bevor der Body ausgefÃ¼hrt wird\n",
      "- **Effizienter** als Zuweisung im Konstruktorblock (insbesondere bei `const`- oder Referenz-Membern)\n",
      "\n",
      "```cpp\nclass Auto {\nprivate:\n    int ps;\npublic:\n    Auto(int p) : ps(p) {}   // Initialisierung mit Doppelpunkten\n};\n```\n",
      "\n",
      "### Warum `:` statt `=` im Body?\n",
      "- `:` initialisiert direkt beim Erzeugen â†’ **vermeidet unnÃ¶tige Standardinitialisierung + spÃ¤tere Zuweisung**\n",
      "- Pflicht bei `const` oder Referenzen:\n",
      "```cpp\nclass Test {\n    const int wert;\npublic:\n    Test(int w) : wert(w) {}  // Muss so gemacht werden\n};\n```\n",
      "\n",
      "### Einheitliche Initialisierung mit `{}`\n",
      "- EingefÃ¼hrt mit C++11\n",
      "- Kann **Konstruktoren**, **Arrays**, **STL-Container** und **structs** initialisieren\n",
      "- **Vermeidet Verwechslungen** mit Funktionsdeklarationen (Most Vexing Parse)\n",
      "\n",
      "```cpp\nint a{5};                  // Direktinitialisierung\nstd::vector<int> zahlen{1, 2, 3};\nAuto b{150};                // ruft Konstruktor mit `int` auf\n```\n",
      "\n",
      "### Kombination\n",
      "- Beides lÃ¤sst sich kombinieren:\n",
      "```cpp\nclass Zahl {\n    int wert;\npublic:\n    Zahl(int w) : wert{w} {}  // Doppelt sicher: Initialisierungsliste + {}\n};\n```\n",
      "\n",
      "ðŸ‘‰ Faustregel:\n",
      "- **Konstruktoren mit `:` initialisieren Member**\n",
      "- **`{}` ist sicherer, universeller Stil ab C++11**\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Beispiel {\nprivate:\n    const int wert;\n    std::vector<int> zahlen;\n\npublic:\n    // Initialisierung mit : und {}\n    Beispiel(int w) : wert(w), zahlen{1, 2, 3} {}\n\n    void anzeigen() {\n        std::cout << \"Wert: \" << wert << \" | Erster Wert: \" << zahlen[0] << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b{42};      // Konstruktor-Aufruf mit {} Initialisierung\n    b.anzeigen();         // Ausgabe: Wert: 42 | Erster Wert: 1\n\n    int x{10};            // Brace-Initialisierung einer einfachen Variable\n    std::cout << \"x: \" << x << std::endl;\n\n    return 0;\n}"
    ]
        }
      }
    ]
  },







  {
    "category": "Ein-/Ausgabe",
    "subtopics": [
      {
        "title": "Eingabe",
        "content": {
          "text": [
            "### === Benutzereingabe in C++ ===\n",
            "FÃ¼r die Eingabe in C++ wird meist `std::cin` verwendet. Dabei wird direkt aus der Konsole gelesen.\n",
            "\n",
            "### `std::cin`\n",
            "- Liest eine Eingabe **bis zum ersten Leerzeichen**\n",
            "- Nur fÃ¼r einzelne WÃ¶rter oder Zahlen geeignet\n",
            "\n",
            "### `std::getline`\n",
            "- Liest eine ganze **Zeile** (inklusive Leerzeichen)\n",
            "- Ideal fÃ¼r Namen, Adressen, ganze SÃ¤tze usw.\n",
            "- Wichtig: vorher `std::cin.ignore()` nutzen, wenn zuvor `cin` verwendet wurde\n",
            "\n",
            "### `std::cin.ignore()`\n",
            "- Leert den Eingabepuffer, z.B. nach `cin` vor `getline`\n",
            "- Typisch: `std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');`\n",
            "\n",
            "### `std::stringstream`\n",
            "- Konvertiert zwischen Strings und Zahlen\n",
            "- NÃ¼tzlich fÃ¼r Eingaben mit vielen Werten in einer Zeile\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <limits> // fÃ¼r std::numeric_limits\n\nint main() {\n  std::string name;\n  int alter;\n\n  // Eingabe eines einzelnen Werts\n  std::cout << \"Wie alt bist du? \";\n  std::cin >> alter;\n\n  // Eingabepuffer leeren (wichtig vor getline)\n  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n  // Eingabe einer ganzen Zeile\n  std::cout << \"Wie heiÃŸt du? \";\n  std::getline(std::cin, name);\n\n  std::cout << \"Hallo \" << name << \", du bist \" << alter << \" Jahre alt.\" << std::endl;\n\n  // Stringstream Beispiel\n  std::string eingabe = \"23 42 99\";\n  std::stringstream ss(eingabe);\n  int zahl1, zahl2, zahl3;\n  ss >> zahl1 >> zahl2 >> zahl3;\n  std::cout << \"Zahlen aus dem String: \" << zahl1 << \", \" << zahl2 << \", \" << zahl3 << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Ausgabe",
        "content": {
          "text": [
            "### === Ausgabe mit `std::cout` in C++ ===\n",
            "`std::cout` ist der Standardausgabestrom in C++ und wird fÃ¼r Konsolenausgaben verwendet.\n",
            "\n",
            "### Grundlegende Ausgabe\n",
            "`std::cout << \"Text\" << variable;`\n",
            "- Die `<<`-Operatoren hÃ¤ngen Inhalte aneinander\n",
            "- Mit `\\n` oder `std::endl` wird eine Zeile beendet\n",
            "\n",
            "### Formatierung mit `<iomanip>`\n",
            "- `std::setw(n)`: Feldbreite setzen\n",
            "- `std::setprecision(n)`: Genauigkeit fÃ¼r Nachkommastellen\n",
            "- `std::fixed`: Kommazahlen mit fester Nachkommastellenzahl\n",
            "- `std::left` / `std::right`: Ausrichtung\n",
            "\n",
            "### Fehlerausgabe mit `std::cerr` und `std::clog`\n",
            "- `std::cerr`: Wird fÃ¼r **Fehlermeldungen** verwendet (ungespeichert)\n",
            "- `std::clog`: Wird fÃ¼r **Logmeldungen** verwendet (gepuffert)\n",
            "- Beide gehen wie `std::cout` in die Konsole, kÃ¶nnen aber **umgeleitet** werden\n",
            "\n",
            "### FÃ¼hrende Nullen bei Zahlen\n",
            "- Mit `std::setw(n)` und `std::setfill('0')` lassen sich Zahlen mit fÃ¼hrenden Nullen formatieren:\n",
            "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // Ausgabe: 00017\n```\n",
            "- Mit `std::string`: Umwandlung und manuelles AuffÃ¼llen:\n",
            "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17); // \"00017\"\n```\n",
            "- Ab C++20: `std::format` macht es besonders einfach:\n",
            "```cpp\nstd::cout << std::format(\"{:05}\", 17); // Ausgabe: 00017\n```\n",
            "\n",
            "### Zahlenformat: `dec`, `hex`, `oct`\n",
            "- `std::dec`: Ausgabe als Dezimalzahl (Standard)\n",
            "- `std::hex`: Ausgabe als Hexadezimalzahl\n",
            "- `std::oct`: Ausgabe als Oktalzahl\n",
            "- Wichtig bei BinÃ¤rformaten, Flags oder Speicheradressen\n"
          ],
          "code": [
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int alter = 21;\n  double kontostand = 1234.56789;\n\n  // Einfache BegrÃ¼ÃŸung\n  std::cout << \"Hallo, \" << name << \"!\\n\"; // Ausgabe: Hallo, Kilian!\n\n  // Formatierte Tabelle\n  std::cout << std::left << std::setw(10) << \"Name\"\n            << std::right << std::setw(10) << \"Alter\"\n            << std::setw(15) << \"Kontostand\" << std::endl;\n\n  std::cout << std::left << std::setw(10) << name\n            << std::right << std::setw(10) << alter\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl;\n\n  // Zahlenformat\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;\n\n  // FÃ¼hrende Nullen mit iomanip\n  int nummer = 17;\n  std::cout << \"FÃ¼hrende Nullen (iomanip): \" << std::setw(5) << std::setfill('0') << nummer << std::endl; // Ausgabe: 00017\n\n  // Mit std::string auffÃ¼llen\n  std::string gepolstert = std::string(5 - std::to_string(nummer).length(), '0') + std::to_string(nummer);\n  std::cout << \"Mit std::string: \" << gepolstert << std::endl; // Ausgabe: 00017\n\n#if __cpp_lib_format\n  // C++20: std::format\n  std::cout << \"Mit std::format: \" << std::format(\"{:05}\", nummer) << std::endl; // Ausgabe: 00017\n#endif\n\n  // Fehlermeldung und Logausgabe\n  std::cerr << \"Dies ist eine Fehlermeldung!\" << std::endl;\n  std::clog << \"Dies ist eine Logmeldung.\" << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
  "title": "Datei",
  "content": {
    "text": [
      "### === Datei-Ein-/Ausgabe in C++ ===\n",
      "`<fstream>` wird fÃ¼r klassische Dateiarbeit verwendet, `<filesystem>` fÃ¼r moderne Pfad- und ExistenzprÃ¼fungen.\n",
      "\n",
      "### ðŸ”¹ Typen aus `<fstream>`\n",
      "- `std::ofstream`: Schreiben (`output file stream`)\n",
      "- `std::ifstream`: Lesen (`input file stream`)\n",
      "- `std::fstream`: Beides\n",
      "\n",
      "### ðŸ”¹ Datei Ã¶ffnen\n",
      "- `std::ofstream f(\"name.txt\");` â€“ zum Schreiben (Ã¼berschreibt!)\n",
      "- `std::ofstream f(\"name.txt\", std::ios::app);` â€“ **zum AnhÃ¤ngen**\n",
      "- `std::ifstream f(\"name.txt\");` â€“ zum Lesen\n",
      "\n",
      "### ðŸ”¹ Datei prÃ¼fen\n",
      "- Mit `.is_open()` oder Ã¼ber `if (stream)`\n",
      "- Mit `std::filesystem::exists(pfad)` prÃ¼ft man, ob eine Datei/Ordner **existiert**\n",
      "- `std::filesystem::is_regular_file(pfad)`: prÃ¼ft auf **normale Datei**\n",
      "- `std::filesystem::is_directory(pfad)`: prÃ¼ft auf **Verzeichnis**\n",
      "\n",
      "### ðŸ”¹ Zeilenweise lesen und verÃ¤ndern\n",
      "- Mit `std::getline()` Zeilen einlesen\n",
      "- In `std::vector<std::string>` zwischenspeichern\n",
      "- Ã„nderungen durchfÃ¼hren und danach Datei neu schreiben\n",
      "\n",
      "### ðŸ”¹ Beispiel: Datei erstellen, anhÃ¤ngen, lesen, Ã¤ndern, prÃ¼fen mit `<filesystem>`"
    ],
    "code": [
      "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <filesystem>\n\nint main() {\n  std::string dateiname = \"daten.txt\";\n\n  // PrÃ¼fen, ob Datei bereits existiert\n  if (std::filesystem::exists(dateiname)) {\n    std::cout << \"Datei existiert bereits.\" << std::endl;\n  } else {\n    std::cout << \"Datei existiert NICHT. Wird erstellt...\" << std::endl;\n  }\n\n  // Neue Datei anlegen\n  std::ofstream out(dateiname);\n  if (out) {\n    out << \"Zeile 1\\n\" << \"Zeile 2\\n\" << \"Zeile 3\\n\";\n    out.close();\n  }\n\n  // Zeile anhÃ¤ngen\n  std::ofstream append(dateiname, std::ios::app);\n  append << \"Neue Zeile am Ende\\n\";\n  append.close();\n\n  // Datei einlesen\n  std::ifstream in(dateiname);\n  std::vector<std::string> inhalt;\n  std::string zeile;\n  while (std::getline(in, zeile)) {\n    inhalt.push_back(zeile);\n  }\n  in.close();\n\n  // Zeile 2 bearbeiten (Index 1)\n  if (inhalt.size() >= 2) {\n    inhalt[1] = \"[GEÃ„NDERT] \" + inhalt[1];\n  }\n\n  // Datei Ã¼berschreiben\n  std::ofstream out2(dateiname);\n  for (const std::string& z : inhalt) {\n    out2 << z << \"\\n\";\n  }\n  out2.close();\n\n  // PrÃ¼fung auf Verzeichnis\n  if (std::filesystem::is_directory(\".\")) {\n    std::cout << \"Aktuelles Verzeichnis ist gÃ¼ltig.\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Date/Time",
        "content": {
          "text": [
            "### === Datum und Uhrzeit in C++ ===\n",
            "C++ bietet mehrere MÃ¶glichkeiten, um mit Datum und Zeit zu arbeiten.\n",
            "\n",
            "### `std::time` & `std::localtime`\n",
            "- `std::time(nullptr)` liefert aktuelle Zeit (Sekunden seit 01.01.1970)\n",
            "- `std::localtime()` wandelt sie in eine `tm`-Struktur fÃ¼r lesbares Datum um\n",
            "\n",
            "### `std::put_time()` (aus `<iomanip>`) fÃ¼r Formatierung\n",
            "- `std::put_time()` funktioniert wie `strftime`\n",
            "- Beispiel-Formate: `%d.%m.%Y`, `%H:%M:%S`, `%Y-%m-%d_%H-%M`\n",
            "- Mit `std::ostringstream` kann man Datum/Zeit auch als `std::string` speichern\n",
            "\n",
            "### Zeitmessung mit `<chrono>`\n",
            "- Nutze `std::chrono::high_resolution_clock` fÃ¼r prÃ¤zise Messungen\n",
            "- `std::this_thread::sleep_for(...)` pausiert das Programm gezielt\n"
          ],
          "code": [
            "#include <iostream>\n#include <ctime>        // time, localtime\n#include <iomanip>      // put_time\n#include <sstream>      // ostringstream fÃ¼r string-Formate\n#include <chrono>       // chrono fÃ¼r Zeitmessung\n#include <thread>       // sleep_for\n\nint main() {\n  // 1. Aktuelle Uhrzeit formatieren und anzeigen\n  std::time_t jetzt = std::time(nullptr);               // Sekunden seit 1970\n  std::tm* lokal = std::localtime(&jetzt);              // lokale Zeitstruktur\n\n  std::cout << \"Aktuelle Uhrzeit: \"\n            << std::put_time(lokal, \"%d.%m.%Y %H:%M:%S\") << std::endl; // Ausgabe: 28.05.2025 19:45:12\n\n  // 2. Zeit als String speichern\n  std::ostringstream oss;\n  oss << std::put_time(lokal, \"%Y-%m-%d_%H-%M-%S\");\n  std::string zeitString = oss.str();\n  std::cout << \"Als String gespeichert: \" << zeitString << std::endl; // Ausgabe: 2025-05-28_19-45-12\n\n  // 3. Kurze Pause (Thread schlafen lassen)\n  std::cout << \"Warte 1 Sekunde...\" << std::endl;\n  std::this_thread::sleep_for(std::chrono::seconds(1)); // Pause fÃ¼r 1 Sekunde\n  std::cout << \"Weiter!\" << std::endl; // Ausgabe: Weiter!\n\n  // 4. Zeitmessung mit chrono\n  auto start = std::chrono::high_resolution_clock::now();\n\n  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 0,5 Sek warten\n\n  auto ende = std::chrono::high_resolution_clock::now();\n  auto dauer = std::chrono::duration_cast<std::chrono::milliseconds>(ende - start);\n\n  std::cout << \"Verstrichene Zeit: \" << dauer.count() << \" ms\" << std::endl; // Ausgabe: Verstrichene Zeit: 500 ms\n\n  return 0;\n}"
          ]
        }
      }
    ]
  },









  


  {
    "category": "Struktur",
    "subtopics": [
    {
   "title": "Schleifen / Loops",
   "content": {
    "text": [
      "### === Schleifen in C++ ===\n",
      "Schleifen ermÃ¶glichen **wiederholte AusfÃ¼hrung** von Code, solange eine Bedingung erfÃ¼llt ist.\n",
      "\n",
      "### ðŸ” `while`-Schleife\n",
      "- FÃ¼hrt Code **solange** aus, wie die Bedingung **wahr** ist\n",
      "- **Kopfgesteuert** (Bedingung wird **vorher** geprÃ¼ft)\n",
      "```cpp\nint i = 0;\nwhile (i < 3) {\n  std::cout << i << std::endl;\n  i++;\n}\n```\n",
      "\n",
      "### ðŸ” `do-while`-Schleife\n",
      "- FÃ¼hrt den Block **mindestens einmal** aus\n",
      "- **FuÃŸgesteuert** (Bedingung wird **nachher** geprÃ¼ft)\n",
      "```cpp\nint j = 0;\ndo {\n  std::cout << j << std::endl;\n  j++;\n} while (j < 3);\n```\n",
      "\n",
      "### ðŸ” `for`-Schleife\n",
      "- Ideal fÃ¼r Schleifen mit **ZÃ¤hler**\n",
      "- Besteht aus Initialisierung, Bedingung, Inkrement\n",
      "```cpp\nfor (int k = 0; k < 3; ++k) {\n  std::cout << k << std::endl;\n}\n```\n",
      "\n",
      "### ðŸ” `range-based for` (seit C++11)\n",
      "- FÃ¼r **Container, Arrays** oder **Strings**\n",
      "```cpp\nstd::string text = \"Hi\";\nfor (char c : text) {\n  std::cout << c << std::endl;\n}\n```\n",
      "\n",
      "### ðŸ” Schleifensteuerung:\n",
      "- `break;` â†’ Schleife **sofort beenden**\n",
      "- `continue;` â†’ NÃ¤chste Iteration Ã¼berspringen\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n  // while-Schleife\n  int i = 0;\n  while (i < 3) {\n    std::cout << \"while: \" << i << std::endl; // Ausgabe: 0, 1, 2\n    i++;\n  }\n\n  // do-while-Schleife\n  int j = 0;\n  do {\n    std::cout << \"do-while: \" << j << std::endl; // Ausgabe: 0, 1, 2\n    j++;\n  } while (j < 3);\n\n  // for-Schleife\n  for (int k = 0; k < 3; ++k) {\n    std::cout << \"for: \" << k << std::endl; // Ausgabe: 0, 1, 2\n  }\n\n  // range-based for\n  std::vector<std::string> namen = {\"Anna\", \"Bob\", \"Clara\"};\n  for (const std::string& name : namen) {\n    std::cout << \"range-for: \" << name << std::endl; // Ausgabe: Anna, Bob, Clara\n  }\n\n  // break und continue\n  for (int x = 0; x < 5; ++x) {\n    if (x == 2) continue; // Ã¼berspringt 2\n    if (x == 4) break;    // bricht bei 4 ab\n    std::cout << \"x: \" << x << std::endl; // Ausgabe: 0, 1, 3\n  }\n\n  return 0;\n}"
    ]
        }
      },
      {
  "title": "if / else und switch",
  "content": {
    "text": [
      "### === Bedingungen mit `if` / `else` und `switch` ===\n",
      "In C++ werden Bedingungen mit `if`, `else if`, `else` und `switch` verwendet, um **Entscheidungen** im Programmablauf zu treffen.\n",
      "\n",
      "### ðŸ”¸ `if` / `else if` / `else`\n",
      "- FÃ¼hrt Code aus, wenn eine **Bedingung erfÃ¼llt** ist\n",
      "- `else if` fÃ¼r weitere Alternativen, `else` fÃ¼r den Standardfall\n",
      "```cpp\nif (x > 0) {\n  std::cout << \"Positiv\";\n} else if (x == 0) {\n  std::cout << \"Null\";\n} else {\n  std::cout << \"Negativ\";\n}\n```\n",
      "\n",
      "### ðŸ”¸ Vergleichsoperatoren\n",
      "- `==`, `!=`, `<`, `>`, `<=`, `>=`\n",
      "- Kombinieren mit `&&`, `||`, `!` fÃ¼r UND/ODER/NICHT\n",
      "\n",
      "### ðŸ”¸ `switch`-Anweisung\n",
      "- PrÃ¼ft **einen konkreten Wert** (ganzzahlig oder `enum`)\n",
      "- Jeder `case` ist ein mÃ¶glicher Wert; `default` ist der Standardfall\n",
      "- `break;` beendet den jeweiligen Fall â€“ sonst wird weiter ausgefÃ¼hrt (**Fallthrough**!)\n",
      "```cpp\nswitch (auswahl) {\n  case 1: std::cout << \"Eins\"; break;\n  case 2: std::cout << \"Zwei\"; break;\n  default: std::cout << \"Unbekannt\";\n}\n```\n",
      "\n",
      "ðŸ’¡ Tipp: Bei mehreren Optionen, die das gleiche tun, kann man **Fallthrough** bewusst einsetzen:\n",
      "```cpp\ncase 1:\ncase 2: std::cout << \"Eins oder Zwei\"; break;\n```"
    ],
    "code": [
      "#include <iostream>\n\nint main() {\n  int x = -3;\n\n  // if / else if / else\n  if (x > 0) {\n    std::cout << \"x ist positiv\" << std::endl; // (nicht ausgefÃ¼hrt)\n  } else if (x == 0) {\n    std::cout << \"x ist Null\" << std::endl; // (nicht ausgefÃ¼hrt)\n  } else {\n    std::cout << \"x ist negativ\" << std::endl; // Ausgabe: x ist negativ\n  }\n\n  // Vergleich mit logischen Operatoren\n  int a = 10, b = 20;\n  if (a < b && b < 30) {\n    std::cout << \"a ist kleiner als b und b < 30\" << std::endl; // Ausgabe\n  }\n\n  // switch-Anweisung\n  int wahl = 2;\n  switch (wahl) {\n    case 1:\n      std::cout << \"Du hast Eins gewÃ¤hlt.\" << std::endl;\n      break;\n    case 2:\n      std::cout << \"Du hast Zwei gewÃ¤hlt.\" << std::endl; // Ausgabe\n      break;\n    case 3:\n      std::cout << \"Du hast Drei gewÃ¤hlt.\" << std::endl;\n      break;\n    default:\n      std::cout << \"UngÃ¼ltige Auswahl.\" << std::endl;\n  }\n\n  // Fallthrough bewusst\n  int note = 1;\n  switch (note) {\n    case 1:\n    case 2:\n      std::cout << \"Sehr gut oder gut!\" << std::endl; // Ausgabe bei 1 oder 2\n      break;\n    case 3:\n      std::cout << \"Befriedigend\" << std::endl;\n      break;\n    default:\n      std::cout << \"Andere Note\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
  "title": "Zeiger & this-Zeiger / Pointer",
  "content": {
    "text": [
      "### === Zeiger in C++ ===\n",
      "Ein Zeiger ist eine Variable, die die Adresse eines anderen Objekts speichert.\n",
      "\n",
      "### Zeiger-Grundlagen:\n",
      "- `int* ptr;` â†’ zeigt auf eine `int`-Variable\n",
      "- `*ptr` â†’ greift auf den Wert zu\n",
      "- `&x` â†’ gibt die Adresse von `x` zurÃ¼ck\n",
      "\n",
      "```cpp\nint x = 10;\nint* ptr = &x;\n*ptr = 20;  // x wird geÃ¤ndert\n```\n",
      "\n",
      "### Dynamischer Speicher:\n",
      "- Mit `new` wird Speicher auf dem Heap reserviert\n",
      "- Mit `delete` muss er wieder freigegeben werden\n",
      "```cpp\nint* p = new int(5);\ndelete p;\n```\n",
      "\n",
      "### Zeiger auf Objekte:\n",
      "- Klassenobjekte kÃ¶nnen ebenfalls per Zeiger angesprochen werden\n",
      "- Zugriff Ã¼ber `->`\n",
      "```cpp\nPerson* p = new Person(\"Kilian\");\np->anzeigen();\ndelete p;\n```\n",
      "\n",
      "### === `this`-Zeiger ===\n",
      "- Jede Memberfunktion hat automatisch Zugriff auf `this`\n",
      "- `this` ist ein Zeiger auf das **aktuelle Objekt**\n",
      "- Wird z.B. fÃ¼r Vergleich, RÃ¼ckgabe oder Methodenkette genutzt\n",
      "\n",
      "```cpp\nclass Test {\n    int wert;\npublic:\n    Test(int w) : wert(w) {}\n\n    Test& setWert(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n```\n",
      "\n",
      "ðŸ‘‰ So kann man z.B. Methoden verkettet aufrufen: `obj.setWert(5).setWert(10);`\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\nprivate:\n    int wert;\n\npublic:\n    Zahl(int w) : wert(w) {}\n\n    void verdoppeln() {\n        wert *= 2;\n        std::cout << \"[this: \" << this << \"] Wert: \" << wert << std::endl;\n    }\n\n    Zahl& setze(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n\nint main() {\n    int x = 5;\n    int* ptr = &x;\n    std::cout << \"Zeiger: \" << *ptr << std::endl;  // 5\n\n    *ptr = 10;\n    std::cout << \"x: \" << x << std::endl;           // 10\n\n    Zahl z(7);\n    z.verdoppeln();          // 14\n    z.setze(3).verdoppeln(); // 6\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Smart Pointer",
  "content": {
    "text": [
      "### === Smart Pointer in C++ ===\n",
      "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ungÃ¼ltige Speicherbereiche**.\n",
      "Sie gehÃ¶ren zum Header `<memory>` und sind seit **C++11** verfÃ¼gbar.\n",
      "\n",
      "### Warum Smart Pointer?\n",
      "- Kein manuelles `delete` nÃ¶tig\n",
      "- Klare BesitzverhÃ¤ltnisse\n",
      "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
      "\n",
      "### ðŸ”¹ `std::unique_ptr<T>`\n",
      "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
      "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
      "- Objekt wird beim Verlassen des Scopes automatisch gelÃ¶scht\n",
      "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles LÃ¶schen mÃ¶glich\n```\n",
      "\n",
      "### ðŸ”¹ `std::shared_ptr<T>`\n",
      "- **Mehrere Besitzer** teilen sich das Objekt\n",
      "- Automatische LÃ¶schung, wenn **alle Kopien** verschwinden\n",
      "- Intern wird ein **ReferenzzÃ¤hler** verwaltet (`use_count()`)\n",
      "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
      "- `reset()` lÃ¶scht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
      "\n",
      "### ðŸ”¹ `std::weak_ptr<T>`\n",
      "- Beobachtet ein Objekt von `shared_ptr`, **ohne den ZÃ¤hler zu erhÃ¶hen**\n",
      "- Kann ungÃ¼ltig werden â†’ **immer mit `.lock()` prÃ¼fen**\n",
      "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
      "\n",
      "### ðŸ” Vergleichstabelle:\n",
      "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
      "| `unique_ptr`  | exklusiv     | âŒ nein     | nur mit `std::move` Ã¼bertragbar  |\n",
      "| `shared_ptr`  | gemeinsam    | âœ… ja       | ZÃ¤hler zÃ¤hlt aktive Referenzen   |\n",
      "| `weak_ptr`    | kein Besitz  | âœ… ja       | Beobachtet ohne mitzuzÃ¤hlen      |\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // ReferenzzÃ¤hler = 2\n    std::cout << \"shared_ptr ZÃ¤hler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset ZÃ¤hler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei â†’ Destruktor wird aufgerufen\n\n    return 0;\n}"
    ]
  }
},
   {
   "title": "Namespaces",
   "content": {
   "text": [
      "### === Namespaces in C++ ===\n",
      "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
      "\n",
      "### Warum Namespaces?\n",
      "- Zwei Funktionen mit gleichem Namen kÃ¶nnen in unterschiedlichen Namespaces existieren\n",
      "- GroÃŸe Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
      "\n",
      "### Verwendung von Namespaces\n",
      "- Definition:\n",
      "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
      "- Aufruf:\n",
      "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
      "\n",
      "### `using namespace` (nicht immer empfohlen)\n",
      "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
      "- Nachteil: Alle Namen des Namespace werden global sichtbar â†’ Konfliktgefahr\n",
      "- Besser: Nur gezielt importieren\n",
      "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
      "\n",
      "### Anonyme Namespaces (Datei-spezifisch)\n",
      "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
      "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
      "\n",
      "### Verschachtelte Namespaces (modernes C++)\n",
      "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
      "\n",
      "ðŸ‘‰ `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
      "ðŸ‘‰ Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n"
    ],
    "code": [
            "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
          ]
        }
      },
      {
      "title": "Namespace vs. Class",
      "content": {
      "text": [
            "### === Unterschied: Namespace vs. Class ===\n",
            "`namespace` und `class` dienen beide zur Strukturierung, haben aber vÃ¶llig unterschiedliche Funktionen:\n",
            "\n",
            "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
            "|----------------------|-----------------------------------------|-------------------------------------------|\n",
            "| Zweck                | Gruppierung von Code                   | Bauplan fÃ¼r Objekte (Daten + Methoden)    |\n",
            "| Objekte erzeugbar?   | âŒ Nein                                 | âœ… Ja                                      |\n",
            "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
            "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
            "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
            "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
            "\n",
            "### Beispiel zur Verdeutlichung:\n",
            "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
            "\n",
            "ðŸ‘‰ Merksatz: `namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**."
          ],
          "code": []
        }
      },
{
  "title": "Const",
  "content": {
    "text": [
      "### === `const` in C++ ===\n",
      "`const` schÃ¼tzt vor ungewollten Ã„nderungen â€“ je nach Position bedeutet es etwas anderes:\n",
      "\n",
      "### ðŸ”¹ `const` bei Variablen:\n",
      "- Der Wert darf **nicht verÃ¤ndert** werden\n",
      "```cpp\nconst int x = 5;\n// x = 10; // âŒ Fehler\n```\n",
      "\n",
      "### ðŸ”¹ `const` bei Funktionsparametern:\n",
      "- Verhindert Ã„nderungen am Ãœbergabewert\n",
      "```cpp\nvoid zeige(const std::string& text);\n```\n",
      "- spart **Kopieraufwand** + schÃ¼tzt Daten\n",
      "\n",
      "### ðŸ”¹ `const`-Methoden:\n",
      "- Garantie, dass innerhalb der Methode **nichts verÃ¤ndert wird**\n",
      "```cpp\nclass Person {\n    std::string name;\npublic:\n    std::string getName() const; // âŒ darf name nicht Ã¤ndern\n};\n```\n",
      "\n",
      "### ðŸ”¹ `const` bei Zeigern:\n",
      "| Schreibweise           | Bedeutung                               |\n",
      "| `const int* p`        | Zeiger auf **konstante Daten**           |\n",
      "| `int* const p`        | **Konstanter Zeiger** auf Daten          |\n",
      "| `const int* const p`  | **Beides konstant**                      |\n",
      "\n",
      "```cpp\nconst int* p = &x;   // *p darf nicht geÃ¤ndert werden\nint* const q = &x;   // q darf nicht woanders hinzeigen\n```\n",
      "\n",
      "### ðŸ”¹ `const` bei RÃ¼ckgabewerten:\n",
      "- Schutz vor Modifikation des RÃ¼ckgabewerts\n",
      "```cpp\nconst std::string& getName() const;  // RÃ¼ckgabe nicht modifizierbar\n```\n",
      "\n",
      "### Merksatz:\n",
      "- Lies `const` **von rechts nach links**:\n",
      "    - `int* const` = konstanter Zeiger auf int\n",
      "    - `const int*` = Zeiger auf konstantes int\n",
      "\n",
      "ðŸ‘‰ `const` hilft, **Bugs zu vermeiden**, **Lesbarkeit zu erhÃ¶hen** und ist **Best Practice** in modernem C++\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n    std::string name;\n\npublic:\n    Person(const std::string& n) : name(n) {}\n\n    // const-Methode: darf nichts verÃ¤ndern\n    std::string getName() const {\n        return name;\n    }\n\n    // const-RÃ¼ckgabe + const-Parameter\n    void begruessung(const std::string& begrussung) const {\n        std::cout << begrussung << \", \" << name << \"!\" << std::endl;\n    }\n};\n\nint main() {\n    const int x = 5;\n    // x = 10; // âŒ nicht erlaubt\n\n    const int* ptr1 = &x;    // Zeiger auf konstanten Wert\n    // *ptr1 = 20; // âŒ nicht erlaubt\n\n    int y = 8;\n    int* const ptr2 = &y;    // Konstanter Zeiger\n    *ptr2 = 12;              // âœ… erlaubt\n\n    Person p(\"Kilian\");\n    p.begruessung(\"Hallo\");\n    std::cout << \"Name: \" << p.getName() << std::endl;\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Const Overloading",
  "content": {
    "text": [
      "### === `const` Overloading ===\n",
      "In C++ kann man Funktionen **Ã¼berladen**, indem man einmal eine `const`- und einmal eine **nicht-`const`-Version** erstellt.\n",
      "\n",
      "### Warum?\n",
      "- `const`-Objekte dÃ¼rfen nur `const`-Funktionen aufrufen.\n",
      "- So kann dieselbe Funktion **unterschiedliches Verhalten** haben â€“ je nach `const`-Zustand des Objekts.\n",
      "\n",
      "### `const` am Ende einer Methode:\n",
      "- Bedeutet: Diese Funktion **verÃ¤ndert keine Membervariablen** (auÃŸer `mutable`)\n",
      "- Wichtig fÃ¼r **Zugriffsmethoden (Getter)** oder bei Funktionen, die nur lesen\n",
      "\n",
      "ðŸ‘‰ `const` ist Teil der Funktionssignatur und wird bei der Ãœberladung beachtet."
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n  std::string name;\n\npublic:\n  Person(std::string n) : name(n) {}\n\n  // Nicht-const-Version\n  std::string& getName() {\n    std::cout << \"Nicht-const Version\" << std::endl;\n    return name;\n  }\n\n  // Const-Version (fÃ¼r const Objekte)\n  const std::string& getName() const {\n    std::cout << \"Const-Version\" << std::endl;\n    return name;\n  }\n};\n\nint main() {\n  Person p1(\"Kilian\");\n  const Person p2(\"Lisa\");\n\n  std::cout << p1.getName() << std::endl;  // Ausgabe: Nicht-const Version\\nKilian\n  std::cout << p2.getName() << std::endl;  // Ausgabe: Const-Version\\nLisa\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Mutable",
  "content": {
    "text": [
      "### === `mutable` in C++ ===\n",
      "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu verÃ¤ndern**.\n",
      "\n",
      "### Wann braucht man das?\n",
      "- Normalerweise dÃ¼rfen `const`-Funktionen **keine Membervariablen verÃ¤ndern**.\n",
      "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.â€¯B. fÃ¼r Logging, Caching oder ZugriffszÃ¤hler.\n",
      "\n",
      "### Auch ohne `const` nÃ¼tzlich:\n",
      "- `mutable`-Member sind **immer unabhÃ¤ngig von `const`**, also z.â€¯B. nicht betroffen von `std::atomic<T>` oder `const`-Zustand anderer Objekte.\n",
      "- Sie kÃ¶nnen **immer verÃ¤ndert werden**, auch auÃŸerhalb von `const`-Kontexten â€“ z.â€¯B. als interne ZÃ¤hler oder ZustÃ¤nde.\n",
      "\n",
      "### Wichtig:\n",
      "- `mutable` funktioniert **nur bei Membervariablen**.\n",
      "- Hat **nichts** mit `const` Variablen zu tun â€“ es ist ein **Zugriffs-Modifier** fÃ¼r Klassenmitglieder.\n",
      "\n",
      "ðŸ‘‰ Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZÃ¤hler = 0;  // darf auch in const-Funktion verÃ¤ndert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZÃ¤hler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZÃ¤hler() const {\n    return leseZÃ¤hler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZÃ¤hler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Static",
  "content": {
    "text": [
      "### === `static` in C++ ===\n",
      "`static` hat in C++ mehrere Bedeutungen â€“ je nachdem, **wo** es verwendet wird:\n",
      "\n",
      "### ðŸ”¹ `static` innerhalb einer Funktion:\n",
      "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
      "- Bleibt zwischen Aufrufen **erhalten**\n",
      "```cpp\nvoid zÃ¤hler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
      "\n",
      "### ðŸ”¹ `static` in Klassen (statisch fÃ¼r alle Objekte):\n",
      "- Variable gehÃ¶rt **zur Klasse, nicht zum Objekt**\n",
      "- Wird **auÃŸerhalb der Klasse** definiert\n",
      "- Gleicher Wert fÃ¼r **alle Instanzen**\n",
      "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
      "\n",
      "### ðŸ”¹ `static` bei Klassenfunktionen:\n",
      "- Funktion gehÃ¶rt **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
      "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
      "- Wird Ã¼ber `Klassenname::Funktion()` aufgerufen\n",
      "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
      "\n",
      "### ðŸ”¹ `static` bei Funktionen (auÃŸerhalb von Klassen):\n",
      "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
      "- NÃ¼tzlich zur Kapselung beim Modularisieren\n",
      "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
      "\n",
      "ðŸ‘‰ `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschrÃ¤nken**.\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Test {\npublic:\n    static int zÃ¤hler;\n    void erhÃ¶hen() {\n        zÃ¤hler++;\n    }\n};\n\nint Test::zÃ¤hler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion auÃŸerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erhÃ¶hen();\n    b.erhÃ¶hen();\n    std::cout << \"static in Klasse: \" << Test::zÃ¤hler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
    ]
  }
}
    ]
  },







  {
    "category": "Speicherverwaltung",
    "subtopics": [
      {
  "title": "Heap (new / new[])",
  "content": {
    "text": [
      "### === Heap-Speicher in C++ (new / delete) ===\n",
      "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
      "\n",
      "### ðŸ”¹ Warum Heap?\n",
      "- Stack ist nur fÃ¼r **kurzlebige, kleine** Daten\n",
      "- Heap erlaubt **dynamische GrÃ¶ÃŸe** und **lÃ¤ngere Lebenszeit**\n",
      "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
      "\n",
      "### ðŸ”¸ `new` fÃ¼r EIN Objekt:\n",
      "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
      "- Speicher fÃ¼r genau **ein Objekt** wird angefordert\n",
      "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
      "\n",
      "### ðŸ”¸ `new[]` fÃ¼r MEHRERE Objekte (Array):\n",
      "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
      "- Reserviert **zusammenhÃ¤ngenden Speicherplatz** fÃ¼r mehrere Objekte\n",
      "- Muss mit **`delete[]`** freigegeben werden!\n",
      "\n",
      "### â— Vorsicht bei falscher Kombination:\n",
      "- `new[]` â†’ `delete[]`\n",
      "- `new` â†’ `delete`\n",
      "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
      "\n",
      "### ðŸ”¹ Klassen & Konstruktoren:\n",
      "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gelÃ¶scht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
      "\n",
      "### ðŸ”¹ Wann `new[]` statt `new`?\n",
      "- Wenn du mehrere gleichartige Objekte brauchst â†’ `new[]`\n",
      "- Wenn du nur ein einzelnes Objekt brauchst â†’ `new`\n",
      "\n",
      "### â— Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
      "ðŸ‘‰ Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gelÃ¶scht\\n\"; }\n};\n\nint main() {\n    // new fÃ¼r EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] fÃ¼r MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt lÃ¶schen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gelÃ¶scht\n    delete[] pArr;  // 2x Punkt gelÃ¶scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Speicherverwaltung: Heap vs. Stack",
  "content": {
    "text": [
      "### === Speicherverwaltung in C++: Stack vs. Heap ===\n",
      "In C++ unterscheidet man bei der Speichervergabe zwischen **Stack** und **Heap**:\n",
      "\n",
      "### ðŸ”¹ Stack-Speicher (automatisch)\n",
      "- Wird fÃ¼r **lokale Variablen** verwendet\n",
      "- Speicher wird **automatisch** freigegeben, wenn der Block verlassen wird\n",
      "- Sehr schnell & sicher, aber begrenzt (Stack Overflow bei groÃŸen Arrays)\n",
      "\n",
      "```cpp\nvoid funktion() {\n    int a = 10;        // auf dem Stack\n} // a wird automatisch gelÃ¶scht\n```\n",
      "\n",
      "### ðŸ”¹ Heap-Speicher (dynamisch)\n",
      "- Wird bei Bedarf mit `new` reserviert und mit `delete` freigegeben\n",
      "- Muss **manuell** verwaltet werden â†’ Gefahr von Speicherlecks\n",
      "- GrÃ¶ÃŸer, aber langsamer als der Stack\n",
      "\n",
      "```cpp\nint* ptr = new int(5);  // Speicher im Heap\n*ptr = 42;\ndelete ptr;             // Speicher freigeben\n```\n",
      "\n",
      "### ðŸ”¹ Vergleich:\n",
      "| Merkmal     | Stack                     | Heap                          |\n",
      "| Geschwindigkeit | Sehr schnell              | Langsamer                    |\n",
      "| Lebensdauer | Block-lokal (automatisch) | Manuell, bis `delete`        |\n",
      "| SpeichergrÃ¶ÃŸe | Begrenzter Speicher       | GrÃ¶ÃŸerer Speicher verfÃ¼gbar  |\n",
      "| Fehlerquellen | Stack Overflow mÃ¶glich    | Speicherlecks, Dangling Ptr  |\n",
      "\n",
      "### ðŸ”¸ Modern C++ Tipp:\n",
      "- Statt `new` / `delete` â†’ besser `std::unique_ptr`, `std::shared_ptr`\n",
      "- Smart Pointer Ã¼bernehmen Speicherverwaltung automatisch\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory> // fÃ¼r Smart Pointer\n\nvoid stackBeispiel() {\n    int zahl = 10;                    // Stack-Speicher\n    std::cout << \"Stack: \" << zahl << std::endl;\n} // zahl wird automatisch gelÃ¶scht\n\nvoid heapBeispiel() {\n    int* ptr = new int(42);           // Heap-Speicher\n    std::cout << \"Heap: \" << *ptr << std::endl;\n    delete ptr;                       // manuell lÃ¶schen\n}\n\nvoid smartPointerBeispiel() {\n    std::unique_ptr<int> sp = std::make_unique<int>(100);\n    std::cout << \"SmartPointer: \" << *sp << std::endl;\n} // wird automatisch gelÃ¶scht\n\nint main() {\n    stackBeispiel();\n    heapBeispiel();\n    smartPointerBeispiel();\n    return 0;\n}"
    ]
  }
}

    ]
  },



  {
    "category": "Container",
    "subtopics": [
      {
        "title": "Strings",
        "content": {
          "text": [
            "### === String-Funktionen in C++ ===\n",
            "",
            "```cpp",
            "std::string example = \"Hello, World\";\n",
            "std::string number = \"42\";",
            "```\n",
            "",
            "-> `.size()` â€“ Gibt die LÃ¤nge des Strings zurÃ¼ck\n",
            "```cpp",
            "example.size(); // 12",
            "```\n",
            "",
            "-> `.substr(start, length)` â€“ Teilstring ab Startindex\n",
            "```cpp",
            "example.substr(3, 5); // \"lo, W\"",
            "```\n",
            "",
            "-> `.replace(start, count, string)` â€“ Ersetzt einen Teil des Strings\n",
            "```cpp",
            "example.replace(7, 5, \"Universe\"); // Hello, Universe",
            "```\n",
            "",
            "-> `.empty()` â€“ PrÃ¼ft ob der String leer ist\n",
            "-> `example[1]` â€“ Zugriff auf Zeichen an Position\n",
            "-> `.find(\"text\")` â€“ Sucht ein Teilwort im String\n",
            "",
            "### === String <-> Zahl ===\n",
            "",
            "```cpp",
            "int i = std::stoi(\"42\");     // â†’ 42\n",
            "double d = std::stod(\"3.14\"); // â†’ 3.14\n",
            "std::string s = std::to_string(100); // â†’ \"100\"",
            "```\n",
            "",
            "### === String-Konkatenation & Vergleich ===\n",
            "",
            "```cpp",
            "std::string s1 = \"Hello\";\n",
            "std::string s2 = \"World\";\n",
            "std::string s3 = s1 + \" \" + s2; // \"Hello World\"\n",
            "s1.compare(s2); // < 0 â†’ s1 < s2",
            "```\n",
            "",
            "### === GroÃŸ- und Kleinschreibung ===\n",
            "",
            "-> `#include <cctype>`, `#include <algorithm>` fÃ¼r toupper/tolower\n",
            "",
            "```cpp",
            "std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n",
            "std::transform(str.begin(), str.end(), str.begin(), ::tolower);",
            "```\n",
            "",
            "-> Einzelzeichen:\n",
            "```cpp",
            "std::toupper('a'); // â†’ 'A'\n",
            "std::islower('B'); // â†’ false\n",
            "std::isalpha('x'); // â†’ true\n",
            "std::isdigit('9'); // â†’ true",
            "```\n",
            "",
            "### === istringstream: String analysieren ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::string zeile = \"3 Apfel 1.99\";\n",
            "std::istringstream iss(zeile);\n",
            "int menge; std::string produkt; double preis;\n",
            "iss >> menge >> produkt >> preis;\n",
            "// menge = 3, produkt = Apfel, preis = 1.99",
            "```\n",
            "",
            "### === ostringstream: String zusammensetzen ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::ostringstream oss;\n",
            "oss << menge << \" \" << produkt << \" kosten \" << (menge * preis);\n",
            "std::string ausgabe = oss.str();",
            "```"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n\nint main() {\n  std::string text = \"C++ macht SpaÃŸ!\";\n\n  // LÃ¤nge\n  std::cout << \"LÃ¤nge: \" << text.length() << std::endl; // Ausgabe: 15\n\n  // Teilstring\n  std::string teil = text.substr(4, 5);\n  std::cout << \"Teilstring: \" << teil << std::endl; // Ausgabe: macht\n\n  // finden\n  size_t pos = text.find(\"SpaÃŸ\");\n  if (pos != std::string::npos)\n    std::cout << \"\\\"SpaÃŸ\\\" gefunden an Position: \" << pos << std::endl; // Ausgabe: 11\n\n  // ersetzen\n  text.replace(4, 5, \"ist cool\");\n  std::cout << \"Nach replace: \" << text << std::endl; // Ausgabe: C++ ist cool SpaÃŸ!\n\n  // anhÃ¤ngen\n  text += \" :)\";\n  std::cout << \"Nach AnfÃ¼gen: \" << text << std::endl; // Ausgabe: C++ ist cool SpaÃŸ! :)\n\n  // einfÃ¼gen\n  text.insert(0, \"[INFO] \");\n  std::cout << \"Mit Prefix: \" << text << std::endl; // Ausgabe: [INFO] C++ ist cool SpaÃŸ! :)\n\n  // lÃ¶schen\n  text.erase(0, 7);\n  std::cout << \"Ohne Prefix: \" << text << std::endl; // Ausgabe: C++ ist cool SpaÃŸ! :)\n\n  // vergleichen\n  std::string a = \"Apfel\", b = \"Banane\";\n  if (a.compare(b) < 0)\n    std::cout << a << \" kommt vor \" << b << std::endl; // Ausgabe: Apfel kommt vor Banane\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Vektor",
        "content": {
          "text": [
            "### === Vector-Funktionen in C++ ===\n",
            "-> `std::vector<int> zahlen = {5, 3, 8, 1};` // Initialisierung eines Vektors\n",
            "-> `zahlen.push_back(element);` // FÃ¼gt ein Element hinten an (kopiert oder verschiebt es)\n",
            "-> `zahlen.emplace_back(argumente);` // Baut das Element direkt im Vektor (konstruiert es vor Ort)\n",
            "### Unterschied `push_back` und `emplace_back`",
            "`push_back` erwartet ein fertiges Objekt,\n",
            "`emplace_back` Ã¼bernimmt die Konstruktion direkt im Speicher des Vektors.\n",
            "Besonders nÃ¼tzlich bei komplexen Typen wie `std::pair` oder eigenen Klassen.\n",
            "```cpp",
            "Beispiel: v.emplace_back(\"Text\", 42); statt: v.push_back(std::make_pair(\"Text\", 42));",
            "```\n",
            "-> `zahlen.size();` // Gibt die Anzahl der Elemente im Vektor zurÃ¼ck\n",
            "-> `zahlen[2];` // Greift direkt auf das Element mit Index 2 zu (kein Bounds-Check)\n",
            "-> `zahlen.at(1);` // Greift sicher auf Index 1 zu (mit Bounds-Check)\n",
            "-> `zahlen.front();` // Gibt das erste Element im Vektor zurÃ¼ck\n",
            "-> `zahlen.back();` // Gibt das letzte Element im Vektor zurÃ¼ck\n",
            "-> `zahlen.empty();` // PrÃ¼ft, ob der Vektor leer ist (true/false)\n",
            "-> `std::find(zahlen.begin(), zahlen.end(), 3);` // Sucht nach Wert 3 im Vektor\n",
            "-> `zahlen.insert(zahlen.begin() + 1, 42);` // FÃ¼gt 42 an Position 1 ein\n",
            "-> `std::sort(zahlen.begin(), zahlen.end());` // Sortiert den Vektor aufsteigend\n",
            "-> `std::reverse(zahlen.begin(), zahlen.end());` // Dreht die Reihenfolge um\n",
            "\n",
            "-> `zahlen.erase(zahlen.begin());` // LÃ¶scht das erste Element\n",
            "-> `zahlen.erase(zahlen.begin(), zahlen.begin() + 2);` // LÃ¶scht die ersten zwei Elemente\n",
            "-> `zahlen.erase(zahlen.begin() + 2);` // LÃ¶scht das Element an Index 2\n",
            "-> `zahlen.clear();` // LÃ¶scht alle Elemente aus dem Vektor\n",
            "-> `zahlen.pop_back();` // Entfernt das letzte Element im Vektor\n",
            "\n",
            "-> `zahlen.assign(5, 7);` // Setzt den Vektor auf 5 Elemente mit dem Wert 7\n",
            "-> `std::remove(zahlen.begin(), zahlen.end(), 5);` // Entfernt alle Vorkommen von 5 (nutzt erase danach!)\n",
            "-> `std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x; });` // Wendet eine Funktion auf alle Elemente an\n",
            "\n",
            "### === 2D Vektor in C++ ===\n",
            "-> `std::vector<std::vector<int>> v3 = {{1}, {2, 3}, {4, 5, 6}};` // 2D vector\n",
            "Erstellt 2D-Vektor (Vektoren von Vektoren)\n",
            "`v3` hat drei Zeilen: `v3[0] = {1}; v3[1] = {2, 3}; v3[2] = {4, 5, 6}`\n",
            "`v3[2][2]` gibt `6` zurÃ¼ck (Zeile 3, Spalte 3)\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // fÃ¼r sort()\n\nint main() {\n  // Vektor mit Werten initialisieren\n  std::vector<int> zahlen = {4, 2, 7};\n\n  // Element hinzufÃ¼gen\n  zahlen.push_back(5); // Vektor = {4, 2, 7, 5}\n\n  // GrÃ¶ÃŸe des Vektors\n  std::cout << \"Anzahl Elemente: \" << zahlen.size() << std::endl; // Ausgabe: 4\n\n  // Zugriff auf Elemente\n  std::cout << \"Erstes Element: \" << zahlen[0] << std::endl; // Ausgabe: 4\n  std::cout << \"Zweites Element: \" << zahlen.at(1) << std::endl; // Ausgabe: 2\n  std::cout << \"Letztes Element: \" << zahlen.back() << std::endl; // Ausgabe: 5\n\n  // Ausgabe mit Schleife\n  std::cout << \"Alle Elemente: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 4 2 7 5\n  std::cout << std::endl;\n\n  // Element entfernen (letztes)\n  zahlen.pop_back(); // entfernt 5\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end()); // Vektor = {2, 4, 7}\n\n  // Ausgabe nach Sortierung\n  std::cout << \"Sortiert: \";\n  for (size_t i = 0; i < zahlen.size(); ++i) {\n    std::cout << zahlen[i] << \" \";\n  } // Ausgabe: 2 4 7\n  std::cout << std::endl;\n\n  // leeren Vektor prÃ¼fen\n  if (!zahlen.empty()) {\n    std::cout << \"Vektor ist NICHT leer\" << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Sets",
        "content": {
          "text": [
            "### === Sets in C++ ===\n",
            "-> `#include <set>`       // FÃ¼r std::set\n",
            "\n",
            "**--- Grundlagen ---**\n",
            "-> `std::set<char> s1 = {'H', 'E', 'L', 'L', 'O'};`\n",
            "   Ein Set speichert nur eindeutige Elemente â€“ doppelte 'L' werden entfernt\n",
            "   Ergebnis: `{ 'E', 'H', 'L', 'O' }` (automatisch sortiert nach ASCII)\n",
            "-> `s1.size()` Gibt die Anzahl der eindeutigen Elemente zurÃ¼ck â†’ 4\n",
            "-> `s1.contains('E')` PrÃ¼ft, ob 'E' im Set enthalten ist â†’ true (1)\n",
            "-> `s1.contains('X')` PrÃ¼ft, ob 'X' im Set enthalten ist â†’ false (0)\n",
            "\n",
            "**--- Elemente hinzufÃ¼gen/entfernen ---**\n",
            "-> `s1.insert('!')` FÃ¼gt ein neues Element hinzu â†’ `{ '!', 'E', 'H', 'L', 'O' }`\n",
            "-> `s1.erase('O')` Entfernt das Element 'O' aus dem Set\n",
            "-> `s1.clear()` Entfernt alle Elemente aus dem Set\n",
            "-> `s1.empty()` PrÃ¼ft, ob das Set leer ist â†’ true (1)\n",
            "\n",
            "**--- Vergleich von Sets ---**\n",
            "-> `std::set<int> a = {1, 2};`\n",
            "-> `std::set<int> b = {2, 1};`\n",
            "-> `a == b` â†’ true (1), Reihenfolge ist egal, nur Inhalte zÃ¤hlen\n",
            "\n",
            "-> `std::set<int> c = {1, 2, 2};`\n",
            "-> `std::set<int> d = {1, 1, 2};`\n",
            "-> `c == d` â†’ true (1), da doppelte EintrÃ¤ge ignoriert werden\n",
            "\n",
            "_Hinweis: `std::set` speichert die Elemente automatisch sortiert,_\n",
            "_Erlaubt keine Duplikate und bietet schnellen Zugriff._\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  // Set mit Ganzzahlen\n  std::set<int> zahlen;\n\n  // Elemente einfÃ¼gen (werden automatisch sortiert)\n  zahlen.insert(5);\n  zahlen.insert(2);\n  zahlen.insert(8);\n  zahlen.insert(2); // Duplikat â€“ wird ignoriert\n\n  // Ausgabe der Elemente\n  std::cout << \"Inhalt des Sets: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 2 5 8\n  std::cout << std::endl;\n\n  // PrÃ¼fen, ob ein Element enthalten ist\n  if (zahlen.count(5) > 0) {\n    std::cout << \"5 ist enthalten\" << std::endl;\n  }\n\n  // Alternative mit find()\n  if (zahlen.find(3) == zahlen.end()) {\n    std::cout << \"3 ist NICHT enthalten\" << std::endl;\n  }\n\n  // Anzahl der Elemente\n  std::cout << \"Set-GrÃ¶ÃŸe: \" << zahlen.size() << std::endl; // Ausgabe: 3\n\n  // Element lÃ¶schen\n  zahlen.erase(2);\n  std::cout << \"Nach LÃ¶schen von 2: \";\n  for (int x : zahlen) std::cout << x << \" \"; // Ausgabe: 5 8\n  std::cout << std::endl;\n\n  // Set leeren\n  zahlen.clear();\n  std::cout << \"Nach clear(): GrÃ¶ÃŸe = \" << zahlen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Maps",
        "content": {
          "text": [
            "### === Maps in C++ ===\n",
            "-> `#include <map>`       // FÃ¼r std::map\n",
            "-> `#include <string>`    // FÃ¼r std::string als SchlÃ¼ssel/Wert\n",
            "\n",
            "**--- Grundlagen ---**\n",
            "-> `std::map<std::string, int> m1;` Leere Map von string â†’ int\n",
            "-> `m1[\"C++\"] = 100;` FÃ¼gt SchlÃ¼ssel \"C++\" mit Wert 100 ein\n",
            "-> `m1[\"Java\"] = 90; m1[\"Python\"] = 85;` Weitere EintrÃ¤ge\n",
            "   Map speichert SchlÃ¼ssel-Wert-Paare, automatisch sortiert nach SchlÃ¼ssel\n",
            "\n",
            "**--- Zugriff & Erstellung ---**\n",
            "-> `std::map<std::string, std::string> m2 = {{\"de\", \"Berlin\"}, {\"fr\", \"Paris\"}, {\"opf\", \"Regensburg\"}};`\n",
            "-> `m2.size()` â†’ Anzahl der Paare in der Map â†’ 3\n",
            "-> `m2[\"de\"]` â†’ Zugriff auf den Wert zu \"de\" â†’ \"Berlin\"\n",
            "-> `m2[\"en\"]` â†’ Nicht vorhanden â†’ erstellt Eintrag mit leerem String als Wert\n",
            "\n",
            "**--- Sichere Abfrage mit at() ---**\n",
            "-> `m1.at(\"C++\")` â†’ Gibt den Wert zu \"C++\" zurÃ¼ck â†’ 100\n",
            "`// m1.at(\"C\")` wÃ¼rde abstÃ¼rzen (throw std::out_of_range), wenn SchlÃ¼ssel nicht existiert!\n",
            "\n",
            "**--- Existenz prÃ¼fen mit count() ---**\n",
            "-> `m1.count(\"Java\")` â†’ Gibt 1 zurÃ¼ck, wenn vorhanden\n",
            "-> `m1.count(\"Cobol\")` â†’ Gibt 0 zurÃ¼ck, wenn nicht vorhanden\n",
            "\n",
            "**--- Entfernen & PrÃ¼fen ---**\n",
            "-> `m1.clear()` â†’ Entfernt alle SchlÃ¼ssel-Wert-Paare\n",
            "-> `m1.empty()` â†’ PrÃ¼ft, ob Map leer ist â†’ true (1)\n",
            "\n",
            "**--- Vergleich von Maps ---**\n",
            "-> `std::map<int, char> mA = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mB = {{1, 'x'}, {2, 'z'}};`\n",
            "-> `mA == mB` â†’ false, da Werte unterschiedlich\n",
            "\n",
            "-> `std::map<int, char> mC = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mD = {{2, 'y'}, {1, 'x'}};`\n",
            "-> `mC == mD` â†’ true, Reihenfolge ist egal, Inhalte gleich\n",
            "\n",
            "-> `std::map<int, char> mE = {{2, 'y'}, {1, 'x'}, {1, 'x'}};`\n",
            "-> `mC == mE` â†’ true, mehrfacher identischer Eintrag zÃ¤hlt nicht doppelt\n",
            "\n",
            "_Hinweis: `std::map` speichert die SchlÃ¼ssel automatisch sortiert â€” bei `int` aufsteigend (1, 2, 3, ...), bei `string` alphabetisch (a, b, c, ...) und erlaubt keine Duplikate._\n"
          ],
          "code": [
            "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  // Map von Namen zu Alter\n  std::map<std::string, int> personen;\n\n  // EintrÃ¤ge hinzufÃ¼gen\n  personen[\"Anna\"] = 23;\n  personen[\"Bob\"] = 30;\n  personen.insert({\"Clara\", 27});\n\n  // Werte lesen\n  std::cout << \"Anna ist \" << personen[\"Anna\"] << \" Jahre alt.\" << std::endl; // Ausgabe: Anna ist 23 Jahre alt.\n\n  // Map durchgehen (automatisch sortiert nach SchlÃ¼ssel)\n  std::cout << \"Alle EintrÃ¤ge:\\n\";\n  for (const auto& eintrag : personen) {\n    std::cout << eintrag.first << \": \" << eintrag.second << std::endl;\n  } // Ausgabe: Anna: 23 / Bob: 30 / Clara: 27 (alphabetisch)\n\n  // Existenz prÃ¼fen\n  if (personen.count(\"Bob\") > 0) {\n    std::cout << \"Bob ist vorhanden.\" << std::endl; // Ausgabe: Bob ist vorhanden.\n  }\n\n  // Mit find() prÃ¼fen und Zugriff\n  auto it = personen.find(\"Dora\");\n  if (it == personen.end()) {\n    std::cout << \"Dora ist NICHT vorhanden.\" << std::endl;\n  }\n\n  // Wert Ã¤ndern\n  personen[\"Anna\"] = 24; // Anna hat jetzt Geburtstag\n\n  // Eintrag lÃ¶schen\n  personen.erase(\"Bob\");\n\n  // Ausgabe nach Ã„nderungen\n  std::cout << \"Nach Ã„nderungen:\\n\";\n  for (const auto& p : personen) {\n    std::cout << p.first << \": \" << p.second << std::endl;\n  } // Ausgabe: Anna: 24 / Clara: 27\n\n  // GrÃ¶ÃŸe der Map\n  std::cout << \"Anzahl Personen: \" << personen.size() << std::endl; // Ausgabe: 2\n\n  // Map leeren\n  personen.clear();\n  std::cout << \"Nach clear(): \" << personen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Stack/Queue",
        "content": {
          "text": [
            "### === Stack/Queue in C++ ===\n",
            "-> `#include <stack>`   // FÃ¼r std::stack\n",
            "-> `#include <queue>`   // FÃ¼r std::queue\n",
            "-> `#include <string>`  // FÃ¼r std::string\n",
            "\n",
            "**--- STACK (LIFO - Last In, First Out) ---**\n",
            "-> `std::stack<std::string> s1;` Erstellt einen leeren Stack vom Typ std::string\n",
            "-> `s1.push(\"Hello\");` FÃ¼gt 'Hello' oben auf den Stack\n",
            "-> `s1.push(\"World\");` FÃ¼gt 'World' oben auf den Stack\n",
            "   Stack-Inhalt (von unten nach oben): [`Hello`, `World`]\n",
            "-> `s1.top();` Gibt das oberste Element zurÃ¼ck â†’ \"World\"\n",
            "-> `s1.pop();` Entfernt das oberste Element (\"World\")\n",
            "-> `s1.size();` Gibt die Anzahl der Elemente im Stack zurÃ¼ck â†’ 1\n",
            "-> `s1.empty();` PrÃ¼ft, ob der Stack leer ist (true/false)\n",
            "\n",
            "**--- QUEUE (FIFO - First In, First Out) ---**\n",
            "-> `std::queue<std::string> q1;` Erstellt eine leere Queue fÃ¼r std::string\n",
            "-> `q1.push(\"Hello\");` FÃ¼gt 'Hello' hinten in die Queue ein\n",
            "-> `q1.push(\"World\");` FÃ¼gt 'World' hinten in die Queue ein\n",
            "   Reihenfolge: front â†’ back = [`Hello`, `World`]\n",
            "-> `q1.front();` Gibt das erste (Ã¤lteste) Element zurÃ¼ck â†’ \"Hello\"\n",
            "-> `q1.back();` Gibt das letzte (neueste) Element zurÃ¼ck â†’ \"World\"\n",
            "-> `q1.pop();` Entfernt das erste Element (\"Hello\")\n",
            "-> `q1.size();` Gibt die Anzahl der Elemente in der Queue zurÃ¼ck â†’ 1\n",
            "-> `q1.empty();` PrÃ¼ft, ob die Queue leer ist (true/false)\n"
          ],
          "code": [
            "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n\nint main() {\n  // -------- STACK (LIFO) --------\n  std::stack<int> stapel;\n  stapel.push(10);\n  stapel.push(20);\n  stapel.push(30); // Stapel: 10, 20, 30 (oben)\n\n  std::cout << \"[STACK] Oberstes Element: \" << stapel.top() << std::endl; // Ausgabe: 30\n  stapel.pop();\n  std::cout << \"[STACK] Nach pop(): \" << stapel.top() << std::endl; // Ausgabe: 20\n\n  std::cout << \"[STACK] GrÃ¶ÃŸe: \" << stapel.size() << std::endl; // Ausgabe: 2\n  if (!stapel.empty()) {\n    std::cout << \"[STACK] Nicht leer.\" << std::endl;\n  }\n\n  // -------- QUEUE (FIFO) --------\n  std::queue<std::string> warteschlange;\n  warteschlange.push(\"Anna\");\n  warteschlange.push(\"Bob\");\n  warteschlange.push(\"Clara\"); // Reihenfolge: Anna, Bob, Clara\n\n  std::cout << \"[QUEUE] Vorne: \" << warteschlange.front() << std::endl; // Ausgabe: Anna\n  std::cout << \"[QUEUE] Hinten: \" << warteschlange.back() << std::endl; // Ausgabe: Clara\n\n  warteschlange.pop();\n  std::cout << \"[QUEUE] Nach pop(): Vorne ist jetzt \" << warteschlange.front() << std::endl; // Ausgabe: Bob\n\n  std::cout << \"[QUEUE] GrÃ¶ÃŸe: \" << warteschlange.size() << std::endl; // Ausgabe: 2\n  if (!warteschlange.empty()) {\n    std::cout << \"[QUEUE] Nicht leer.\" << std::endl;\n  }\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Pairs/Tuples",
        "content": {
          "text": [
            "### === Pairs & Tuples in C++ ===\n",
            "-> `#include <utility>`   // FÃ¼r std::pair\n",
            "-> `#include <tuple>`     // FÃ¼r std::tuple\n",
            "-> `#include <string>`    // FÃ¼r std::string\n",
            "-> `#include <vector>`    // FÃ¼r std::vector\n",
            "\n",
            "**--- std::pair ---**\n",
            "-> `std::pair<std::string, int> p1 = std::make_pair(\"Regensburg\", 199000);`\n",
            "-> `std::pair<std::string, int> p2 = std::make_pair(\"Weiden\", 43000);`\n",
            "-> `std::pair<std::string, int> p3 = std::make_pair(\"Amberg\", 42000);`\n",
            "   Ein Pair enthÃ¤lt genau zwei Werte unterschiedlichen Typs\n",
            "-> `p1.first` â†’ Gibt das erste Element zurÃ¼ck â†’ \"Regensburg\"\n",
            "-> `p1.second` â†’ Gibt das zweite Element zurÃ¼ck â†’ 199000\n",
            "-> `std::vector<std::pair<std::string, int>> cities = {p1, p2, p3};` // Liste von StÃ¤dten mit Einwohnern\n",
            "-> `cities[1].first` â†’ Zugriff auf den Namen der zweiten Stadt â†’ \"Weiden\"\n",
            "\n",
            "**--- std::tuple ---**\n",
            "-> `std::tuple<std::string, int, double> t1 = std::make_tuple(\"Lisa\", 123, 1.0);`\n",
            "-> `std::tuple<std::string, int, double> t2 = std::make_tuple(\"Bart\", 456, 3.7);`\n",
            "-> `std::tuple<std::string, int, double> t3 = std::make_tuple(\"Nelson\", 666, 5.0);`\n",
            "   Ein Tuple kann beliebig viele Werte enthalten\n",
            "-> `std::get<0>(t1)` â†’ Zugriff auf das erste Element â†’ \"Lisa\"\n",
            "-> `std::get<1>(t2)` â†’ Zugriff auf das zweite Element â†’ 456\n",
            "-> `std::get<2>(t3)` â†’ Zugriff auf das dritte Element â†’ 5.0\n",
            "\n",
            "`std::tuple<T1, T2, T3>`: Bei Tuples muss der Index zur Compilezeit bekannt sein â†’ `std::get<1>(...)`\n",
            "   Das bedeutet: `std::get<0>(...)` gibt das erste Element vom Typ `T1` zurÃ¼ck\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <utility>  // fÃ¼r pair, make_pair\n#include <tuple>    // fÃ¼r tuple, make_tuple, get, tie\n\nint main() {\n  // -------- PAIR --------\n  std::pair<std::string, int> person = {\"Anna\", 25};\n  std::cout << \"[PAIR] Name: \" << person.first << \", Alter: \" << person.second << std::endl; // Ausgabe: Anna, 25\n\n  // Alternative mit make_pair\n  auto student = std::make_pair(\"Bob\", 30);\n  std::cout << \"[PAIR] Student: \" << student.first << \" - \" << student.second << std::endl;\n\n  // Vergleich\n  std::pair<int, int> a = {1, 2};\n  std::pair<int, int> b = {1, 3};\n  if (a < b) {\n    std::cout << \"[PAIR] a < b (lexikografisch)\" << std::endl;\n  }\n\n  // -------- TUPLE --------\n  std::tuple<std::string, int, double> daten = {\"Clara\", 28, 1.65};\n  std::cout << \"\\n[TUPLE] Name: \" << std::get<0>(daten)\n            << \", Alter: \" << std::get<1>(daten)\n            << \", GrÃ¶ÃŸe: \" << std::get<2>(daten) << std::endl; // Ausgabe: Clara, 28, 1.65\n\n  // Alternative mit make_tuple\n  auto eintrag = std::make_tuple(\"David\", 32, 1.80);\n\n  // Entpacken mit tie\n  std::string name;\n  int alter;\n  double groesse;\n  std::tie(name, alter, groesse) = eintrag;\n  std::cout << \"[TUPLE] Entpackt: \" << name << \", \" << alter << \", \" << groesse << std::endl;\n\n  // GrÃ¶ÃŸe des Tupels\n  std::cout << \"[TUPLE] Anzahl Elemente: \" << std::tuple_size<decltype(eintrag)>::value << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Iteratoren",
        "content": {
          "text": [
            "### === Iteratoren in C++ ===\n",
            "-> `#include <vector>`   // FÃ¼r std::vector\n",
            "-> `#include <list>`     // FÃ¼r std::list\n",
            "-> `#include <set>`      // FÃ¼r std::set\n",
            "-> `#include <algorithm>`// FÃ¼r std::copy, std::sort, std::merge\n",
            "-> `#include <iterator>` // FÃ¼r std::back_inserter\n",
            "\n",
            "**=== Iteratoren â€“ Grundlagen in C++ ===**\n",
            "-> Iteratoren sind bewegliche Zeiger, die auf ein Element eines Containers zeigen.\n",
            "-> Typbeispiel: `std::vector<std::string>::iterator`\n",
            "\n",
            "**--- Iterator-Zugriff & Navigation ---**\n",
            "-> `container.begin()` â†’ Iterator auf das erste Element\n",
            "-> `container.end()` â†’ Iterator auf das Element *nach* dem letzten\n",
            "-> `*it` â†’ aktuelles Element\n",
            "-> `it->member` entspricht `(*it).member`\n",
            "-> `++it`, `--it` â†’ nÃ¤chstes/vorheriges Element (nur rÃ¼ckwÃ¤rts bei bidirektional)\n",
            "-> `it += x` â†’ x Schritte vor (nur Random-Access, z.B. bei `std::vector`)\n",
            "\n",
            "**--- Iterator-Vergleich ---**\n",
            "-> `it == it2`, `it != it2` â†’ Vergleich\n",
            "-> `it < it2` â†’ Nur bei Random-Access mÃ¶glich\n",
            "\n",
            "**--- Iterator-Arten nach Container ---**\n",
            "`std::vector`, `std::array` â†’ Random-Access\n",
            "`std::list`, `std::set`, `std::map` â†’ Bidirektional\n",
            "`std::forward_list` â†’ Forward-only\n",
            "\n",
            "**--- Klassischer Iterator-Loop ---**\n",
            "```cpp\nstd::vector<int> v = {1, 2, 3};\nfor (auto it = v.begin(); it != v.end(); ++it)\n  std::cout << *it << std::endl;\n```\n",
            "\n",
            "**--- Laufindex (C-Style) ---**\n",
            "```cpp\nfor (int i = 0; i < v.size(); i++) std::cout << v[i];\n```\n",
            "\n",
            "**--- Range-based for loop ---**\n",
            "```cpp\nfor (int vi : v) std::cout << vi;\n```\n",
            "\n",
            "**--- Iterator fÃ¼r jedes 2. Element ---**\n",
            "```cpp\nfor (auto it = v.begin() + 1; it < v.end(); it += 2)\n  std::cout << *it;\n```\n",
            "\n",
            "**--- Iterator fÃ¼r Kopieren, Sortieren ---**\n",
            "```cpp\nstd::copy(v.begin(), v.end(), std::back_inserter(l));\nv.erase(v.begin() + 3);\nstd::sort(v.begin() + 1, v.end() - 1);\n```\n",
            "\n",
            "**--- Iterator bei set: find() ---**\n",
            "```cpp\nstd::set<int> s = {2, 4, 6};\nauto it = s.find(4);\nif (it != s.end()) std::cout << *it;\n```\n",
            "-> `find()` gibt `end()` zurÃ¼ck, wenn das Element nicht vorhanden ist\n",
            "-> Sets haben keine Indexe, nur Iteratoren\n",
            "\n",
            "**--- std::merge (zwei Container zusammenfÃ¼hren) ---**\n",
            "```cpp\nstd::merge(s.begin(), s.end(), v.begin(), v.end(), std::back_inserter(l));\n```\n",
            "-> FÃ¼gt sortiert alle Elemente aus `s` und `v` in `l` ein\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <iterator>  // fÃ¼r advance, distance\n#include <algorithm>\n\nint main() {\n  std::vector<int> zahlen = {10, 20, 30, 40, 50};\n\n  // Iteration mit explizitem Iterator\n  std::cout << \"Normale Iteration: \";\n  for (std::vector<int>::iterator it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  } // Ausgabe: 10 20 30 40 50\n  std::cout << std::endl;\n\n  // Iteration mit auto\n  std::cout << \"Mit auto: \";\n  for (auto it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\n  // RÃ¼ckwÃ¤rts iterieren\n  std::cout << \"RÃ¼ckwÃ¤rts: \";\n  for (auto rit = zahlen.rbegin(); rit != zahlen.rend(); ++rit) {\n    std::cout << *rit << \" \";\n  } // Ausgabe: 50 40 30 20 10\n  std::cout << std::endl;\n\n  // Zugriff & Ã„nderung Ã¼ber Iterator\n  auto it = zahlen.begin();\n  *it = 100; // Ã„ndert erstes Element\n  std::cout << \"Nach Ã„nderung: \" << zahlen[0] << std::endl; // Ausgabe: 100\n\n  // std::advance: verschiebe Iterator um 3 Positionen\n  std::advance(it, 3);\n  std::cout << \"Iterator +3: \" << *it << std::endl; // Ausgabe: 40\n\n  // std::distance: Abstand zwischen zwei Iteratoren\n  int abstand = std::distance(zahlen.begin(), it);\n  std::cout << \"Abstand: \" << abstand << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Allgemeine Funktionen fÃ¼r STL-Container ===\n",
            "-> `begin()`: Gibt Iterator zum ersten Element zurÃ¼ck.\n",
            "   Beispiel: `auto it = container.begin();`\n",
            "-> `end()`: Iterator hinter dem letzten Element.\n",
            "   Beispiel: `for (auto it = c.begin(); it != c.end(); ++it)`\n",
            "-> `size()`: Gibt Anzahl der Elemente zurÃ¼ck.\n",
            "   Beispiel: `std::cout << v.size();`\n",
            "-> `empty()`: PrÃ¼ft, ob Container leer ist.\n",
            "   Beispiel: `if (v.empty()) std::cout << \"leer\";`\n",
            "-> `clear()`: LÃ¶scht alle Elemente.\n",
            "   Beispiel: `v.clear();`\n",
            "-> `erase()`: Entfernt ein Element (Iterator oder Wert).\n",
            "   Beispiel: `v.erase(v.begin());`\n",
            "-> `insert()`: FÃ¼gt Element(e) hinzu.\n",
            "   Beispiel: `s.insert(42);`\n",
            "-> `find()`: Sucht Element (bei set/map).\n",
            "   Beispiel: `if (s.find(3) != s.end()) { ... }`\n",
            "-> `front()`: Erstes Element (z.B. bei vector, queue).\n",
            "   Beispiel: `std::cout << v.front();`\n",
            "-> `back()`: Letztes Element (z.B. bei vector).\n",
            "   Beispiel: `std::cout << v.back();`\n",
            "-> `at()`: Zugriff mit Bounds-Check.\n",
            "   Beispiel: `v.at(2);`\n",
            "-> `operator[]`: Zugriff ohne Check (nur bei vector, string, map).\n",
            "   Beispiel: `v[0] = 42;`\n",
            "-> `swap()`: Tauscht Inhalt zweier Container.\n",
            "   Beispiel: `v1.swap(v2);`\n",
            "-> `assign()`: Ersetzt Inhalt (z.B. bei vector oder string).\n",
            "   Beispiel: `v.assign(5, 0); // 5 Nullen`\n",
            "-> `resize()`: GrÃ¶ÃŸe Ã¤ndern (nur bei Sequenzcontainern).\n",
            "   Beispiel: `v.resize(10);`\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  std::set<int> s = {1, 2, 3};\n\n  // empty()\n  if (!s.empty()) {\n    std::cout << \"Set ist NICHT leer\" << std::endl; // Ausgabe: Set ist NICHT leer\n  }\n\n  // size()\n  std::cout << \"Anzahl Elemente: \" << s.size() << std::endl; // Ausgabe: 3\n\n  // insert()\n  s.insert(4);\n  s.insert(2); // 2 ist bereits enthalten, wird ignoriert\n\n  // erase()\n  s.erase(3); // entfernt 3, falls vorhanden\n\n  // find()\n  auto it = s.find(2);\n  if (it != s.end()) {\n    std::cout << \"2 gefunden\" << std::endl;\n  }\n\n  // count()\n  if (s.count(5) == 0) {\n    std::cout << \"5 ist NICHT enthalten\" << std::endl;\n  }\n\n  // swap()\n  std::set<int> s2 = {10, 20};\n  s.swap(s2); // jetzt enthÃ¤lt s die Elemente von s2\n\n  std::cout << \"Nach swap(): Set enthÃ¤lt: \";\n  for (int x : s) std::cout << x << \" \"; // Ausgabe: 10 20\n  std::cout << std::endl;\n\n  // clear()\n  s.clear();\n  std::cout << \"Nach clear(): GrÃ¶ÃŸe = \" << s.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      }
    ]
  },








  {
    "category": "Klassen",
    "subtopics": [
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Klassen in C++ ===\n",
            "Eine Klasse ist ein Bauplan fÃ¼r Objekte. Sie definiert Eigenschaften (Attribute) und FÃ¤higkeiten (Methoden), die ein Objekt haben kann.\n",
            "-> Mit einer Klasse kann man eigene Datentypen erstellen, die sowohl Daten als auch Funktionen enthalten.\n",
            "-> Klassen helfen beim Strukturieren von Code und sind ein zentrales Konzept der objektorientierten Programmierung.\n",
            "\n",
            "### Aufbau einer Klasse\n",
            "`class Klassenname { ... };` definiert eine Klasse. Darin legt man Member-Variablen (Attribute) und Member-Funktionen (Methoden) fest.\n",
            "Die Sichtbarkeit wird mit `public`, `private` oder `protected` gesteuert:\n",
            "- `private`: Nur innerhalb der Klasse sichtbar (Standard)\n",
            "- `public`: Von auÃŸen sichtbar\n",
            "- `protected`: Kein Zugriff von z.B main. Zugriff aus abgeleiteten Klassen und aus eigener Klasse ist erlaubt.\n",
            "\n",
            "### Objekt-Erzeugung\n",
            "Mit `Klassenname objektname;` wird ein Objekt erstellt. Danach kann man mit `objektname.funktion()` Methoden aufrufen.\n",
            "\n",
            "### Konstruktor\n",
            "Ein Konstruktor ist eine spezielle Methode, die automatisch beim Erzeugen eines Objekts aufgerufen wird. Er trÃ¤gt den Namen der Klasse.\n",
            "\n",
            "### this-Zeiger\n",
            "`this` ist ein Zeiger auf das aktuelle Objekt. Wird oft in Methoden verwendet, wenn man auf die eigene Instanz zugreifen mÃ¶chte.\n"
          ],
            "code": [
            "#include <iostream>\n\n// Definition einer Klasse\nclass Auto {\nprivate:\n  std::string marke;\n  int baujahr;\n\npublic:\n  // Konstruktor\n  Auto(std::string m, int bj) {\n    marke = m;\n    baujahr = bj;\n  }\n\n  // Methode zur Ausgabe\n  void anzeigen() {\n    std::cout << \"Marke: \" << marke << \", Baujahr: \" << baujahr << std::endl;\n  }\n};",
            "int main() {\n  // Objekt erzeugen\n  Auto meinAuto(\"BMW\", 2020);\n  meinAuto.anzeigen(); // Ausgabe: Marke: BMW, Baujahr: 2020\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Public / Private / Protected",
  "content": {
    "text": [
      "### === Zugriffsmodifizierer: `public`, `private`, `protected` ===\n",
      "In C++ bestimmt man mit Zugriffsmodifizierern, welche Teile einer Klasse **von auÃŸen sichtbar** oder **geschÃ¼tzt** sind.\n",
      "\n",
      "-> **Standard in `class`** ist: `private` (bei `struct` dagegen `public`)\n",
      "\n",
      "### ðŸ”’ `private:` (Standard)\n",
      "- Nur innerhalb der Klasse sichtbar\n",
      "- Gut fÃ¼r: Datenkapselung, interne Logik\n",
      "- Nicht sichtbar in Unterklassen\n",
      "\n",
      "### ðŸ”“ `public:`\n",
      "- Frei von Ã¼berall zugÃ¤nglich\n",
      "- Wird verwendet fÃ¼r Schnittstellen (z.B. Methoden wie `anzeigen()`)\n",
      "\n",
      "### ðŸŸ¨ `protected:`\n",
      "- Wie `private`, aber auch **in Unterklassen sichtbar**\n",
      "- Von **auÃŸen weiterhin nicht zugreifbar**\n",
      "- Gut, wenn **abgeleitete Klassen** auf interne Daten zugreifen sollen\n",
      "\n",
      "### âž• Vergleich:\n",
      "| Modifizierer | Sichtbar in Klasse | Sichtbar in Unterklasse | Sichtbar auÃŸerhalb |\n",
      "| private      | âœ…                 | âŒ                       | âŒ                  |\n",
      "| protected    | âœ…                 | âœ…                       | âŒ                  |\n",
      "| public       | âœ…                 | âœ…                       | âœ…                  |\n",
      "\n",
      "ðŸ‘‰ `protected` wird v.â€¯a. bei Vererbung verwendet, wenn man Unterklassen erweiterten, aber kontrollierten Zugriff geben mÃ¶chte."
    ],
    "code": [
      "#include <iostream>\n\nclass Konto {\nprivate:\n  int kontoNummer = 12345;        // Nur innerhalb der Klasse sichtbar\n\nprotected:\n  double kontostand = 100.0;      // FÃ¼r Unterklassen sichtbar\n\npublic:\n  void einzahlen(double betrag) {\n    kontostand += betrag;\n  }\n\n  void anzeigen() {\n    std::cout << \"Kontostand: \" << kontostand << \" EUR\" << std::endl;\n  }\n};\n\nclass KinderKonto : public Konto {\npublic:\n  void abheben(double betrag) {\n    kontostand -= betrag; // Zugriff auf protected-Mitglied erlaubt\n  }\n\n  void kontoInfo() {\n    // std::cout << kontoNummer; // âŒ Fehler: private in Basisklasse\n    std::cout << \"Zugriff auf geschÃ¼tzten Kontostand mÃ¶glich: \" << kontostand << std::endl;\n  }\n};\n\nint main() {\n  KinderKonto k;\n  k.einzahlen(50);\n  k.abheben(30);\n  k.anzeigen(); // Ausgabe: Kontostand: 120 EUR\n\n  // k.kontostand = 999;      // âŒ Fehler: protected von auÃŸen nicht sichtbar\n  // k.kontoNummer = 11111;   // âŒ Fehler: private von auÃŸen nicht sichtbar\n\n  k.kontoInfo(); // Zugriff auf protected innerhalb der Unterklasse\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Konstruktor / Destruktor",
        "content": {
          "text": [
            "### === Konstruktoren & Destruktoren in C++ ===\n",
            "Konstruktoren und Destruktoren sind spezielle Methoden, die automatisch beim Erzeugen bzw. ZerstÃ¶ren eines Objekts aufgerufen werden.\n",
            "\n",
            "### Konstruktor\n",
            "-> Wird beim Erzeugen eines Objekts aufgerufen\n",
            "-> Hat den **gleichen Namen wie die Klasse**, kein RÃ¼ckgabewert (auch kein `void`)\n",
            "-> Wird oft verwendet, um Startwerte zu setzen oder Ressourcen zu reservieren\n",
            "\n",
            "### Destruktor\n",
            "-> Wird beim LÃ¶schen eines Objekts aufgerufen (z.B. am Ende des GÃ¼ltigkeitsbereichs)\n",
            "-> Hat den gleichen Namen wie die Klasse, aber mit einem **Tilde-Zeichen `~`** davor\n",
            "-> Wird genutzt, um Ressourcen wie Speicher oder Dateien freizugeben\n",
            "\n",
            "### Wichtig\n",
            "- Es kann mehrere Konstruktoren geben (Ãœberladung), aber **nur einen Destruktor** pro Klasse\n",
            "- In modernen C++-Projekten ist der Destruktor vor allem bei dynamischem Speicher wichtig\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Tier {\nprivate:\n  std::string name;\n\npublic:\n  // Konstruktor\n  Tier(std::string n) {\n    name = n;\n    std::cout << \"Tier erstellt: \" << name << std::endl;\n  }\n\n  // Destruktor\n  ~Tier() {\n    std::cout << \"Tier gelÃ¶scht: \" << name << std::endl;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht GerÃ¤usche.\" << std::endl;\n  }\n};",
            "int main() {\n  Tier katze(\"Miezi\");\n  katze.sprich();\n\n  // Am Ende von main wird automatisch der Destruktor aufgerufen\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Friend",
        "content": {
          "text": [
            "### === `friend` in C++ ===\n",
            "Ein `friend` erlaubt einer Funktion oder einer anderen Klasse den **Zugriff auf private oder protected Member** einer Klasse.\n",
            "Damit kann gezielt und kontrolliert eine Ausnahme von der Kapselung gemacht werden.\n",
            "\n",
            "### friend-Funktion\n",
            "-> Wird **auÃŸerhalb** der Klasse definiert,\n",
            "-> hat aber Zugriff auf private Member,\n",
            "-> muss **innerhalb** der Klasse mit `friend` deklariert werden.\n",
            "\n",
            "### friend-Klasse\n",
            "-> Eine ganze Klasse kann als `friend` einer anderen Klasse deklariert werden,\n",
            "-> Sie bekommt vollen Zugriff auf alle privaten Elemente der Klasse.\n",
            "\n",
            "### Wann verwendet man `friend`?\n",
            "- Wenn bestimmte Funktionen eng mit der Klasse zusammenarbeiten mÃ¼ssen,\n",
            "- z.B. fÃ¼r Vergleichsfunktionen oder externe OperatorÃ¼berladungen.\n",
            "- Sollte **sparsam und gezielt** verwendet werden, da es die Kapselung aufbricht.\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Geheimnis {\nprivate:\n  int geheimerWert = 42;\n\n  // friend-Funktion erlauben\n  friend void zeigeGeheimnis(const Geheimnis& g);\n};\n\n// Definition der friend-Funktion\nvoid zeigeGeheimnis(const Geheimnis& g) {\n  std::cout << \"Geheimer Wert: \" << g.geheimerWert << std::endl;\n}",
            "int main() {\n  Geheimnis objekt;\n  zeigeGeheimnis(objekt); // Ausgabe: Geheimer Wert: 42\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Copy Constructor & Assignment",
  "content": {
    "text": [
      "### === Copy Constructor & Copy Assignment ===\n",
      "Wenn Objekte kopiert oder zugewiesen werden, kommen spezielle Funktionen ins Spiel:\n",
      "\n",
      "- **Copy Constructor**: Wird aufgerufen bei z.B. `Objekt b = a;`\n",
      "- **Copy Assignment Operator**: Wird aufgerufen bei `b = a;`, wenn `b` schon existiert\n",
      "\n",
      "### Warum ist das wichtig?\n",
      "StandardmÃ¤ÃŸig macht C++ eine **flache Kopie** (Shallow Copy):\n",
      "- Zeiger werden 1:1 Ã¼bernommen\n",
      "- FÃ¼hrt bei `delete` oft zu AbstÃ¼rzen oder doppelt gelÃ¶schtem Speicher\n",
      "\n",
      "Daher sollte man bei dynamischem Speicher (z.B. `new`) eine **tiefe Kopie (Deep Copy)** schreiben:\n",
      "- Es wird ein **neuer Speicher** erstellt und der Inhalt kopiert\n",
      "\n",
      "### Die Rule of 3:\n",
      "Wenn du eins dieser 3 selbst schreibst, solltest du alle schreiben:\n",
      "- Destruktor (`~Klasse()`)\n",
      "- Copy Constructor\n",
      "- Copy Assignment Operator\n",
      "\n",
      "ðŸ‘‰ Ab C++11 gibt es auch die Rule of 5 (inkl. Move Constructor und Move Assignment)\n",
      "\n",
      "### â— `if (this != &other)` â€“ warum?\n",
      "Beim Zuweisungsoperator **kann es passieren**, dass ein Objekt sich selbst zugewiesen wird:\n",
      "```cpp\nobj = obj;\n```\n",
      "Ohne `if (this != &other)` wÃ¼rde man:\n",
      "- Speicher **lÃ¶schen**, der gleich danach **benutzt** wird â†’ âŒ Absturz!\n",
      "- Oder unnÃ¶tig neu kopieren\n",
      "âœ… Mit dem Vergleich wird sichergestellt, dass bei **Selbstzuweisung** nichts passiert."
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n    }\n\n    // Copy Constructor (tiefe Kopie)\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n    }\n\n    // Copy Assignment Operator (tiefe Kopie)\n    Person& operator=(const Person& andere) {\n        if (this != &andere) { // wichtig bei Selbstzuweisung!\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Person p1(\"Kilian\");\n    Person p2 = p1;         // Copy Constructor wird genutzt\n    Person p3(\"Test\");\n    p3 = p1;                // Copy Assignment wird genutzt\n\n    p1.anzeigen();          // Name: Kilian\n    p2.anzeigen();          // Name: Kilian\n    p3.anzeigen();          // Name: Kilian\n\n    p1 = p1;                // Selbstzuweisung â†’ geschÃ¼tzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Move Constructor & Rvalue-Referenz",
  "content": {
    "text": [
      "### === Rvalue-Referenzen & Move Constructor (C++11+) ===\n",
      "Mit C++11 wurde die **Move-Semantik** eingefÃ¼hrt, um unnÃ¶tige Kopien zu vermeiden â€“ besonders bei temporÃ¤ren Objekten.\n",
      "\n",
      "### Was ist eine Rvalue-Referenz (`T&&`)?\n",
      "- `T&&` akzeptiert ein **temporÃ¤res Objekt** (z.B. RÃ¼ckgabewert einer Funktion)\n",
      "- ErmÃ¶glicht das **Ãœbernehmen von Ressourcen**, statt sie zu kopieren\n",
      "\n",
      "### Move Constructor\n",
      "- Wird aufgerufen bei z.B. `Objekt b = std::move(a);`\n",
      "- **\"klaut\"** den Speicher von `a`, statt ihn zu kopieren\n",
      "\n",
      "### Move Assignment Operator\n",
      "- Wird bei `b = std::move(a);` aufgerufen (wenn `b` schon existiert)\n",
      "- Wie Zuweisung, aber mit Ãœbernahme statt Kopie\n",
      "\n",
      "### Wann sinnvoll?\n",
      "- GroÃŸe Objekte (z.B. Strings, Container)\n",
      "- TemporÃ¤re RÃ¼ckgaben (`return obj;`)\n",
      "\n",
      "### Wichtig:\n",
      "- Danach ist das Objekt im \"moved-from\"-Zustand â†’ es darf **nicht mehr normal verwendet**, aber **zerstÃ¶rt** werden\n",
      "- Rvalue-Referenz erkennt man meist mit `std::move(var)`\n",
      "\n",
      "ðŸ‘‰ Wer Copy Constructor, Copy Assignment, Destruktor UND Move-Funktionen schreibt, folgt der **Rule of 5**\n",
      "\n",
      "### â— Auch bei Move Assignment: `if (this != &andere)`\n",
      "Bei `obj = std::move(obj);` kann es zu **Selbst-Zuweisung** kommen!\n",
      "- Ohne PrÃ¼fung: Speicher wird gelÃ¶scht **bevor** er Ã¼bertragen wird â†’ âŒ Absturz!\n",
      "- Mit PrÃ¼fung: Zuweisung wird Ã¼bersprungen â†’ âœ… korrekt\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) { // wichtig bei Selbst-Zuweisung!\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << (name ? name : \"[leer]\") << std::endl;\n    }\n};\n\nPerson erzeugePerson() {\n    return Person(\"Kilian\");\n}\n\nint main() {\n    Person p1 = erzeugePerson();    // Move Constructor\n    Person p2(\"Test\");\n    p2 = std::move(p1);             // Move Assignment\n\n    p2.anzeigen();                  // Name: Kilian\n    p1.anzeigen();                  // Name: [leer]\n\n    p2 = std::move(p2);             // Selbstzuweisung â†’ geschÃ¼tzt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Rule of 5",
  "content": {
    "text": [
      "### === Rule of 5 (C++11+) ===\n",
      "Die **Rule of 5** beschreibt, welche Funktionen du in einer Klasse mit Ressourcen (z.B. `new`) implementieren solltest.\n",
      "\n",
      "Sie erweitert die **Rule of 3** (Copy Constructor, Copy Assignment, Destruktor) um zwei neue Funktionen:\n",
      "\n",
      "### Die fÃ¼nf Funktionen:\n",
      "1. **Destruktor** (`~Klasse()`)\n",
      "2. **Copy Constructor** (`Klasse(const Klasse&)`)\n",
      "3. **Copy Assignment Operator** (`operator=(const Klasse&)`)\n",
      "4. **Move Constructor** (`Klasse(Klasse&&)`)\n",
      "5. **Move Assignment Operator** (`operator=(Klasse&&)`)\n",
      "\n",
      "### Warum das Ganze?\n",
      "- Wenn du eine Funktion manuell schreibst (z.B. Copy Constructor), deaktiviert C++ die automatische Generierung der anderen â†’ du musst sie selbst implementieren\n",
      "- Besonders bei dynamischem Speicher wichtig (deep copy & safe move)\n",
      "\n",
      "### Wann ist die Rule of 5 wichtig?\n",
      "- Wenn deine Klasse **Zeiger oder Ressourcen verwaltet** (z.B. mit `new`, `malloc`, Datei-Handles)\n",
      "- Wenn du **Kopie und Verschiebung erlauben oder verhindern** willst\n",
      "\n",
      "ðŸ‘‰ Alternativen: **Rule of 0** bei reinem Value-Semantik-Code (z.B. `std::vector`, keine `new`) oder Rule of 6 (mit `operator==()`)\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) {\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n};\n\nint main() {\n    Person a(\"Max\");\n    Person b = a;             // Copy Constructor\n    Person c(\"Test\");\n    c = a;                    // Copy Assignment\n    Person d = std::move(a);  // Move Constructor\n    b = std::move(c);         // Move Assignment\n    return 0;\n}"
    ]
  }
},
{
  "title": "Implizite Klassenbestandteile & = delete",
  "content": {
    "text": [
      "### === Implizite Klassenbestandteile in C++ ===\n",
      "C++ erzeugt fÃ¼r jede Klasse automatisch bestimmte Methoden, wenn du sie nicht selbst definierst:\n",
      "\n",
      "### Diese Methoden werden (standardmÃ¤ÃŸig) automatisch generiert:\n",
      "- Standard-Konstruktor (`MyClass()`)\n",
      "- Destruktor (`~MyClass()`)\n",
      "- Copy Constructor (`MyClass(const MyClass&)`)\n",
      "- Copy Assignment (`operator=(const MyClass&)`)\n",
      "- Move Constructor (`MyClass(MyClass&&)`) *(ab C++11)*\n",
      "- Move Assignment (`operator=(MyClass&&)`) *(ab C++11)*\n",
      "\n",
      "### Warum `= delete`?\n",
      "- Verhindert, dass eine bestimmte Methode automatisch generiert oder verwendet wird\n",
      "- Beispiel: Kopieren verhindern (z.B. bei Singleton- oder Handle-Klassen)\n",
      "```cpp\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n",
      "\n",
      "### Warum `= default`?\n",
      "- Erzwingt die automatische Standard-Erstellung (z.B. wenn du trotzdem was anderes schreibst)\n",
      "```cpp\nMyClass() = default;\n```\n",
      "\n",
      "### Wann ist das wichtig?\n",
      "- Wenn deine Klasse z.B. Zeiger enthÃ¤lt und **tiefe Kopie nÃ¶tig** ist\n",
      "- Wenn du **kopieren bewusst verbieten** willst\n",
      "- Wenn du eine Methode **nur deklarieren willst, aber ohne eigene Logik** (z.B. bei APIs)\n",
      "\n",
      "ðŸ‘‰ Moderne Klassen (z.B. mit Ressourcenbesitz) sollten Copy/Move bewusst steuern\n",
      "ðŸ‘‰ In PrÃ¼fungen wird oft gefragt: \"Was macht `= delete`?\" oder \"Was wird implizit generiert?\"\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Beispiel {\npublic:\n    Beispiel() = default; // Standard-Konstruktor explizit erlaubt\n\n    // Copy-VorgÃ¤nge deaktivieren\n    Beispiel(const Beispiel&) = delete;\n    Beispiel& operator=(const Beispiel&) = delete;\n\n    void hallo() {\n        std::cout << \"Hallo!\" << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b1;      // OK\n    b1.hallo();\n\n    // Beispiel b2 = b1;        // Fehler: Copy Constructor ist gelÃ¶scht\n    // Beispiel b3;\n    // b3 = b1;                  // Fehler: Copy Assignment ist gelÃ¶scht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Struct vs. Class",
  "content": {
    "text": [
      "### === struct vs. class in C++ ===\n",
      "`struct` und `class` sind sich in C++ sehr Ã¤hnlich â€“ beide kÃ¶nnen Memberfunktionen, Konstruktoren, Vererbung und vieles mehr enthalten.\n",
      "Der **einzige technische Unterschied** ist die **Standard-Sichtbarkeit**:\n",
      "\n",
      "| Merkmal                     | `struct` (Standard: public)   | `class` (Standard: private)   |\n",
      "| Standard-Sichtbarkeit       | `public`                      | `private`                    |\n",
      "| Wird verwendet fÃ¼r...       | Datencontainer, PODs          | OOP-Klassen, Kapselung       |\n",
      "| Methoden mÃ¶glich?           | âœ… Ja                          | âœ… Ja                         |\n",
      "| Vererbung mÃ¶glich?          | âœ… Ja                          | âœ… Ja                         |\n",
      "| Konstruktoren, Operatoren?  | âœ… Ja                          | âœ… Ja                         |\n",
      "\n",
      "### Beispiel: Unterschied in der Sichtbarkeit\n",
      "```cpp\nstruct A {\n    int x;       // automatisch public\n};\n\nclass B {\n    int x;       // automatisch private\n};\n\nint main() {\n    A a;\n    a.x = 10;    // âœ… erlaubt\n\n    B b;\n    // b.x = 10; // âŒ Fehler: x ist private\n    return 0;\n}\n```\n",
      "\n",
      "### Merksatz:\n",
      "- Verwende `struct`, wenn du **nur Daten speichern willst** (wie bei C-Strukturen)\n",
      "- Verwende `class`, wenn du **Verhalten, Kapselung, Logik** einbauen willst\n",
      "\n",
      "ðŸ‘‰ Aber technisch gesehen sind beide fast identisch â€“ nur der Standardzugriff unterscheidet sich!"
    ],
    "code": [
      "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n\n    void anzeigen() {\n        std::cout << \"x: \" << x << \", y: \" << y << std::endl;\n    }\n};\n\nclass Person {\nprivate:\n    std::string name;\npublic:\n    Person(const std::string& n) : name(n) {}\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Punkt p = {3, 5};\n    p.anzeigen();   // x: 3, y: 5\n\n    Person pers(\"Kilian\");\n    pers.anzeigen(); // Name: Kilian\n\n    return 0;\n}"
    ]
        }
      },
    {
  "title": "explicit",
  "content": {
    "text": [
      "### === `explicit` ===\n",
      "Das SchlÃ¼sselwort `explicit` wird in C++ verwendet, um **automatische Typumwandlungen zu verhindern** â€“ vor allem bei **einparametrigen Konstruktoren**.\n",
      "\n",
      "ðŸ‘‰ Ohne `explicit` kÃ¶nnen Konstruktoren auch dann aufgerufen werden, wenn ein anderer Typ **implizit Ã¼bergeben** wird.\n",
      "\n",
      "### Wozu ist das gut?\n",
      "- Um **unerwartete Konstruktoraufrufe** bei Ãœbergaben oder Zuweisungen zu vermeiden.\n",
      "- Um die Verwendung von Konstruktoren **bewusst und lesbar** zu machen.\n",
      "\n",
      "### Beispiel ohne `explicit`:\n",
      "- Konstruktor kann durch z.B. einen `int`-Wert automatisch aufgerufen werden:\n",
      "```cpp\nZahl z = 5; // erlaubt, weil nicht explicit\n```\n",
      "- Das ist manchmal gewollt, aber oft **versteckt sich dabei ein Fehler**.\n",
      "\n",
      "### Mit `explicit`:\n",
      "- Konstruktor darf **nur direkt** aufgerufen werden:\n",
      "```cpp\nZahl z(5);       // âœ… erlaubt\nZahl z = 5;       // âŒ nicht erlaubt\n```\n",
      "\n",
      "ðŸ“Œ `explicit` kann auch bei **`operator`-Funktionen** verwendet werden (z.B. `operator bool()`), um Konvertierungen z.B. in `if`-Bedingungen zu kontrollieren.\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\npublic:\n  explicit Zahl(int wert) {\n    std::cout << \"Konstruktor aufgerufen mit: \" << wert << std::endl;\n  }\n};\n\nvoid printZahl(Zahl z) {\n  std::cout << \"printZahl() aufgerufen\" << std::endl;\n}\n\nint main() {\n  Zahl z(42);      // âœ… erlaubt: direkte Initialisierung\n  printZahl(z);    // âœ… erlaubt\n\n  // printZahl(42); // âŒ Fehler: implizite Konvertierung verboten durch 'explicit'\n  return 0;\n}\n\n// Beispielausgabe:\n// Konstruktor aufgerufen mit: 42\n// printZahl() aufgerufen"
    ]
  }
},
{
  "title": "Getter- und Setter-Funktionen",
  "content": {
    "text": [
      "### === Getter- und Setter-Funktionen ===\n",
      "Getter und Setter sind spezielle Funktionen, die den **Zugriff auf private Membervariablen** einer Klasse ermÃ¶glichen.\n",
      "\n",
      "ðŸ‘‰ Sie sind ein Teil des **Kapselungskonzepts** in der objektorientierten Programmierung.\n",
      "\n",
      "### Getter:\n",
      "- Lesen den Wert eines privaten Members.\n",
      "- Haben oft den Namen `getXYZ()`.\n",
      "- RÃ¼ckgabetyp entspricht dem Membertyp.\n",
      "\n",
      "### Setter:\n",
      "- Setzen oder Ã¤ndern den Wert eines privaten Members.\n",
      "- Haben oft den Namen `setXYZ()`.\n",
      "- KÃ¶nnen zusÃ¤tzliche PrÃ¼fungen enthalten (z.B. Wertebereich).\n",
      "\n",
      "### Warum verwenden?\n",
      "- Direkter Zugriff auf `private` Variablen ist nicht erlaubt.\n",
      "- Getter/Setter ermÃ¶glichen **kontrollierten Zugriff**.\n",
      "- So bleibt die **DatenintegritÃ¤t** erhalten.\n",
      "\n",
      "ðŸ“Œ In modernen C++-Projekten ist es Ã¼blich, nur dann Getter/Setter zu schreiben, wenn sie **wirklich gebraucht werden**."
    ],
    "code": [
      "#include <iostream>\n\nclass Person {\nprivate:\n  int alter;\n\npublic:\n  // Getter\n  int getAlter() const {\n    return alter;\n  }\n\n  // Setter mit PrÃ¼fung\n  void setAlter(int a) {\n    if (a >= 0)\n      alter = a;\n  }\n};\n\nint main() {\n  Person p;\n  p.setAlter(25); // setzt Alter auf 25\n  std::cout << \"Alter: \" << p.getAlter() << std::endl;\n  return 0;\n}\n\n// Beispielausgabe:\n// Alter: 25"
    ]
  }
}



    ]
  },








{
    "category": "Klassen Vererbung",
    "subtopics": [
{
  "title": "Allgemein",
  "content": {
    "text": [
      "### === Vererbung in C++ ===\n",
      "Vererbung ist ein zentrales Konzept der objektorientierten Programmierung.\n",
      "Damit kann eine neue Klasse (`Kindklasse`) die Eigenschaften und Methoden einer bestehenden Klasse (`Basisklasse`) Ã¼bernehmen.\n",
      "\n",
      "### Vorteile\n",
      "- Code-Wiederverwendung\n",
      "- Erweiterbarkeit\n",
      "- Strukturierte Hierarchien\n",
      "\n",
      "### Syntax\n",
      "`class Kindklasse : public Basisklasse { ... };`\n",
      "-> `public` bedeutet: Ã¶ffentliche Mitglieder der Basisklasse bleiben auch in der Kindklasse Ã¶ffentlich.\n",
      "-> `protected` bedeutet: Ã¶ffentliche Mitglieder der Basisklasse werden in der Kindklasse protected.\n",
      "-> `private` bedeutet: Ã¶ffentliche Mitglieder der Basisklasse werden in der Kindklasse private.\n",
      "\n",
      "### Konstruktoren in Vererbung\n",
      "-> Konstruktor der Basisklasse wird **automatisch zuerst** aufgerufen.\n",
      "-> Kann im Initialisierungsbereich der Kindklasse explizit aufgerufen werden.\n",
      "\n",
      "### Vererbungsmodi in C++\n",
      "C++ kennt drei Vererbungsmodi: `public`, `protected` und `private`.\n",
      "- Sie bestimmen, wie sich die Sichtbarkeit von geerbten Attributen und Methoden in der abgeleiteten Klasse verÃ¤ndert.\n",
      "- Der Modus ist eine **obere Schranke**: `public` lÃ¤sst alles wie es ist, `private` versteckt fast alles.\n",
      "\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n"
    ],
"code": [
  "#include <iostream>\n\n// Basisklasse\nclass Tier {\nprotected:\n  std::string name;\n\npublic:\n  Tier(std::string n) {\n    name = n;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht ein GerÃ¤usch.\" << std::endl;\n  }\n};\n\n// Abgeleitete Klasse\nclass Hund : public Tier {\npublic:\n  Hund(std::string n) : Tier(n) {}\n\n  void bell() {\n    std::cout << name << \" bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  rex.sprich(); // Ausgabe: Rex macht ein GerÃ¤usch.\n  rex.bell();   // Ausgabe: Rex bellt.\n\n  return 0;\n}",
  "// ZusÃ¤tzliche Beispiele zur Vererbungsart:\n\nclass base {\npublic:\n  void f() {}\nprotected:\n  void g() {}\nprivate:\n  int x;\n};\n\nclass derived_1 : public base {\n  // f() bleibt public\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_2 : protected base {\n  // f() wird protected\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_3 : private base {\n  // f() wird private\n  // g() wird private\n  // x ist nicht zugreifbar\n};"
]
        }
      },
{
  "title": "Vererbungsmodi",
  "content": {
    "text": [
      "### === Vererbungsmodi in C++ ===\n",
      "Wenn eine Klasse von einer anderen Klasse erbt, kannst du den **Vererbungsmodus** festlegen:\n",
      "- `public`\n",
      "- `protected`\n",
      "- `private`\n",
      "\n",
      "Der Modus bestimmt, **wie die Zugriffsrechte** (`public` / `protected` / `private`) der Basisklasse in der abgeleiteten Klasse weitervererbt werden.\n",
      "\n",
      "### Vergleichstabelle:\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n",
      "ðŸ‘‰ **private Mitglieder werden nie vererbt**, egal welcher Modus.\n",
      "\n",
      "### Wann welchen Modus?\n",
      "- `public`: Die abgeleitete Klasse ist eine vollwertige â€žist-einâ€œ-Variante (z.B. `Hund ist ein Tier`)\n",
      "- `protected`: Meist intern genutzt, selten in Praxis\n",
      "- `private`: Wenn Vererbung nur als Implementierungshilfe dient und von auÃŸen verborgen bleiben soll"
    ],
    "code": [
      "#include <iostream>\n\nclass base {\npublic:\n  void f() { std::cout << \"f()\\n\"; }\nprotected:\n  void g() { std::cout << \"g()\\n\"; }\nprivate:\n  int x = 42; // nicht vererbbar\n};\n\nclass derived_public : public base {\npublic:\n  void test() {\n    f(); // OK (public bleibt public)\n    g(); // OK (protected bleibt protected)\n    // x; âŒ nicht zugreifbar\n  }\n};\n\nclass derived_protected : protected base {\npublic:\n  void test() {\n    f(); // OK (public wird protected)\n    g(); // OK (protected bleibt protected)\n  }\n};\n\nclass derived_private : private base {\npublic:\n  void test() {\n    f(); // OK (public wird private)\n    g(); // OK (protected wird private)\n  }\n};\n\nint main() {\n  derived_public dp;\n  dp.f(); // OK\n  // dp.g(); âŒ nicht erlaubt (geschÃ¼tzt)\n\n  derived_protected dpr;\n  // dpr.f(); âŒ nicht erlaubt (geschÃ¼tzt)\n\n  derived_private dpi;\n  // dpi.f(); âŒ nicht erlaubt (privat)\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Konstruktorvererbung & -Ã¼bernahme",
  "content": {
    "text": [
      "### === Konstruktorvererbung & -weitergabe in C++ ===\n",
      "Normalerweise werden Konstruktoren **nicht automatisch** an abgeleitete Klassen vererbt.\n",
      "Das bedeutet: Die Unterklasse muss eigene Konstruktoren definieren und dabei die Konstruktoren der Basisklasse explizit aufrufen.\n",
      "\n",
      "### ðŸ”§ Konstruktorweitergabe mit Initialisierungsliste\n",
      "- Ein Konstruktor der Unterklasse kann per `: Basisklasse(...)` den Konstruktor der Oberklasse aufrufen.\n",
      "\n",
      "```cpp\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  Hund(std::string name) : Tier(name) {}\n};\n```\n",
      "\n",
      "### ðŸ” Konstruktorvererbung mit `using` (ab C++11)\n",
      "- Mit `using Basisklasse::Basisklasse;` kÃ¶nnen Konstruktoren **automatisch Ã¼bernommen** werden.\n",
      "- Spart Schreibaufwand, wenn man nichts zusÃ¤tzlich initialisieren muss.\n",
      "\n",
      "ðŸ‘‰ Achtung: Funktioniert **nicht**, wenn die Unterklasse zusÃ¤tzliche Member/Attribute initialisieren muss oder andere Logik enthÃ¤lt.\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  // Weitergabe an Basiskonstruktor\n  Hund(std::string name) : Tier(name) {\n    std::cout << \"Hund-Konstruktor lÃ¤uft.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  // Konstruktorvererbung ab C++11\n  using Tier::Tier;\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  // Ausgabe:\n  // Rex wird erschaffen.\n  // Hund-Konstruktor lÃ¤uft.\n\n  Katze mimi(\"Mimi\");\n  // Ausgabe:\n  // Mimi wird erschaffen.\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Destruktorvererbung",
  "content": {
    "text": [
      "### === Destruktorvererbung ===\n",
      "Wenn Klassen **vererbt** werden und Ã¼ber Zeiger auf die **Basisklasse** gelÃ¶scht wird, ist es wichtig, den Destruktor **virtuell** zu machen.\n",
      "\n",
      "ðŸ‘‰ Nur dann wird der Destruktor der **abgeleiteten Klasse korrekt aufgerufen**.\n",
      "\n",
      "### Warum `virtual` beim Destruktor?\n",
      "- Ohne `virtual` wird beim LÃ¶schen Ã¼ber einen Basisklassenzeiger **nur der Basisklassen-Destruktor** aufgerufen.\n",
      "- Das fÃ¼hrt zu **undefiniertem Verhalten** oder **Speicherlecks**, wenn die abgeleitete Klasse Ressourcen verwaltet.\n",
      "\n",
      "### Best Practice:\n",
      "- In jeder Klasse mit virtuellen Funktionen sollte der Destruktor ebenfalls `virtual` sein.\n",
      "- Auch Interfaceklassen (mit `= 0`) sollten **einen virtuellen Destruktor** haben.\n",
      "\n",
      "ðŸ“Œ Ein `virtual`-Destruktor sorgt dafÃ¼r, dass beim LÃ¶schen Ã¼ber einen Zeiger auf die Basisklasse **alle Destruktoren korrekt und vollstÃ¤ndig** ausgefÃ¼hrt werden."
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual ~Tier() {\n    std::cout << \"Tier-Destruktor\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  ~Hund() {\n    std::cout << \"Hund-Destruktor\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  ~Katze() {\n    std::cout << \"Katze-Destruktor\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  delete t1; // Ausgabe: Hund-Destruktor, Tier-Destruktor\n  delete t2; // Ausgabe: Katze-Destruktor, Tier-Destruktor\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Redefinition von Memberfunktionen",
  "content": {
    "text": [
      "### === Redefinition von Memberfunktionen ===\n",
      "In der objektorientierten Programmierung mit C++ ist es mÃ¶glich, **Funktionen in Unterklassen neu zu definieren**.\n",
      "Dabei Ã¼berschreibt die Unterklasse die gleichnamige Funktion der Oberklasse. Das nennt man auch **â€žRedefinitionâ€œ** oder **â€žÃœberschreibenâ€œ** (nicht zu verwechseln mit Ãœberladung).\n",
      "\n",
      "### Wann macht man das?\n",
      "- Wenn eine abgeleitete Klasse ein **eigenes Verhalten** fÃ¼r eine Methode braucht\n",
      "- Beispiel: `Tier` hat `sprich()`, aber `Hund` bellt und `Katze` miaut\n",
      "\n",
      "### Ohne `virtual` = statisch gebunden\n",
      "- Wenn die Methode **nicht** als `virtual` deklariert ist, entscheidet sich beim **Compilieren**, welche Funktion verwendet wird (statisch)\n",
      "\n",
      "### Mit `virtual` = dynamisch gebunden\n",
      "- Nur wenn die Methode in der Basisklasse als `virtual` markiert ist, wird sie **zur Laufzeit** (dynamisch) aufgelÃ¶st â€“ wichtig fÃ¼r **Polymorphie**\n",
      "\n",
      "ðŸ‘‰ `virtual` sollte bei der Basisklasse verwendet werden, wenn man mÃ¶chte, dass Unterklassen eigene Versionen implementieren\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void sprich() {\n    std::cout << \"Ein Tier macht ein GerÃ¤usch.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() { // Ã¼berschreibt, aber nicht virtuell\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund h;\n  h.sprich(); // Ausgabe: Ein Hund bellt.\n\n  Tier* t = new Hund();\n  t->sprich(); // Ausgabe: Ein Tier macht ein GerÃ¤usch. (weil kein virtual!)\n\n  delete t;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Virtuelle Funktionen",
  "content": {
    "text": [
      "### === Virtuelle Funktionen ===\n",
      "Virtuelle Funktionen ermÃ¶glichen es in C++, dass die **richtige Funktion zur Laufzeit aufgerufen wird**, wenn mit Zeigern oder Referenzen auf Basisklassen gearbeitet wird.\n",
      "\n",
      "ðŸ‘‰ Dieses Verhalten nennt man **dynamisches Binden** oder **Laufzeit-Polymorphie**.\n",
      "\n",
      "### Was passiert ohne `virtual`?\n",
      "- Es wird immer die Funktion der **Basisklasse** aufgerufen, selbst wenn das Objekt eigentlich zur Unterklasse gehÃ¶rt.\n",
      "\n",
      "### Mit `virtual`:\n",
      "- Die Entscheidung, **welche Funktion** aufgerufen wird, erfolgt **zur Laufzeit** (dynamisch), basierend auf dem tatsÃ¤chlichen Objekttyp.\n",
      "- Ideal fÃ¼r Oberklassen mit gemeinsamem Interface, das von Unterklassen **spezialisiert** wird.\n",
      "\n",
      "### Wichtig:\n",
      "- Wird in einer Klasse `virtual` verwendet, sollte in abgeleiteten Klassen `override` verwendet werden (seit C++11).\n",
      "- Der Destruktor einer Basisklasse sollte fast immer `virtual` sein, wenn Vererbung verwendet wird!\n",
      "\n",
      "### ðŸ”’ Pur-virtuelle Funktionen (`= 0`)\n",
      "- Eine Funktion kann als **rein virtuell** deklariert werden:\n",
      "```cpp\nvirtual void sprich() = 0;\n```\n",
      "- Die Klasse wird dadurch **abstrakt** â€“ es kÃ¶nnen **keine Objekte davon erstellt** werden.\n",
      "- Jede abgeleitete Klasse **muss** diese Funktion implementieren, sonst ist auch sie abstrakt.\n",
      "- Wird oft fÃ¼r **Interfaces** genutzt (z.B. gemeinsame Schnittstelle fÃ¼r viele Untertypen).\n",
      "\n",
      "ðŸš« **Nicht erlaubt:**\n",
      "- Es ist **nicht erlaubt**, direkt ein Objekt einer abstrakten Klasse zu erzeugen:\n",
      "```cpp\nLebewesen l; // âŒ Fehler: Objekt von abstrakter Klasse\n```\n",
      "- Auch das Erzeugen eines Zeigers oder einer Referenz ist **nur erlaubt**, wenn kein Konstruktor direkt aufgerufen wird:\n",
      "```cpp\nLebewesen* ptr; // âœ… erlaubt, solange kein Objekt erstellt wird\n```"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein GerÃ¤usch.\" << std::endl;\n  }\n\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  t1->sprich(); // Ausgabe: Ein Hund bellt.\n  t2->sprich(); // Ausgabe: Eine Katze miaut.\n\n  delete t1;\n  delete t2;\n  return 0;\n}",
      "\n// Beispiel mit rein virtueller Funktion:\n#include <iostream>\n\nclass Lebewesen {\npublic:\n  virtual void bewegung() = 0; // rein virtuelle Funktion\n  virtual ~Lebewesen() {}\n};\n\nclass Fisch : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Fisch schwimmt.\" << std::endl;\n  }\n};\n\nclass Vogel : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Vogel fliegt.\" << std::endl;\n  }\n};\n\nint main() {\n  // Lebewesen l; // âŒ Fehler: Kann nicht instanziiert werden (abstrakte Klasse)\n\n  Lebewesen* l1 = new Fisch();\n  Lebewesen* l2 = new Vogel();\n\n  l1->bewegung(); // Ausgabe: Ein Fisch schwimmt.\n  l2->bewegung(); // Ausgabe: Ein Vogel fliegt.\n\n  delete l1;\n  delete l2;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Statisches vs. dynamisches Binden",
  "content": {
    "text": [
      "### === Statisches vs. dynamisches Binden ===\n",
      "**Binden** bedeutet, dass der Compiler entscheidet, **welche Funktion** bei einem Funktionsaufruf verwendet wird.\n",
      "In C++ gibt es zwei Arten:\n",
      "\n",
      "### ðŸ”’ Statisches Binden (Compile-Time Binding)\n",
      "- Der **Compiler** entscheidet zur **Ãœbersetzungszeit**, welche Funktion aufgerufen wird.\n",
      "- Gilt fÃ¼r **nicht-virtuelle Funktionen**.\n",
      "- Schneller, aber **nicht polymorph**.\n",
      "\n",
      "### ðŸ”“ Dynamisches Binden (Run-Time Binding)\n",
      "- Die Entscheidung erfolgt zur **Laufzeit**.\n",
      "- Nur mÃ¶glich bei **virtuellen Funktionen** Ã¼ber **Zeiger oder Referenzen** auf die Basisklasse.\n",
      "- ErmÃ¶glicht **Polymorphie**.\n",
      "\n",
      "### Vergleich:\n",
      "| Merkmal              | Statisch (`default`)    | Dynamisch (`virtual`)      |\n",
      "| Zeitpunkt der Bindung| Kompilierzeit          | Laufzeit                    |\n",
      "| Geschwindigkeit      | Schnell                | Etwas langsamer             |\n",
      "| Polymorphie mÃ¶glich? | âŒ                     | âœ…                          |\n",
      "| Anwendbar auf        | normale Funktionen     | virtuelle Funktionen        |\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Tier\" << std::endl;\n  }\n\n  virtual void sprich() {\n    std::cout << \"[dynamisch] Tier macht ein GerÃ¤usch\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Hund\" << std::endl;\n  }\n\n  void sprich() override {\n    std::cout << \"[dynamisch] Hund bellt\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* tierPtr = new Hund();\n\n  tierPtr->info();   // Ausgabe: [statisch] Tier (keine virtuelle Methode)\n  tierPtr->sprich(); // Ausgabe: [dynamisch] Hund bellt (virtuell)\n\n  delete tierPtr;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Polymorphie",
  "content": {
    "text": [
      "### === Polymorphie in C++ ===\n",
      "Polymorphie bedeutet, dass ein Objekt **unterschiedliche Formen annehmen** kann â€“ also dass **eine Schnittstelle viele Implementierungen** zulÃ¤sst.\n",
      "\n",
      "ðŸ‘‰ In C++ tritt Polymorphie oft in Verbindung mit **Vererbung und virtuellen Funktionen** auf.\n",
      "\n",
      "### Vorteile der Polymorphie:\n",
      "- ErmÃ¶glicht flexiblen und erweiterbaren Code\n",
      "- Funktionen kÃ¶nnen auf **Basisklassen zeigen**, aber das Verhalten **von Unterklassen ausfÃ¼hren**\n",
      "- Wichtig fÃ¼r Designmuster wie Strategy, Factory, etc.\n",
      "\n",
      "### Voraussetzungen fÃ¼r Polymorphie:\n",
      "- Eine **Basisklasse** mit mindestens einer `virtual`-Funktion\n",
      "- Funktionen werden Ã¼ber **Zeiger oder Referenzen** aufgerufen\n",
      "\n",
      "ðŸ‘‰ Polymorphie funktioniert **nicht bei Werten**, sondern nur Ã¼ber Zeiger oder Referenz!"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein GerÃ¤usch.\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Tier*> tiere;\n  tiere.push_back(new Hund());\n  tiere.push_back(new Katze());\n  tiere.push_back(new Hund());\n\n  for (Tier* t : tiere) {\n    t->sprich();\n    // Ausgabe:\n    // Ein Hund bellt.\n    // Eine Katze miaut.\n    // Ein Hund bellt.\n  }\n\n  for (Tier* t : tiere) {\n    delete t;\n  }\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Abstrakte Klassen und Schnittstellenklassen",
  "content": {
    "text": [
      "### === Abstrakte Klassen und Schnittstellenklassen ===\n",
      "Abstrakte Klassen dienen als **Basisklassen**, von denen **kein direktes Objekt erstellt** werden kann.\n",
      "\n",
      "ðŸ‘‰ Sie enthalten mindestens **eine rein virtuelle Funktion** (`= 0`).\n",
      "\n",
      "### Eigenschaften abstrakter Klassen:\n",
      "- KÃ¶nnen normale Memberfunktionen und Membervariablen enthalten.\n",
      "- KÃ¶nnen **teilweise implementiert** sein (z.B. gemeinsames Verhalten).\n",
      "- KÃ¶nnen als **Basisklasse** fÃ¼r konkrete Unterklassen dienen.\n",
      "\n",
      "### Schnittstellenklassen (Interfaces):\n",
      "- Eine Sonderform der abstrakten Klasse.\n",
      "- Enthalten **nur rein virtuelle Funktionen** (und evtl. einen virtuellen Destruktor).\n",
      "- Dienen nur als **Vertrag**, was eine Klasse kÃ¶nnen muss.\n",
      "- Kein Zustand, keine Implementierung â€“ nur Methoden ohne KÃ¶rper.\n",
      "\n",
      "ðŸ§© In C++ gibt es keine eigene `interface`-Syntax wie in Java oder C#, stattdessen nutzt man reine virtuelle Funktionen.\n",
      "\n",
      "### Beispiel fÃ¼r eine Interfaceklasse:\n",
      "```cpp\nclass Druckbar {\npublic:\n  virtual void drucke() = 0;\n  virtual ~Druckbar() {}\n};\n```\n",
      "\n",
      "### Warum verwenden?\n",
      "- Um **Verhalten festzulegen**, das von mehreren Klassen auf **unterschiedliche Weise** umgesetzt wird.\n",
      "- Um **Polymorphie** zu ermÃ¶glichen.\n",
      "- Um **AbhÃ¤ngigkeiten zu entkoppeln** (z.B. bei Plugins, Testbarkeit usw.)."
    ],
    "code": [
      "// Abstrakte Klasse mit gemeinsamer Logik\n#include <iostream>\n#include <vector>\n\nclass Form {\npublic:\n  virtual double flaeche() = 0; // rein virtuelle Funktion\n  void zeige() {\n    std::cout << \"FlÃ¤che: \" << flaeche() << std::endl;\n  }\n  virtual ~Form() {}\n};\n\nclass Kreis : public Form {\n  double radius;\npublic:\n  Kreis(double r) : radius(r) {}\n  double flaeche() override {\n    return 3.14159 * radius * radius;\n  }\n};\n\nclass Quadrat : public Form {\n  double seite;\npublic:\n  Quadrat(double s) : seite(s) {}\n  double flaeche() override {\n    return seite * seite;\n  }\n};\n\nint main() {\n  std::vector<Form*> formen;\n  formen.push_back(new Kreis(2));\n  formen.push_back(new Quadrat(3));\n\n  for (Form* f : formen) {\n    f->zeige();\n  }\n\n  for (Form* f : formen) {\n    delete f;\n  }\n  return 0;\n}"
    ]
  }
},
{
  "title": "Finale Klassen und Memberfunktionen",
  "content": {
    "text": [
      "### === Finale Klassen und Memberfunktionen ===\n",
      "Mit dem SchlÃ¼sselwort `final` kann man in C++ **Vererbung oder Ãœberschreiben verhindern**.\n",
      "\n",
      "ðŸ‘‰ Das ist nÃ¼tzlich, wenn du sicherstellen willst, dass bestimmte Funktionen oder Klassen **nicht mehr verÃ¤ndert** werden dÃ¼rfen.\n",
      "\n",
      "### Finale Memberfunktionen:\n",
      "- Eine `virtual`-Funktion kann mit `final` markiert werden:\n",
      "```cpp\nvirtual void machEtwas() final;\n```\n",
      "- Dadurch **kann sie in abgeleiteten Klassen nicht mehr Ã¼berschrieben** werden.\n",
      "- Wird oft verwendet, um bestimmte Methoden **festzulegen und abzusichern**.\n",
      "\n",
      "### Finale Klassen:\n",
      "- Eine ganze Klasse kann mit `final` markiert werden:\n",
      "```cpp\nclass A final { ... };\n```\n",
      "- Dadurch **kann von dieser Klasse nicht mehr geerbt** werden.\n",
      "- Ideal, wenn die Klasse **vollstÃ¤ndig abgeschlossen** ist oder keine weitere Spezialisierung erwÃ¼nscht ist.\n",
      "\n",
      "ðŸ“Œ `final` wurde mit **C++11** eingefÃ¼hrt. Es erhÃ¶ht die **Lesbarkeit**, verbessert die **Fehlersicherheit** und kann dem Compiler sogar **Optimierungen** ermÃ¶glichen."
    ],
    "code": [
      "#include <iostream>\n\nclass Basis {\npublic:\n  virtual void begruessung() {\n    std::cout << \"Hallo aus Basis\" << std::endl;\n  }\n  virtual void fixMethode() final {\n    std::cout << \"Diese Methode ist final und kann nicht Ã¼berschrieben werden.\" << std::endl;\n  }\n  virtual ~Basis() {}\n};\n\nclass Abgeleitet : public Basis {\npublic:\n  void begruessung() override {\n    std::cout << \"Hallo aus Abgeleitet\" << std::endl;\n  }\n  // void fixMethode() override {} // âŒ Fehler: Methode ist final in der Basisklasse\n};\n\n// === Finale Klasse ===\nclass Endklasse final {\npublic:\n  void info() {\n    std::cout << \"Dies ist eine finale Klasse.\" << std::endl;\n  }\n};\n\n// class Versuch : public Endklasse {}; // âŒ Fehler: Endklasse ist final, kann nicht geerbt werden\n\nint main() {\n  Basis* b = new Abgeleitet();\n  b->begruessung(); // Ausgabe: Hallo aus Abgeleitet\n  b->fixMethode();  // Ausgabe: Diese Methode ist final und kann nicht Ã¼berschrieben werden.\n\n  Endklasse e;\n  e.info(); // Ausgabe: Dies ist eine finale Klasse.\n\n  delete b;\n  return 0;\n"
    ]
  }
},
{
  "title": "Kovariante RÃ¼ckgabetypen",
  "content": {
    "text": [
      "### === Kovariante RÃ¼ckgabetypen ===\n",
      "Kovariante RÃ¼ckgabetypen ermÃ¶glichen es in C++, dass eine **Ã¼berschriebene virtuelle Funktion** in einer abgeleiteten Klasse **einen spezielleren RÃ¼ckgabetyp** liefert.\n",
      "\n",
      "ðŸ‘‰ Der RÃ¼ckgabetyp darf sich Ã¤ndern, **wenn er ein Zeiger oder eine Referenz auf einen abgeleiteten Typ** ist.\n",
      "\n",
      "### Beispiel:\n",
      "- In der Basisklasse wird eine Funktion deklariert, die `Basis*` zurÃ¼ckgibt.\n",
      "- In der abgeleiteten Klasse kann dieselbe Funktion dann `Abgeleitet*` zurÃ¼ckgeben.\n",
      "\n",
      "âœ… Das ist erlaubt, **solange die RÃ¼ckgabetypen kompatibel vererbt** sind (also `Abgeleitet*` ist ein Spezialfall von `Basis*`).\n",
      "\n",
      "### Vorteile:\n",
      "- ErmÃ¶glicht **prÃ¤zisere Typen** bei polymorphem Verhalten.\n",
      "- Spart **unnÃ¶tige Casts** im Code.\n",
      "\n",
      "ðŸ“Œ Achtung: Kovarianz gilt **nur** fÃ¼r RÃ¼ckgabetypen bei **virtuellen Funktionen**, nicht bei Parametern."
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Tier {\npublic:\n  virtual Tier* klonen() const {\n    std::cout << \"Tier wird geklont\" << std::endl;\n    return new Tier(*this); // Kopiert das aktuelle Objekt (Kopierkonstruktor)\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  Hund* klonen() const override { // âœ… kovarianter RÃ¼ckgabetyp: Hund* statt Tier*\n    std::cout << \"Hund wird geklont\" << std::endl;\n    return new Hund(*this); // âœ… korrekt: erstellt Kopie des aktuellen Hund-Objekts\n    // return *(new Hund()); // âŒ Fehler: ergibt Objekt (Hund), kein Zeiger (Hund*)\n  }\n\n  // int klonen() const override { return 1; } // âŒ Fehler: inkompatibler RÃ¼ckgabetyp (int â‰  Tier*)\n};\n\n// === Beispiel fÃ¼r RÃ¼ckgabe als Referenz ===\nclass Fog {\npublic:\n  std::string name = \"Fog\";\n};\n\nclass DemoRef {\npublic:\n  Fog& getFog() const {\n    return *(new Fog()); // âœ… erlaubt: RÃ¼ckgabe als Referenz (&), Objekt lebt auf dem Heap\n  }\n};\n\nint main() {\n  Tier* t = new Hund();\n  Tier* neu = t->klonen(); // Ausgabe: Hund wird geklont\n\n  DemoRef d;\n  Fog& f = d.getFog();\n  std::cout << f.name << std::endl; // Ausgabe: Fog\n\n  delete t;\n  delete neu;\n  delete &f; // â—ï¸manuell lÃ¶schen, da mit new erzeugt\n  return 0;\n"
    ]
  }
},
{
  "title": "Object Slicing",
  "content": {
    "text": [
      "### === Object Slicing ===\n",
      "Beim **Object Slicing** (Objektabschneiden) geht Information **verloren**, wenn ein Objekt einer abgeleiteten Klasse in ein Objekt einer Basisklasse **kopiert** wird â€“ **ohne Zeiger oder Referenz**.\n",
      "\n",
      "ðŸ‘‰ Dabei werden **nur die Mitglieder der Basisklasse** Ã¼bernommen â€“ alles, was zur Unterklasse gehÃ¶rt, **geht verloren**.\n",
      "\n",
      "### Wann passiert Slicing?\n",
      "- Wenn ein Objekt **per Wert** (also nicht per Zeiger oder Referenz) Ã¼bergeben oder zugewiesen wird.\n",
      "- Typisch bei: `Base b = Derived();`\n",
      "\n",
      "### Warum ist das ein Problem?\n",
      "- Virtuelle Funktionen verhalten sich dann **nicht mehr polymorph**.\n",
      "- Das Objekt \"vergisst\", dass es eigentlich ein Unterklassen-Objekt war.\n",
      "\n",
      "### Wie vermeidet man Slicing?\n",
      "- Arbeite immer mit **Zeigern (`*`) oder Referenzen (`&`)**, nicht mit Objekten per Wert.\n",
      "- Ãœbergib Objekte polymorph:\n",
      "```cpp\nvoid verarbeite(const Base& b);\n```\n",
      "\n",
      "ðŸ“Œ C++ selbst erkennt Slicing **nicht als Fehler** â€“ du musst es **bewusst vermeiden**!"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  std::string name = \"Tier\";\n\n  virtual void sprich() const {\n    std::cout << name << \" spricht\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  std::string rasse = \"SchÃ¤ferhund\";\n\n  void sprich() const override {\n    std::cout << name << \" bellt. Rasse: \" << rasse << std::endl;\n  }\n};\n\nvoid machGerÃ¤usch(Tier t) { // âŒ Slicing: Hund wird zu Tier kopiert\n  std::cout << \"[Slicing] Name: \" << t.name << std::endl;\n  t.sprich(); // Ausgabe: Tier spricht\n}\n\nvoid machGerÃ¤uschRichtig(const Tier& t) { // âœ… korrekt per Referenz\n  std::cout << \"[Kein Slicing] Name bleibt erhalten\" << std::endl;\n  t.sprich(); // Ausgabe: Hund bellt. Rasse: SchÃ¤ferhund\n}\n\nint main() {\n  Hund h;\n  h.name = \"Bello\";\n  h.rasse = \"Labrador\";\n\n  machGerÃ¤usch(h);        // âŒ slicing: nur Tier-Teil bleibt Ã¼brig\n  machGerÃ¤uschRichtig(h); // âœ… korrekt: vollstÃ¤ndiges Objekt erhalten\n\n  return 0;\n"
    ]
  }
},
{
  "title": "Mehrfachvererbung",
  "content": {
    "text": [
      "### === Mehrfachvererbung ===\n",
      "In C++ ist es mÃ¶glich, dass eine Klasse **von mehreren Basisklassen gleichzeitig erbt**.\n",
      "\n",
      "ðŸ‘‰ Das nennt man **Mehrfachvererbung** und sie kann nÃ¼tzlich sein â€“ aber auch schnell zu Problemen fÃ¼hren.\n",
      "\n",
      "### Syntax:\n",
      "- Eine Klasse kann mehrere Basisklassen angeben:\n",
      "```cpp\nclass C : public A, public B { ... };\n```\n",
      "\n",
      "### Vorteile:\n",
      "- Kombinieren von FunktionalitÃ¤t aus verschiedenen Klassen.\n",
      "- Kann helfen, **Code zu teilen**, z.B. bei Interfaceklassen.\n",
      "\n",
      "### Probleme (Diamond Problem):\n",
      "- Wenn **mehrere Basisklassen** von **derselben Oberklasse** erben, kann es zu **Mehrdeutigkeiten** kommen.\n",
      "- Beispiel: Beide Elternklassen erben von `Grundklasse`, Kindklasse erbt von beiden â†’ `Grundklasse` ist **zweimal** vorhanden!\n",
      "\n",
      "### LÃ¶sung: `virtual`-Vererbung\n",
      "- Mit `virtual` wird sichergestellt, dass es **nur eine gemeinsame Instanz** der Basisklasse gibt:\n",
      "```cpp\nclass A : virtual public Grundklasse { };\n```\n",
      "- Wird auch **virtuelle Vererbung** genannt.\n",
      "\n",
      "### Reihenfolge: Konstruktoren & Destruktoren\n",
      "- Die Konstruktoren der **Basisklassen** werden in der Reihenfolge aufgerufen, wie sie **in der Klassendeklaration** erscheinen â€“ **nicht nach Reihenfolge im Initialisierungslisten-Code**.\n",
      "- Destruktoren laufen **in umgekehrter Reihenfolge** (von abgeleitet nach oben).\n",
      "- Bei **virtueller Vererbung** wird der virtuelle Basisklassenkonstruktor **nur einmal** aufgerufen â€“ von der **untersten Klasse** im Hierarchiebaum.\n",
      "\n",
      "ðŸ“Œ Mehrfachvererbung ist mÃ¤chtig, sollte aber **mit Bedacht eingesetzt** werden. Oft sind Komposition oder Interfaces die bessere Wahl."
    ],
    "code": [
      "#include <iostream>\n\nclass Lebewesen {\npublic:\n  Lebewesen() { std::cout << \"[Konstruktor] Lebewesen\" << std::endl; }\n  ~Lebewesen() { std::cout << \"[Destruktor] Lebewesen\" << std::endl; }\n  void atme() { std::cout << \"Lebewesen atmet\" << std::endl; }\n};\n\nclass Schwimmer : virtual public Lebewesen {\npublic:\n  Schwimmer() { std::cout << \"[Konstruktor] Schwimmer\" << std::endl; }\n  ~Schwimmer() { std::cout << \"[Destruktor] Schwimmer\" << std::endl; }\n  void schwimme() { std::cout << \"Ich schwimme\" << std::endl; }\n};\n\nclass LÃ¤ufer : virtual public Lebewesen {\npublic:\n  LÃ¤ufer() { std::cout << \"[Konstruktor] LÃ¤ufer\" << std::endl; }\n  ~LÃ¤ufer() { std::cout << \"[Destruktor] LÃ¤ufer\" << std::endl; }\n  void laufe() { std::cout << \"Ich laufe\" << std::endl; }\n};\n\nclass Triathlet : public Schwimmer, public LÃ¤ufer {\npublic:\n  Triathlet() { std::cout << \"[Konstruktor] Triathlet\" << std::endl; }\n  ~Triathlet() { std::cout << \"[Destruktor] Triathlet\" << std::endl; }\n  void wettkampf() {\n    atme();\n    schwimme();\n    laufe();\n  }\n};\n\nint main() {\n  Triathlet t;\n  t.wettkampf();\n  return 0;\n}\n\n// Beispielausgabe:\n// [Konstruktor] Lebewesen\n// [Konstruktor] Schwimmer\n// [Konstruktor] LÃ¤ufer\n// [Konstruktor] Triathlet\n// Lebewesen atmet\n// Ich schwimme\n// Ich laufe\n// [Destruktor] Triathlet\n// [Destruktor] LÃ¤ufer\n// [Destruktor] Schwimmer\n// [Destruktor] Lebewesen"
    ]
  }
}






      
    ]
  },







  {
    "category": "Ãœberladung",
    "subtopics": [
      {
        "title": "Funktionen",
        "content": {
          "text": [
            "### === FunktionsÃ¼berladung in C++ ===\n",
            "FunktionsÃ¼berladung bedeutet, dass mehrere Funktionen **denselben Namen**, aber **unterschiedliche Parameterlisten** haben kÃ¶nnen.\n",
            "\n",
            "Der Compiler wÃ¤hlt beim Aufruf die passende Funktion anhand der Ã¼bergebenen Argumente.\n",
            "\n",
            "### Regeln\n",
            "- Funktionen mÃ¼ssen sich in der Anzahl oder dem Typ der Parameter unterscheiden\n",
            "- RÃ¼ckgabewert allein reicht **nicht** zur Unterscheidung!\n",
            "\n",
            "### Vorteile\n",
            "- Lesbarkeit: Gleicher Funktionsname fÃ¼r Ã¤hnliche Aufgaben\n",
            "- FlexibilitÃ¤t: Funktion kann mit verschiedenen Datentypen arbeiten\n"
          ],
          "code": [
            "#include <iostream>\n\n// FunktionsÃ¼berladungen\nvoid begruessung() {\n  std::cout << \"Hallo!\" << std::endl;\n}\n\nvoid begruessung(std::string name) {\n  std::cout << \"Hallo, \" << name << \"!\" << std::endl;\n}\n\nvoid begruessung(int stunde) {\n  if (stunde < 12)\n    std::cout << \"Guten Morgen!\" << std::endl;\n  else\n    std::cout << \"Guten Tag!\" << std::endl;\n}\n\nint main() {\n  begruessung();              // Ausgabe: Hallo!\n  begruessung(\"Kilian\");     // Ausgabe: Hallo, Kilian!\n  begruessung(9);             // Ausgabe: Guten Morgen!\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Operatoren",
        "content": {
          "text": [
            "### === OperatorÃ¼berladung in C++ ===\n",
            "OperatorÃ¼berladung erlaubt es, **eigene Klassen** so zu definieren, dass Standard-Operatoren (`+`, `==`, `<<`, usw.) auch mit diesen Klassen funktionieren.\n",
            "\n",
            "### Warum Operatoren Ã¼berladen?\n",
            "- Mehr Lesbarkeit: `a + b` statt `a.addiere(b)`\n",
            "- NatÃ¼rlichere Verwendung eigener Typen\n",
            "\n",
            "### Syntax\n",
            "`RÃ¼ckgabetyp operator<OPERATOR>(Parameter)`\n",
            "-> Wird innerhalb oder auÃŸerhalb der Klasse definiert\n",
            "-> Kann fast jeder Operator Ã¼berladen werden (auÃŸer z.B. `.` oder `::`)\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Punkt {\nprivate:\n  int x, y;\n\npublic:\n  Punkt(int x, int y) : x(x), y(y) {}\n\n  // OperatorÃ¼berladung fÃ¼r +\n  Punkt operator+(const Punkt& other) {\n    return Punkt(x + other.x, y + other.y);\n  }\n\n  // Ausgabeoperator Ã¼berladen (als friend)\n  friend std::ostream& operator<<(std::ostream& os, const Punkt& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n  }\n};\n\nint main() {\n  Punkt a(2, 3);\n  Punkt b(4, 1);\n  Punkt c = a + b;\n\n  std::cout << \"a + b = \" << c << std::endl; // Ausgabe: a + b = (6, 4)\n\n  return 0;\n}"

          ]
        }
      }
    ]
  },







  {
    "category": "Extras",
    "subtopics": [
      {
  "title": "Formatierung",
  "content": {
    "text": [
      "### === Formatierung in C++ ===\n",
      "In C++ gibt es verschiedene MÃ¶glichkeiten, Ausgaben optisch zu formatieren â€“ z.â€¯B. fÃ¼r Tabellen, Zahlen, Texte und Spezialformate.\n",
      "\n",
      "### ðŸ“ Feldbreite und Ausrichtung (`<iomanip>`)\n",
      "- `std::setw(n)`: Legt die Breite eines Felds fest\n",
      "- `std::left`, `std::right`: Textausrichtung (nur in Verbindung mit `std::setw()`)\n",
      "- `std::setfill(c)`: Zeichen zum AuffÃ¼llen (z.â€¯B. `0` oder `-`)\n",
      "\n",
      "### ðŸ”¢ Nachkommastellen und Gleitkommaformat\n",
      "- `std::fixed`: Feste Anzahl Nachkommastellen\n",
      "- `std::setprecision(n)`: Anzahl Nachkommastellen\n",
      "- `std::scientific`: Wissenschaftliche Notation\n",
      "\n",
      "### ðŸ”£ Zahlenformate\n",
      "- `std::dec` â†’ dezimal (Standard)\n",
      "- `std::hex` â†’ hexadezimal\n",
      "- `std::oct` â†’ oktal\n",
      "- Praktisch fÃ¼r Debug-Ausgaben oder Speicheradressen\n",
      "\n",
      "### ðŸ” FÃ¼hrende Nullen\n",
      "- Mit `std::setw()` und `std::setfill('0')`:\n",
      "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // 00017\n```\n",
      "- Mit `std::string` manuell:\n",
      "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17);\n```\n",
      "- Ab C++20 mit `std::format`:\n",
      "```cpp\nstd::format(\"{:05}\", 17); // 00017\n```\n",
      "\n",
      "### ðŸ†• `std::format` (C++20)\n",
      "- Moderner, leistungsfÃ¤higer Formatter\n",
      "- Nutzt Python-Ã¤hnliche Syntax\n",
      "- Beispiele:\n",
      "```cpp\nstd::format(\"{} hat {} Punkte\", name, punkte);\nstd::format(\"{:>10}\", \"rechts\"); // rechtsbÃ¼ndig\n```\n",
      "- Erfordert Compiler mit C++20 + Format-UnterstÃ¼tzung (`<format>`)"
    ],
    "code": [
  "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int punkte = 42;\n  double kontostand = 1234.56789;\n\n  // Feldbreite und Ausrichtung\n  std::cout << std::left << std::setw(12) << \"Name\"\n            << std::right << std::setw(8) << \"Punkte\"\n            << std::setw(15) << \"Kontostand\" << std::endl; // Ausgabe: Name            Punkte     Kontostand\n  std::cout << std::left << std::setw(12) << name\n            << std::right << std::setw(8) << punkte\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl; // Ausgabe: Kilian             42         1234.57\n\n  // Zahlenformate\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;        // Ausgabe: Dezimal: 42\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;   // Ausgabe: Hexadezimal: 2a\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;          // Ausgabe: Oktal: 52\n\n  // FÃ¼hrende Nullen mit iomanip\n  std::cout << \"FÃ¼hrende Nullen: \" << std::setw(5) << std::setfill('0') << zahl << std::endl; // Ausgabe: FÃ¼hrende Nullen: 00042\n\n  // Mit std::string\n  std::string gepolstert = std::string(5 - std::to_string(zahl).length(), '0') + std::to_string(zahl);\n  std::cout << \"Manuell gepolstert: \" << gepolstert << std::endl; // Ausgabe: Manuell gepolstert: 00042\n\n#if __cpp_lib_format\n  // Mit std::format (C++20)\n  std::cout << std::format(\"std::format fÃ¼hrend: {:05}\\n\", zahl); // Ausgabe: std::format fÃ¼hrend: 00042\n  std::cout << std::format(\"Name: {}, Punkte: {}\\n\", name, punkte); // Ausgabe: Name: Kilian, Punkte: 42\n  std::cout << std::format(\"{:>10}\\n\", \"rechts\"); // Ausgabe:     rechts\n#endif\n\n  return 0;\n"
]

  }
},
    {
  "title": "Casting",
  "content": {
    "text": [
      "### === Casting in C++ ===\n",
      "Casting ist die Umwandlung eines Ausdrucks von einem Datentyp in einen anderen.\n",
      "In C++ gibt es sowohl **C-Style Casts** als auch **C++-spezifische Casts**:\n",
      "\n",
      "### ðŸŸ¥ C-Style Cast (unsicher!)\n",
      "```cpp\nint x = (int)3.14;   // Ergebnis: 3\n```\n",
      "- Alt, kompakt, aber **unsicher**\n",
      "- Kann **gefÃ¤hrliche Typumwandlungen** stillschweigend zulassen\n",
      "\n",
      "### âœ… C++ Casts (sicherer & spezifischer):\n",
      "\n",
      "#### ðŸ”¹ static_cast<T>(expr)\n",
      "- FÃ¼r **sichere, logische Konvertierungen** (z.B. `double` â†’ `int`, `Base*` â†’ `Derived*` bei Vererbung ohne RTTI)\n",
      "```cpp\nint x = static_cast<int>(3.7);  // x = 3\n```\n",
      "\n",
      "#### ðŸ”¹ dynamic_cast<T>(expr)\n",
      "- FÃ¼r **sichere Konvertierung bei Vererbung** mit `virtual`\n",
      "- Funktioniert nur mit **Polymorphie** (mind. eine `virtual`-Methode)\n",
      "- Gibt `nullptr` zurÃ¼ck, wenn Cast fehlschlÃ¤gt\n",
      "```cpp\nBase* b = new Derived();\nDerived* d = dynamic_cast<Derived*>(b);  // OK\n```\n",
      "\n",
      "#### ðŸ”¹ reinterpret_cast<T>(expr)\n",
      "- FÃ¼r **rohe Speicherumwandlungen**, z.B. zwischen Zeigertypen\n",
      "- Sehr gefÃ¤hrlich â€“ nur mit groÃŸem VerstÃ¤ndnis verwenden\n",
      "```cpp\nint* p = reinterpret_cast<int*>(0x1234);\n```\n",
      "\n",
      "#### ðŸ”¹ const_cast<T>(expr)\n",
      "- Entfernt oder fÃ¼gt `const` hinzu (z.B. um schreibende Funktion auf `const`-Objekte anzuwenden)\n",
      "- Nur erlaubt, wenn Ursprungsobjekt nicht wirklich `const` war\n",
      "```cpp\nconst int* p = ...;\nint* mod = const_cast<int*>(p);\n```\n",
      "\n",
      "### ðŸ‘‡ Empfehlung:\n",
      "- Verwende **`static_cast` fÃ¼r fast alles**, wenn du den Typ kennst\n",
      "- **Vermeide `reinterpret_cast` und `C-Style`-Casts**, wenn mÃ¶glich\n",
      "- **Nutze `dynamic_cast` nur bei Vererbung**, sonst bringt es nichts\n",
      "- **Vermeide `const_cast`**, auÃŸer in SpezialfÃ¤llen\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\" << std::endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\" << std::endl; }\n};\n\nint main() {\n    double pi = 3.14;\n    int x = static_cast<int>(pi);               // static_cast: 3\n    std::cout << \"x: \" << x << std::endl;\n\n    Base* base = new Derived();\n    Derived* d = dynamic_cast<Derived*>(base);  // dynamic_cast: OK\n    if (d) d->show();                           // Ausgabe: Derived\n\n    const int a = 42;\n    int* b = const_cast<int*>(&a);              // const_cast: âš ï¸ gefÃ¤hrlich\n    std::cout << \"b: \" << *b << std::endl;\n\n    delete base;\n    return 0;\n}"
    ]
  }
},
      {
        "title": "Algorithmen",
        "content": {
          "text": [
            "### === STL-Algorithmen in C++ ===\n",
            "Die Standard Template Library (STL) bietet viele nÃ¼tzliche Algorithmen zur Bearbeitung von Containern wie `vector`, `set`, `map`, etc.\n",
            "\n",
            "### Wichtige Algorithmen:\n",
            "- `std::sort`: Sortiert Elemente (benÃ¶tigt `<algorithm>`)\n",
            "- `std::reverse`: Dreht die Reihenfolge um\n",
            "- `std::find`: Sucht ein bestimmtes Element\n",
            "- `std::count`: ZÃ¤hlt, wie oft ein bestimmter Wert vorkommt\n",
            "- `std::for_each`: FÃ¼hrt eine Funktion auf jedem Element aus\n",
            "- `std::remove`: Entfernt (logisch) ein Element â€“ mit `erase` kombinieren\n",
            "\n",
            "### Allgemein\n",
            "- Alle Algorithmen arbeiten mit **Iteratoren** (z.B. `begin()` / `end()`)\n",
            "- STL-Algorithmen verÃ¤ndern nicht den Container direkt (auÃŸer `sort`, `reverse`, etc.)\n",
            "- Viele Algorithmen nutzen **Lambdas** oder Funktionsobjekte\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // fÃ¼r sort, find, etc.\n\nint main() {\n  std::vector<int> zahlen = {4, 2, 7, 2, 9};\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end());\n\n  // ausgeben\n  std::cout << \"Sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \";\n  std::cout << std::endl; // Ausgabe: 2 2 4 7 9\n\n  // zÃ¤hlen\n  int anz = std::count(zahlen.begin(), zahlen.end(), 2);\n  std::cout << \"Die Zahl 2 kommt \" << anz << \" mal vor.\" << std::endl;\n\n  // suchen\n  auto it = std::find(zahlen.begin(), zahlen.end(), 7);\n  if (it != zahlen.end()) {\n    std::cout << \"7 gefunden an Position \" << (it - zahlen.begin()) << std::endl; //(it - zahlen.begin()) == Abstand im Container\n  }\n\n  // for_each mit Lambda\n  std::cout << \"Alle Werte verdoppelt: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x * 2 << \" \"; });\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Templates",
        "content": {
          "text": [
            "### === Templates in C++ ===\n",
            "Templates ermÃ¶glichen es, **generischen Code** zu schreiben, der mit beliebigen Datentypen funktioniert.\n",
            "\n",
            "### Warum Templates?\n",
            "- Wiederverwendbarkeit: gleiche Funktion/Klasse fÃ¼r viele Datentypen\n",
            "- FlexibilitÃ¤t: z.B. `int`, `double`, `std::string`, eigene Typen\n",
            "- Kein mehrfacher Code nÃ¶tig fÃ¼r unterschiedliche Typen\n",
            "\n",
            "### Funktions-Template\n",
            "```cpp\n template <typename T>\n T max(T a, T b) {\n   return (a > b) ? a : b;\n }\n```\n",
            "`T` ist ein Platzhalter fÃ¼r einen beliebigen Typ.\n",
            "Beim Aufruf wird automatisch der passende Typ eingesetzt (Typinferenz).\n",
            "\n",
            "### EinschrÃ¤nkung bei Operatoren\n",
            "Ein Funktions-Template wie `addiere(T a, T b)` funktioniert **nur, wenn fÃ¼r `T` der `+`-Operator definiert ist**.\n",
            "Beispiele, wo es funktioniert:\n",
            "- `int`, `double`, `std::string`\n",
            "Bei eigenen Typen (z.B. `struct Person`) musst du den `operator+` **selbst Ã¼berladen**, damit das Template funktioniert.\n",
            "\n",
            "### Klassen-Template\n",
            "```cpp\n template <typename T>\n class Box {\n   T inhalt;\n   // ...\n };\n```\n",
            "Auch Klassen lassen sich so fÃ¼r beliebige Typen definieren.\n",
            "\n### Typ muss bei Klassen-Templates immer angegeben werden\n",
            "Im Gegensatz zu Funktions-Templates kann der Compiler bei Klassen **nicht automatisch den Typ ableiten**.\n",
            "Du musst beim Erstellen eines Objekts **immer den gewÃ¼nschten Typ explizit angeben**:\n",
            "```cpp\nBehÃ¤lter<int> b(10);   // âœ… korrekt\nBehÃ¤lter b(10);        // âŒ Fehler â€“ Typ fehlt\n```\n",
            "Der Compiler kann aus den Konstruktorargumenten **nicht selbst schlieÃŸen**, welchen Typ `T` annehmen soll.\n",
            "\n",
            "### `typename` oder `class`?\n",
            "Beide Varianten sind bei Templates **gleichwertig** und funktionieren identisch:\n",
            "```cpp\ntemplate <typename T>   // bevorzugt in moderner C++-Schreibweise\ntemplate <class T>      // historisch hÃ¤ufiger verwendet\n```\n",
            "Du kannst die Variante frei wÃ¤hlen â€“ in modernen Projekten ist `typename` oft Ã¼blicher, weil es semantisch klarer ist.\n",
            "\n### Methoden auÃŸerhalb von Template-Klassen definieren\n",
            "Wenn eine Methode **auÃŸerhalb** einer Template-Klasse definiert wird, muss der Compiler genau wissen, dass auch die Methode ein Template ist.\n",
            "Dazu muss man:\n",
            "- die `template <typename T>`-Zeile **vor jeder Methode** wiederholen\n",
            "- beim Klassennamen den **Typparameter mit angeben**\n",
            "```cpp\n// Klassendeklaration\ntemplate <typename T>\nclass Complex {\n  T re();\n};\n\n// Methodendefinition auÃŸerhalb\ntemplate <typename T>\nT Complex<T>::re() {\n  // ...\n}\n```\n",
            "Ohne diese Angaben kann der Compiler die Funktion nicht korrekt zuordnen und meldet einen Fehler.\n",
                "\n### Templates und Dateiaufteilung\n",
            "Bei normalen Klassen ist es Ã¼blich, Deklaration und Definition auf `.h` und `.cpp` aufzuteilen.\n",
            "â†’ Bei Template-Klassen funktioniert das **nicht**, weil der Compiler beim Verwenden (z.â€¯B. `Complex<int>`) **alle Methoden kennen muss**.\n",
            "\n",
            "### LÃ¶sung: `.tpp`-Datei\n",
            "Um den Code trotzdem Ã¼bersichtlich zu halten, wird die Implementierung oft in eine `.tpp`-Datei ausgelagert.\n",
            "Diese wird **ausnahmsweise in der Header-Datei eingebunden**:\n",
            "```cpp\n// complex.h\n#ifndef COMPLEX_H\n#define COMPLEX_H\n\ntemplate <typename T>\nclass Complex {\n  // ...\n  T re();\n  T im();\n};\n\n#include \"complex.tpp\"  // Wichtig: im Header einbinden!\n\n#endif\n```\n",
            "```cpp\n// complex.tpp\ntemplate <typename T>\nT Complex<T>::re() { return re_; }\n\ntemplate <typename T>\nT Complex<T>::im() { return im_; }\n```\n",
            "So bleibt der Code sauber getrennt, aber der Compiler kann beim Instanziieren alle Definitionen sehen.\n",
            "\n### Statische Member in Template-Klassen\n",
            "Statische Variablen in Template-Klassen werden **fÃ¼r jede Typ-Instanziierung separat erzeugt**.\n",
            "Das bedeutet: `complex<int>` und `complex<long>` haben **unabhÃ¤ngige** eigene `counter_`-Werte.\n",
            "Will man statisch **typÃ¼bergreifend** zÃ¤hlen, muss man eine **globale Variable auÃŸerhalb** der Klasse verwenden.\n",
            "\n### Templates mit Wertparametern\n",
            "Templates kÃ¶nnen neben Typen auch **konstante Werte als Parameter** annehmen â€“ sogenannte **Nicht-Typ-Template-Parameter**.\n",
            "Diese werden wie normale Parameter in der Template-Liste angegeben, z.â€¯B. `int offset`:\n",
            "```cpp\ntemplate <typename T, int offset = 42>\nT shiftedMax(T x, T y) {\n  return offset + (x > y ? x : y);\n}\n```\n",
            "Aufrufbeispiele:\n",
            "- `shiftedMax<int, 10>(2, 3)` â†’ ergibt `13`\n",
            "- `shiftedMax<double>(2.0, 3.0)` â†’ ergibt `45.0` (Default-Offset 42)\n",
            "- `shiftedMax(2, 3)` â†’ ergibt `45` (Typ und Offset abgeleitet)\n",
            "\n",
            "ðŸ“Œ ZulÃ¤ssig sind nur **integrale Datentypen** wie `int`, `char`, `bool` oder `enum`.\n",
            "ðŸ‘‰ Integrale Datentypen sind alle **ganzzahligen Typen**, also ohne Nachkommastellen.\n",
            "FÃ¼r **jede Kombination von Typ und Wert** wird beim Kompilieren **neuer Code generiert**.\n",
                "\n### Template-Klassen mit Wert- und Typ-Defaults\n",
            "Auch Klassen-Templates kÃ¶nnen **konstante Wertparameter** enthalten â€“ z.â€¯B. zur Festlegung von Array-GrÃ¶ÃŸen.\n",
            "ZusÃ¤tzlich kÃ¶nnen **Standardwerte fÃ¼r Typen und Werte** angegeben werden:\n",
            "```cpp\ntemplate <class T = int, unsigned int size = 2>\nstruct my_array {\n  T data[size];\n};\n```\n",
            "Verwendung:\n",
            "- `my_array<> a;` â†’ ergibt `my_array<int, 2>`\n",
            "- `my_array<double> b;` â†’ ergibt `my_array<double, 2>`\n",
            "- `my_array<double, 10> c;` â†’ ergibt `my_array<double, 10>`\n",
            "\n",
            "ðŸ“Œ Der Wertparameter `size` muss ein **konstanter Ausdruck** sein, z.â€¯B. `unsigned int`.\n",
            "So lassen sich Klassen flexibel anpassen, ohne jedes Detail beim Aufruf anzugeben.\n",
"\n### Template-Template-Parameter\n",
            "Templates kÃ¶nnen auch **andere Templates als Parameter** annehmen. Das nennt man **Template-Template-Parameter** oder kurz: **Template-Templates**.\n",
            "\n",
            "Ein typisches Beispiel ist ein generischer Container-Wrapper:\n",
            "```cpp\ntemplate <class T,\n          template<typename, typename> class C,\n          template<typename> class A = std::allocator>\nclass container_wrapper {\n  C<T, A<T>> container;\npublic:\n  void insert(const T& t) { container.push_back(t); }\n  const T& get(unsigned int i) { return container[i]; }\n};\n```\n",
            "\n",
            "#### ðŸ” Was passiert hier?\n",
            "- `T` ist der Typ der Elemente, z.â€¯B. `int` oder `std::string`\n",
            "- `C` ist ein Container-Template wie `std::vector` oder `std::list`, das **zwei Typen erwartet** (`T`, `Allocator<T>`) â†’ deshalb `template<typename, typename>`\n",
            "- `A` ist der **Allocator**, also eine Speicherverwaltungsklasse, z.â€¯B. `std::allocator` (Standardwert)\n",
            "\n",
            "âž¡ï¸ Der Ausdruck `C<T, A<T>> container;` wird z.â€¯B. zu `std::vector<int, std::allocator<int>>`.\n",
            "\n",
            "#### âœ… Beispiel:\n",
            "```cpp\ncontainer_wrapper<std::string, std::vector> cw;\ncw.insert(\"Hello\");\nstd::cout << cw.get(0);  // Ausgabe: Hello\n```\n",
            "\n",
            "#### ðŸ“Œ Warum ist das so aufgebaut?\n",
            "- Container wie `std::vector` benÃ¶tigen zwei Parameter: den Datentyp und den Allocator\n",
            "- Deshalb muss `C` so definiert sein: `template<typename, typename>`\n",
            "- Der extra `A`-Parameter erlaubt es, den Allocator gezielt zu setzen oder den Standard zu verwenden\n",
            "\n",
            "ðŸ’¡ Ein **Allocator** kÃ¼mmert sich intern um die Speicherverwaltung â€“ in der Praxis brauchst du ihn meist nicht aktiv zu benutzen.\n",
            "\n",
            "Template-Template-Parameter sind ein mÃ¤chtiges Werkzeug fÃ¼r sehr flexible, generische Konstrukte â€“ aber sie kÃ¶nnen schnell komplex wirken.\n",
                "\n### AbhÃ¤ngige Typen und `typename`\n",
            "In Template-Klassen kÃ¶nnen auch **Typen auftreten, die vom Typparameter abhÃ¤ngen** â€“ z.â€¯B. `T*` oder `std::vector<T>::iterator`.\n",
            "Solche Typen nennt man **abhÃ¤ngige Typen** (*dependent types*), weil sie erst beim Instantiieren des Templates eindeutig sind.\n",
            "\n",
            "ðŸ“Œ Wichtig: Wenn du innerhalb eines Templates auf einen solchen abhÃ¤ngigen Typ zugreifst, **musst du `typename` davor schreiben`, damit der Compiler weiÃŸ, dass es sich um einen Typ handelt:\n",
            "```cpp\ntypename std::vector<T>::iterator iter;\n```\n",
            "Ohne `typename` denkt der Compiler eventuell, es handelt sich um ein Datenmitglied oder eine Funktion â€“ und gibt einen Fehler aus.\n",
                "\n### Vererbung mit Template-Klassen\n",
            "Template-Klassen kÃ¶nnen als **Basisklassen** in Vererbungshierarchien dienen.\n",
            "Sie eignen sich z.â€¯B. fÃ¼r generische Schnittstellen mit Memberfunktionen, die verschiedene Typen verarbeiten sollen.\n",
            "Wenn eine **nicht-template Unterklasse** davon ableitet, muss sie den **Typparameter festlegen**:\n",
            "```cpp\nclass add_double : invertible_operation<double> { ... };\n```\n",
            "So kann man z.â€¯B. mit einer Basisklasse `operation<T>` die Methode `T apply(T, T)` vorschreiben â€“ unabhÃ¤ngig vom konkreten Typ.\n",
            "Mit virtuellen oder rein virtuellen Methoden lassen sich dabei flexible, generische Interfaces bauen.\n",
                "\n### Template-Metaprogrammierung\n",
            "Templates kÃ¶nnen in C++ nicht nur fÃ¼r generischen Code verwendet werden â€“ man kann damit auch **Werte zur Compile-Zeit berechnen**. Das nennt man **Template-Metaprogrammierung**.\n",
            "\n",
            "Ein klassisches Beispiel ist die FakultÃ¤t (n!) als rekursive Template-Variable:\n",
            "```cpp\ntemplate<unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\n\ntemplate<>\nconstexpr unsigned long long factorial<0> = 1;\n```\n",
            "Diese Definition berechnet z.â€¯B. `factorial<5>` schon beim Ãœbersetzen als `120`.\n",
            "\n",
            "ÃœberprÃ¼fen lÃ¤sst sich das mit `static_assert`, das bei einem falschen Ergebnis einen Compilerfehler auslÃ¶st:\n",
            "```cpp\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n```\n",
            "Das Programm fÃ¼hrt diese Berechnung **nicht zur Laufzeit aus**, sondern ersetzt `factorial<5>` direkt mit dem Wert.\n",
                "\n### SFINAE mit `std::enable_if` (TypabhÃ¤ngige Spezialisierung)\n",
            "Mithilfe von `std::enable_if` und `type_traits` wie `std::is_integral` oder `std::is_floating_point` lassen sich **Funktionen gezielt nur fÃ¼r bestimmte Typen definieren**.\n",
            "Das funktioniert Ã¼ber das Prinzip **SFINAE** (Substitution Failure Is Not An Error): Wenn eine Typbedingung nicht zutrifft, wird die Funktion einfach ignoriert â€“ ohne Compilerfehler.\n",
            "\n",
            "Beispiel: Eine Funktion, die einen Wert mit 2â¿ multipliziert â€“ einmal fÃ¼r Ganzzahlen mit Bitshift, einmal fÃ¼r FlieÃŸkommazahlen mit `std::pow`:\n",
            "```cpp\n// fÃ¼r Ganzzahlen (schnell via Bitshift)\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\n\n// fÃ¼r Gleitkommazahlen\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n```\n",
            "Je nach Ã¼bergebenem Typ (`int` oder `double`) wird die passende Version der Funktion instanziiert.\n",
                "\n### Concepts (ab C++20)\n",
            "Templates kÃ¶nnen fehlschlagen, wenn bestimmte Operationen mit einem Typ nicht erlaubt sind â€“ z.â€¯B. wenn ein Typ nicht durchlaufbar ist oder kein `+=` unterstÃ¼tzt.\n",
            "Mit **Concepts** kann man diese Voraussetzungen **explizit machen**.\n",
            "\n",
            "Beispiel: Das Concept `Sequence` prÃ¼ft, ob ein Typ `.begin()` und `.end()` besitzt:\n",
            "```cpp\ntemplate<typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\n```\n",
            "Damit kann man eine Funktion nur fÃ¼r passende Typen zulassen:\n",
            "```cpp\ntemplate<Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n```\n",
            "Wenn ein ungeeigneter Typ Ã¼bergeben wird (z.â€¯B. ein String-Literal), gibt der Compiler eine **klare Fehlermeldung** â€“ z.â€¯B.:\n",
            "- `ERROR: constraints not satisfied: the required expression 's.begin()' is invalid`\n",
            "\n",
            "ðŸ“Œ Concepts helfen dabei, Templates **zu beschrÃ¤nken**, **Fehler verstÃ¤ndlicher zu machen** und sind eine moderne Alternative zu `std::enable_if` und `type_traits`.\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <array>\n#include <type_traits>\n#include <cmath>\n#include <string>\n#include <memory>\n#include <concepts>\n\n// === Funktions-Template ===\ntemplate <typename T>\nT maxValue(T a, T b) {\n  return (a > b) ? a : b;\n}\n\n// === Klassen-Template mit statischem Member ===\ntemplate <typename T>\nclass CounterBox {\npublic:\n  static int count;\n  T value;\n  CounterBox(T v) : value(v) { ++count; }\n};\ntemplate <typename T>\nint CounterBox<T>::count = 0;\n\n// === Template mit Wertparameter ===\ntemplate <typename T, int offset = 0>\nT shiftedMax(T a, T b) {\n  return offset + ((a > b) ? a : b);\n}\n\n// === Template-Klasse mit Typ- und Wert-Default ===\ntemplate <typename T = int, size_t N = 3>\nstruct MyArray {\n  T data[N];\n};\n\n// === Template-Template-Parameter ===\ntemplate <typename T, template<typename, typename> class Container, template<typename> class Alloc = std::allocator>\nclass ContainerWrapper {\n  Container<T, Alloc<T>> items;\npublic:\n  void add(const T& t) { items.push_back(t); }\n  const T& get(size_t i) { return items[i]; }\n};\n\n// === AbhÃ¤ngiger Typ mit typename ===\ntemplate <typename T>\nclass WithIterator {\npublic:\n  typename std::vector<T>::iterator it;\n};\n\n// === Vererbung mit Templates ===\ntemplate <typename T>\nclass Operation {\npublic:\n  virtual T apply(T, T) const = 0;\n};\ntemplate <typename T>\nclass InvertibleOperation : public Operation<T> {\npublic:\n  virtual T apply_inverse(T, T) const = 0;\n};\nclass AddDouble : public InvertibleOperation<double> {\npublic:\n  double apply(double a, double b) const override { return a + b; }\n  double apply_inverse(double a, double b) const override { return a - b; }\n};\n\n// === Template-Metaprogrammierung ===\ntemplate <unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\ntemplate <>\nconstexpr unsigned long long factorial<0> = 1;\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n\n// === SFINAE mit enable_if ===\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n\n// === Concepts ===\ntemplate <typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\ntemplate <Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n\nint main() {\n  std::cout << maxValue(4, 7) << std::endl;\n  CounterBox<int> a(1), b(2);\n  std::cout << \"Anzahl CounterBox<int>: \" << CounterBox<int>::count << std::endl;\n  std::cout << shiftedMax<int, 10>(3, 5) << std::endl;\n  MyArray<> arr1;\n  MyArray<double, 5> arr2;\n  ContainerWrapper<std::string, std::vector> cw;\n  cw.add(\"Hello\");\n  std::cout << cw.get(0) << std::endl;\n  AddDouble ad;\n  std::cout << ad.apply(3.5, 2.5) << \", \" << ad.apply_inverse(3.5, 2.5) << std::endl;\n  std::cout << multByPow2(2, 3) << \" | \" << multByPow2(0.5, 4) << std::endl;\n  std::vector<int> v = {1, 2, 3};\n  std::cout << accum(v, 0) << std::endl;\n  return 0;\n}"
          ]
        }
      },
            {
        "title": "Lambdas",
        "content": {
          "text": [
            "### === Lambda-AusdrÃ¼cke in C++ ===\n",
            "Ein Lambda ist eine **anonyme Funktion**, die direkt im Code definiert und z.B. an Algorithmen Ã¼bergeben werden kann.\n",
            "\n",
            "### Warum Lambdas?\n",
            "- Wenn man **kleine Funktionen nur einmalig** braucht (z.B. in `sort`, `for_each`), ist es **unnÃ¶tig**, extra eine benannte Funktion zu schreiben.\n",
            "- Lambdas machen den Code **kÃ¼rzer, klarer und direkt an Ort und Stelle**.\n",
            "- Sie lassen sich auch mit lokalen Variablen verknÃ¼pfen (Ã¼ber `[]`-Capture).\n",
            "\n",
            "### Syntax\n",
            "`[capture](parameter) -> rÃ¼ckgabetyp { body }`\n",
            "- `capture`: Welche Variablen von auÃŸen verwendet werden dÃ¼rfen (z.B. `[x]`, `[&]`, `[=]`, `[]`)\n",
            "- `parameter`: Ãœbergabeparameter wie bei normalen Funktionen\n",
            "- `rÃ¼ckgabetyp` ist optional (oft automatisch erkannt)\n",
            "\n",
            "### Beispiel â€“ einfache Lambda-Funktion\n",
            "`auto quadrat = [](int x) { return x * x; };`\n",
            "`quadrat(5); // ergibt 25`\n",
            "\n",
            "### Lambdas mit Algorithmen\n",
            "Sehr praktisch in Verbindung mit `std::for_each`, `std::sort`, usw.\n",
            "```cpp\n std::for_each(v.begin(), v.end(), [](int x){ std::cout << x << \" \"; });\n```\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // fÃ¼r for_each, sort\n\nint main() {\n  std::vector<int> zahlen = {5, 2, 8, 1};\n\n  // Lambda speichern und benutzen\n  auto quadrat = [](int x) { return x * x; };\n  std::cout << \"Quadrat von 4: \" << quadrat(4) << std::endl; // Ausgabe: 16\n\n  // for_each mit Lambda\n  std::cout << \"Zahlen: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x << \" \"; });\n  std::cout << std::endl;\n\n  // sortieren mit Lambda (absteigend)\n  std::sort(zahlen.begin(), zahlen.end(), [](int a, int b){ return a > b; });\n\n  std::cout << \"Absteigend sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \"; // Ausgabe: 8 5 2 1\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Exceptions",
        "content": {
          "text": [
            "### === Exceptions in C++ ===\n",
            "Exceptions (Ausnahmen) dienen der **kontrollierten Fehlerbehandlung** zur Laufzeit.\n",
            "Statt einen Fehler mit `if` zu prÃ¼fen, kann ein Fehler als Exception â€žgeworfenâ€œ werden und mit `try`/`catch` behandelt werden.\n",
            "\n",
            "### Warum Exceptions?\n",
            "- Trennen normalen Code von Fehlerbehandlung\n",
            "- Sorgen fÃ¼r sauberen und robusten Code\n",
            "- Besonders nÃ¼tzlich bei Funktionen, die fehlschlagen kÃ¶nnen (z.B. Datei Ã¶ffnen, Division durch 0, Eingabe prÃ¼fen)\n",
            "\n",
            "### Grundstruktur\n",
            "```cpp\n try {\n   // Code, der eine Ausnahme werfen kann\n } catch (Typ der Ausnahme) {\n   // Fehlerbehandlung\n }\n```\n",
            "-> Mit `throw` wirft man eine Ausnahme\n",
            "-> Mit `catch` fÃ¤ngt man sie ab\n",
            "\n",
            "### Typen\n",
            "- Beliebige Datentypen mÃ¶glich: `int`, `std::string`, eigene Klassen\n",
            "- Meist verwendet: `std::exception` (und Unterklassen wie `std::runtime_error`)\n",
            "\n",
            "### `ex.what()` erklÃ¤rt\n",
            "- Wenn du im `catch`-Block `std::exception& ex` abfÃ¤ngst, kannst du `ex.what()` aufrufen\n",
            "- `what()` gibt eine **Fehlermeldung als Text (const char\\*)** zurÃ¼ck\n",
            "- Beispiel:\n",
            "```cpp\n throw std::runtime_error(\"Fehler beim Laden der Datei\");\n // spÃ¤ter:\n catch (const std::exception& ex) {\n   std::cout << ex.what(); // Ausgabe: Fehler beim Laden der Datei\n }\n```\n",
            "- Eigene Klassen mÃ¼ssen `what()` selbst definieren, wenn du diesen Mechanismus nutzen willst\n"
          ],
          "code": [
            "#include <iostream>\n#include <stdexcept> // fÃ¼r std::runtime_error\n\nint teile(int a, int b) {\n  if (b == 0) {\n    throw std::runtime_error(\"Division durch 0 nicht erlaubt\");\n  }\n  return a / b;\n}",
            "int main() {\n  try {\n    int ergebnis = teile(10, 0);\n    std::cout << \"Ergebnis: \" << ergebnis << std::endl;\n  } catch (const std::exception& ex) {\n    std::cerr << \"Fehler: \" << ex.what() << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
       {
        "title": "Doxygen",
        "content": {
          "text": [
      "### === Doxygen â€“ Automatische Dokumentation fÃ¼r C++ ===\n",
      "Doxygen ist ein Tool, mit dem man aus speziell kommentiertem C++-Code automatisch eine HTML- oder PDF-Dokumentation erzeugen kann â€“ Ã¤hnlich wie Javadoc bei Java.\n",
      "\n",
      "### Vorteile von Doxygen:\n",
      "- Ãœbersichtliche Dokumentation fÃ¼r groÃŸe Projekte\n",
      "- Besseres VerstÃ¤ndnis fÃ¼r andere Entwickler (oder dich selbst spÃ¤ter)\n",
      "- Funktioniert direkt aus dem C++-Quellcode\n",
      "\n",
      "### Grundprinzip:\n",
      "- Man kommentiert Klassen, Funktionen, Variablen mit speziellen `/** ... */`- oder `///`-BlÃ¶cken\n",
      "- Doxygen liest diese Kommentare und erzeugt daraus eine strukturierte Dokumentation\n",
      "\n",
      "### Wichtige Doxygen-Kommentare:\n",
      "- `@brief`: Kurzbeschreibung\n",
      "- `@param`: Beschreibung eines Parameters\n",
      "- `@return`: RÃ¼ckgabewert\n",
      "- `@author`, `@version`, `@date`, ...\n",
      "\n",
      "### Beispiel fÃ¼r eine dokumentierte Funktion:\n",
      "```cpp\n/**\n * @brief Addiert zwei Zahlen\n * @param a Erste Zahl\n * @param b Zweite Zahl\n * @return Summe von a und b\n */\nint addiere(int a, int b) {\n    return a + b;\n}\n```\n",
      "\n",
      "### So benutzt du Doxygen:\n",
      "1. Lade dir Doxygen von https://www.doxygen.nl/download.html herunter\n",
      "2. Starte das Tool (`doxygen -g`) und bearbeite die `Doxyfile`\n",
      "3. FÃ¼ge deinen Projektpfad ein\n",
      "4. FÃ¼hre Doxygen aus: `doxygen Doxyfile`\n",
      "5. Dokumentation wird im `html/` oder `latex/`-Ordner erstellt\n",
      "\n",
      "ðŸ‘‰ Doxygen wird besonders im Beruf, in Open-Source-Projekten oder bei Bibliotheken verwendet\n",
      "ðŸ‘‰ Du kannst es auch lokal nutzen, um dein Projekt ordentlich zu strukturieren"
    ],
          "code": []
  }
}

    ]
  }
  
]

