[
  {
    "category": "Grundlagen",
    "icon": "üìò",
    "subcategories": [
      
      {
        "name": "Basics",
        "icon": "üìò",
        "topics": [
          {
          "title": "Namensgebung ",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Namensgebung",
              "text": "Namensgebung beschreibt die Regeln und Konventionen zur Benennung von Variablen, Funktionen, Klassen, Typen und anderen Bezeichnern in C++ mit dem Ziel, Code verst√§ndlich, wartbar und eindeutig zu machen."
            },
            {
              "type": "explanation",
              "title": "Warum Namensgebung wichtig ist",
              "text": [
                "C++ erlaubt sehr viele g√ºltige Bezeichner, aber nur ein kleiner Teil davon ist sinnvoll. Der Compiler pr√ºft nur die Syntax, nicht ob ein Name verst√§ndlich ist.",
                "Gute Namen transportieren Bedeutung, reduzieren Kommentare und helfen dabei, Fehler schneller zu erkennen. Schlechte Namen machen selbst korrekten Code schwer wartbar."
              ]
            },
            {
              "type": "list",
              "title": "Allgemeine Regeln f√ºr Bezeichner",
              "items": [
                "Bezeichner bestehen aus Buchstaben, Ziffern und Unterstrichen",
                "Ein Bezeichner darf nicht mit einer Ziffer beginnen",
                "Gro√ü und Kleinschreibung sind relevant",
                "Reservierte Schl√ºsselw√∂rter d√ºrfen nicht verwendet werden"
              ]
            },
            {
              "type": "comparison",
              "title": "Gro√ü und Kleinschreibung",
              "columns": ["Bezeichner", "Bedeutung"],
              "rows": [
                {
                  "aspect": "value vs Value",
                  "values": ["zwei verschiedene Namen", "Gro√üschreibung erzeugt einen anderen Bezeichner"]
                }
              ]
            },
            {
              "type": "explanation",
              "title": "√úbliche Namenskonventionen in C++",
              "text": [
                "C++ selbst erzwingt keine Namenskonventionen, aber in der Praxis haben sich feste Muster etabliert, um Code konsistent zu halten.",
                "Welche Konvention genutzt wird, h√§ngt oft vom Projekt, Team oder Styleguide ab, sollte aber innerhalb eines Projekts einheitlich sein."
              ]
            },
            {
              "type": "list",
              "title": "Typische Konventionen",
              "items": [
                "Variablen und Funktionen meist klein geschrieben",
                "Mehrteilige Namen werden oft mit Unterstrichen getrennt",
                "Klassen und Typen beginnen h√§ufig mit einem Gro√übuchstaben",
                "Konstanten werden oft komplett gro√ü geschrieben"
              ]
            },
            {
              "type": "code",
              "title": "Beispiele f√ºr g√ºltige Bezeichner",
              "language": "cpp",
              "code": "int age;\nint user_count;\nvoid calculateSum();\nclass PatientRecord {};\nconst int MAX_SIZE = 100;"
            },
            {
              "type": "example",
              "title": "Gute vs. schlechte Namen",
              "text": [
                "count ist besser als c",
                "calculateAverage ist besser als func1",
                "patient_age ist verst√§ndlicher als pa"
              ]
            },
            {
              "type": "pitfall",
              "title": "Mehrdeutige oder nichtssagende Namen",
              "text": "Kurze oder generische Namen wie x, tmp oder data sagen nichts √ºber ihre Bedeutung aus und f√ºhren schnell zu Verst√§ndnisproblemen."
            },
            {
              "type": "important",
              "text": "Ein guter Name erkl√§rt seine Bedeutung ohne zus√§tzlichen Kommentar."
            },
            {
              "type": "note",
              "variant": "modern_cpp",
              "text": "Moderne C++ Projekte legen gro√üen Wert auf sprechende Namen, da Code h√§ufiger gelesen als geschrieben wird."
            },
            {
              "type": "summary",
              "points": [
                "C++ erlaubt viele Namen, aber nicht jeder ist sinnvoll",
                "Gro√ü und Kleinschreibung unterscheidet Bezeichner",
                "Einheitliche Konventionen erh√∂hen Lesbarkeit",
                "Sprechende Namen sind wichtiger als kurze Namen"
              ]
            }
          ]
        },
          {
            "title": "Wichtige Grundbegriffe ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Deklaration",
                "text": "Macht einen Namen und seinen Typ bekannt, ohne ihn zwingend vollst√§ndig festzulegen. (z.B. `int x;`)"
              },
              {
                "type": "definition",
                "term": "Definition",
                "text": "Legt Speicher oder die konkrete Implementierung eines Namens fest. (z.B. `int x = 5;`)"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Vergibt beim Erzeugen einer Variable direkt einen Startwert."
              },
              {
                "type": "definition",
                "term": "Zuweisung",
                "text": "√Ñndert den Wert einer bereits existierenden Variable."
              },
              {
                "type": "definition",
                "term": "Variable",
                "text": "Ein benannter Speicherbereich zur Ablage von Daten."
              },
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Legt fest, welche Art von Wert gespeichert wird und wie viel Speicher ben√∂tigt wird."
              },
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "definition",
                "term": "Funktion",
                "text": "Ein benannter Codeblock, der eine bestimmte Aufgabe ausf√ºhrt."
              },
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Platzhalter in der Funktionsdefinition f√ºr √ºbergebene Werte."
              },
              {
                "type": "definition",
                "term": "Argument",
                "text": "Konkreter Wert, der beim Funktionsaufruf √ºbergeben wird."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Scope",
                "text": "Der G√ºltigkeitsbereich, in dem ein Name verwendet werden darf."
              },
              {
                "type": "definition",
                "term": "Block",
                "text": "Ein zusammengeh√∂riger Codebereich, der durch geschweifte Klammern begrenzt ist."
              },
              {
                "type": "definition",
                "term": "Namespace",
                "text": "Ein Namensraum zur Strukturierung und Vermeidung von Namenskonflikten."
              },
              {
                "type": "definition",
                "term": "Klasse",
                "text": "Ein Bauplan f√ºr Objekte, der Daten und Funktionen zusammenfasst."
              },
              {
                "type": "definition",
                "term": "Objekt",
                "text": "Eine konkrete Instanz einer Klasse."
              },
              {
                "type": "definition",
                "term": "Konstruktor",
                "text": "Spezielle Funktion, die beim Erzeugen eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Destruktor",
                "text": "Spezielle Funktion, die beim Zerst√∂ren eines Objekts aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Header-Datei",
                "text": "Datei, die Deklarationen f√ºr andere √úbersetzungseinheiten bereitstellt."
              },
              {
                "type": "definition",
                "term": "Quell-Datei",
                "text": "Datei, die die eigentlichen Definitionen und Implementierungen enth√§lt."
              },
              {
                "type": "important",
                "text": "Diese Begriffe bilden das Fundament zum Verstehen von C++ Code und Compiler-Fehlern."
              },
              {
                "type": "summary",
                "points": [
                  "Deklaration und Definition sind nicht dasselbe",
                  "Parameter geh√∂ren zur Funktion, Argumente zum Aufruf",
                  "Referenzen und Zeiger arbeiten beide mit bestehenden Objekten",
                  "Klassen definieren Strukturen, Objekte sind ihre Instanzen"
                ]
              }
            ]
          },
          {
            "title": "Datentypen ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Datentyp",
                "text": "Ein Datentyp legt fest, welche Art von Wert gespeichert wird und wie dieser interpretiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundlegende Datentypen",
                "text": [
                  "Grundlegende Datentypen sind fest in C++ eingebaut und bilden die Basis aller weiteren Typen.",
                  "Sie unterscheiden sich in Speicherbedarf, Wertebereich und Verwendungszweck."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige grundlegende Datentypen",
                "items": [
                  "int: Ganzzahltyp",
                  "double: Gleitkommazahl",
                  "char: Einzelnes Zeichen",
                  "bool: Wahrheitswert true oder false",
                  "void: Kein Wert"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Datentypen Beispiel",
                "language": "cpp",
                "code": "int a = 5;\ndouble b = 3.14;\nbool ok = true;"
              },
              {
                "type": "definition",
                "term": "size_t",
                "text": "Ein vorzeichenloser Ganzzahltyp zur Darstellung von Gr√∂√üen und Indizes."
              },
              {
                "type": "code",
                "title": "size_t Beispiel",
                "language": "cpp",
                "code": "size_t len = 10;"
              },
              {
                "type": "definition",
                "term": "std::string",
                "text": "Ein Standardtyp zur komfortablen Verarbeitung von Texten."
              },
              {
                "type": "code",
                "title": "std::string Beispiel",
                "language": "cpp",
                "code": "std::string name = \"C++\";"
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert f√ºr einen ung√ºltigen Zeiger."
              },
              {
                "type": "code",
                "title": "nullptr Beispiel",
                "language": "cpp",
                "code": "int* p = nullptr;"
              },
              {
                "type": "definition",
                "term": "auto",
                "text": "L√§sst den Compiler den Datentyp einer Variablen automatisch ableiten."
              },
              {
                "type": "code",
                "title": "auto Beispiel",
                "language": "cpp",
                "code": "auto x = 42;"
              },
              {
                "type": "definition",
                "term": "decltype",
                "text": "Ermittelt den Typ eines Ausdrucks, ohne ihn auszuwerten."
              },
              {
                "type": "code",
                "title": "decltype Beispiel",
                "language": "cpp",
                "code": "int a = 0;\ndecltype(a) b = 1;"
              },
              {
                "type": "definition",
                "term": "struct",
                "text": "Ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer Werte."
              },
              {
                "type": "definition",
                "term": "class",
                "text": "Ein benutzerdefinierter Datentyp mit Kapselung und Zugriffskontrolle."
              },
              {
                "type": "code",
                "title": "struct und class mit Funktionen",
                "language": "cpp",
                "code": "struct Point {\n    int x;\n    int y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n};\n\nclass Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n\n    int get() const {\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "enum",
                "text": "Ein Datentyp mit einer festen Menge benannter Ganzzahlwerte."
              },
              {
                "type": "code",
                "title": "enum Beispiel",
                "language": "cpp",
                "code": "enum Color { Red, Green, Blue };"
              },
              {
                "type": "definition",
                "term": "enum class",
                "text": "Stark typisierte Enumeration mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung zu int."
              },
              {
                "type": "code",
                "title": "enum class Beispiel",
                "language": "cpp",
                "code": "enum class Status { Ok, Error, Unknown };\n\nStatus s = Status::Ok;"
              },
              {
                "type": "definition",
                "term": "typedef",
                "text": "Erstellt einen Aliasnamen f√ºr einen bestehenden Datentyp."
              },
              {
                "type": "definition",
                "term": "using",
                "text": "Moderne Alternative zu typedef f√ºr Typaliasse."
              },
              {
                "type": "code",
                "title": "typedef und using Beispiel",
                "language": "cpp",
                "code": "typedef unsigned int uint;\nusing Index = size_t;"
              },
              {
                "type": "explanation",
                "title": "Typumwandlung in C++",
                "text": [
                  "Typumwandlungen werden verwendet, wenn ein Wert in einem anderen Datentyp weiterverarbeitet werden soll.",
                  "Explizite Casts wie static_cast sind sicherer und besser lesbar als implizite Umwandlungen."
                ]
              },
              {
                "type": "list",
                "title": "G√§ngige Cast-Arten",
                "items": [
                  "static_cast: normale, √ºberpr√ºfbare Umwandlungen",
                  "const_cast: Entfernen oder Hinzuf√ºgen von const",
                  "reinterpret_cast: bitweise Umdeutung, sehr gef√§hrlich",
                  "dynamic_cast: sichere Laufzeitpr√ºfung bei Vererbung"
                ]
              },
              {
                "type": "code",
                "title": "Typumwandlung Beispiel",
                "language": "cpp",
                "code": "double d = 4.9;\nint i = static_cast<int>(d);"
              },
              {
                "type": "important",
                "text": "Datentypen bestimmen Speicher, Verhalten und Sicherheit von C++ Programmen."
              },
              {
                "type": "summary",
                "points": [
                  "Grundlegende Typen bilden die Basis aller Programme",
                  "size_t, string und nullptr sind zentrale Standardtypen",
                  "auto und decltype vereinfachen typsicheren Code",
                  "struct, class und enum erlauben eigene Datentypen",
                  "using ersetzt typedef in modernem C++"
                ]
              }
            ]
          },
          {
            "title": "I/O Grundprinzipien",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "I/O",
                "text": "Input und Output bezeichnen das Einlesen von Daten in ein Programm und das Ausgeben von Daten nach au√üen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Ein und Ausgabe",
                "text": [
                  "C++ arbeitet bei Ein und Ausgabe mit sogenannten Streams. Ein Stream ist eine Abfolge von Zeichen oder Daten.",
                  "Programme lesen Daten aus einem Eingabestrom und schreiben Daten in einen Ausgabestrom."
                ]
              },
              {
                "type": "definition",
                "term": "Stream",
                "text": "Ein abstrakter Datenstrom, der Zeichen sequenziell transportiert."
              },
              {
                "type": "definition",
                "term": "Standard Input",
                "text": "Der voreingestellte Eingabestrom, meist die Tastatur."
              },
              {
                "type": "definition",
                "term": "Standard Output",
                "text": "Der voreingestellte Ausgabestrom, meist die Konsole."
              },
              {
                "type": "definition",
                "term": "Standard Error",
                "text": "Separater Ausgabestrom f√ºr Fehlermeldungen."
              },
              {
                "type": "list",
                "title": "Wichtige Standard-Streams",
                "items": [
                  "std::cin: Standardeingabe",
                  "std::cout: Standardausgabe",
                  "std::cerr: Fehlerausgabe",
                  "std::clog: Protokollausgabe"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe mit cout",
                "language": "cpp",
                "code": "std::cout << \"Hallo Welt\" << std::endl;"
              },
              {
                "type": "code",
                "title": "Einfache Eingabe mit cin",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;"
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Schreibt Daten in einen Ausgabestrom."
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Liest Daten aus einem Eingabestrom."
              },
              {
                "type": "explanation",
                "title": "Verkettung von Streams",
                "text": [
                  "Einf√ºge und Extraktionsoperatoren k√∂nnen verkettet werden.",
                  "Dadurch lassen sich mehrere Werte in einer Anweisung ein oder ausgeben."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Ein und Ausgabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b;\nstd::cout << a << \" \" << b;"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Zwischenspeicherung von Ausgaben, bevor sie tats√§chlich geschrieben werden."
              },
              {
                "type": "definition",
                "term": "Flush",
                "text": "Erzwingt das sofortige Schreiben des Ausgabepuffers."
              },
              {
                "type": "code",
                "title": "Flush Beispiel",
                "language": "cpp",
                "code": "std::cout << \"Text\" << std::flush;"
              },
              {
                "type": "pitfall",
                "title": "Eingabe ohne Pr√ºfung",
                "text": "Fehlerhafte Eingaben k√∂nnen Streams in einen Fehlerzustand versetzen und weitere Eingaben verhindern."
              },
              {
                "type": "important",
                "text": "I/O in C++ basiert auf Streams und Operatoren, nicht auf direkten Ger√§tezugriffen."
              },
              {
                "type": "summary",
                "points": [
                  "Ein und Ausgabe erfolgt √ºber Streams",
                  "cin, cout und cerr sind zentrale Standard-Streams",
                  "<< schreibt, >> liest",
                  "Streams k√∂nnen verkettet werden",
                  "Pufferung beeinflusst, wann Ausgaben sichtbar werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Operatoren",
        "icon": "‚ûï",
        "topics": [
          {
            "title": "Arithmetische Operatoren",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Arithmetischer Operator",
                "text": "Ein Operator zur Durchf√ºhrung mathematischer Berechnungen auf numerischen Datentypen."
              },
              {
                "type": "list",
                "title": "Grundlegende arithmetische Operatoren",
                "items": [
                  "+: Addition",
                  "-: Subtraktion",
                  "*: Multiplikation",
                  "/: Division",
                  "%: Modulo Restbildung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Operatoren Beispiel",
                "language": "cpp",
                "code": "int a = 10;\nint b = 3;\nint sum = a + b;\nint diff = a - b;\nint prod = a * b;\nint quot = a / b;\nint rest = a % b;"
              },
              {
                "type": "definition",
                "term": "Ganzzahldivision",
                "text": "Division zweier Ganzzahlen, bei der der Nachkommateil verworfen wird."
              },
              {
                "type": "code",
                "title": "Ganzzahldivision Beispiel",
                "language": "cpp",
                "code": "int x = 7 / 2;"
              },
              {
                "type": "definition",
                "term": "Modulo",
                "text": "Berechnet den Rest einer Ganzzahldivision."
              },
              {
                "type": "explanation",
                "title": "Inkrement und Dekrement",
                "text": [
                  "Inkrement und Dekrement erh√∂hen oder verringern einen Wert um eins.",
                  "Es wird zwischen Pr√§fix und Postfix unterschieden."
                ]
              },
              {
                "type": "list",
                "title": "Inkrement und Dekrement Operatoren",
                "items": [
                  "++x: Pr√§fix Inkrement",
                  "x++: Postfix Inkrement",
                  "--x: Pr√§fix Dekrement",
                  "x--: Postfix Dekrement"
                ]
              },
              {
                "type": "code",
                "title": "Inkrement und Dekrement Beispiel",
                "language": "cpp",
                "code": "int i = 5;\nint a = ++i;\nint b = i++;"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Legt fest, in welcher Reihenfolge Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Operatorpriorit√§t und Klammern",
                "text": [
                  "Multiplikation und Division werden vor Addition und Subtraktion ausgewertet.",
                  "Klammern k√∂nnen verwendet werden, um die Auswertungsreihenfolge explizit festzulegen."
                ]
              },
              {
                "type": "code",
                "title": "Operatorpriorit√§t Beispiel",
                "language": "cpp",
                "code": "int r1 = 2 + 3 * 4;\nint r2 = (2 + 3) * 4;"
              },
              {
                "type": "pitfall",
                "title": "Unerwartete Ganzzahldivision",
                "text": "Division mit int liefert kein Kommaergebnis, auch wenn das mathematisch erwartet wird."
              },
              {
                "type": "important",
                "text": "Der Datentyp der Operanden beeinflusst das Ergebnis arithmetischer Operationen."
              },
              {
                "type": "summary",
                "points": [
                  "Arithmetische Operatoren f√ºhren grundlegende Berechnungen aus",
                  "Ganzzahldivision verwirft den Nachkommateil",
                  "Modulo liefert den Divisionsrest",
                  "Inkrement und Dekrement unterscheiden Pr√§fix und Postfix",
                  "Klammern steuern die Auswertungsreihenfolge"
                ]
              }
            ]
          },
          {
            "title": "Vergleichsoperatoren ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Vergleichsoperator",
                "text": "Ein Operator, der zwei Werte vergleicht und einen booleschen Wert zur√ºckliefert."
              },
              {
                "type": "list",
                "title": "Grundlegende Vergleichsoperatoren",
                "items": [
                  "==: gleich",
                  "!=: ungleich",
                  "<: kleiner als",
                  ">: gr√∂√üer als",
                  "<=: kleiner oder gleich",
                  ">=: gr√∂√üer oder gleich"
                ]
              },
              {
                "type": "code",
                "title": "Vergleichsoperatoren Beispiel",
                "language": "cpp",
                "code": "int a = 5;\nint b = 7;\nbool r1 = (a == b);\nbool r2 = (a < b);"
              },
              {
                "type": "definition",
                "term": "bool",
                "text": "Ein Datentyp mit den m√∂glichen Werten true oder false."
              },
              {
                "type": "explanation",
                "title": "Vergleiche in Bedingungen",
                "text": [
                  "Vergleichsoperatoren werden h√§ufig in if Anweisungen und Schleifen verwendet.",
                  "Das Ergebnis entscheidet √ºber den weiteren Programmfluss."
                ]
              },
              {
                "type": "code",
                "title": "Vergleich in einer Bedingung",
                "language": "cpp",
                "code": "if (a >= 0)\n{\n    std::cout << \"positiv\";\n}"
              },
              {
                "type": "definition",
                "term": "Vergleich von Gleitkommazahlen",
                "text": "Der direkte Vergleich von Gleitkommazahlen kann wegen Rundungsfehlern problematisch sein."
              },
              {
                "type": "pitfall",
                "title": "== statt =",
                "text": "Das Verwechseln von Zuweisung und Vergleich f√ºhrt zu logischen Fehlern."
              },
              {
                "type": "important",
                "text": "Vergleichsoperatoren liefern immer einen booleschen Wert."
              },
              {
                "type": "summary",
                "points": [
                  "Vergleichsoperatoren pr√ºfen Beziehungen zwischen Werten",
                  "Das Ergebnis ist immer true oder false",
                  "Sie steuern Bedingungen und Schleifen",
                  "Besondere Vorsicht bei Gleitkommazahlen"
                ]
              }
            ]
          },
          {
            "title": "Logische Operatoren ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Logischer Operator",
                "text": "Ein Operator zur logischen Verkn√ºpfung oder Negation boolescher Ausdr√ºcke."
              },
              {
                "type": "list",
                "title": "Grundlegende logische Operatoren",
                "items": [
                  "&&: logisches UND",
                  "||: logisches ODER",
                  "!: logisches NICHT"
                ]
              },
              {
                "type": "code",
                "title": "Logische Operatoren Beispiel",
                "language": "cpp",
                "code": "bool a = true;\nbool b = false;\nbool r1 = a && b;\nbool r2 = a || b;\nbool r3 = !a;"
              },
              {
                "type": "definition",
                "term": "Kurzschlussauswertung",
                "text": "Der zweite Operand wird nur ausgewertet, wenn das Ergebnis noch beeinflusst werden kann."
              },
              {
                "type": "explanation",
                "title": "Kurzschlussverhalten",
                "text": [
                  "Bei && wird der zweite Ausdruck nur gepr√ºft, wenn der erste true ist.",
                  "Bei || wird der zweite Ausdruck nur gepr√ºft, wenn der erste false ist."
                ]
              },
              {
                "type": "code",
                "title": "Kurzschluss Beispiel",
                "language": "cpp",
                "code": "if (ptr != nullptr && ptr->value > 0)\n{\n}"
              },
              {
                "type": "definition",
                "term": "Operatorpriorit√§t",
                "text": "Bestimmt die Reihenfolge, in der logische Operatoren ausgewertet werden."
              },
              {
                "type": "explanation",
                "title": "Priorit√§t und Klammern",
                "text": [
                  "! wird vor && ausgewertet.",
                  "&& wird vor || ausgewertet. Klammern erh√∂hen die Lesbarkeit."
                ]
              },
              {
                "type": "code",
                "title": "Priorit√§t Beispiel",
                "language": "cpp",
                "code": "bool r = !a || b && a;\nbool r2 = (!a || b) && a;"
              },
              {
                "type": "pitfall",
                "title": "Bitweise mit logischen Operatoren verwechseln",
                "text": "& und | sind bitweise Operatoren und nicht gleichbedeutend mit && und ||."
              },
              {
                "type": "important",
                "text": "Logische Operatoren arbeiten mit booleschen Ausdr√ºcken und nutzen Kurzschlussauswertung."
              },
              {
                "type": "summary",
                "points": [
                  "&&, || und ! verkn√ºpfen boolesche Ausdr√ºcke",
                  "Kurzschlussauswertung verhindert unn√∂tige Auswertungen",
                  "Operatorpriorit√§t beachten oder Klammern setzen",
                  "Nicht mit bitweisen Operatoren verwechseln"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "const & constexpr",
        "icon": "üìò",
        "topics": [
          {
            "title": "const Variablen ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const",
                "text": "const kennzeichnet Werte oder Objekte, die nach ihrer Initialisierung nicht mehr ver√§ndert werden d√ºrfen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const",
                "text": [
                  "const dient dazu, unbeabsichtigte √Ñnderungen zu verhindern und Code verst√§ndlicher zu machen.",
                  "Der Compiler erzwingt die Unver√§nderlichkeit zur √úbersetzungszeit."
                ]
              },
              {
                "type": "code",
                "title": "const Variable",
                "language": "cpp",
                "code": "const int maxValue = 10;"
              },
              {
                "type": "definition",
                "term": "const Initialisierung",
                "text": "const Variablen m√ºssen beim Erzeugen initialisiert werden."
              },
              {
                "type": "pitfall",
                "title": "Fehlende Initialisierung",
                "text": "const Variablen ohne Initialisierung f√ºhren zu Compilerfehlern."
              },
              {
                "type": "definition",
                "term": "const Referenz",
                "text": "Eine Referenz, √ºber die das referenzierte Objekt nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenz Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nconst int& r = x;"
              },
              {
                "type": "definition",
                "term": "const Zeiger",
                "text": "Je nach Position von const kann der Zeiger selbst oder das Ziel unver√§nderlich sein."
              },
              {
                "type": "code",
                "title": "const und Zeiger",
                "language": "cpp",
                "code": "int x = 1;\nconst int* p1 = &x; // Zeiger auf konstante Daten\nint* const p2 = &x; // Konstanter Zeiger auf Daten\nconst int* const p3 = &x; // Beides konstant"
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die den Zustand des Objekts nicht ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "const Memberfunktion Beispiel",
                "language": "cpp",
                "code": "class A {\n    int v;\npublic:\n    int get() const { return v; }\n};"
              },
              {
                "type": "important",
                "text": "const ist ein zentrales Werkzeug f√ºr sicheren und gut wartbaren C++ Code."
              },
              {
                "type": "summary",
                "points": [
                  "const verhindert unbeabsichtigte √Ñnderungen",
                  "const Variablen m√ºssen initialisiert werden",
                  "const kann auf Objekte, Referenzen, Zeiger und Funktionen angewendet werden",
                  "const Memberfunktionen garantieren unver√§nderten Objektzustand"
                ]
              }
            ]
          },
          {
            "title": "const Parameter ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Parameter",
                "text": "Ein Funktionsparameter, der innerhalb der Funktion nicht ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Warum const Parameter verwenden",
                "text": [
                  "const Parameter verhindern unbeabsichtigte √Ñnderungen an √ºbergebenen Werten.",
                  "Sie machen Funktionsschnittstellen klarer und sicherer, besonders bei Referenzen und Zeigern."
                ]
              },
              {
                "type": "code",
                "title": "const Wertparameter",
                "language": "cpp",
                "code": "void print(const int x)\n{\n    // x darf hier nicht ver√§ndert werden\n    // x = 5; // Compilerfehler\n}"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Parameter, der per Referenz √ºbergeben wird, aber nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter Beispiel",
                "language": "cpp",
                "code": "void print(const std::string& text)\n{\n    // text wird nicht kopiert\n    // text.clear(); // Compilerfehler\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Vorteile von const Referenzen",
                "text": [
                  "Vermeidet unn√∂tige Kopien gro√üer Objekte.",
                  "Garantiert, dass die Funktion das Objekt nicht ver√§ndert."
                ]
              },
              {
                "type": "definition",
                "term": "const Zeigerparameter",
                "text": "Bei Zeigerparametern kann entweder das Ziel oder der Zeiger selbst als const markiert werden."
              },
              {
                "type": "code",
                "title": "const Zeigerparameter Beispiel",
                "language": "cpp",
                "code": "void read(const int* ptr)\n{\n    // *ptr darf nicht ver√§ndert werden\n    // *ptr = 10; // Compilerfehler\n}\n\nvoid move(int* const ptr)\n{\n    // ptr darf nicht neu gesetzt werden\n    // ptr = nullptr; // Compilerfehler\n}"
              },
              {
                "type": "pitfall",
                "title": "const vergessen",
                "text": "Fehlendes const bei Parametern kann unn√∂tige Einschr√§nkungen f√ºr Aufrufer verursachen."
              },
              {
                "type": "important",
                "text": "const Parameter sind ein Versprechen der Funktion an den Aufrufer."
              },
              {
                "type": "summary",
                "points": [
                  "const Parameter verhindern √Ñnderungen innerhalb der Funktion",
                  "const Referenzen sind effizient und sicher",
                  "Bei Zeigern bestimmt die Position von const die Bedeutung",
                  "const verbessert Lesbarkeit und API Design"
                ]
              }
            ]
          },
          {
            "title": "const Klassenmember ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const Klassenmember",
                "text": "Ein Datenmember einer Klasse, dessen Wert nach der Initialisierung nicht mehr ver√§ndert werden darf."
              },
              {
                "type": "explanation",
                "title": "Grundidee von const Membern",
                "text": [
                  "const Member repr√§sentieren feste Eigenschaften eines Objekts, die sich w√§hrend der Lebensdauer nicht √§ndern sollen.",
                  "Der Compiler erzwingt, dass diese Member nicht neu zugewiesen werden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierungsliste",
                "text": "Mechanismus zum Initialisieren von Klassenmembern beim Erzeugen eines Objekts."
              },
              {
                "type": "code",
                "title": "const Member und Initialisierungsliste",
                "language": "cpp",
                "code": "class User {\nprivate:\n    const int id; // darf nach Konstruktion nicht ge√§ndert werden\n\npublic:\n    User(int idValue) : id(idValue) {}\n\n    int getId() const {\n        return id; // Lesen erlaubt\n    }\n};"
              },
              {
                "type": "pitfall",
                "title": "Zuweisung im Konstruktor",
                "text": "const Member k√∂nnen nicht im Konstruktorrumpf zugewiesen werden, sondern nur in der Initialisierungsliste."
              },
              {
                "type": "definition",
                "term": "const Memberfunktion",
                "text": "Eine Memberfunktion, die garantiert, dass sie keine nicht-const Member ver√§ndert."
              },
              {
                "type": "code",
                "title": "const Memberfunktion und Zugriff",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    Counter() : value(0) {}\n\n    int get() const {\n        // value++;\n        // nicht erlaubt, da Funktion const ist\n        return value;\n    }\n\n    void increment() {\n        value++; // erlaubt, Funktion ist nicht const\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Zusammenspiel von const Membern und Funktionen",
                "text": [
                  "const Memberfunktionen d√ºrfen nur const Member oder lesenden Zugriff verwenden.",
                  "Nicht-const Memberfunktionen d√ºrfen alle Member ver√§ndern."
                ]
              },
              {
                "type": "important",
                "text": "const Member m√ºssen immer √ºber die Initialisierungsliste gesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "const Klassenmember sind nach der Konstruktion unver√§nderlich",
                  "Sie m√ºssen in der Initialisierungsliste gesetzt werden",
                  "const Memberfunktionen d√ºrfen den Objektzustand nicht √§ndern",
                  "const verbessert Korrektheit und Objektmodellierung"
                ]
              }
            ]
          },
          {
            "title": "const √úberladung ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "const √úberladung",
                "text": "Eine Form der Funktions√ºberladung, bei der sich Funktionen nur durch const unterscheiden."
              },
              {
                "type": "explanation",
                "title": "Grundidee der const √úberladung",
                "text": [
                  "const √úberladung wird fast ausschlie√ülich bei Memberfunktionen verwendet.",
                  "Je nach const Zustand des Objekts wird eine andere Funktionsversion aufgerufen."
                ]
              },
              {
                "type": "definition",
                "term": "const Objekt",
                "text": "Ein Objekt, das als const deklariert wurde und nur const Memberfunktionen aufrufen darf."
              },
              {
                "type": "code",
                "title": "const √úberladung bei Memberfunktionen",
                "language": "cpp",
                "code": "class Box {\nprivate:\n    int value;\n\npublic:\n    Box(int v) : value(v) {}\n\n    int& get() {\n        // wird bei nicht-const Objekten aufgerufen\n        return value;\n    }\n\n    const int& get() const {\n        // wird bei const Objekten aufgerufen\n        return value;\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Bei einem nicht-const Objekt wird die nicht-const Version bevorzugt.",
                  "Bei einem const Objekt ist nur die const Version erlaubt."
                ]
              },
              {
                "type": "code",
                "title": "Aufruf der √ºberladenen Funktionen",
                "language": "cpp",
                "code": "Box b(5);\nb.get() = 10; // erlaubt, nicht-const Version\n\nconst Box cb(7);\nint x = cb.get(); // nur const Version m√∂glich"
              },
              {
                "type": "pitfall",
                "title": "Fehlende const Version",
                "text": "Ohne const √ºberladene Memberfunktion k√∂nnen const Objekte wichtige Funktionen nicht nutzen."
              },
              {
                "type": "important",
                "text": "const √úberladung erh√∂ht Korrektheit und Flexibilit√§t von Klassen."
              },
              {
                "type": "summary",
                "points": [
                  "const √úberladung unterscheidet Funktionen nach const",
                  "Sie wird haupts√§chlich bei Memberfunktionen eingesetzt",
                  "const Objekte d√ºrfen nur const Funktionen aufrufen",
                  "Nicht-const Objekte nutzen bevorzugt nicht-const Versionen"
                ]
              }
            ]
          },
          {
            "title": "constexpr ",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "constexpr",
                "text": "constexpr kennzeichnet Ausdr√ºcke, Variablen oder Funktionen, die zur Compilezeit ausgewertet werden k√∂nnen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von constexpr",
                "text": [
                  "constexpr erm√∂glicht es, Berechnungen bereits zur Compilezeit durchzuf√ºhren.",
                  "Dadurch werden Programme effizienter und sicherer, da Fehler fr√ºher erkannt werden."
                ]
              },
              {
                "type": "definition",
                "term": "constexpr Variable",
                "text": "Eine Variable, deren Wert zur Compilezeit bekannt sein muss."
              },
              {
                "type": "code",
                "title": "constexpr Variable Beispiel",
                "language": "cpp",
                "code": "constexpr int maxSize = 100; // Wert ist zur Compilezeit festgelegt"
              },
              {
                "type": "definition",
                "term": "constexpr Funktion",
                "text": "Eine Funktion, die bei konstanten Argumenten zur Compilezeit ausgewertet werden kann."
              },
              {
                "type": "code",
                "title": "constexpr Funktion Beispiel",
                "language": "cpp",
                "code": "constexpr int square(int x)\n{\n    return x * x;\n}\n\nconstexpr int value = square(5); // Compilezeit"
              },
              {
                "type": "explanation",
                "title": "Compilezeit vs. Laufzeit",
                "text": [
                  "constexpr Funktionen k√∂nnen sowohl zur Compilezeit als auch zur Laufzeit ausgef√ºhrt werden.",
                  "Ob Compilezeit oder Laufzeit entscheidet der Kontext der Verwendung."
                ]
              },
              {
                "type": "code",
                "title": "constexpr zur Laufzeit",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x;\nint y = square(x); // Laufzeit, da x nicht konstant ist"
              },
              {
                "type": "comparison",
                "title": "const vs. constexpr",
                "columns": ["const", "constexpr"],
                "rows": [
                  {
                    "aspect": "Zeitpunkt der Auswertung",
                    "values": ["Laufzeit oder Compilezeit", "Immer Compilezeit m√∂glich"]
                  },
                  {
                    "aspect": "Einsatz",
                    "values": ["Unver√§nderlichkeit", "Konstante Ausdr√ºcke"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "constexpr mit nicht-konstanten Werten",
                "text": "constexpr erfordert zur Compilezeit bekannte Werte, sonst schl√§gt die √úbersetzung fehl."
              },
              {
                "type": "important",
                "text": "constexpr ist st√§rker als const und erm√∂glicht echte Compilezeit-Berechnungen."
              },
              {
                "type": "summary",
                "points": [
                  "constexpr erzwingt Compilezeit-Auswertbarkeit",
                  "constexpr Variablen sind echte Konstanten",
                  "constexpr Funktionen k√∂nnen auch zur Laufzeit genutzt werden",
                  "constexpr erh√∂ht Effizienz und Typsicherheit"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Ein- und Ausgabe",
    "icon": "‚å®Ô∏è",
    "subcategories": [
      {
        "name": "Standard Streams",
        "icon": "‚å®Ô∏è",
        "topics": [
          {
            "title": "std::cout",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cout",
                "text": "std::cout ist der Standard-Ausgabestream in C++ zur Ausgabe von Text und Werten auf die Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cout",
                "text": [
                  "std::cout schreibt Daten in den Standard-Output, der in der Regel das Terminal ist.",
                  "Die Ausgabe erfolgt √ºber den Einf√ºgeoperator << und kann verkettet werden."
                ]
              },
              {
                "type": "definition",
                "term": "Einf√ºgeoperator <<",
                "text": "Operator, mit dem Werte in einen Ausgabestream geschrieben werden."
              },
              {
                "type": "code",
                "title": "Einfache Ausgabe",
                "language": "cpp",
                "code": "int x = 5;\nstd::cout << x; // gibt 5 auf der Konsole aus"
              },
              {
                "type": "explanation",
                "title": "Verkettete Ausgabe",
                "text": [
                  "Mehrere Werte k√∂nnen hintereinander ausgegeben werden.",
                  "Die Operatoren werden von links nach rechts ausgewertet."
                ]
              },
              {
                "type": "code",
                "title": "Verkettung mit Text",
                "language": "cpp",
                "code": "int a = 3;\nint b = 4;\nstd::cout << \"a = \" << a << \", b = \" << b; // kombinierte Ausgabe"
              },
              {
                "type": "definition",
                "term": "std::endl",
                "text": "Gibt einen Zeilenumbruch aus und leert zus√§tzlich den Ausgabepuffer."
              },
              {
                "type": "code",
                "title": "Zeilenumbruch",
                "language": "cpp",
                "code": "std::cout << \"Hallo\" << std::endl; // neue Zeile und flush"
              },
              {
                "type": "definition",
                "term": "Pufferung",
                "text": "Ausgaben werden zwischengespeichert und nicht sofort angezeigt."
              },
              {
                "type": "comparison",
                "title": "std::endl vs. '\\n'",
                "columns": ["std::endl", "\\n"],
                "rows": [
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Ja", "Ja"]
                  },
                  {
                    "aspect": "Flush",
                    "values": ["Ja", "Nein"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Unn√∂tiger Einsatz von std::endl",
                "text": "H√§ufiges std::endl kann Programme deutlich verlangsamen, da jedes Mal geflusht wird."
              },
              {
                "type": "important",
                "text": "std::cout ist ein gepufferter Stream und arbeitet mit dem Operator <<."
              },
              {
                "type": "summary",
                "points": [
                  "std::cout dient zur Standardausgabe",
                  "Ausgabe erfolgt mit dem Operator <<",
                  "Mehrere Ausgaben k√∂nnen verkettet werden",
                  "std::endl erzeugt Zeilenumbruch und Flush",
                  "\\n ist meist effizienter als std::endl"
                ]
              }
            ]
          },
          {
            "title": "std::cin",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::cin",
                "text": "std::cin ist der Standard-Eingabestream in C++ zum Einlesen von Daten aus der Konsole."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::cin",
                "text": [
                  "std::cin liest Daten aus dem Standard-Input, meist der Tastatur.",
                  "Das Einlesen erfolgt mit dem Extraktionsoperator >> und ist typabh√§ngig."
                ]
              },
              {
                "type": "definition",
                "term": "Extraktionsoperator >>",
                "text": "Operator, mit dem Werte aus einem Eingabestream gelesen werden."
              },
              {
                "type": "code",
                "title": "Einfache Eingabe",
                "language": "cpp",
                "code": "int x;\nstd::cin >> x; // liest eine Ganzzahl von der Konsole"
              },
              {
                "type": "explanation",
                "title": "Mehrere Werte einlesen",
                "text": [
                  "Mehrere Eingaben k√∂nnen in einer Anweisung verkettet werden.",
                  "Die Werte werden in der angegebenen Reihenfolge gelesen."
                ]
              },
              {
                "type": "code",
                "title": "Verkettete Eingabe",
                "language": "cpp",
                "code": "int a, b;\nstd::cin >> a >> b; // liest zwei Ganzzahlen"
              },
              {
                "type": "definition",
                "term": "Whitespace-Verhalten",
                "text": "std::cin √ºberspringt f√ºhrende Leerzeichen, Tabs und Zeilenumbr√ºche."
              },
              {
                "type": "code",
                "title": "Eingabe von Text",
                "language": "cpp",
                "code": "std::string name;\nstd::cin >> name; // liest bis zum n√§chsten Leerzeichen"
              },
              {
                "type": "definition",
                "term": "Stream-Zustand",
                "text": "Interner Status eines Streams, der angibt, ob die letzte Eingabe erfolgreich war."
              },
              {
                "type": "code",
                "title": "Eingabe pr√ºfen",
                "language": "cpp",
                "code": "int value;\nif (std::cin >> value) {\n    // Eingabe war erfolgreich\n}"
              },
              {
                "type": "pitfall",
                "title": "Fehlerhafte Eingaben",
                "text": "Ung√ºltige Eingaben setzen den Stream in einen Fehlerzustand und blockieren weitere Lesevorg√§nge."
              },
              {
                "type": "important",
                "text": "std::cin ist typabh√§ngig und nutzt den Operator >> zum Einlesen."
              },
              {
                "type": "summary",
                "points": [
                  "std::cin liest Daten von der Konsole",
                  "Eingabe erfolgt mit dem Operator >>",
                  "Whitespace wird automatisch √ºbersprungen",
                  "Der Stream-Zustand sollte gepr√ºft werden",
                  "Ung√ºltige Eingaben k√∂nnen weitere Eingaben verhindern"
                ]
              }
            ]
          },
          {
            "title": "std::getline",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::getline",
                "text": "std::getline liest eine komplette Zeile aus einem Eingabestream bis zum Zeilenumbruch."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::getline",
                "text": [
                  "std::getline eignet sich zum Einlesen von Texten mit Leerzeichen.",
                  "Der Zeilenumbruch wird gelesen, aber nicht im Ergebnis gespeichert."
                ]
              },
              {
                "type": "definition",
                "term": "Zeilenweises Einlesen",
                "text": "Einleseform, bei der der gesamte Inhalt bis zum Zeilenende √ºbernommen wird."
              },
              {
                "type": "code",
                "title": "Einfache Verwendung von std::getline",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(std::cin, line); // liest eine komplette Zeile"
              },
              {
                "type": "explanation",
                "title": "Unterschied zu std::cin >>",
                "text": [
                  "std::cin >> liest nur bis zum n√§chsten Leerzeichen.",
                  "std::getline liest die gesamte Zeile inklusive Leerzeichen."
                ]
              },
              {
                "type": "comparison",
                "title": "std::getline vs. std::cin >>",
                "columns": ["std::getline", "std::cin >>"],
                "rows": [
                  {
                    "aspect": "Leerzeichen",
                    "values": ["Werden mitgelesen", "Beenden die Eingabe"]
                  },
                  {
                    "aspect": "Zeilenumbruch",
                    "values": ["Beendet das Lesen", "Wird √ºbersprungen"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "std::getline nach std::cin >>",
                "text": "Nach einer >> Eingabe bleibt der Zeilenumbruch im Stream und wird von getline sofort gelesen."
              },
              {
                "type": "code",
                "title": "Korrekte Kombination von cin und getline",
                "language": "cpp",
                "code": "int age;\nstd::cin >> age;\nstd::cin.ignore(); // entfernt den Zeilenumbruch\n\nstd::string name;\nstd::getline(std::cin, name); // liest den Namen korrekt"
              },
              {
                "type": "important",
                "text": "std::getline ist die richtige Wahl f√ºr ganze Textzeilen."
              },
              {
                "type": "summary",
                "points": [
                  "std::getline liest komplette Zeilen",
                  "Leerzeichen sind Teil der Eingabe",
                  "Unterschiedliches Verhalten zu std::cin >>",
                  "Nach >> muss oft ignore verwendet werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Dateien",
        "icon": "üóÇÔ∏è",
        "topics": [
          {
            "title": "std::ifstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ifstream",
                "text": "std::ifstream ist ein Eingabestream zum Lesen von Daten aus Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ifstream",
                "text": [
                  "std::ifstream funktioniert √§hnlich wie std::cin, liest seine Daten aber aus einer Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Input verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Dateistream",
                "text": "Ein Stream, der Daten aus einer Datei liest oder in eine Datei schreibt."
              },
              {
                "type": "code",
                "title": "Datei √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ifstream file(\"data.txt\"); // √∂ffnet Datei zum Lesen"
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "√ñffnen pr√ºfen",
                "language": "cpp",
                "code": "std::ifstream file(\"data.txt\");\nif (!file) {\n    // Datei konnte nicht ge√∂ffnet werden\n}"
              },
              {
                "type": "explanation",
                "title": "Lesen aus einer Datei",
                "text": [
                  "Das Lesen aus ifstream erfolgt mit denselben Operatoren wie bei std::cin.",
                  "Auch std::getline kann f√ºr zeilenweises Lesen verwendet werden."
                ]
              },
              {
                "type": "code",
                "title": "Lesen mit >>",
                "language": "cpp",
                "code": "int x;\nfile >> x; // liest eine Ganzzahl aus der Datei"
              },
              {
                "type": "code",
                "title": "Zeilenweise lesen",
                "language": "cpp",
                "code": "std::string line;\nstd::getline(file, line); // liest eine Zeile aus der Datei"
              },
              {
                "type": "definition",
                "term": "End of File",
                "text": "Zustand, der erreicht wird, wenn keine weiteren Daten in der Datei vorhanden sind."
              },
              {
                "type": "code",
                "title": "Lesen bis Dateiende",
                "language": "cpp",
                "code": "std::string line;\nwhile (std::getline(file, line)) {\n    // verarbeitet jede Zeile der Datei\n}"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der √ñffnungszustand nicht gepr√ºft, kann es zu undefiniertem Programmverhalten kommen."
              },
              {
                "type": "important",
                "text": "std::ifstream sollte immer auf erfolgreiches √ñffnen gepr√ºft werden."
              },
              {
                "type": "summary",
                "points": [
                  "std::ifstream liest Daten aus Dateien",
                  "Er wird √ºber <fstream> eingebunden",
                  "Lesen erfolgt wie bei std::cin",
                  "std::getline eignet sich f√ºr zeilenweises Lesen",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::ofstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::ofstream",
                "text": "std::ofstream ist ein Ausgabestream zum Schreiben von Daten in Dateien."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::ofstream",
                "text": [
                  "std::ofstream funktioniert √§hnlich wie std::cout, schreibt seine Ausgabe aber in eine Datei.",
                  "Er geh√∂rt zur Standardbibliothek <fstream> und wird f√ºr dateibasierten Output verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Datei √∂ffnen",
                "text": "Der Vorgang, bei dem eine Datei zum Schreiben mit einem Stream verbunden wird."
              },
              {
                "type": "code",
                "title": "Datei zum Schreiben √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::ofstream file(\"output.txt\"); // erstellt oder √ºberschreibt die Datei"
              },
              {
                "type": "definition",
                "term": "√úberschreiben",
                "text": "Standardverhalten von ofstream, bei dem vorhandene Dateiinhalte gel√∂scht werden."
              },
              {
                "type": "definition",
                "term": "Anh√§ngen",
                "text": "Schreiben neuer Daten ans Ende einer bestehenden Datei."
              },
              {
                "type": "code",
                "title": "Dateiinhalt anh√§ngen",
                "language": "cpp",
                "code": "std::ofstream file(\"output.txt\", std::ios::app); // schreibt ans Dateiende"
              },
              {
                "type": "explanation",
                "title": "Schreiben in eine Datei",
                "text": [
                  "Das Schreiben erfolgt mit dem Einf√ºgeoperator << wie bei std::cout.",
                  "Es k√∂nnen beliebige ausgabef√§hige Datentypen geschrieben werden."
                ]
              },
              {
                "type": "code",
                "title": "Schreiben mit <<",
                "language": "cpp",
                "code": "file << \"Ergebnis: \" << 42 << '\\n'; // schreibt Text und Zahl in die Datei"
              },
              {
                "type": "definition",
                "term": "Datei schlie√üen",
                "text": "Beendet die Verbindung zwischen Stream und Datei und schreibt den Puffer."
              },
              {
                "type": "code",
                "title": "Datei schlie√üen",
                "language": "cpp",
                "code": "file.close(); // optional, erfolgt auch automatisch"
              },
              {
                "type": "pitfall",
                "title": "Datei nicht pr√ºfen",
                "text": "Wird der Stream nicht gepr√ºft, kann das Schreiben fehlschlagen, ohne dass es bemerkt wird."
              },
              {
                "type": "important",
                "text": "std::ofstream √ºberschreibt Dateien standardm√§√üig, wenn kein Modus angegeben wird."
              },
              {
                "type": "summary",
                "points": [
                  "std::ofstream schreibt Daten in Dateien",
                  "Standardm√§√üig wird die Datei √ºberschrieben",
                  "Anh√§ngen erfolgt mit std::ios::app",
                  "Schreiben erfolgt mit dem Operator <<",
                  "Streams sollten auf Fehler gepr√ºft werden"
                ]
              }
            ]
          },
          {
            "title": "std::fstream",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::fstream",
                "text": "std::fstream ist ein Dateistream, der sowohl Lesen als auch Schreiben in einer Datei erlaubt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::fstream",
                "text": [
                  "std::fstream kombiniert die Funktionalit√§t von std::ifstream und std::ofstream.",
                  "Er wird verwendet, wenn eine Datei sowohl gelesen als auch beschrieben werden soll."
                ]
              },
              {
                "type": "definition",
                "term": "√ñffnungsmodus",
                "text": "Ein Modus, der festlegt, wie eine Datei ge√∂ffnet wird, zum Beispiel zum Lesen oder Schreiben."
              },
              {
                "type": "list",
                "title": "H√§ufige √ñffnungsmodi",
                "items": [
                  "std::ios::in: Datei lesen",
                  "std::ios::out: Datei schreiben",
                  "std::ios::app: ans Dateiende schreiben",
                  "std::ios::trunc: Dateiinhalt l√∂schen",
                  "std::ios::binary: Bin√§rmodus"
                ]
              },
              {
                "type": "code",
                "title": "Datei mit fstream √∂ffnen",
                "language": "cpp",
                "code": "#include <fstream>\n\nstd::fstream file(\"data.txt\", std::ios::in | std::ios::out);"
              },
              {
                "type": "definition",
                "term": "Lese- und Schreibzugriff",
                "text": "Die M√∂glichkeit, Daten aus derselben Datei zu lesen und in sie zu schreiben."
              },
              {
                "type": "code",
                "title": "Lesen und Schreiben",
                "language": "cpp",
                "code": "int x;\nfile >> x;          // liest aus der Datei\nfile << x * 2;      // schreibt in die Datei"
              },
              {
                "type": "definition",
                "term": "Dateiposition",
                "text": "Die aktuelle Lese- oder Schreibposition innerhalb der Datei."
              },
              {
                "type": "explanation",
                "title": "Dateiposition und Zeiger",
                "text": [
                  "fstream besitzt einen Lesezeiger und einen Schreibzeiger.",
                  "Diese k√∂nnen unabh√§ngig voneinander verschoben werden."
                ]
              },
              {
                "type": "explanation",
                "title": "Was ist die Dateiposition",
                "text": [
                  "Die Dateiposition beschreibt die aktuelle Stelle in der Datei, an der gelesen oder geschrieben wird.",
                  "Bei std::fstream gibt es getrennte Positionen f√ºr Lesen und Schreiben."
                ]
              },
              {
                "type": "definition",
                "term": "Lesezeiger",
                "text": "Interne Position, von der aus der n√§chste Lesevorgang beginnt."
              },
              {
                "type": "definition",
                "term": "Schreibzeiger",
                "text": "Interne Position, an der der n√§chste Schreibvorgang erfolgt."
              },
              {
                "type": "definition",
                "term": "tellg",
                "text": "Gibt die aktuelle Position des Lesezeigers zur√ºck."
              },
              {
                "type": "definition",
                "term": "tellp",
                "text": "Gibt die aktuelle Position des Schreibzeigers zur√ºck."
              },
              {
                "type": "code",
                "title": "Aktuelle Dateiposition abfragen",
                "language": "cpp",
                "code": "std::fstream file(\"data.txt\", std::ios::in | std::ios::out);\n\nstd::streampos readPos = file.tellg(); // aktuelle Leseposition\nstd::streampos writePos = file.tellp(); // aktuelle Schreibposition"
              },
              {
                "type": "definition",
                "term": "seekg",
                "text": "Setzt die Position des Lesezeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "definition",
                "term": "seekp",
                "text": "Setzt die Position des Schreibzeigers auf eine neue Stelle in der Datei."
              },
              {
                "type": "code",
                "title": "Dateiposition ver√§ndern",
                "language": "cpp",
                "code": "file.seekg(0);          // Lesezeiger an den Anfang der Datei\nfile.seekp(0);          // Schreibzeiger an den Anfang der Datei"
              },
              {
                "type": "explanation",
                "title": "Relative Positionierung",
                "text": [
                  "Die Dateiposition kann relativ zu bestimmten Referenzpunkten gesetzt werden.",
                  "Typische Referenzen sind Anfang, aktuelle Position und Dateiende."
                ]
              },
              {
                "type": "code",
                "title": "Relative Dateiposition",
                "language": "cpp",
                "code": "file.seekg(10, std::ios::beg); // 10 Bytes ab Dateianfang\nfile.seekg(0, std::ios::cur);  // aktuelle Position\nfile.seekg(-5, std::ios::end); // 5 Bytes vor Dateiende"
              },
              {
                "type": "pitfall",
                "title": "Lesen und Schreiben ohne Positionskontrolle",
                "text": "Ohne bewusstes Setzen der Dateiposition k√∂nnen Lese- und Schreibzugriffe an unerwarteten Stellen erfolgen."
              },
              {
                "type": "important",
                "text": "tellg und seekg steuern das Lesen, tellp und seekp das Schreiben."
              },
              {
                "type": "summary",
                "points": [
                  "Dateiposition bestimmt, wo gelesen oder geschrieben wird",
                  "fstream besitzt getrennte Lese- und Schreibzeiger",
                  "tellg und tellp fragen die aktuelle Position ab",
                  "seekg und seekp ver√§ndern die Position gezielt",
                  "Relative Positionierung ist mit beg, cur und end m√∂glich"
                ]
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger √ñffnungsmodus",
                "text": "Wird eine Datei ohne passenden Modus ge√∂ffnet, k√∂nnen Lese- oder Schreiboperationen fehlschlagen."
              },
              {
                "type": "important",
                "text": "std::fstream eignet sich f√ºr kombinierten Lese- und Schreibzugriff auf Dateien."
              },
              {
                "type": "summary",
                "points": [
                  "std::fstream vereint ifstream und ofstream",
                  "√ñffnungsmodi steuern das Dateiverhalten",
                  "Lesen und Schreiben sind in derselben Datei m√∂glich",
                  "Der √ñffnungszustand sollte immer gepr√ºft werden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Kontrollstrukturen",
    "icon": "üîÄ",
    "subcategories": [
      {
        "name": "Bedingungen",
        "icon": "‚ùì",
        "topics": [
          {
            "title": "if / else",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "if Anweisung",
                "text": "Eine Kontrollstruktur, die Code nur dann ausf√ºhrt, wenn eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee von if und else",
                "text": [
                  "Mit if wird eine Bedingung gepr√ºft, die einen booleschen Wert liefert.",
                  "Mit else kann ein alternativer Codepfad definiert werden, falls die Bedingung false ist."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches if Beispiel",
                "language": "cpp",
                "code": "int x = 5;\n\nif (x > 0) {\n    // wird ausgef√ºhrt, wenn x gr√∂√üer als 0 ist\n}"
              },
              {
                "type": "definition",
                "term": "else",
                "text": "Erg√§nzt ein if um einen Codeblock, der ausgef√ºhrt wird, wenn die Bedingung false ist."
              },
              {
                "type": "code",
                "title": "if else Beispiel",
                "language": "cpp",
                "code": "int x = -3;\n\nif (x >= 0) {\n    // x ist nicht negativ\n} else {\n    // x ist negativ\n}"
              },
              {
                "type": "definition",
                "term": "else if",
                "text": "Erm√∂glicht das Pr√ºfen mehrerer Bedingungen nacheinander."
              },
              {
                "type": "code",
                "title": "else if Kette",
                "language": "cpp",
                "code": "int value = 10;\n\nif (value < 0) {\n    // negativ\n} else if (value == 0) {\n    // null\n} else {\n    // positiv\n}"
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Ein Ausdruck, der zu true oder false ausgewertet wird."
              },
              {
                "type": "explanation",
                "title": "Bedingungen formulieren",
                "text": [
                  "Bedingungen bestehen meist aus Vergleichs- und logischen Operatoren.",
                  "Komplexe Bedingungen k√∂nnen mit &&, || und ! kombiniert werden."
                ]
              },
              {
                "type": "code",
                "title": "Komplexe Bedingung",
                "language": "cpp",
                "code": "int age = 20;\nbool hasTicket = true;\n\nif (age >= 18 && hasTicket) {\n    // Zutritt erlaubt\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergleich mit = statt ==",
                "text": "Die Verwendung von = statt == in einer Bedingung f√ºhrt zu logischen Fehlern oder Warnungen."
              },
              {
                "type": "important",
                "text": "Die Bedingung in if muss immer einen booleschen Wert liefern."
              },
              {
                "type": "summary",
                "points": [
                  "if steuert bedingte Programmausf√ºhrung",
                  "else definiert einen alternativen Pfad",
                  "else if erlaubt mehrere Bedingungen",
                  "Bedingungen basieren auf Vergleichen und logischen Operatoren",
                  "Sorgf√§ltige Formulierung vermeidet logische Fehler"
                ]
              }
            ]
          },
          {
            "title": "switch",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "switch Anweisung",
                "text": "Eine Kontrollstruktur zur Auswahl eines Codepfads basierend auf dem Wert eines Ausdrucks."
              },
              {
                "type": "explanation",
                "title": "Grundidee von switch",
                "text": [
                  "switch vergleicht einen Ausdruck mit mehreren festen Werten.",
                  "Je nach Treffer wird der zugeh√∂rige Codeblock ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "case",
                "text": "Ein m√∂glicher Vergleichswert innerhalb einer switch Anweisung."
              },
              {
                "type": "definition",
                "term": "default",
                "text": "Ein optionaler Zweig, der ausgef√ºhrt wird, wenn kein case passt."
              },
              {
                "type": "code",
                "title": "Einfaches switch Beispiel",
                "language": "cpp",
                "code": "int day = 3;\n\nswitch (day) {\ncase 1:\n    // Montag\n    break;\ncase 2:\n    // Dienstag\n    break;\ncase 3:\n    // Mittwoch\n    break;\ndefault:\n    // Ung√ºltiger Tag\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "break",
                "text": "Beendet einen case Block und verhindert das Weiterlaufen in den n√§chsten case."
              },
              {
                "type": "explanation",
                "title": "Fallthrough",
                "text": [
                  "Ohne break wird der Code im n√§chsten case ebenfalls ausgef√ºhrt.",
                  "Dieses Verhalten nennt man Fallthrough."
                ]
              },
              {
                "type": "code",
                "title": "Fallthrough Beispiel",
                "language": "cpp",
                "code": "int x = 1;\n\nswitch (x) {\ncase 1:\n    // wird ausgef√ºhrt\ncase 2:\n    // wird ebenfalls ausgef√ºhrt\n    break;\n}"
              },
              {
                "type": "definition",
                "term": "switch Ausdruck",
                "text": "Der Ausdruck in switch muss ein ganzzahliger oder enum Typ sein."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes break",
                "text": "Fehlende break Anweisungen f√ºhren oft zu unerwartetem Verhalten."
              },
              {
                "type": "important",
                "text": "switch ist geeignet f√ºr viele feste Vergleichswerte, nicht f√ºr komplexe Bedingungen."
              },
              {
                "type": "summary",
                "points": [
                  "switch w√§hlt Codepfade anhand eines Wertes",
                  "case definiert m√∂gliche Vergleichswerte",
                  "default deckt alle √ºbrigen F√§lle ab",
                  "break verhindert Fallthrough",
                  "switch funktioniert nur mit bestimmten Datentypen"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Schleifen",
        "icon": "üîÅ",
        "topics": [
          {
            "title": "for Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "for Schleife",
                "text": "Eine Schleife, die einen Codeblock eine festgelegte Anzahl von Durchl√§ufen ausf√ºhrt."
              },
              {
                "type": "explanation",
                "title": "Grundidee der for Schleife",
                "text": [
                  "Die for Schleife besteht aus Initialisierung, Bedingung und Schritt.",
                  "Sie eignet sich besonders f√ºr z√§hlbasierte Wiederholungen."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Wird einmal vor dem ersten Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "definition",
                "term": "Bedingung",
                "text": "Wird vor jedem Durchlauf gepr√ºft und entscheidet √ºber das Weiterlaufen der Schleife."
              },
              {
                "type": "definition",
                "term": "Schritt",
                "text": "Wird nach jedem Schleifendurchlauf ausgef√ºhrt."
              },
              {
                "type": "code",
                "title": "Klassische for Schleife",
                "language": "cpp",
                "code": "for (int i = 0; i < 5; i++) {\n    // i l√§uft von 0 bis 4\n}"
              },
              {
                "type": "explanation",
                "title": "Ablauf einer for Schleife",
                "text": [
                  "Zuerst wird die Initialisierung ausgef√ºhrt.",
                  "Danach wird vor jedem Durchlauf die Bedingung gepr√ºft und am Ende der Schritt ausgef√ºhrt."
                ]
              },
              {
                "type": "code",
                "title": "for Schleife mit anderer Schrittweite",
                "language": "cpp",
                "code": "for (int i = 0; i <= 10; i += 2) {\n    // i nimmt die Werte 0, 2, 4, 6, 8, 10 an\n}"
              },
              {
                "type": "definition",
                "term": "Bereichsbasierte for Schleife",
                "text": "Moderne for Schleife zum Durchlaufen von Containern und Arrays."
              },
              {
                "type": "code",
                "title": "Bereichsbasierte for Schleife",
                "language": "cpp",
                "code": "int values[] = {1, 2, 3};\n\nfor (int v : values) {\n    // v nimmt nacheinander die Werte 1, 2, 3 an\n}"
              },
              {
                "type": "pitfall",
                "title": "Endlosschleife",
                "text": "Eine falsche Bedingung oder ein fehlender Schritt kann zu einer Endlosschleife f√ºhren."
              },
              {
                "type": "important",
                "text": "for Schleifen eignen sich besonders f√ºr bekannte oder z√§hlbare Wiederholungen."
              },
              {
                "type": "summary",
                "points": [
                  "for Schleifen bestehen aus Initialisierung, Bedingung und Schritt",
                  "Sie sind ideal f√ºr Z√§hlschleifen",
                  "Schrittweite kann frei gew√§hlt werden",
                  "Bereichsbasierte for Schleifen vereinfachen Containerzugriffe",
                  "Sorgf√§ltige Bedingungen verhindern Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "while Schleife",
                "text": "Eine Schleife, die einen Codeblock ausf√ºhrt, solange eine Bedingung true ist."
              },
              {
                "type": "explanation",
                "title": "Grundidee der while Schleife",
                "text": [
                  "Die Bedingung wird vor jedem Durchlauf gepr√ºft.",
                  "Ist die Bedingung false, wird der Schleifenrumpf nicht ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Kopfgesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung vor dem ersten Durchlauf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\nwhile (i < 5) {\n    // wird ausgef√ºhrt, solange i kleiner als 5 ist\n    i++;\n}"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "while Schleifen werden genutzt, wenn die Anzahl der Durchl√§ufe vorher nicht bekannt ist.",
                  "H√§ufig wird die Schleife durch Benutzereingaben oder Dateiinhalte gesteuert."
                ]
              },
              {
                "type": "code",
                "title": "while mit Eingabe",
                "language": "cpp",
                "code": "int value;\n\nwhile (std::cin >> value) {\n    // l√§uft, solange die Eingabe g√ºltig ist\n}"
              },
              {
                "type": "definition",
                "term": "Endlosschleife",
                "text": "Eine Schleife, deren Bedingung niemals false wird."
              },
              {
                "type": "code",
                "title": "Bewusste Endlosschleife",
                "language": "cpp",
                "code": "while (true) {\n    // l√§uft unendlich\n}"
              },
              {
                "type": "pitfall",
                "title": "Vergessene Zustands√§nderung",
                "text": "Wird die Schleifenbedingung im Rumpf nicht beeinflusst, entsteht unbeabsichtigt eine Endlosschleife."
              },
              {
                "type": "important",
                "text": "Die Schleifenbedingung muss irgendwann false werden, au√üer bei gewollten Endlosschleifen."
              },
              {
                "type": "summary",
                "points": [
                  "while Schleifen pr√ºfen die Bedingung vor jedem Durchlauf",
                  "Sie eignen sich f√ºr unbestimmte Wiederholungen",
                  "Die Bedingung steuert den Programmfluss",
                  "Fehlende Zustands√§nderungen f√ºhren zu Endlosschleifen"
                ]
              }
            ]
          },
          {
            "title": "do-while Schleife",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "do while Schleife",
                "text": "Eine Schleife, bei der der Codeblock mindestens einmal ausgef√ºhrt wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee der do while Schleife",
                "text": [
                  "Die Bedingung wird erst nach dem Schleifendurchlauf gepr√ºft.",
                  "Der Schleifenrumpf wird daher immer mindestens einmal ausgef√ºhrt."
                ]
              },
              {
                "type": "definition",
                "term": "Fu√ügesteuerte Schleife",
                "text": "Eine Schleife, bei der die Bedingung nach dem Schleifenrumpf gepr√ºft wird."
              },
              {
                "type": "code",
                "title": "Einfache do while Schleife",
                "language": "cpp",
                "code": "int i = 0;\n\ndo {\n    // wird mindestens einmal ausgef√ºhrt\n    i++;\n} while (i < 5);"
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzf√§lle",
                "text": [
                  "do while wird genutzt, wenn eine Aktion mindestens einmal erfolgen muss.",
                  "H√§ufig bei Men√ºs oder wiederholten Benutzereingaben."
                ]
              },
              {
                "type": "code",
                "title": "do while mit Benutzereingabe",
                "language": "cpp",
                "code": "int choice;\n\ndo {\n    // Men√º anzeigen\n    std::cin >> choice;\n} while (choice != 0);"
              },
              {
                "type": "definition",
                "term": "Unterschied zu while",
                "text": "do while pr√ºft die Bedingung nach dem Durchlauf, while davor."
              },
              {
                "type": "pitfall",
                "title": "Vergessenes Semikolon",
                "text": "Nach der while Bedingung der do while Schleife ist ein Semikolon Pflicht."
              },
              {
                "type": "important",
                "text": "do while garantiert mindestens einen Schleifendurchlauf."
              },
              {
                "type": "summary",
                "points": [
                  "do while ist eine fu√ügesteuerte Schleife",
                  "Der Schleifenrumpf l√§uft mindestens einmal",
                  "Die Bedingung wird am Ende gepr√ºft",
                  "Typisch f√ºr Men√ºs und Eingabeschleifen",
                  "Semikolon nach while nicht vergessen"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Funktionen",
    "icon": "üîß",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üîß",
        "topics": [
          {
            "title": "Funktionsdefinition",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktionsdefinition",
                "text": "Die vollst√§ndige Beschreibung einer Funktion inklusive R√ºckgabetyp, Name, Parameterliste und Funktionsrumpf."
              },
              {
                "type": "explanation",
                "title": "Bestandteile einer Funktionsdefinition",
                "text": [
                  "Eine Funktionsdefinition legt fest, was eine Funktion tut und wie sie implementiert ist.",
                  "Sie besteht aus R√ºckgabetyp, Funktionsname, Parametern und dem Codeblock."
                ]
              },
              {
                "type": "list",
                "title": "Bestandteile",
                "items": [
                  "R√ºckgabetyp",
                  "Funktionsname",
                  "Parameterliste",
                  "Funktionsrumpf"
                ]
              },
              {
                "type": "code",
                "title": "Einfache Funktionsdefinition",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    // addiert zwei Zahlen\n    return a + b;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der Datentyp des Werts, den eine Funktion zur√ºckliefert."
              },
              {
                "type": "definition",
                "term": "Funktionsname",
                "text": "Bezeichner, unter dem die Funktion aufgerufen wird."
              },
              {
                "type": "definition",
                "term": "Parameterliste",
                "text": "Liste von Variablen, √ºber die Werte an die Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "Funktionsrumpf",
                "text": "Der Codeblock, der beim Aufruf der Funktion ausgef√ºhrt wird."
              },
              {
                "type": "definition",
                "term": "void Funktion",
                "text": "Eine Funktion ohne R√ºckgabewert."
              },
              {
                "type": "code",
                "title": "void Funktionsdefinition",
                "language": "cpp",
                "code": "void printHello() {\n    // gibt eine Begr√º√üung aus\n    std::cout << \"Hallo\";\n}"
              },
              {
                "type": "definition",
                "term": "return",
                "text": "Anweisung zum Zur√ºckgeben eines Werts und Beenden der Funktion."
              },
              {
                "type": "pitfall",
                "title": "Fehlender return",
                "text": "Nicht-void Funktionen m√ºssen in allen F√§llen einen Wert zur√ºckgeben."
              },
              {
                "type": "important",
                "text": "Die Funktionsdefinition legt das Verhalten fest, die Deklaration nur die Schnittstelle."
              },
              {
                "type": "summary",
                "points": [
                  "Eine Funktionsdefinition beschreibt das Verhalten einer Funktion",
                  "Sie besteht aus R√ºckgabetyp, Name, Parametern und Rumpf",
                  "void Funktionen liefern keinen Wert zur√ºck",
                  "return beendet die Funktion und gibt einen Wert zur√ºck"
                ]
              }
            ]
          },
          {
            "title": "Parameter & R√ºckgabe",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Parameter",
                "text": "Variablen in der Funktionsdefinition, √ºber die Werte an eine Funktion √ºbergeben werden."
              },
              {
                "type": "definition",
                "term": "R√ºckgabewert",
                "text": "Wert, den eine Funktion nach ihrer Ausf√ºhrung an den Aufrufer zur√ºckliefert."
              },
              {
                "type": "explanation",
                "title": "√úbersicht der √úbergabearten",
                "text": [
                  "C++ unterscheidet zwischen √úbergabe per Wert, per Referenz und per Zeiger.",
                  "Die Wahl beeinflusst Performance, Sicherheit und √Ñnderbarkeit der Daten."
                ]
              },
              {
                "type": "definition",
                "term": "√úbergabe per Wert",
                "text": "Der Parameter erh√§lt eine Kopie des √ºbergebenen Werts."
              },
              {
                "type": "code",
                "title": "Parameter per Wert",
                "language": "cpp",
                "code": "void setToZero(int x) {\n    x = 0; // √§ndert nur die Kopie\n}\n\nint a = 5;\nsetToZero(a); // a bleibt 5"
              },
              {
                "type": "definition",
                "term": "√úbergabe per Referenz",
                "text": "Der Parameter ist ein Alias f√ºr die √ºbergebene Variable."
              },
              {
                "type": "code",
                "title": "Parameter per Referenz",
                "language": "cpp",
                "code": "void setToZero(int& x) {\n    x = 0; // √§ndert die Originalvariable\n}\n\nint a = 5;\nsetToZero(a); // a wird 0"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert und nicht ver√§ndert\n    std::cout << text;\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Wert",
                "text": "Die Funktion gibt eine Kopie des Ergebnisses zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Wert",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b; // R√ºckgabe einer Kopie\n}"
              },
              {
                "type": "definition",
                "term": "R√ºckgabe per Referenz",
                "text": "Die Funktion gibt eine Referenz auf ein existierendes Objekt zur√ºck."
              },
              {
                "type": "code",
                "title": "R√ºckgabe per Referenz",
                "language": "cpp",
                "code": "int& access(int& x) {\n    return x; // Referenz auf bestehenden Wert\n}"
              },
              {
                "type": "pitfall",
                "title": "Referenz auf lokale Variable zur√ºckgeben",
                "text": "Das Zur√ºckgeben einer Referenz auf eine lokale Variable f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Typen per Wert, gro√üe Objekte per const Referenz √ºbergeben."
              },
              {
                "type": "summary",
                "points": [
                  "Parameter definieren die Eingaben einer Funktion",
                  "√úbergabe per Wert kopiert Daten",
                  "Referenzen erlauben direkten Zugriff auf Originaldaten",
                  "R√ºckgaben k√∂nnen per Wert oder Referenz erfolgen",
                  "Referenzen auf lokale Variablen d√ºrfen nie zur√ºckgegeben werden"
                ]
              }
            ]
          },
          {
            "title": "Funktions√ºberladung",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Funktions√ºberladung",
                "text": "Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Parameterliste."
              },
              {
                "type": "explanation",
                "title": "Grundidee der √úberladung",
                "text": [
                  "Funktionen k√∂nnen denselben Namen tragen, solange sich ihre Parameter unterscheiden.",
                  "Der Compiler entscheidet anhand der Argumente, welche Funktion aufgerufen wird."
                ]
              },
              {
                "type": "definition",
                "term": "Signatur",
                "text": "Kombination aus Funktionsname und Parametertypen."
              },
              {
                "type": "code",
                "title": "Einfache Funktions√ºberladung",
                "language": "cpp",
                "code": "int add(int a, int b) {\n    return a + b;\n}\n\ndouble add(double a, double b) {\n    return a + b;\n}"
              },
              {
                "type": "explanation",
                "title": "Auswahl der passenden Funktion",
                "text": [
                  "Die Auswahl erfolgt zur Compilezeit.",
                  "R√ºckgabetyp allein reicht nicht zur √úberladung aus."
                ]
              },
              {
                "type": "code",
                "title": "√úberladung mit unterschiedlicher Parameteranzahl",
                "language": "cpp",
                "code": "int sum(int a, int b) {\n    return a + b;\n}\n\nint sum(int a, int b, int c) {\n    return a + b + c;\n}"
              },
              {
                "type": "definition",
                "term": "√úberladung und const",
                "text": "const kann Teil der Funktionssignatur sein, insbesondere bei Memberfunktionen."
              },
              {
                "type": "pitfall",
                "title": "Mehrdeutige Aufrufe",
                "text": "Unklare Typumwandlungen k√∂nnen dazu f√ºhren, dass der Compiler keine passende √úberladung findet."
              },
              {
                "type": "important",
                "text": "Funktions√ºberladung verbessert Lesbarkeit, wenn gleiche Konzepte logisch zusammengeh√∂ren."
              },
              {
                "type": "summary",
                "points": [
                  "Mehrere Funktionen k√∂nnen denselben Namen haben",
                  "Die Parameterliste muss sich unterscheiden",
                  "Die Entscheidung erfolgt zur Compilezeit",
                  "Der R√ºckgabetyp allein gen√ºgt nicht",
                  "√úberladung sollte klar und eindeutig bleiben"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Besondere Funktionen",
        "icon": "üß†",
        "topics": [
          {
            "title": "inline Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "inline Funktion",
                "text": "Eine Funktion, bei der der Compiler versucht, den Funktionsaufruf durch den Funktionscode zu ersetzen."
              },
              {
                "type": "explanation",
                "title": "Grundidee von inline",
                "text": [
                  "inline soll den Overhead eines Funktionsaufrufs vermeiden.",
                  "Der Compiler darf inline ignorieren, es ist nur eine Empfehlung."
                ]
              },
              {
                "type": "definition",
                "term": "Funktionsaufruf Overhead",
                "text": "Zus√§tzlicher Aufwand durch Sprung, R√ºcksprung und Parameter√ºbergabe bei einem Funktionsaufruf."
              },
              {
                "type": "code",
                "title": "inline Funktionsdefinition",
                "language": "cpp",
                "code": "inline int square(int x) {\n    // einfacher, kurzer Code\n    return x * x;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann inline sinnvoll ist",
                "text": [
                  "Bei sehr kleinen, h√§ufig aufgerufenen Funktionen.",
                  "Typisch bei Getter und Setter Funktionen."
                ]
              },
              {
                "type": "code",
                "title": "Typischer Einsatz in Klassen",
                "language": "cpp",
                "code": "class Counter {\nprivate:\n    int value;\n\npublic:\n    int get() const { // implizit inline\n        return value;\n    }\n};"
              },
              {
                "type": "definition",
                "term": "implizit inline",
                "text": "Funktionen, die innerhalb einer Klassendefinition definiert sind, gelten automatisch als inline."
              },
              {
                "type": "explanation",
                "title": "inline und Header Dateien",
                "text": [
                  "inline Funktionen d√ºrfen in Header Dateien definiert werden.",
                  "Mehrfache Definitionen sind erlaubt, solange sie identisch sind."
                ]
              },
              {
                "type": "pitfall",
                "title": "Zu gro√üe inline Funktionen",
                "text": "Gro√üe inline Funktionen k√∂nnen den Code aufbl√§hen und die Performance verschlechtern."
              },
              {
                "type": "important",
                "text": "inline ist kein Garant f√ºr Performance, die Entscheidung trifft der Compiler."
              },
              {
                "type": "summary",
                "points": [
                  "inline reduziert Funktionsaufruf Overhead",
                  "Der Compiler entscheidet, ob inline angewendet wird",
                  "Besonders sinnvoll f√ºr kleine Funktionen",
                  "Methoden in Klassen sind implizit inline",
                  "Zu viel inline kann schaden"
                ]
              }
            ]
          },
          {
            "title": "Lambda Funktionen",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Lambda Funktion",
                "text": "Eine anonyme Funktion, die direkt an der Verwendungsstelle definiert wird."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Lambda Funktionen",
                "text": [
                  "Lambda Funktionen sind kurze Funktionsobjekte ohne eigenen Namen.",
                  "Sie werden h√§ufig f√ºr Callbacks, kurze Berechnungen und Standardalgorithmen genutzt."
                ]
              },
              {
                "type": "definition",
                "term": "Lambda Syntax",
                "text": "Besteht aus Capture Liste, Parameterliste, optionalem R√ºckgabetyp und Funktionsrumpf."
              },
              {
                "type": "code",
                "title": "Grundlegende Lambda Syntax",
                "language": "cpp",
                "code": "auto f = [](int x) {\n    return x * 2;\n};"
              },
              {
                "type": "definition",
                "term": "Capture Liste",
                "text": "Legt fest, welche √§u√üeren Variablen im Lambda verwendet werden d√ºrfen und wie sie √ºbergeben werden."
              },
              {
                "type": "list",
                "title": "Wichtige Capture Modi",
                "items": [
                  "[]: keine Variablen capturen",
                  "[x]: x per Wert capturen",
                  "[&x]: x per Referenz capturen",
                  "[=]: alle verwendeten Variablen per Wert capturen",
                  "[&]: alle verwendeten Variablen per Referenz capturen",
                  "[=, &x]: alle per Wert, x per Referenz",
                  "[&, x]: alle per Referenz, x per Wert"
                ]
              },
              {
                "type": "code",
                "title": "Capture Beispiele",
                "language": "cpp",
                "code": "int a = 1;\nint b = 2;\n\nauto l1 = [a]() { return a; };        // Wert-Capture\nauto l2 = [&b]() { b++; };            // Referenz-Capture\nauto l3 = [=]() { return a + b; };    // alle per Wert\nauto l4 = [=, &b]() { b += a; };      // Mischung"
              },
              {
                "type": "definition",
                "term": "mutable Lambda",
                "text": "Ein Lambda, das erlaubt, per Wert gecapturete Variablen zu ver√§ndern."
              },
              {
                "type": "code",
                "title": "mutable Lambda Beispiel",
                "language": "cpp",
                "code": "int x = 5;\nauto l = [x]() mutable {\n    x++;            // erlaubt wegen mutable\n    return x;\n};"
              },
              {
                "type": "definition",
                "term": "R√ºckgabetyp",
                "text": "Der R√ºckgabetyp eines Lambdas wird meist automatisch bestimmt, kann aber explizit angegeben werden."
              },
              {
                "type": "code",
                "title": "Expliziter R√ºckgabetyp",
                "language": "cpp",
                "code": "auto div = [](int a, int b) -> double {\n    return static_cast<double>(a) / b;\n};"
              },
              {
                "type": "definition",
                "term": "std::function",
                "text": "Ein Typ, der beliebige aufrufbare Objekte mit einer festen Signatur speichern kann."
              },
              {
                "type": "explanation",
                "title": "Lambda mit std::function",
                "text": [
                  "Lambdas k√∂nnen in std::function gespeichert werden.",
                  "Dies ist flexibel, aber langsamer als direkte Nutzung eines Lambdas."
                ]
              },
              {
                "type": "code",
                "title": "Lambda in std::function",
                "language": "cpp",
                "code": "#include <functional>\n\nstd::function<int(int)> f = [](int x) {\n    return x * x;\n};"
              },
              {
                "type": "definition",
                "term": "Lambda in Algorithmen",
                "text": "Lambda Funktionen werden h√§ufig als Pr√§dikate oder Aktionen in Standardalgorithmen verwendet."
              },
              {
                "type": "code",
                "title": "Lambda mit std::algorithm",
                "language": "cpp",
                "code": "#include <algorithm>\n#include <vector>\n\nstd::vector<int> v = {1, 2, 3, 4};\n\nint count = std::count_if(v.begin(), v.end(), [](int x) {\n    return x % 2 == 0; // z√§hlt gerade Zahlen\n});"
              },
              {
                "type": "pitfall",
                "title": "Referenz Capture und Lebensdauer",
                "text": "Referenz-Captures sind gef√§hrlich, wenn das Lambda l√§nger lebt als die referenzierte Variable."
              },
              {
                "type": "important",
                "text": "Standardfall: kleine Logik direkt als Lambda, komplexe Logik als normale Funktion."
              },
              {
                "type": "summary",
                "points": [
                  "Lambda Funktionen sind anonyme Funktionsobjekte",
                  "Capture Listen steuern Zugriff auf √§u√üere Variablen",
                  "mutable erlaubt √Ñnderungen an Wert-Captures",
                  "Lambdas k√∂nnen in std::function gespeichert werden",
                  "Standardalgorithmen nutzen Lambdas intensiv"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Arrays & Strings",
    "icon": "üìè",
    "subcategories": [
      {
        "name": "Arrays",
        "icon": "üî¢",
        "topics": [
          {
            "title": "C Arrays",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C Array",
                "text": "Ein C Array ist eine feste, zusammenh√§ngende Sequenz von Elementen gleichen Typs."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Arrays",
                "text": [
                  "C Arrays haben eine feste Gr√∂√üe, die zur Compilezeit bekannt sein muss.",
                  "Der Name des Arrays verweist implizit auf das erste Element."
                ]
              },
              {
                "type": "code",
                "title": "Deklaration eines C Arrays",
                "language": "cpp",
                "code": "int values[5]; // Array mit 5 int Elementen"
              },
              {
                "type": "definition",
                "term": "Initialisierung",
                "text": "Beim Erzeugen eines Arrays k√∂nnen Startwerte angegeben werden."
              },
              {
                "type": "code",
                "title": "Initialisierung eines C Arrays",
                "language": "cpp",
                "code": "int numbers[3] = {1, 2, 3};"
              },
              {
                "type": "definition",
                "term": "Indexzugriff",
                "text": "Zugriff auf ein Element √ºber seinen Index, beginnend bei 0."
              },
              {
                "type": "code",
                "title": "Zugriff per Index",
                "language": "cpp",
                "code": "int x = numbers[0]; // erstes Element"
              },
              {
                "type": "definition",
                "term": "Arraygr√∂√üe",
                "text": "Die Anzahl der Elemente eines C Arrays."
              },
              {
                "type": "explanation",
                "title": "Arraygr√∂√üe ermitteln",
                "text": [
                  "C Arrays kennen ihre Gr√∂√üe nicht selbst.",
                  "Die Gr√∂√üe muss separat verwaltet oder berechnet werden."
                ]
              },
              {
                "type": "code",
                "title": "Arraygr√∂√üe berechnen",
                "language": "cpp",
                "code": "int size = sizeof(numbers) / sizeof(numbers[0]);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Arrays pr√ºfen nicht, ob ein Index g√ºltig ist, was zu undefiniertem Verhalten f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Arrays sind einfach, aber unsicher und unflexibel."
              },
              {
                "type": "summary",
                "points": [
                  "C Arrays haben feste Gr√∂√üe",
                  "Index beginnt bei 0",
                  "Keine automatische Gr√∂√üenverwaltung",
                  "Kein Bounds Check",
                  "In modernem C++ oft durch Container ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::array",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::array",
                "text": "std::array ist ein Container aus der Standardbibliothek mit fester Gr√∂√üe und sicherem Zugriff."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::array",
                "text": [
                  "std::array kapselt ein C Array in einer Klasse.",
                  "Es bietet zus√§tzliche Funktionen wie size und at."
                ]
              },
              {
                "type": "definition",
                "term": "Template Parameter",
                "text": "std::array ben√∂tigt einen Datentyp und eine feste Gr√∂√üe als Template Argumente."
              },
              {
                "type": "code",
                "title": "Deklaration von std::array",
                "language": "cpp",
                "code": "#include <array>\n\nstd::array<int, 3> values = {1, 2, 3};"
              },
              {
                "type": "explanation",
                "title": "Vorteile gegen√ºber C Arrays",
                "text": [
                  "std::array kennt seine eigene Gr√∂√üe.",
                  "Es unterst√ºtzt range based for Schleifen und Standardalgorithmen."
                ]
              },
              {
                "type": "code",
                "title": "std::array in einer for Schleife",
                "language": "cpp",
                "code": "for (int v : values) {\n    // Zugriff auf jedes Element\n}"
              },
              {
                "type": "pitfall",
                "title": "Feste Gr√∂√üe",
                "text": "Auch std::array hat eine feste Gr√∂√üe und kann nicht zur Laufzeit wachsen."
              },
              {
                "type": "important",
                "text": "std::array ist die sichere Alternative zu C Arrays bei fester Gr√∂√üe."
              },
              {
                "type": "summary",
                "points": [
                  "std::array ist ein Wrapper um C Arrays",
                  "Die Gr√∂√üe ist Teil des Typs",
                  "size liefert die Elementanzahl",
                  "at bietet Bounds Checking",
                  "Bevorzugt gegen√ºber rohen C Arrays"
                ]
              },
              {
                "type": "explanation",
                "title": "Wichtige Funktionen von std::array",
                "text": [
                  "std::array stellt im Vergleich zu C Arrays zus√§tzliche Memberfunktionen bereit.",
                  "Diese Funktionen erh√∂hen Sicherheit, Lesbarkeit und Integration mit der Standardbibliothek."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Elemente im Array."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> a = {1, 2, 3};\nstd::size_t n = a.size(); // n ist 3"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob das Array leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (a.empty()) {\n    // nur true bei Gr√∂√üe 0\n}"
              },
              {
                "type": "definition",
                "term": "operator[]",
                "text": "Greift ohne Indexpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Indexzugriff mit []",
                "language": "cpp",
                "code": "int x = a[0]; // kein Bounds Check"
              },
              {
                "type": "definition",
                "term": "at",
                "text": "Greift mit Laufzeitpr√ºfung auf ein Element zu."
              },
              {
                "type": "code",
                "title": "Sicherer Zugriff mit at",
                "language": "cpp",
                "code": "int x = a.at(1); // wirft Ausnahme bei ung√ºltigem Index"
              },
              {
                "type": "definition",
                "term": "front",
                "text": "Liefert das erste Element des Arrays."
              },
              {
                "type": "code",
                "title": "front Beispiel",
                "language": "cpp",
                "code": "int first = a.front();"
              },
              {
                "type": "definition",
                "term": "back",
                "text": "Liefert das letzte Element des Arrays."
              },
              {
                "type": "code",
                "title": "back Beispiel",
                "language": "cpp",
                "code": "int last = a.back();"
              },
              {
                "type": "definition",
                "term": "data",
                "text": "Gibt einen Zeiger auf das interne C Array zur√ºck."
              },
              {
                "type": "code",
                "title": "data Beispiel",
                "language": "cpp",
                "code": "int* ptr = a.data(); // kompatibel mit C APIs"
              },
              {
                "type": "definition",
                "term": "fill",
                "text": "Setzt alle Elemente des Arrays auf denselben Wert."
              },
              {
                "type": "code",
                "title": "fill Beispiel",
                "language": "cpp",
                "code": "a.fill(0); // alle Elemente werden 0"
              },
              {
                "type": "definition",
                "term": "swap",
                "text": "Tauscht den Inhalt zweier Arrays gleicher Gr√∂√üe und gleichen Typs."
              },
              {
                "type": "code",
                "title": "swap Beispiel",
                "language": "cpp",
                "code": "std::array<int, 3> b = {4, 5, 6};\na.swap(b); // Inhalte von a und b werden getauscht"
              },
              {
                "type": "important",
                "text": "at bietet Sicherheit, operator[] bietet Geschwindigkeit ohne Pr√ºfung."
              },
              {
                "type": "summary",
                "points": [
                  "std::array kennt seine eigene Gr√∂√üe",
                  "size und empty liefern Metainformationen",
                  "at pr√ºft Indizes zur Laufzeit",
                  "front und back erlauben direkten Randzugriff",
                  "data erm√∂glicht Interoperabilit√§t mit C Code"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Strings",
        "icon": "üßµ",
        "topics": [
          {
            "title": "C Strings",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "C String",
                "text": "Ein C String ist ein Array von char, das mit einem Nullterminator '\\0' endet."
              },
              {
                "type": "explanation",
                "title": "Grundidee von C Strings",
                "text": [
                  "C Strings stammen aus der C Sprache und werden in C++ weiterhin unterst√ºtzt.",
                  "Das Ende des Strings wird durch das Zeichen '\\0' markiert."
                ]
              },
              {
                "type": "definition",
                "term": "Nullterminator",
                "text": "Ein spezielles Zeichen '\\0', das das Ende eines C Strings kennzeichnet."
              },
              {
                "type": "code",
                "title": "Deklaration eines C Strings",
                "language": "cpp",
                "code": "char text[6] = \"Hallo\"; // 'H','a','l','l','o','\\0'"
              },
              {
                "type": "definition",
                "term": "Stringliterale",
                "text": "Feste Zeichenketten, die im Programmcode definiert sind."
              },
              {
                "type": "code",
                "title": "Stringliteral",
                "language": "cpp",
                "code": "const char* msg = \"Hallo Welt\";"
              },
              {
                "type": "definition",
                "term": "cstring",
                "text": "Header mit Funktionen zur Arbeit mit C Strings."
              },
              {
                "type": "code",
                "title": "C String Funktionen",
                "language": "cpp",
                "code": "#include <cstring>\n\nsize_t len = std::strlen(text);"
              },
              {
                "type": "pitfall",
                "title": "Kein Bounds Check",
                "text": "C Strings pr√ºfen nicht, ob genug Speicher vorhanden ist, was zu Buffer Overflows f√ºhren kann."
              },
              {
                "type": "important",
                "text": "C Strings sind fehleranf√§llig und sollten in modernem C++ nur gezielt eingesetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "C Strings sind char Arrays mit Nullterminator",
                  "Die L√§nge ist nicht im Typ gespeichert",
                  "Arbeiten mit C Strings ist unsicher",
                  "cstring stellt Hilfsfunktionen bereit",
                  "In modernem C++ meist durch std::string ersetzt"
                ]
              }
            ]
          },
          {
            "title": "std::string",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "std::string",
                "text": "std::string ist ein Standardcontainer zur sicheren und komfortablen Verarbeitung von Texten."
              },
              {
                "type": "explanation",
                "title": "Grundidee von std::string",
                "text": [
                  "std::string verwaltet Speicher automatisch.",
                  "Er kennt seine L√§nge und w√§chst dynamisch."
                ]
              },
              {
                "type": "definition",
                "term": "Dynamische L√§nge",
                "text": "Die L√§nge eines std::string kann sich zur Laufzeit √§ndern."
              },
              {
                "type": "code",
                "title": "Deklaration und Initialisierung",
                "language": "cpp",
                "code": "#include <string>\n\nstd::string name = \"Kilian\";"
              },
              {
                "type": "definition",
                "term": "Zugriff auf Zeichen",
                "text": "Einzelne Zeichen k√∂nnen √ºber einen Index gelesen oder ver√§ndert werden."
              },
              {
                "type": "code",
                "title": "Indexzugriff",
                "language": "cpp",
                "code": "char c = name[0]; // erstes Zeichen"
              },
              {
                "type": "definition",
                "term": "Konkatenation",
                "text": "Zusammenf√ºgen von Strings."
              },
              {
                "type": "code",
                "title": "Strings verketten",
                "language": "cpp",
                "code": "std::string a = \"Hallo\";\nstd::string b = \"Welt\";\nstd::string c = a + \" \" + b;"
              },
              {
                "type": "definition",
                "term": "c_str",
                "text": "Liefert einen C String Zeiger auf den internen Speicher."
              },
              {
                "type": "code",
                "title": "Umwandlung zu C String",
                "language": "cpp",
                "code": "const char* raw = name.c_str();"
              },
              {
                "type": "pitfall",
                "title": "Ung√ºltiger Zeiger von c_str",
                "text": "Der von c_str gelieferte Zeiger wird ung√ºltig, wenn der String ver√§ndert wird."
              },
              {
                "type": "important",
                "text": "std::string ist der Standard f√ºr Textverarbeitung in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "std::string verwaltet Speicher automatisch",
                  "Die L√§nge ist jederzeit bekannt",
                  "Strings k√∂nnen sicher ver√§ndert und verkettet werden",
                  "c_str erm√∂glicht Interoperabilit√§t mit C APIs",
                  "std::string ist C Strings klar vorzuziehen"
                ]
              },
              {
                "type": "explanation",
                "title": "Funktionen von std::string",
                "text": [
                  "Der Header <string> liefert viele n√ºtzliche Funktionen f√ºr std::string Variablen."
                ]
              },
              {
                "type": "definition",
                "term": "size",
                "text": "Liefert die Anzahl der Zeichen im String."
              },
              {
                "type": "code",
                "title": "size Beispiel",
                "language": "cpp",
                "code": "std::size_t len = name.size();"
              },
              {
                "type": "definition",
                "term": "length",
                "text": "Liefert die Anzahl der Zeichen im String. Entspricht funktional size."
              },
              {
                "type": "code",
                "title": "length Beispiel",
                "language": "cpp",
                "code": "std::string s = \"Hallo\";\nstd::size_t n = s.length(); // n ist 5"
              },
              {
                "type": "definition",
                "term": "empty",
                "text": "Pr√ºft, ob der String leer ist."
              },
              {
                "type": "code",
                "title": "empty Beispiel",
                "language": "cpp",
                "code": "if (s.empty()) {\n    // String enth√§lt keine Zeichen\n}"
              },
              {
                "type": "definition",
                "term": "clear",
                "text": "Entfernt alle Zeichen aus dem String."
              },
              {
                "type": "code",
                "title": "clear Beispiel",
                "language": "cpp",
                "code": "s.clear(); // String ist danach leer"
              },
              {
                "type": "definition",
                "term": "append",
                "text": "H√§ngt Text an das Ende des Strings an."
              },
              {
                "type": "code",
                "title": "append Beispiel",
                "language": "cpp",
                "code": "s.append(\" Welt\"); // entspricht s += \" Welt\""
              },
              {
                "type": "definition",
                "term": "substr",
                "text": "Erzeugt einen Teilstring aus dem String."
              },
              {
                "type": "code",
                "title": "substr Beispiel",
                "language": "cpp",
                "code": "std::string sub = s.substr(0, 2); // erste zwei Zeichen"
              },
              {
                "type": "definition",
                "term": "find",
                "text": "Sucht nach einem Teilstring oder Zeichen und liefert die Position."
              },
              {
                "type": "code",
                "title": "find Beispiel",
                "language": "cpp",
                "code": "std::size_t pos = s.find(\"ll\");\nif (pos != std::string::npos) {\n    // Teilstring gefunden\n}"
              },
              {
                "type": "definition",
                "term": "replace",
                "text": "Ersetzt einen Teil des Strings durch einen anderen Text."
              },
              {
                "type": "code",
                "title": "replace Beispiel",
                "language": "cpp",
                "code": "s.replace(0, 5, \"Hi\"); // ersetzt die ersten 5 Zeichen"
              },
              {
                "type": "definition",
                "term": "compare",
                "text": "Vergleicht zwei Strings lexikografisch."
              },
              {
                "type": "code",
                "title": "compare Beispiel",
                "language": "cpp",
                "code": "int r = s.compare(\"Hallo\");\n// r == 0: gleich, <0: kleiner, >0: gr√∂√üer"
              },
              {
                "type": "important",
                "text": "size und length sind gleichwertig, size ist der bevorzugte Stil in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "size und length liefern die Stringl√§nge",
                  "empty pr√ºft auf leeren String",
                  "append und += h√§ngen Text an",
                  "substr erzeugt Teilstrings",
                  "find sucht Teilstrings sicher √ºber npos"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Zeiger & Referenzen",
    "icon": "üéØ",
    "subcategories": [
      {
        "name": "Zeiger",
        "icon": "üéØ",
        "topics": [
          {
            "title": "Pointer Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Zeiger",
                "text": "Ein Zeiger speichert die Speicheradresse eines Objekts."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Zeigern",
                "text": [
                  "Zeiger erm√∂glichen den indirekten Zugriff auf Variablen √ºber ihre Adresse.",
                  "Sie werden h√§ufig f√ºr dynamischen Speicher, Arrays und Funktionsparameter verwendet."
                ]
              },
              {
                "type": "definition",
                "term": "Adresse",
                "text": "Die Speicherposition einer Variable im Arbeitsspeicher."
              },
              {
                "type": "definition",
                "term": "Dereferenzierung",
                "text": "Der Zugriff auf den Wert, auf den ein Zeiger zeigt."
              },
              {
                "type": "code",
                "title": "Pointer Deklaration und Nutzung",
                "language": "cpp",
                "code": "int x = 5;\nint* p = &x;     // p speichert die Adresse von x\nint y = *p;      // Dereferenzierung, y wird 5"
              },
              {
                "type": "definition",
                "term": "Zeigertyp",
                "text": "Der Typ eines Zeigers gibt an, auf welchen Datentyp er zeigt."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierter Zeiger",
                "text": "Ein nicht initialisierter Zeiger zeigt auf eine undefinierte Adresse."
              },
              {
                "type": "important",
                "text": "Ein Zeiger sollte immer initialisiert werden, idealerweise mit nullptr."
              },
              {
                "type": "summary",
                "points": [
                  "Zeiger speichern Adressen",
                  "Dereferenzierung erfolgt mit *",
                  "Der Zeigertyp bestimmt den Zieltyp",
                  "Uninitialisierte Zeiger sind gef√§hrlich"
                ]
              }
            ]
          },
          {
            "title": "Pointer Arithmetik",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Pointer Arithmetik",
                "text": "Rechenoperationen auf Zeigern, die sich an der Gr√∂√üe des Zieltyps orientieren."
              },
              {
                "type": "explanation",
                "title": "Grundidee der Pointer Arithmetik",
                "text": [
                  "Zeiger k√∂nnen vor und zur√ºck bewegt werden.",
                  "Die Schrittweite entspricht der Gr√∂√üe des Datentyps."
                ]
              },
              {
                "type": "definition",
                "term": "Inkrementieren eines Zeigers",
                "text": "Verschiebt den Zeiger auf das n√§chste Element desselben Typs."
              },
              {
                "type": "code",
                "title": "Pointer Arithmetik mit Arrays",
                "language": "cpp",
                "code": "int arr[3] = {10, 20, 30};\nint* p = arr;        // zeigt auf arr[0]\nint a = *p;          // 10\np++;                 // zeigt auf arr[1]\nint b = *p;          // 20"
              },
              {
                "type": "definition",
                "term": "Array und Pointer",
                "text": "Der Name eines Arrays zerf√§llt oft implizit zu einem Zeiger auf das erste Element."
              },
              {
                "type": "explanation",
                "title": "Erlaubte und unerlaubte Operationen",
                "text": [
                  "Addition und Subtraktion mit Ganzzahlen ist erlaubt.",
                  "Addition zweier Zeiger ist nicht erlaubt."
                ]
              },
              {
                "type": "pitfall",
                "title": "Au√üerhalb des Arrays",
                "text": "Pointer Arithmetik au√üerhalb der Arraygrenzen f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "Pointer Arithmetik ist eng an Arrays gebunden und erfordert gro√üe Sorgfalt."
              },
              {
                "type": "summary",
                "points": [
                  "Pointer bewegen sich in Schritten der Typgr√∂√üe",
                  "Typischer Einsatz bei Arrays",
                  "Arrayname verh√§lt sich wie Zeiger",
                  "Grenzen d√ºrfen nicht √ºberschritten werden"
                ]
              }
            ]
          },
          {
            "title": "Nullpointer",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Nullpointer",
                "text": "Ein Zeiger, der auf kein g√ºltiges Objekt zeigt."
              },
              {
                "type": "definition",
                "term": "nullptr",
                "text": "Ein spezieller Literalwert zur sicheren Darstellung eines Nullpointers."
              },
              {
                "type": "explanation",
                "title": "Grundidee von nullptr",
                "text": [
                  "nullptr ersetzt √§ltere Konzepte wie NULL oder 0.",
                  "Er ist eindeutig als Zeigerwert typisiert."
                ]
              },
              {
                "type": "code",
                "title": "nullptr verwenden",
                "language": "cpp",
                "code": "int* p = nullptr; // zeigt auf nichts\n\nif (p == nullptr) {\n    // Zeiger ist ung√ºltig\n}"
              },
              {
                "type": "definition",
                "term": "Nullpointer Dereferenzierung",
                "text": "Der Zugriff auf einen Nullpointer ist undefiniertes Verhalten."
              },
              {
                "type": "pitfall",
                "title": "Dereferenzierung von nullptr",
                "text": "Das Dereferenzieren eines Nullpointers f√ºhrt meist zu Programmabst√ºrzen."
              },
              {
                "type": "important",
                "text": "nullptr ist der einzige empfohlene Weg, einen leeren Zeiger darzustellen."
              },
              {
                "type": "summary",
                "points": [
                  "Nullpointer zeigen auf kein Objekt",
                  "nullptr ist typsicher",
                  "Vor Dereferenzierung immer pr√ºfen",
                  "NULL und 0 sollten vermieden werden"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Referenzen",
        "icon": "üîó",
        "topics": [
          {
            "title": "Referenzen Basics",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenz",
                "text": "Eine Referenz ist ein alternativer Name f√ºr ein bereits existierendes Objekt."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzen",
                "text": [
                  "Referenzen erm√∂glichen den direkten Zugriff auf eine Variable, ohne deren Adresse explizit zu verwenden.",
                  "Sie verhalten sich wie Aliase und sind nach der Initialisierung fest gebunden."
                ]
              },
              {
                "type": "definition",
                "term": "Initialisierung einer Referenz",
                "text": "Eine Referenz muss beim Erzeugen an ein Objekt gebunden werden."
              },
              {
                "type": "code",
                "title": "Referenz deklarieren",
                "language": "cpp",
                "code": "int x = 10;\nint& ref = x; // ref ist ein Alias f√ºr x"
              },
              {
                "type": "definition",
                "term": "Alias Verhalten",
                "text": "√Ñnderungen √ºber die Referenz wirken sich direkt auf das referenzierte Objekt aus."
              },
              {
                "type": "code",
                "title": "Alias Beispiel",
                "language": "cpp",
                "code": "ref = 20;      // √§ndert x\nint y = x;     // y ist 20"
              },
              {
                "type": "definition",
                "term": "Neu binden",
                "text": "Referenzen k√∂nnen nach der Initialisierung nicht auf ein anderes Objekt zeigen."
              },
              {
                "type": "pitfall",
                "title": "Uninitialisierte Referenz",
                "text": "Referenzen m√ºssen immer initialisiert werden, sonst ist der Code ung√ºltig."
              },
              {
                "type": "important",
                "text": "Referenzen sind keine Zeiger und k√∂nnen nicht null sein."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzen sind Aliase f√ºr bestehende Objekte",
                  "Sie m√ºssen sofort initialisiert werden",
                  "Referenzen k√∂nnen nicht neu gebunden werden",
                  "Zugriff erfolgt ohne Dereferenzierung",
                  "Referenzen k√∂nnen nicht null sein"
                ]
              }
            ]
          },
          {
            "title": "Referenzparameter",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Referenzparameter",
                "text": "Ein Funktionsparameter, der per Referenz √ºbergeben wird und direkt auf das Argument zugreift."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Referenzparametern",
                "text": [
                  "Referenzparameter erlauben es, Argumente innerhalb einer Funktion zu ver√§ndern.",
                  "Sie vermeiden Kopien und sind effizient f√ºr gro√üe Objekte."
                ]
              },
              {
                "type": "definition",
                "term": "√Ñnderbarer Referenzparameter",
                "text": "Ein Referenzparameter ohne const, der das √ºbergebene Objekt ver√§ndern darf."
              },
              {
                "type": "code",
                "title": "Referenzparameter ver√§ndern Wert",
                "language": "cpp",
                "code": "void increment(int& x) {\n    x++; // √§ndert die Originalvariable\n}\n\nint a = 5;\nincrement(a); // a ist jetzt 6"
              },
              {
                "type": "definition",
                "term": "const Referenzparameter",
                "text": "Ein Referenzparameter, der nicht ver√§ndert werden darf."
              },
              {
                "type": "code",
                "title": "const Referenzparameter",
                "language": "cpp",
                "code": "void print(const std::string& text) {\n    // text wird nicht kopiert\n    std::cout << text;\n}"
              },
              {
                "type": "explanation",
                "title": "Wann const Referenzen verwenden",
                "text": [
                  "Bei gro√üen Objekten, die nicht ver√§ndert werden sollen.",
                  "Als Standard f√ºr Lesezugriff in Funktionsschnittstellen."
                ]
              },
              {
                "type": "pitfall",
                "title": "Unerwartete √Ñnderungen",
                "text": "Nicht-const Referenzparameter k√∂nnen Seiteneffekte verursachen."
              },
              {
                "type": "important",
                "text": "Standardregel: √úbergabe per Wert f√ºr kleine Typen, per const Referenz f√ºr gro√üe Typen."
              },
              {
                "type": "summary",
                "points": [
                  "Referenzparameter greifen direkt auf Argumente zu",
                  "Sie vermeiden Kopien",
                  "Nicht-const Referenzen erlauben √Ñnderungen",
                  "const Referenzen verhindern Seiteneffekte",
                  "Referenzparameter sind sicherer als Zeiger"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Speicherverwaltung",
    "icon": "üíæ",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üíæ",
        "topics": [
          {
            "title": "Stack vs. Heap",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Speicherverwaltung",
                "text": "Mechanismen zur Reservierung und Freigabe von Speicher f√ºr Variablen und Objekte."
              },
              {
                "type": "definition",
                "term": "Stack",
                "text": "Automatischer Speicherbereich f√ºr lokale Variablen mit klar definierter Lebensdauer."
              },
              {
                "type": "definition",
                "term": "Heap",
                "text": "Dynamischer Speicherbereich f√ºr Objekte mit frei bestimmbarer Lebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Stack Speicher",
                "text": [
                  "Stack Speicher wird automatisch verwaltet.",
                  "Variablen werden beim Betreten eines G√ºltigkeitsbereichs angelegt und beim Verlassen automatisch freigegeben."
                ]
              },
              {
                "type": "code",
                "title": "Stack Beispiel",
                "language": "cpp",
                "code": "void foo() {\n    int x = 5;   // liegt auf dem Stack\n} // x wird hier automatisch zerst√∂rt"
              },
              {
                "type": "explanation",
                "title": "Grundidee von Heap Speicher",
                "text": [
                  "Heap Speicher wird manuell angefordert und freigegeben.",
                  "Objekte auf dem Heap leben so lange, bis sie explizit freigegeben werden.",
                  "Der Heap ist nicht an Blockgrenzen oder Funktionslebensdauer gebunden.",
                  "Heap Speicher ist flexibler, aber fehleranf√§lliger als Stack Speicher."
                ]
              },
              {
                "type": "code",
                "title": "Heap Grundprinzip",
                "language": "cpp",
                "code": "int* p = new int(5); // Speicher auf dem Heap\n// p zeigt auf ein Heap Objekt"
              },
              {
                "type": "comparison",
                "title": "Stack vs. Heap",
                "columns": ["Stack", "Heap"],
                "rows": [
                  {
                    "aspect": "Verwaltung",
                    "values": ["Automatisch", "Manuell"]
                  },
                  {
                    "aspect": "Lebensdauer",
                    "values": ["An G√ºltigkeitsbereich gebunden", "Beliebig steuerbar"]
                  },
                  {
                    "aspect": "Geschwindigkeit",
                    "values": ["Sehr schnell", "Langsamer"]
                  },
                  {
                    "aspect": "Fehleranf√§lligkeit",
                    "values": ["Gering", "Hoch"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Heap Speicher vergessen freizugeben",
                "text": "Nicht freigegebener Heap Speicher f√ºhrt zu Speicherlecks."
              },
              {
                "type": "important",
                "text": "Stack wann immer m√∂glich nutzen, Heap nur wenn n√∂tig."
              },
              {
                "type": "summary",
                "points": [
                  "Stack Speicher ist automatisch und sicher",
                  "Heap Speicher ist flexibel, aber manuell zu verwalten",
                  "Heap Objekte leben unabh√§ngig von Funktionen",
                  "Fehler im Heap f√ºhren oft zu schwer findbaren Bugs"
                ]
              }
            ]
          },
          {
            "title": "new & delete",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "new",
                "text": "Operator zum Anfordern von Speicher auf dem Heap und zum Erzeugen eines Objekts."
              },
              {
                "type": "definition",
                "term": "delete",
                "text": "Operator zum Freigeben von mit new reserviertem Heap Speicher."
              },
              {
                "type": "explanation",
                "title": "Grundprinzip von new und delete",
                "text": [
                  "new reserviert Speicher und ruft den Konstruktor auf.",
                  "delete ruft den Destruktor auf und gibt den Speicher frei."
                ]
              },
              {
                "type": "code",
                "title": "Einfaches new und delete",
                "language": "cpp",
                "code": "int* p = new int(10); // Heap Speicher\n// Nutzung von *p\ndelete p;              // Speicher freigeben\np = nullptr;           // guter Stil"
              },
              {
                "type": "definition",
                "term": "Speicherleck",
                "text": "Nicht freigegebener Heap Speicher, der nicht mehr erreichbar ist."
              },
              {
                "type": "pitfall",
                "title": "delete vergessen",
                "text": "Wird delete nicht aufgerufen, bleibt der Speicher bis Programmende belegt."
              },
              {
                "type": "definition",
                "term": "new[]",
                "text": "Reserviert Speicher f√ºr ein Array auf dem Heap."
              },
              {
                "type": "definition",
                "term": "delete[]",
                "text": "Gibt Speicher frei, der mit new[] reserviert wurde."
              },
              {
                "type": "code",
                "title": "new[] und delete[]",
                "language": "cpp",
                "code": "int* arr = new int[3]; // Array auf dem Heap\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n\ndelete[] arr;          // korrektes Freigeben"
              },
              {
                "type": "pitfall",
                "title": "new[] mit delete",
                "text": "new[] und delete m√ºssen zusammen verwendet werden, genauso new und delete[]."
              },
              {
                "type": "code",
                "title": "Falsche Kombination",
                "language": "cpp",
                "code": "int* arr = new int[5];\n// delete arr; // falsch, f√ºhrt zu undefiniertem Verhalten"
              },
              {
                "type": "explanation",
                "title": "Warum new[] und delete[] zusammengeh√∂ren",
                "text": [
                  "Bei new[] m√ºssen mehrere Destruktoren aufgerufen werden.",
                  "delete[] wei√ü, wie viele Elemente zerst√∂rt werden m√ºssen."
                ]
              },
              {
                "type": "definition",
                "term": "Dangling Pointer",
                "text": "Ein Zeiger, der auf bereits freigegebenen Speicher zeigt."
              },
              {
                "type": "pitfall",
                "title": "Dangling Pointer",
                "text": "Zugriff auf freigegebenen Speicher f√ºhrt zu undefiniertem Verhalten."
              },
              {
                "type": "important",
                "text": "In modernem C++ sollten new und delete m√∂glichst durch Container und Smart Pointer ersetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "new reserviert Heap Speicher",
                  "delete gibt Heap Speicher frei",
                  "new[] erfordert delete[]",
                  "Vergessenes delete verursacht Speicherlecks",
                  "Dangling Pointer sind extrem gef√§hrlich"
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "RAII & Smart Pointer",
        "icon": "üß†",
        "topics": [
          {
            "title": "RAII Prinzip",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "RAII",
                "text": "RAII steht f√ºr Resource Acquisition Is Initialization und koppelt Ressourcen an Objektlebensdauer."
              },
              {
                "type": "explanation",
                "title": "Grundidee von RAII",
                "text": [
                  "Eine Ressource wird im Konstruktor eines Objekts erworben.",
                  "Die Freigabe erfolgt automatisch im Destruktor, wenn das Objekt den G√ºltigkeitsbereich verl√§sst."
                ]
              },
              {
                "type": "definition",
                "term": "Ressource",
                "text": "Alles, was explizit angefordert und freigegeben werden muss, zum Beispiel Speicher, Dateien oder Mutexes."
              },
              {
                "type": "code",
                "title": "RAII mit Speicher",
                "language": "cpp",
                "code": "class Buffer {\nprivate:\n    int* data;\n\npublic:\n    Buffer() {\n        data = new int[10]; // Ressource erwerben\n    }\n\n    ~Buffer() {\n        delete[] data;      // Ressource freigeben\n    }\n};"
              },
              {
                "type": "explanation",
                "title": "Vorteile von RAII",
                "text": [
                  "Automatische Freigabe auch bei return oder Exceptions.",
                  "Kein explizites Aufr√§umen im Code n√∂tig."
                ]
              },
              {
                "type": "pitfall",
                "title": "RAII umgehen",
                "text": "Manuelles new und delete au√üerhalb von RAII Klassen untergr√§bt das Prinzip."
              },
              {
                "type": "important",
                "text": "RAII ist das zentrale Speicherverwaltungsprinzip in modernem C++."
              },
              {
                "type": "summary",
                "points": [
                  "Ressourcen sind an Objekte gebunden",
                  "Konstruktor erwirbt, Destruktor gibt frei",
                  "Sicher bei Exceptions",
                  "Grundlage f√ºr Smart Pointer"
                ]
              }
            ]
          },
          {
            "title": "Smart Pointer",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "Smart Pointer",
                "text": "Objekte, die Zeiger kapseln und Speicher automatisch nach RAII verwalten."
              },
              {
                "type": "explanation",
                "title": "Grundidee von Smart Pointern",
                "text": [
                  "Smart Pointer ersetzen rohe Zeiger mit automatischer Speicherfreigabe.",
                  "Sie verhindern Speicherlecks und Dangling Pointer."
                ]
              },
              {
                "type": "definition",
                "term": "std::unique_ptr",
                "text": [
                  "Ein Smart Pointer mit exklusivem Besitz an einer Ressource.", 
                  " Objekt wird beim Verlassen des Scopes automatisch gel√∂scht"
                ]
              },
              {
                "type": "code",
                "title": "unique_ptr Beispiel",
                "language": "cpp",
                "code": "#include <memory>\n\nstd::unique_ptr<int> p = std::make_unique<int>(5);\n// kein delete n√∂tig"
              },
              {
                "type": "definition",
                "term": "Move Semantik",
                "text": "√úbertr√§gt Besitz einer Ressource von einem Objekt auf ein anderes."
              },
              {
                "type": "code",
                "title": "unique_ptr verschieben",
                "language": "cpp",
                "code": "std::unique_ptr<int> a = std::make_unique<int>(3);\nstd::unique_ptr<int> b = std::move(a); // Besitzwechsel"
              },
              {
                "type": "definition",
                "term": "std::shared_ptr",
                "text": "Ein Smart Pointer mit gemeinsamem Besitz und Referenzz√§hlung. Automatische L√∂schung, wenn alle Kopien verschwinden."
              },
              {
                "type": "code",
                "title": "shared_ptr Beispiel",
                "language": "cpp",
                "code": "#include <memory>\n\nstd::shared_ptr<int> p1 = std::make_shared<int>(10);\nstd::shared_ptr<int> p2 = p1; // geteilter Besitz"
              },
              {
                "type": "explanation",
                "title": "Referenzz√§hlung bei std::shared_ptr",
                "text": [
                  "std::shared_ptr verwaltet eine Ressource √ºber eine interne Referenzz√§hlung.",
                  "Die Ressource wird automatisch freigegeben, wenn die Referenzz√§hlung auf null f√§llt."
                ]
              },
              {
                "type": "definition",
                "term": "use_count",
                "text": "Gibt die aktuelle Anzahl der shared_ptr zur√ºck, die dieselbe Ressource besitzen."
              },
              {
                "type": "code",
                "title": "Referenzz√§hlung abfragen",
                "language": "cpp",
                "code": "std::shared_ptr<int> p1 = std::make_shared<int>(42);\nstd::shared_ptr<int> p2 = p1;\n\nstd::size_t count = p1.use_count(); // count ist 2"
              },
              {
                "type": "note",
                "variant": "info",
                "text": "use_count dient nur zur Diagnose. Logik sollte nicht davon abh√§ngig gemacht werden."
              },
              {
                "type": "definition",
                "term": "reset",
                "text": "L√∂st einen shared_ptr von seiner Ressource und verringert die Referenzz√§hlung."
              },
              {
                "type": "code",
                "title": "shared_ptr freigeben",
                "language": "cpp",
                "code": "std::shared_ptr<int> p = std::make_shared<int>(5);\n\np.reset(); // Referenzz√§hlung wird reduziert\n// wenn dies der letzte shared_ptr war, wird die Ressource gel√∂scht"
              },
              {
                "type": "explanation",
                "title": "Wann wird die Ressource gel√∂scht",
                "text": [
                  "Die Ressource wird automatisch zerst√∂rt, sobald der letzte shared_ptr sie freigibt.",
                  "Das kann durch reset oder durch Verlassen des G√ºltigkeitsbereichs passieren."
                ]
              },
              {
                "type": "important",
                "text": "shared_ptr Speicher wird niemals manuell gel√∂scht, sondern immer √ºber Referenzz√§hlung."
              },
              {
                "type": "definition",
                "term": "std::weak_ptr",
                "text": "Ein nicht-besitzender Smart Pointer zur Beobachtung eines shared_ptr ohne den Z√§hler zu erh√∂hen."
              },
              {
                "type": "code",
                "title": "weak_ptr Beispiel",
                "language": "cpp",
                "code": "std::weak_ptr<int> w = p1;\nif (auto sp = w.lock()) {\n    // Ressource existiert noch\n}"
              },
              {
                "type": "explanation",
                "title": "weak_ptr::lock",
                "text": [
                  "lock erzeugt aus einem std::weak_ptr tempor√§r einen std::shared_ptr.",
                  "Existiert die verwaltete Ressource noch, liefert lock einen g√ºltigen shared_ptr.",
                  "Wurde die Ressource bereits freigegeben, liefert lock einen leeren shared_ptr."
                ]
              },
              {
                "type": "pitfall",
                "title": "Zyklische Referenzen",
                "text": "shared_ptr Zyklen verhindern automatische Freigabe ohne weak_ptr."
              },
              {
                "type": "important",
                "text": "unique_ptr ist Standardwahl, shared_ptr nur bei echtem geteiltem Besitz."
              },
              {
                "type": "summary",
                "points": [
                  "Smart Pointer implementieren RAII",
                  "unique_ptr f√ºr exklusiven Besitz",
                  "shared_ptr f√ºr geteilten Besitz",
                  "weak_ptr bricht Besitzzyklen",
                  "Rohzeiger m√∂glichst vermeiden"
                ]
              }
            ]
          }
        ]
      }
    ]
  },

  {
    "category": "Header & Bibliotheken",
    "icon": "üìö",
    "subcategories": [
      {
      "name": "Ein- und Ausgabe",
      "icon": "üñ®Ô∏è",
      "topics": [
        {
          "title": "iostream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<iostream>",
              "text": "Header f√ºr Ein und Ausgabe √ºber die Konsole."
            },
            {
              "type": "explanation",
              "title": "Zweck von <iostream>",
              "text": [
                "<iostream> stellt die grundlegenden Standard Streams f√ºr die Konsole bereit.",
                "Er wird f√ºr Benutzereingaben, Ausgaben und einfache Debugzwecke verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Streams",
              "items": [
                "std::cin: Standardeingabe",
                "std::cout: Standardausgabe",
                "std::cerr: Fehlerausgabe ‚Üí ungepuffert ‚Üí sofort sichtbar",
                "std::clog: Protokollausgabe ‚Üí gepuffert ‚Üí bei Flush oder Ende sichtbar"
              ]
            },
            {
              "type": "code",
              "title": "Standard Ein und Ausgabe mit cin und cout",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int x;\n\n    std::cin >> x;               // Liest eine Zahl von der Standardeingabe\n    std::cout << x << '\\n';      // Gibt die Zahl auf der Standardausgabe aus\n}\n"
            },
            {
              "type": "code",
              "title": "Fehlerausgabe mit cerr ‚Üí ungepuffert ‚Üí sofort sichtbar",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    int x;\n\n    // Versuch, eine Zahl einzulesen\n    if (!(std::cin >> x)) {\n        // std::cerr ist f√ºr Fehlermeldungen gedacht\n        // Die Ausgabe ist ungepuffert und erscheint sofort\n        // Auch wenn die normale Ausgabe (cout) umgeleitet ist\n        std::cerr << \"Fehler: Ung√ºltige Eingabe\" << std::endl;\n        // Typische Ausgabe auf stderr:\n        // Fehler: Ung√ºltige Eingabe\n        return 1;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Log-Ausgabe mit clog ‚Üí gepuffert ‚Üí bei Flush oder Ende sichtbar",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    // std::clog ist f√ºr Log- und Statusmeldungen gedacht\n    // Die Ausgabe ist gepuffert (effizienter als cerr)\n    std::clog << \"Programmstart\" << std::endl;\n    // Typische Ausgabe auf stderr (gepuffert):\n    // Programmstart\n\n    int x = 42;\n\n    // Log-Meldung √ºber internen Zustand\n    std::clog << \"Verarbeite Wert: \" << x << std::endl;\n    // Typische Ausgabe:\n    // Verarbeite Wert: 42\n}\n"
            },
            {
              "type": "code",
              "title": "Vergleich von cout, cerr und clog",
              "language": "cpp",
              "code": "#include <iostream>\n\nint main() {\n    std::cout << \"Normale Ausgabe\" << std::endl;\n    std::clog << \"Log Meldung\" << std::endl;\n    std::cerr << \"Fehlermeldung\" << std::endl;\n}\n"
            },
            {
              "type": "important",
              "text": "<iostream> ist die Basis f√ºr nahezu jede Konsolenanwendung."
            },
            {
              "type": "summary",
              "points": [
                "Grundlegender Ein und Ausgabe Header",
                "Arbeitet mit Streams",
                "cin liest, cout schreibt",
                "cerr f√ºr Fehlermeldungen"
              ]
            }
          ]
        },
        {
          "title": "fstream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<fstream>",
              "text": "Header f√ºr dateibasierte Ein und Ausgabe."
            },
            {
              "type": "explanation",
              "title": "Zweck von <fstream>",
              "text": [
                "<fstream> erlaubt das Lesen aus und Schreiben in Dateien.",
                "Er nutzt dasselbe Stream Prinzip wie <iostream>, aber mit Dateien statt Konsole."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Klassen",
              "items": [
                "std::ifstream: Datei lesen",
                "std::ofstream: Datei schreiben",
                "std::fstream: Lesen und Schreiben"
              ]
            },
            {
              "type": "code",
              "title": "Datei schreiben mit ofstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    // ofstream = output file stream (nur schreiben)\n    std::ofstream file(\"daten.txt\");\n\n    // Pr√ºfen, ob die Datei erfolgreich ge√∂ffnet wurde\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    // Schreiben funktioniert wie bei std::cout\n    file << \"Hallo Datei\" << std::endl;\n    file << 42 << std::endl;\n\n    // Datei explizit schlie√üen (optional, passiert auch im Destruktor)\n    file.close();\n\n    // Typischer Inhalt von daten.txt:\n    // Hallo Datei\n    // 42\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen mit ifstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    // ifstream = input file stream (nur lesen)\n    std::ifstream file(\"daten.txt\");\n\n    // Pr√ºfen, ob die Datei existiert und ge√∂ffnet werden konnte\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    std::string line;\n\n    // Zeilenweises Lesen bis Dateiende\n    while (std::getline(file, line)) {\n        std::cout << line << std::endl;\n    }\n\n    // Datei schlie√üen (optional)\n    file.close();\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen und schreiben mit fstream",
              "language": "cpp",
              "code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    // fstream kann lesen UND schreiben\n    std::fstream file(\"log.txt\", std::ios::in | std::ios::out | std::ios::app);\n\n    // ios::app -> Schreiben immer ans Dateiende\n\n    if (!file) {\n        std::cerr << \"Fehler: Datei konnte nicht ge√∂ffnet werden\" << std::endl;\n        return 1;\n    }\n\n    // Schreiben in die Datei\n    file << \"Neue Log-Zeile\" << std::endl;\n\n    // Zur√ºck an den Anfang springen, um zu lesen\n    file.seekg(0);\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::cout << line << std::endl;\n    }\n\n    file.close();\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Datei nicht gepr√ºft",
              "text": "Wird der √ñffnungszustand nicht gepr√ºft, k√∂nnen Lese oder Schreibfehler unbemerkt bleiben."
            },
            {
              "type": "summary",
              "points": [
                "Dateibasierte Streams",
                "ifstream f√ºr Lesen",
                "ofstream f√ºr Schreiben",
                "fstream f√ºr beides"
              ]
            }
          ]
        },
        {
          "title": "iomanip",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<iomanip>",
              "text": "Header mit Manipulatoren zur Steuerung der Ausgabeformatierung."
            },
            {
              "type": "explanation",
              "title": "Einsatzgebiet von <iomanip>",
              "text": [
                "<iomanip> ver√§ndert, wie Werte ausgegeben werden, nicht die Werte selbst.",
                "Er wird h√§ufig f√ºr saubere Konsolenausgaben und Tabellen verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Manipulatoren",
              "items": [
                "std::setw: Feldbreite setzen",
                "std::setprecision: Anzahl der Stellen",
                "std::fixed: feste Nachkommastellen",
                "std::left / std::right: Ausrichtung",
                "std::put_time: Zeitangaben formatieren",
                "std::boolalpha: true/false als Text"
              ]
            },
            {
              "type": "code",
              "title": "Feste Nachkommastellen",
              "language": "cpp",
              "code": "#include <iomanip>\n\nstd::cout << std::fixed << std::setprecision(2) << 3.14159; // 3.14"
            },
            {
              "type": "code",
              "title": "Feldbreite und Ausrichtung",
              "language": "cpp",
              "code": "std::cout << std::setw(10) << std::right << 42;\nstd::cout << std::setw(10) << std::left << 42;"
            },
            {
              "type": "code",
              "title": "Tabellenartige Ausgabe",
              "language": "cpp",
              "code": "std::cout << std::setw(10) << \"Name\"\n          << std::setw(5) << \"Age\" << '\\n';\n\nstd::cout << std::setw(10) << \"Anna\"\n          << std::setw(5) << 23 << '\\n';"
            },
            {
              "type": "code",
              "title": "boolalpha verwenden",
              "language": "cpp",
              "code": "bool flag = true;\nstd::cout << std::boolalpha << flag; // gibt \"true\" aus"
            },
            {
              "type": "code",
              "title": "Manipulatoren kombinieren",
              "language": "cpp",
              "code": "double x = 12.3456;\nstd::cout << std::setw(8)\n          << std::fixed\n          << std::setprecision(1)\n          << x;"
            },
            {
              "type": "code",
              "title": "Datum und Uhrzeit mit put_time",
              "language": "cpp",
              "code": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr);\n    std::tm* local = std::localtime(&now);\n\n    std::cout << std::put_time(local, \"%d.%m.%Y %H:%M:%S\"); // z.B. 20.12.2025 14:32:10\n}\n"
            },
            {
              "type": "explanation",
              "title": "put_time",
              "text": [
                "std::put_time formatiert Zeitangaben aus einer tm Struktur f√ºr die Ausgabe.",
                "Das Format folgt den gleichen Platzhaltern wie strftime aus der C Bibliothek."
              ]
            },
            {
              "type": "pitfall",
              "title": "Abh√§ngigkeit von <ctime>",
              "text": "put_time ben√∂tigt eine gueltige tm Struktur, die meist aus <ctime> stammt."
            },
            {
              "type": "important",
              "text": "put_time ist der empfohlene Weg zur formatierten Zeit Ausgabe mit Streams."
            },
            {
              "type": "summary",
              "points": [
                "Manipulatoren steuern die Darstellung",
                "setw f√ºr Spaltenbreite",
                "setprecision und fixed f√ºr Zahlen",
                "put_time f√ºr formatierte Zeit Ausgabe",
                "Formatierung wirkt auf den Stream"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "String Header",
      "icon": "üßµ",
      "topics": [
          {
            "title": "string",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<string>",
                "text": "Der Header <string> stellt die Klasse std::string und zugeh√∂rige Funktionen f√ºr sichere und dynamische Zeichenketten bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<string> bietet eine moderne Alternative zu C-Strings und kapselt Speicherverwaltung sowie L√§ngenverwaltung vollst√§ndig.",
                  "Strings k√∂nnen sicher kopiert, verglichen, erweitert und ver√§ndert werden."
                ]
              },
              {
                "type": "explanation",
                "title": "std::string",
                "text": [
                  "std::string repr√§sentiert eine ver√§nderbare Folge von Zeichen mit bekannter L√§nge.",
                  "Der Typ verwaltet seinen Speicher selbst und verhindert viele typische Fehler aus der C-Welt."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Funktionen und Methoden",
                "items": [
                  "size() / length() - Anzahl der Zeichen",
                  "empty() - pr√ºft ob der String leer ist",
                  "operator[] / at() - Zugriff auf einzelne Zeichen",
                  "append(), operator+= - Anh√§ngen von Text",
                  "substr(pos, len) - Teilstring erzeugen",
                  "find(str) - Suche nach Teilstrings",
                  "c_str() - Zugriff auf C-String Darstellung"
                ]
              },
              {
                "type": "code",
                "title": "Grundlegende Verwendung",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s = \"Hallo\";          // Initialisierung\n    s += \" Welt\";                     // Anh√§ngen\n\n    std::cout << s << std::endl;       // Ausgabe: Hallo Welt\n    std::cout << s.size() << std::endl; // Ausgabe der L√§nge\n}\n"
              },
              {
                "type": "code",
                "title": "Zugriff und Teilstrings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string text = \"Informatik\";\n\n    char c = text[0];                  // Zugriff ohne Bereichspr√ºfung\n    char d = text.at(1);               // Zugriff mit Pr√ºfung\n\n    std::string sub = text.substr(0, 4); // \"Info\"\n\n    std::cout << c << \" \" << d << \" \" << sub << std::endl;\n}\n"
              },
              {
                "type": "comparison",
                "title": "std::string vs C-String",
                "columns": ["std::string", "char*"],
                "rows": [
                  {
                    "aspect": "Speicherverwaltung",
                    "values": ["Automatisch", "Manuell"]
                  },
                  {
                    "aspect": "L√§ngeninformation",
                    "values": ["Direkt verf√ºgbar", "Nur durch strlen"]
                  },
                  {
                    "aspect": "Sicherheit",
                    "values": ["Hoch", "Fehleranf√§llig"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "operator[] ohne Pr√ºfung",
                "text": "Der Zugriff mit operator[] pr√ºft keine Grenzen und kann bei falschen Indizes zu undefiniertem Verhalten f√ºhren."
              },
              {
                "type": "important",
                "text": "In modernem C++ sollte std::string fast immer gegen√ºber C-Strings bevorzugt werden."
              },
              {
                "type": "summary",
                "points": [
                  "<string> stellt std::string bereit",
                  "Automatische Speicherverwaltung erh√∂ht Sicherheit",
                  "Bietet umfangreiche String-Operationen"
                ]
              }
            ]
          },
          {
            "title": "string_view",
            "difficulty": "intermediate",
            "blocks": [
              {
                "type": "definition",
                "term": "<string_view>",
                "text": "Der Header <string_view> stellt den Typ std::string_view bereit, der eine nicht-besitzende Sicht auf eine Zeichenkette beschreibt."
              },
              {
                "type": "explanation",
                "title": "Grundidee",
                "text": [
                  "std::string_view speichert lediglich einen Zeiger auf Zeichen und eine L√§nge, besitzt aber keinen eigenen Speicher.",
                  "Dadurch k√∂nnen Strings effizient gelesen und weitergereicht werden, ohne Kopien zu erzeugen."
                ]
              },
              {
                "type": "explanation",
                "title": "Typische Einsatzszenarien",
                "text": [
                  "Funktionsparameter f√ºr nur-lesenden Zugriff auf Strings.",
                  "Arbeiten mit Teilstrings ohne Erzeugung neuer std::string Objekte."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Eigenschaften",
                "items": [
                  "Kein Besitz am Speicher",
                  "Konstante Zeit f√ºr Kopieren und Zuweisung",
                  "Kann aus std::string, C-String und String-Literalen erstellt werden",
                  "Nur lesender Zugriff auf die Zeichen"
                ]
              },
              {
                "type": "code",
                "title": "Verwendung als Funktionsparameter",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string>\n#include <string_view>\n\nvoid print(std::string_view sv) {\n    std::cout << sv << std::endl; // Gibt den betrachteten String aus\n}\n\nint main() {\n    std::string s = \"Hallo Welt\";\n    print(s);                     // Keine Kopie von s\n    print(\"C++\");                // Auch String-Literale sind erlaubt\n}\n"
              },
              {
                "type": "code",
                "title": "Teilstring ohne Kopie",
                "language": "cpp",
                "code": "#include <iostream>\n#include <string_view>\n\nint main() {\n    std::string_view sv = \"Informatik\";\n    std::string_view sub = sv.substr(0, 4); // Sicht auf \"Info\"\n\n    std::cout << sub << std::endl;           // Ausgabe: Info\n}\n"
              },
              {
                "type": "comparison",
                "title": "std::string_view vs std::string",
                "columns": ["std::string_view", "std::string"],
                "rows": [
                  {
                    "aspect": "Speicherbesitz",
                    "values": ["Nein", "Ja"]
                  },
                  {
                    "aspect": "Kopierkosten",
                    "values": ["Sehr gering", "Abh√§ngig von L√§nge"]
                  },
                  {
                    "aspect": "Ver√§nderbarkeit",
                    "values": ["Nein", "Ja"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Lebensdauerproblem",
                "text": "Ein std::string_view wird ung√ºltig, sobald der zugrunde liegende String zerst√∂rt oder ver√§ndert wird."
              },
              {
                "type": "important",
                "text": "std::string_view eignet sich ideal f√ºr nur-lesenden Zugriff, darf aber niemals l√§nger leben als der referenzierte String."
              },
              {
                "type": "summary",
                "points": [
                  "<string_view> bietet eine effiziente String-Sicht",
                  "Keine Speicherverwaltung, keine Kopien",
                  "Lebensdauer des Original-Strings ist entscheidend"
                ]
              }
            ]
          },
          {
          "title": "sstream",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<sstream>",
              "text": "Header f√ºr String Streams, mit denen Strings wie Ein und Ausgabestr√∂me behandelt werden."
            },
            {
              "type": "explanation",
              "title": "Einsatzgebiet von <sstream>",
              "text": [
                "<sstream> wird genutzt, um Text sicher in andere Datentypen umzuwandeln oder strukturiert zusammenzusetzen.",
                "Er ist besonders hilfreich beim Parsen von Eingaben oder beim Erzeugen formatierter Strings."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Klassen",
              "items": [
                "std::stringstream: Lesen und Schreiben",
                "std::istringstream: Nur Lesen aus Strings",
                "std::ostringstream: Nur Schreiben in Strings"
              ]
            },
            {
              "type": "code",
              "title": "String zu Zahl umwandeln",
              "language": "cpp",
              "code": "#include <sstream>\n\nstd::string text = \"42\";\nstd::stringstream ss(text);\nint value;\nss >> value; // value ist 42"
            },
            {
              "type": "code",
              "title": "Mehrere Werte aus einem String lesen",
              "language": "cpp",
              "code": "std::string line = \"10 20 30\";\nstd::istringstream iss(line);\nint a, b, c;\niss >> a >> b >> c; // a=10, b=20, c=30"
            },
            {
              "type": "code",
              "title": "Zahl zu String erzeugen",
              "language": "cpp",
              "code": "std::ostringstream oss;\noss << 3.14;\nstd::string result = oss.str(); // \"3.14\""
            },
            {
              "type": "code",
              "title": "Komplexen String zusammensetzen",
              "language": "cpp",
              "code": "int id = 5;\nstd::string name = \"Max\";\n\nstd::ostringstream oss;\noss << \"ID=\" << id << \", Name=\" << name;\nstd::string output = oss.str();"
            },
            {
              "type": "pitfall",
              "title": "stringstream wiederverwenden",
              "text": "Beim Wiederverwenden muss der Streaminhalt und der Zustand zur√ºckgesetzt werden."
            },
            {
              "type": "important",
              "text": "<sstream> ist die sichere Alternative zu manueller String Verarbeitung."
            },
            {
              "type": "summary",
              "points": [
                "Strings k√∂nnen wie Streams gelesen werden",
                "Ideal f√ºr Parsen und Typumwandlungen",
                "ostringstream zum Erzeugen von Text",
                "Sicherer als C Funktionen"
              ]
            }
            ]
          },
          {
            "title": "cstring",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<cstring>",
                "text": "Der Header <cstring> stellt Funktionen zur Arbeit mit nullterminierten C-Strings und rohen Speicherbereichen bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<cstring> ist die C++ Variante des C-Headers string.h und enth√§lt niedrigstufige String- und Speicherfunktionen.",
                  "Die Funktionen arbeiten mit char-Arrays und setzen ein korrekt gesetztes Nullterminierungszeichen voraus."
                ]
              },
              {
                "type": "explanation",
                "title": "C-Strings",
                "text": [
                  "Ein C-String ist ein Array von char, das mit dem Zeichen '\\0' endet.",
                  "Die L√§nge wird nicht gespeichert, sondern zur Laufzeit durch Suchen des Terminators bestimmt."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige String-Funktionen",
                "items": [
                  "strlen(str) - L√§nge eines C-Strings ohne '\\0'",
                  "strcpy(dest, src) - kopiert einen String",
                  "strncpy(dest, src, n) - kopiert maximal n Zeichen",
                  "strcmp(a, b) - vergleicht zwei Strings",
                  "strcat(dest, src) - h√§ngt Strings aneinander"
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Speicherfunktionen",
                "items": [
                  "memcpy(dest, src, n) - kopiert n Bytes Speicher",
                  "memmove(dest, src, n) - sicheres Kopieren bei √úberlappung",
                  "memset(ptr, value, n) - setzt Speicher auf einen Wert",
                  "memcmp(a, b, n) - vergleicht Speicherbereiche"
                ]
              },
              {
                "type": "code",
                "title": "L√§nge und Vergleich von C-Strings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    const char a[] = \"Hallo\";\n    const char b[] = \"Welt\";\n\n    std::cout << std::strlen(a) << std::endl; // Ausgabe: 5\n    std::cout << std::strcmp(a, b) << std::endl; // Ungleich 0, da verschieden\n}\n"
              },
              {
                "type": "code",
                "title": "Kopieren von Strings",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    char dest[10];\n    const char src[] = \"C++\";\n\n    std::strcpy(dest, src);           // Kopiert inkl. '\\0'\n    std::cout << dest << std::endl;   // Ausgabe: C++\n}\n"
              },
              {
                "type": "code",
                "title": "Arbeiten mit Speicherfunktionen",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cstring>\n\nint main() {\n    int a[3] = {1, 2, 3};\n    int b[3];\n\n    std::memcpy(b, a, sizeof(a));     // Kopiert rohe Bytes\n    std::cout << b[0] << std::endl;   // Ausgabe: 1\n}\n"
              },
              {
                "type": "comparison",
                "title": "memcpy vs memmove",
                "columns": ["memcpy", "memmove"],
                "rows": [
                  {
                    "aspect": "√úberlappende Speicherbereiche",
                    "values": ["Nicht erlaubt", "Erlaubt"]
                  },
                  {
                    "aspect": "Performance",
                    "values": ["Meist schneller", "Etwas langsamer"]
                  }
                ]
              },
              {
                "type": "pitfall",
                "title": "Fehlendes Nullterminierungszeichen",
                "text": "Fehlt das abschlie√üende '\\0', lesen Funktionen wie strlen oder strcpy √ºber das Arrayende hinaus."
              },
              {
                "type": "important",
                "text": "Funktionen aus <cstring> sind fehleranf√§llig und sollten in modernem C++ m√∂glichst durch std::string ersetzt werden."
              },
              {
                "type": "summary",
                "points": [
                  "<cstring> arbeitet mit C-Strings und rohem Speicher",
                  "Keine automatische L√§ngen oder Speicherverwaltung",
                  "Hohe Fehleranf√§lligkeit bei falscher Nutzung"
                ]
              }
            ]
          },
          {
            "title": "cctype",
            "difficulty": "basic",
            "blocks": [
              {
                "type": "definition",
                "term": "<cctype>",
                "text": "Der Header <cctype> stellt Funktionen zur Klassifikation und einfachen Umwandlung einzelner Zeichen bereit."
              },
              {
                "type": "explanation",
                "title": "Zweck des Headers",
                "text": [
                  "<cctype> ist die C++ Variante des C-Headers ctype.h und arbeitet auf einzelnen Zeichen.",
                  "Die Funktionen werden h√§ufig beim Parsen von Text, bei Validierungen und einfachen Analysen eingesetzt."
                ]
              },
              {
                "type": "explanation",
                "title": "Funktionsprinzip",
                "text": [
                  "Die Funktionen pr√ºfen Eigenschaften eines Zeichens wie Ziffer, Buchstabe oder Leerzeichen.",
                  "R√ºckgabewerte sind ganzzahlig, werden aber logisch wie bool verwendet."
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Pr√ºf-Funktionen",
                "items": [
                  "std::isdigit(c) - pr√ºft ob c eine Ziffer ist",
                  "std::isalpha(c) - pr√ºft ob c ein Buchstabe ist",
                  "std::isalnum(c) - pr√ºft ob c Buchstabe oder Ziffer ist",
                  "std::isspace(c) - pr√ºft ob c ein Leerzeichen ist",
                  "std::islower(c) - pr√ºft ob c klein geschrieben ist",
                  "std::isupper(c) - pr√ºft ob c gro√ü geschrieben ist"
                ]
              },
              {
                "type": "list",
                "title": "Wichtige Umwandlungs-Funktionen",
                "items": [
                  "std::tolower(c) - wandelt Zeichen in Kleinbuchstaben um",
                  "std::toupper(c) - wandelt Zeichen in Gro√übuchstaben um"
                ]
              },
              {
                "type": "code",
                "title": "Zeichen klassifizieren",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cctype>\n\nint main() {\n    char c = '7';\n\n    if (std::isdigit(c)) {\n        std::cout << \"Ziffer\" << std::endl; // Wird ausgegeben\n    }\n\n    if (std::isalpha(c)) {\n        std::cout << \"Buchstabe\" << std::endl;\n    }\n}\n"
              },
              {
                "type": "code",
                "title": "Gro√ü- und Kleinschreibung",
                "language": "cpp",
                "code": "#include <iostream>\n#include <cctype>\n\nint main() {\n    char c = 'a';\n\n    char upper = std::toupper(c); // Wandelt in 'A'\n    char lower = std::tolower('Z'); // Wandelt in 'z'\n\n    std::cout << upper << \" \" << lower << std::endl; // Ausgabe: A z\n}\n"
              },
              {
                "type": "pitfall",
                "title": "Vorzeichen von char",
                "text": "Die Funktionen aus <cctype> erwarten unsigned char Werte oder EOF, bei negativem char kann undefiniertes Verhalten auftreten."
              },
              {
                "type": "important",
                "text": "Vor der √úbergabe an <cctype>-Funktionen sollte char bei Bedarf zu unsigned char gecastet werden."
              },
              {
                "type": "summary",
                "points": [
                  "<cctype> klassifiziert und wandelt einzelne Zeichen",
                  "Wichtig f√ºr Parser und Texteingaben",
                  "Achtung bei negativem char Wert"
                ]
              }
            ]
          }
        ]
      },
      {
      "name": "Mathematik & Zufall",
      "icon": "üßÆ",
      "topics": [
        {
          "title": "cmath",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cmath>",
              "text": "Der Header <cmath> stellt mathematische Funktionen f√ºr Gleitkomma- und Ganzzahlberechnungen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cmath> enth√§lt elementare mathematische Funktionen wie Wurzeln, Potenzen, Logarithmen und trigonometrische Funktionen.",
                "Die Funktionen sind gr√∂√ütenteils aus der C-Standardbibliothek √ºbernommen, aber im Namensraum std definiert."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "Numerische Berechnungen in Technik, Physik und Informatik.",
                "Mathematische Transformationen, Simulationen und Auswertungen."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "sqrt(x) - Quadratwurzel",
                "pow(x, y) - Potenzfunktion",
                "",
                "abs(x) - Absolutwert",
                "copysign(a, b) - Betrag von a, Vorzeichen von b",
                "",
                "sin(x), cos(x), tan(x) - Trigonometrische Funktionen",
                "asin(x), acos(x), atan(x) - Trigonometrische Umkehrfunktionen",
                "",
                "log(x) - nat√ºrlicher Logarithmus (ln)",
                "log10(x) - Logarithmus zur Basis 10", 
                "",
                "floor(x) - rundet nach unten",
                "ceil(x) - rundet nach oben",
                "round(x) - rundet zur n√§chsten ganzen Zahl",
                "trunc(x) - schneidet Nachkommastellen ab",
                "",
                "fmin(a, b) - kleinere Zahl (float-sicher)",
                "fmax(a, b) - gr√∂√üere Zahl",
                "isinf(x) - pr√ºft auf ¬±‚àû",
                "isnan(x) - pr√ºft auf NaN"
              ]
            },
            {
              "type": "code",
              "title": "Quadratwurzel und Potenz",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double x = 9.0;\n    double y = 2.0;\n\n    std::cout << std::sqrt(x) << std::endl; // Ausgabe: 3\n    std::cout << std::pow(x, y) << std::endl; // Ausgabe: 81\n}\n"
            },
            {
              "type": "code",
              "title": "Trigonometrische Funktionen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double angle = 3.141592653589793 / 2.0; // pi/2\n\n    std::cout << std::sin(angle) << std::endl; // Ausgabe: 1\n    std::cout << std::cos(angle) << std::endl; // Ausgabe: 0\n}\n"
            },
            {
              "type": "code",
              "title": "Rundungsfunktionen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cmath>\n\nint main() {\n    double v = 3.7;\n\n    std::cout << std::floor(v) << std::endl; // Ausgabe: 3\n    std::cout << std::ceil(v) << std::endl;  // Ausgabe: 4\n    std::cout << std::round(v) << std::endl; // Ausgabe: 4\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Ganzzahlargumente",
              "text": "Viele Funktionen aus <cmath> arbeiten intern mit Gleitkommazahlen, was bei Ganzzahlargumenten zu impliziten Typumwandlungen f√ºhrt."
            },
            {
              "type": "important",
              "text": "Trigonometrische Funktionen erwarten Winkel immer im Bogenma√ü, nicht in Grad."
            },
            {
              "type": "summary",
              "points": [
                "<cmath> stellt mathematische Standardfunktionen bereit",
                "Funktionen liegen im Namensraum std",
                "Trigonometrische Funktionen arbeiten mit Bogenma√ü"
              ]
            }
          ]
        },
        {
          "title": "cstdlib",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cstdlib>",
              "text": "Der Header <cstdlib> stellt grundlegende Hilfsfunktionen f√ºr Speicherverwaltung, Zufallszahlen, Programmsteuerung und Konvertierungen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cstdlib> ist die C++ Variante des C-Headers stdlib.h und enth√§lt viele niedrigstufige Standardfunktionen.",
                "Die Funktionen sind im Namensraum std definiert und werden h√§ufig f√ºr systemnahe oder einfache Hilfsaufgaben genutzt."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzgebiete",
              "text": [
                "Erzeugen einfacher Zufallszahlen.",
                "Konvertieren von Strings in numerische Typen oder Beenden eines Programms."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::rand() - erzeugt eine Pseudozufallszahl",
                "std::srand(seed) - initialisiert den Zufallszahlengenerator",
                "std::abs(x) - Absolutwert f√ºr Ganzzahlen",
                "std::atoi(str), std::atof(str) - String zu Zahl Konvertierung",
                "std::exit(code) - sofortiges Beenden des Programms"
              ]
            },
            {
              "type": "code",
              "title": "Zufallszahlen erzeugen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nint main() {\n    std::srand(std::time(nullptr)); // Initialisierung mit aktueller Zeit\n\n    int r = std::rand() % 10;        // Zufallszahl zwischen 0 und 9\n    std::cout << r << std::endl;     // Beispielausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "String zu Ganzzahl konvertieren",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n\nint main() {\n    const char* text = \"123\";\n\n    int value = std::atoi(text);     // Konvertierung nach int\n    std::cout << value << std::endl; // Ausgabe: 123\n}\n"
            },
            {
              "type": "code",
              "title": "Programm beenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <cstdlib>\n\nint main() {\n    std::cout << \"Fehler aufgetreten\" << std::endl;\n    std::exit(1);                    // Beendet das Programm sofort\n}\n"
            },
            {
              "type": "pitfall",
              "title": "atoi und fehlende Fehlerpr√ºfung",
              "text": "std::atoi liefert bei ung√ºltigen Eingaben keinen Fehler, sondern 0, was eine sichere Fehlerbehandlung unm√∂glich macht."
            },
            {
              "type": "important",
              "text": "F√ºr moderne Zufallszahlen sollte <random> statt rand und srand verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "<cstdlib> enth√§lt grundlegende Standardfunktionen",
                "Bietet Zufallszahlen, Konvertierungen und exit",
                "Viele Funktionen sind historisch und nur eingeschr√§nkt sicher"
              ]
            }
          ]
        },
        {
          "title": "random",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<random>",
              "text": "Der Header <random> stellt moderne, flexible und statistisch saubere Zufallszahlengeneratoren und Verteilungen bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<random> trennt klar zwischen Zufallszahlengeneratoren und Wahrscheinlichkeitsverteilungen.",
                "Dadurch ist die Erzeugung reproduzierbarer und qualitativ hochwertiger Zufallszahlen m√∂glich."
              ]
            },
            {
              "type": "explanation",
              "title": "Aufbau des Random-Systems",
              "text": [
                "Ein Generator erzeugt rohe Zufallswerte, zum Beispiel std::mt19937.",
                "Eine Verteilung formt diese Werte in den gew√ºnschten Zahlenbereich oder die gew√ºnschte Statistik um."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Generatoren",
              "items": [
                "std::mt19937 - Mersenne-Twister mit 32 Bit",
                "std::mt19937_64 - Mersenne-Twister mit 64 Bit",
                "std::default_random_engine - Implementierungsabh√§ngiger Standardgenerator"
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Verteilungen",
              "items": [
                "std::uniform_int_distribution - Gleichverteilung ganzer Zahlen",
                "std::uniform_real_distribution - Gleichverteilung reeller Zahlen",
                "std::normal_distribution - Normalverteilung",
                "std::bernoulli_distribution - Wahr oder Falsch mit Wahrscheinlichkeit p"
              ]
            },
            {
              "type": "code",
              "title": "Moderne Zufallszahlen f√ºr ganze Zahlen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::random_device rd;           // Liefert einen nichtdeterministischen Seed\n    std::mt19937 gen(rd());           // Initialisierung des Generators\n    std::uniform_int_distribution<int> dist(1, 6); // Zahlen von 1 bis 6\n\n    int wuerfel = dist(gen);           // Erzeugt eine Zufallszahl\n    std::cout << wuerfel << std::endl; // Beispielausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "Zufallszahlen f√ºr Gleitkommazahlen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::mt19937 gen(42); // Fester Seed f√ºr reproduzierbare Ergebnisse\n    std::uniform_real_distribution<double> dist(0.0, 1.0);\n\n    double value = dist(gen);\n    std::cout << value << std::endl; // Zufallszahl zwischen 0.0 und 1.0\n}\n"
            },
            {
              "type": "code",
              "title": "Normalverteilung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <random>\n\nint main() {\n    std::mt19937 gen(std::random_device{}());\n    std::normal_distribution<double> dist(0.0, 1.0); // Mittelwert 0, Standardabweichung 1\n\n    double x = dist(gen);\n    std::cout << x << std::endl; // Beispielausgabe\n}\n"
            },
            {
              "type": "comparison",
              "title": "Vergleich mit rand",
              "columns": ["<random>", "rand()"],
              "rows": [
                {
                  "aspect": "Qualit√§t",
                  "values": ["Hoch und kontrollierbar", "Gering"]
                },
                {
                  "aspect": "Verteilungen",
                  "values": ["Viele vorhanden", "Nur Gleichverteilung"]
                },
                {
                  "aspect": "Reproduzierbarkeit",
                  "values": ["Gezielt steuerbar", "Unzuverl√§ssig"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Seed mehrfach setzen",
              "text": "Wird der Generator in kurzen Zeitabst√§nden neu ges√§t, k√∂nnen identische Zufallsfolgen entstehen."
            },
            {
              "type": "important",
              "text": "<random> ist der empfohlene Weg f√ºr Zufallszahlen in modernem C++ und ersetzt rand und srand."
            },
            {
              "type": "summary",
              "points": [
                "<random> trennt Generator und Verteilung",
                "Erlaubt hochwertige und reproduzierbare Zufallszahlen",
                "Sollte rand vollst√§ndig ersetzen"
              ]
            }
          ]
        },
        {
          "title": "limits",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<limits>",
              "text": "Der Header <limits> stellt zur Compilezeit abrufbare Eigenschaften fundamentaler Datentypen bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<limits> erlaubt es, Grenzwerte und Eigenschaften von Datentypen wie int, double oder char programmatisch abzufragen.",
                "Dadurch wird Code robuster, portabler und unabh√§ngig von konkreten Plattformannahmen."
              ]
            },
            {
              "type": "explanation",
              "title": "numeric_limits",
              "text": [
                "Die zentrale Schnittstelle ist die Templateklasse std::numeric_limits<T>.",
                "Sie stellt statische Konstanten und Funktionen f√ºr den jeweiligen Typ T bereit."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Eigenschaften",
              "items": [
                "min() - kleinster darstellbarer Wert",
                "max() - gr√∂√üter darstellbarer Wert",
                "lowest() - kleinster darstellbarer Wert inklusive negativer Zahlen",
                "epsilon() - kleinste Differenz bei Gleitkommazahlen",
                "is_integer - pr√ºft ob der Typ ganzzahlig ist",
                "digits - Anzahl der Bin√§rstellen des Typs"
              ]
            },
            {
              "type": "code",
              "title": "Grenzwerte eines int",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<int>::min() << std::endl; // Kleinster int-Wert\n    std::cout << std::numeric_limits<int>::max() << std::endl; // Gr√∂√üter int-Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Gleitkomma Eigenschaften",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<double>::epsilon() << std::endl; // Maschinengenauigkeit\n    std::cout << std::numeric_limits<double>::lowest() << std::endl;  // Kleinster Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Typ Eigenschaften abfragen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <limits>\n\nint main() {\n    std::cout << std::numeric_limits<int>::is_integer << std::endl; // 1 f√ºr int\n    std::cout << std::numeric_limits<double>::is_integer << std::endl; // 0 f√ºr double\n}\n"
            },
            {
              "type": "comparison",
              "title": "min vs lowest",
              "columns": ["min()", "lowest()"],
              "rows": [
                {
                  "aspect": "Ganzzahltypen",
                  "values": ["Kleinster negativer Wert", "Identisch zu min()"]
                },
                {
                  "aspect": "Gleitkommatypen",
                  "values": ["Kleinster positiver Wert", "Kleinster negativer Wert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "min bei double",
              "text": "Bei Gleitkommazahlen liefert min() nicht den negativsten Wert, sondern den kleinsten positiven normalisierten Wert."
            },
            {
              "type": "important",
              "text": "<limits> sollte immer verwendet werden statt fest kodierter Zahlen wie INT_MAX oder magischer Konstanten."
            },
            {
              "type": "summary",
              "points": [
                "<limits> liefert Typgrenzen zur Compilezeit",
                "numeric_limits ist typsicher und portabel",
                "Besonders wichtig f√ºr robuste numerische Programme"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "Zeit & Timing",
      "icon": "‚è±Ô∏è",
      "topics": [
        {
          "title": "chrono",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<chrono>",
              "text": "Der Header <chrono> stellt typsichere Zeitpunkte, Zeitspannen und Uhren f√ºr Zeitmessung und Zeitberechnungen bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<chrono> trennt klar zwischen Zeitpunkten, Zeitdauern und Uhren.",
                "Zeit wird nicht als nackte Zahl behandelt, sondern als eigener Typ mit Einheit."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Konzepte",
              "text": [
                "std::chrono::duration beschreibt eine Zeitspanne wie Sekunden oder Millisekunden.",
                "std::chrono::time_point beschreibt einen konkreten Zeitpunkt relativ zu einer Uhr."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Uhren",
              "items": [
                "std::chrono::steady_clock - monotone Uhr f√ºr Zeitmessungen",
                "std::chrono::system_clock - Systemzeit und Kalenderzeit",
                "std::chrono::high_resolution_clock - m√∂glichst hohe Aufl√∂sung"
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Zeitdauern",
              "items": [
                "std::chrono::seconds",
                "std::chrono::milliseconds",
                "std::chrono::microseconds",
                "std::chrono::nanoseconds"
              ]
            },
            {
              "type": "code",
              "title": "Zeit messen mit steady_clock",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < 1000000; ++i) {\n        // Leere Schleife zur Laufzeitmessung\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n    std::cout << duration.count() << std::endl; // Vergangene Zeit in ms\n}\n"
            },
            {
              "type": "code",
              "title": "Arbeiten mit durations",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::seconds s(2);\n    std::chrono::milliseconds ms = s; // Implizite Umrechnung\n\n    std::cout << ms.count() << std::endl; // Ausgabe: 2000\n}\n"
            },
            {
              "type": "code",
              "title": "system_clock und aktuelle Zeit",
              "language": "cpp",
              "code": "#include <iostream>\n#include <chrono>\n\nint main() {\n    auto now = std::chrono::system_clock::now();\n    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch());\n\n    std::cout << seconds.count() << std::endl; // Sekunden seit Epoche\n}\n"
            },
            {
              "type": "comparison",
              "title": "steady_clock vs system_clock",
              "columns": ["steady_clock", "system_clock"],
              "rows": [
                {
                  "aspect": "Monoton",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Geeignet f√ºr Messungen",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Bezug zur Uhrzeit",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "note",
              "variant": "formatting",
              "text": "Um Zeit oder Datum zu formatieren, nutzt man den Header <iomanip>, mit der Funktion put_time."
            },
            {
              "type": "pitfall",
              "title": "Falsche Uhr f√ºr Messungen",
              "text": "system_clock kann durch Systemzeit√§nderungen springen und ist f√ºr Laufzeitmessungen ungeeignet."
            },
            {
              "type": "important",
              "text": "F√ºr Zeitmessungen sollte immer steady_clock verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "<chrono> bietet typsichere Zeitmessung",
                "Trennung von duration, time_point und clock",
                "steady_clock ist Standard f√ºr Laufzeitmessungen"
              ]
            }
          ]
        },
        {
          "title": "ctime",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<ctime>",
              "text": "Der Header <ctime> stellt C-kompatible Funktionen und Typen zur Arbeit mit Kalenderzeit und Uhrzeit bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<ctime> ist die C++ Variante des C-Headers time.h und arbeitet mit der Systemzeit.",
                "Er bietet einfache, aber unflexible Mechanismen zur Zeitmessung und Zeitdarstellung."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Typen",
              "text": [
                "time_t repr√§sentiert einen Zeitpunkt als Sekunden seit der Epoch.",
                "struct tm speichert eine aufgeschl√ºsselte Kalenderzeit wie Jahr, Monat und Tag."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::time(nullptr) - aktuelle Systemzeit als time_t",
                "std::localtime - Umwandlung von time_t in lokale Zeit",
                "std::gmtime - Umwandlung in UTC Zeit",
                "std::difftime - Differenz zweier Zeitpunkte",
                "std::asctime - Umwandlung von tm in lesbaren Text",
                "std::ctime - Umwandlung von time_t in lesbaren Text"
              ]
            },
            {
              "type": "code",
              "title": "Aktuelle Zeit ermitteln",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr); // Aktuelle Zeit\n    std::cout << now << std::endl;        // Sekunden seit Epoch\n}\n"
            },
            {
              "type": "code",
              "title": "Kalenderzeit mit tm",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t now = std::time(nullptr);\n    std::tm* local = std::localtime(&now); // Lokale Zeit\n\n    std::cout << local->tm_year + 1900 << std::endl; // Jahr\n    std::cout << local->tm_mon + 1 << std::endl;     // Monat\n    std::cout << local->tm_mday << std::endl;        // Tag\n}\n"
            },
            {
              "type": "code",
              "title": "Zeitdifferenz berechnen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <ctime>\n\nint main() {\n    std::time_t t1 = 1000;\n    std::time_t t2 = 1500;\n\n    double diff = std::difftime(t2, t1); // Differenz in Sekunden\n    std::cout << diff << std::endl;      // Ausgabe: 500\n}\n"
            },
            {
              "type": "comparison",
              "title": "<ctime> vs <chrono>",
              "columns": ["<ctime>", "<chrono>"],
              "rows": [
                {
                  "aspect": "Typensicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Zeitmessung",
                  "values": ["Eingeschr√§nkt", "Flexibel"]
                },
                {
                  "aspect": "Modernes C++",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "note",
              "variant": "formatting",
              "text": "Um Zeit oder Datum zu formatieren, nutzt man den Header <iomanip>, mit der Funktion put_time."
            },
            {
              "type": "pitfall",
              "title": "localtime und Thread-Sicherheit",
              "text": "std::localtime liefert einen Zeiger auf statischen Speicher und ist nicht thread-sicher."
            },
            {
              "type": "important",
              "text": "<ctime> ist historisch und sollte in modernem C++ nach M√∂glichkeit durch <chrono> ersetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "<ctime> arbeitet mit System und Kalenderzeit",
                "Einfach, aber wenig typsicher",
                "Heute meist durch <chrono> ersetzt"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "System & Low-Level",
      "icon": "üß∞",
      "topics": [
        {
          "title": "thread",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<thread>",
              "text": "Der Header <thread> stellt Funktionen und Typen zur nebenl√§ufigen Ausf√ºhrung von Code in eigenen Threads bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<thread> erm√∂glicht es, mehrere Ausf√ºhrungsstr√§nge parallel oder nebenl√§ufig laufen zu lassen.",
                "Jeder Thread f√ºhrt eine Funktion unabh√§ngig vom aufrufenden Thread aus."
              ]
            },
            {
              "type": "explanation",
              "title": "std::thread",
              "text": [
                "std::thread repr√§sentiert einen ausf√ºhrenden Thread.",
                "Ein Thread startet sofort bei der Konstruktion und muss vor Programmende beendet oder verbunden werden."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "std::thread - startet einen neuen Thread",
                "join() - wartet auf das Ende eines Threads",
                "detach() - trennt den Thread vom Objekt",
                "std::this_thread::sleep_for - pausiert den aktuellen Thread",
                "std::this_thread::get_id - liefert die Thread ID"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher Thread",
              "language": "cpp",
              "code": "#include <iostream>\n#include <thread>\n\nvoid work() {\n    std::cout << \"Thread l√§uft\" << std::endl;\n}\n\nint main() {\n    std::thread t(work); // Startet neuen Thread\n    t.join();            // Wartet bis Thread fertig ist\n}\n"
            },
            {
              "type": "code",
              "title": "sleep_for verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <thread>\n#include <chrono>\n\nint main() {\n    std::cout << \"Start\" << std::endl;\n\n    std::this_thread::sleep_for(std::chrono::seconds(2)); // Pausiert f√ºr 2 Sekunden\n\n    std::cout << \"Weiter\" << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "sleep_for",
              "text": [
                "sleep_for pausiert den aktuell laufenden Thread f√ºr eine bestimmte Zeitspanne.",
                "Die Zeitspanne wird als std::chrono::duration √ºbergeben."
              ]
            },
            {
              "type": "comparison",
              "title": "join vs detach",
              "columns": ["join()", "detach()"],
              "rows": [
                {
                  "aspect": "Warten auf Thread",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Lebensdauer kontrollierbar",
                  "values": ["Ja", "Nein"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessener join",
              "text": "Wird ein joinbarer Thread nicht gejoint oder detached, beendet std::terminate das Programm."
            },
            {
              "type": "important",
              "text": "sleep_for geh√∂rt zu <thread>, nutzt aber Zeittypen aus <chrono>."
            },
            {
              "type": "summary",
              "points": [
                "<thread> erm√∂glicht nebenl√§ufige Aus√ºhrung",
                "Threads m√ºssen gejoint oder detached werden",
                "sleep_for pausiert den aktuellen Thread kontrolliert"
              ]
            }
          ]
        },
        {
          "title": "future",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "<future>",
              "text": "Der Header <future> stellt Mechanismen zur asynchronen Ausf√ºhrung und zum sicheren Austausch von Ergebnissen zwischen Threads bereit."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "<future> kapselt nebenl√§ufige Berechnungen und deren Ergebnisse in Objekten.",
                "Das Ergebnis wird sp√§ter abgeholt, sobald die Berechnung abgeschlossen ist."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Typen",
              "text": [
                "std::future repr√§sentiert ein zuk√ºnftiges Ergebnis einer Berechnung.",
                "std::promise dient dazu, ein Ergebnis explizit zu setzen.",
                "std::async startet eine Funktion asynchron und liefert ein future zur√ºck."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "std::future<T> - Zugriff auf ein sp√§teres Ergebnis",
                "std::promise<T> - Setzen eines Ergebnisses",
                "std::async - komfortabler Start asynchroner Aufgaben",
                "get() - holt das Ergebnis und blockiert falls n√∂tig",
                "wait() - wartet auf Abschluss ohne Ergebnisabfrage"
              ]
            },
            {
              "type": "code",
              "title": "Asynchrone Berechnung mit async",
              "language": "cpp",
              "code": "#include <iostream>\n#include <future>\n\nint berechne() {\n    return 42;\n}\n\nint main() {\n    std::future<int> f = std::async(std::launch::async, berechne);\n\n    int ergebnis = f.get();        // Blockiert bis Ergebnis verf√ºgbar ist\n    std::cout << ergebnis << std::endl; // Ausgabe: 42\n}\n"
            },
            {
              "type": "code",
              "title": "future blockiert bei get",
              "language": "cpp",
              "code": "#include <iostream>\n#include <future>\n#include <chrono>\n#include <thread>\n\nint arbeit() {\n    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simuliert Arbeit\n    return 7;\n}\n\nint main() {\n    std::future<int> f = std::async(std::launch::async, arbeit);\n\n    std::cout << \"Warte auf Ergebnis...\" << std::endl;\n    std::cout << f.get() << std::endl; // Wartet ca. 2 Sekunden\n}\n"
            },
            {
              "type": "comparison",
              "title": "future vs thread",
              "columns": ["std::future", "std::thread"],
              "rows": [
                {
                  "aspect": "R√ºckgabewert",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Fehler√ºbertragung",
                  "values": ["Ja, per Exception", "Nein"]
                },
                {
                  "aspect": "Synchronisation",
                  "values": ["Automatisch", "Manuell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "get nur einmal erlaubt",
              "text": "std::future::get darf nur einmal aufgerufen werden, danach ist das future leer."
            },
            {
              "type": "important",
              "text": "<future> vereinfacht nebenl√§ufige Programmierung erheblich, da Ergebnisse und Exceptions sicher √ºbertragen werden."
            },
            {
              "type": "summary",
              "points": [
                "<future> erm√∂glicht asynchrone Berechnungen mit R√ºckgabewert",
                "std::async ist der einfachste Einstieg",
                "get blockiert bis das Ergebnis verf√ºgbar ist",
                "Exceptions werden automatisch weitergereicht"
              ]
            }
          ]
        },
        {
          "title": "typeinfo",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<typeinfo>",
              "text": "Der Header <typeinfo> stellt Laufzeitinformationen √ºber Typen bereit und wird f√ºr Runtime Type Information verwendet."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<typeinfo> erm√∂glicht es, Typinformationen erst zur Laufzeit abzufragen.",
                "Dies ist vor allem bei Polymorphie und dynamischem Casting relevant."
              ]
            },
            {
              "type": "explanation",
              "title": "RTTI Grundidee",
              "text": [
                "RTTI bedeutet, dass der tats√§chliche Typ eines Objekts zur Laufzeit bestimmt werden kann.",
                "Dies funktioniert nur bei Klassen mit mindestens einer virtuellen Funktion."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "typeid(expr) - liefert Typinformation eines Ausdrucks",
                "std::type_info - Klasse zur Repr√§sentation von Typinformationen",
                "name() - liefert einen implementationsabh√§ngigen Typnamen",
                "operator== - Vergleich von Typinformationen"
              ]
            },
            {
              "type": "code",
              "title": "Typ mit typeid abfragen",
              "language": "cpp",
              "code": "#include <iostream>\n#include <typeinfo>\n\nint main() {\n    int x = 5;\n    double y = 3.14;\n\n    std::cout << typeid(x).name() << std::endl; // Typ von x\n    std::cout << typeid(y).name() << std::endl; // Typ von y\n}\n"
            },
            {
              "type": "code",
              "title": "RTTI bei Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <typeinfo>\n\nstruct Base {\n    virtual ~Base() {} // notwendig f√ºr RTTI\n};\n\nstruct Derived : Base {};\n\nint main() {\n    Base* b = new Derived();\n\n    std::cout << typeid(*b).name() << std::endl; // Tats√§chlicher Typ: Derived\n    delete b;\n}\n"
            },
            {
              "type": "comparison",
              "title": "typeid vs dynamic_cast",
              "columns": ["typeid", "dynamic_cast"],
              "rows": [
                {
                  "aspect": "Zweck",
                  "values": ["Typabfrage", "Sicheres Casten"]
                },
                {
                  "aspect": "R√ºckgabewert",
                  "values": ["type_info", "Zeiger oder Referenz"]
                },
                {
                  "aspect": "RTTI notwendig",
                  "values": ["Ja", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Implementationsabh√§ngiger Typname",
              "text": "Der von name() gelieferte Typname ist nicht standardisiert und nicht portabel."
            },
            {
              "type": "important",
              "text": "<typeinfo> sollte sparsam eingesetzt werden, da gutes Design meist ohne explizite Typabfragen auskommt."
            },
            {
              "type": "summary",
              "points": [
                "<typeinfo> erm√∂glicht Laufzeit Typinformationen",
                "typeid liefert std::type_info",
                "RTTI erfordert virtuelle Funktionen",
                "Typnamen sind implementationsabh√§ngig"
              ]
            }
          ]
        },
        {
          "title": "new",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<new>",
              "text": "Der Header <new> stellt Mechanismen f√ºr dynamische Speicherallokation und Speicherfehlerbehandlung bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<new> definiert die Operatoren new und delete sowie Hilfsmittel zur Kontrolle ihres Verhaltens.",
                "Er wird verwendet, wenn Speicher dynamisch zur Laufzeit angefordert oder freigegeben wird."
              ]
            },
            {
              "type": "explanation",
              "title": "new und delete",
              "text": [
                "new reserviert Speicher und ruft anschlie√üend den Konstruktor eines Objekts auf.",
                "delete ruft den Destruktor auf und gibt den reservierten Speicher wieder frei."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Bestandteile",
              "items": [
                "operator new - reserviert Speicher",
                "operator delete - gibt Speicher frei",
                "std::nothrow - unterdr√ºckt Exceptions bei Speicherfehlern",
                "std::bad_alloc - Exception bei fehlgeschlagener Allokation",
                "placement new - Konstruktion an vorgegebenem Speicherort"
              ]
            },
            {
              "type": "code",
              "title": "Dynamische Speicherallokation",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nint main() {\n    int* p = new int(42);          // Speicher reservieren und Wert setzen\n    std::cout << *p << std::endl; // Ausgabe: 42\n    delete p;                     // Speicher freigeben\n}\n"
            },
            {
              "type": "code",
              "title": "new mit nothrow",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nint main() {\n    int* p = new (std::nothrow) int;\n\n    if (p == nullptr) {\n        std::cout << \"Kein Speicher verf√ºgbar\" << std::endl;\n    } else {\n        *p = 10;\n        std::cout << *p << std::endl;\n        delete p;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "placement new",
              "language": "cpp",
              "code": "#include <iostream>\n#include <new>\n\nstruct Test {\n    int x;\n    Test(int v) : x(v) {}\n};\n\nint main() {\n    alignas(Test) char buffer[sizeof(Test)];\n\n    Test* t = new (buffer) Test(5); // Objekt im bestehenden Speicher konstruieren\n    std::cout << t->x << std::endl; // Ausgabe: 5\n\n    t->~Test(); // Destruktor manuell aufrufen\n}\n"
            },
            {
              "type": "comparison",
              "title": "new vs malloc",
              "columns": ["new", "malloc"],
              "rows": [
                {
                  "aspect": "Konstruktoraufruf",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Typensicherheit",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Fehlerbehandlung",
                  "values": ["Exception", "nullptr"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessenes delete",
              "text": "Nicht freigegebener Speicher f√ºhrt zu Speicherlecks."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten new und delete m√∂glichst durch Smart Pointer ersetzt werden."
            },
            {
              "type": "summary",
              "points": [
                "<new> steuert dynamische Speicherallokation",
                "new ruft Konstruktoren auf, delete Destruktoren",
                "std::bad_alloc signalisiert Speicherfehler",
                "placement new konstruiert Objekte in vorhandenem Speicher"
              ]
            }
          ]
        },
        {
          "title": "memory",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<memory>",
              "text": "Der Header <memory> stellt Smart Pointer und Hilfsmittel f√ºr sichere und moderne Speicherverwaltung bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<memory> abstrahiert dynamische Speicherverwaltung und verhindert viele typische Fehler wie Speicherlecks.",
                "Statt rohem new und delete werden Smart Pointer verwendet, die Speicher automatisch freigeben."
              ]
            },
            {
              "type": "explanation",
              "title": "Smart Pointer Grundidee",
              "text": [
                "Smart Pointer kapseln einen rohen Zeiger in einem Objekt mit klarer Besitzsemantik.",
                "Der Speicher wird automatisch freigegeben, wenn der letzte Besitzer verschwindet."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Smart Pointer",
              "items": [
                "std::unique_ptr - exklusiver Besitz eines Objekts",
                "std::shared_ptr - geteilter Besitz mit Referenzz√§hlung",
                "std::weak_ptr - schwache Referenz ohne Besitz",
                "std::make_unique - sichere Erzeugung von unique_ptr",
                "std::make_shared - effiziente Erzeugung von shared_ptr"
              ]
            },
            {
              "type": "code",
              "title": "unique_ptr verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p = std::make_unique<int>(42);\n\n    std::cout << *p << std::endl; // Zugriff auf den Wert\n}\n"
            },
            {
              "type": "code",
              "title": "Besitz√ºbertragung mit move",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> a = std::make_unique<int>(10);\n    std::unique_ptr<int> b = std::move(a); // Besitz wird √ºbertragen\n\n    if (a == nullptr) {\n        std::cout << \"a ist leer\" << std::endl;\n    }\n\n    std::cout << *b << std::endl; // Ausgabe: 10\n}\n"
            },
            {
              "type": "code",
              "title": "shared_ptr verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(5);\n    std::shared_ptr<int> p2 = p1; // Referenzz√§hlung +1\n\n    std::cout << p1.use_count() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "code",
              "title": "weak_ptr zur Zyklusvermeidung",
              "language": "cpp",
              "code": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(7);\n    std::weak_ptr<int> wp = sp;\n\n    if (auto locked = wp.lock()) {\n        std::cout << *locked << std::endl; // Zugriff nur wenn Objekt existiert\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "unique_ptr vs shared_ptr",
              "columns": ["unique_ptr", "shared_ptr"],
              "rows": [
                {
                  "aspect": "Besitz",
                  "values": ["Exklusiv", "Geteilt"]
                },
                {
                  "aspect": "Kopierbar",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Overhead",
                  "values": ["Sehr gering", "H√∂her durch Referenzz√§hlung"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zyklische Referenzen",
              "text": "Zwei shared_ptr aufeinander verhindern die Speicherfreigabe und f√ºhren zu Speicherlecks."
            },
            {
              "type": "important",
              "text": "<memory> ist zentral f√ºr modernes C++ und sollte rohes new und delete fast immer ersetzen."
            },
            {
              "type": "summary",
              "points": [
                "<memory> stellt Smart Pointer bereit",
                "unique_ptr f√ºr exklusiven Besitz",
                "shared_ptr f√ºr geteilten Besitz",
                "weak_ptr verhindert Referenzzyklen",
                "Automatische Speicherfreigabe erh√∂ht Sicherheit"
              ]
            }
          ]
        },
        {
          "title": "cstdio",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "<cstdio>",
              "text": "Der Header <cstdio> stellt C-kompatible Funktionen f√ºr Ein- und Ausgabe √ºber Dateien und Standardstreams bereit."
            },
            {
              "type": "explanation",
              "title": "Zweck des Headers",
              "text": [
                "<cstdio> ist die C++ Variante des C-Headers stdio.h und arbeitet mit C-Streams.",
                "Er wird f√ºr einfache, schnelle oder systemnahe Ein- und Ausgabeoperationen genutzt."
              ]
            },
            {
              "type": "explanation",
              "title": "C-Streams",
              "text": [
                "Ein- und Ausgabe erfolgt √ºber FILE* Objekte.",
                "Standardstreams sind stdin, stdout und stderr."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Funktionen",
              "items": [
                "printf(format, ...) - formatierte Ausgabe",
                "scanf(format, ...) - formatierte Eingabe",
                "fprintf(stream, ...) - Ausgabe in Datei",
                "fscanf(stream, ...) - Eingabe aus Datei",
                "fopen(name, mode) - Datei √∂ffnen",
                "fclose(file) - Datei schlie√üen",
                "fgets(buffer, n, stream) - Zeile lesen",
                "fputs(text, stream) - Text schreiben"
              ]
            },
            {
              "type": "code",
              "title": "Formatierte Ausgabe mit printf",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    int x = 5;\n    double y = 3.14;\n\n    std::printf(\"x = %d, y = %.2f\\n\", x, y); // Formatierte Ausgabe\n}\n"
            },
            {
              "type": "code",
              "title": "Datei schreiben",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    FILE* f = std::fopen(\"test.txt\", \"w\");\n\n    if (f != nullptr) {\n        std::fprintf(f, \"Hallo Datei\\n\");\n        std::fclose(f);\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Datei lesen",
              "language": "cpp",
              "code": "#include <cstdio>\n\nint main() {\n    char buffer[100];\n    FILE* f = std::fopen(\"test.txt\", \"r\");\n\n    if (f != nullptr) {\n        std::fgets(buffer, 100, f);\n        std::printf(\"%s\", buffer);\n        std::fclose(f);\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "<cstdio> vs <iostream>",
              "columns": ["<cstdio>", "<iostream>"],
              "rows": [
                {
                  "aspect": "Typensicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Performance",
                  "values": ["Oft h√∂her", "Etwas geringer"]
                },
                {
                  "aspect": "Modernes C++",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "scanf und Formatfehler",
              "text": "Falsche Formatstrings bei scanf f√ºhren leicht zu undefiniertem Verhalten."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten <iostream> oder <fstream> bevorzugt werden, au√üer bei bewusster C-Kompatibilit√§t."
            },
            {
              "type": "summary",
              "points": [
                "<cstdio> stellt C-Style Ein- und Ausgabe bereit",
                "Arbeitet mit FILE* und Formatstrings",
                "Schnell, aber nicht typsicher",
                "Heute meist durch iostreams ersetzt"
              ]
            }
          ]
        }
        ]
      },
      {
      "name": "Algorithmen & Utility Header",
      "icon": "üì¶",
      "topics": [
       {
        "title": "algorithm",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<algorithm>",
            "text": "Der Header <algorithm> stellt eine gro√üe Sammlung generischer Algorithmen zur Verarbeitung von Containern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<algorithm> arbeitet iteratorbasiert und ist dadurch unabh√§ngig vom konkreten Containertyp.",
              "Die Algorithmen trennen klar Datenhaltung von Verarbeitung und f√∂rdern wiederverwendbaren Code."
            ]
          },
          {
            "type": "explanation",
            "title": "Zusammenspiel mit Containern",
            "text": [
              "Algorithmen arbeiten typischerweise mit Iteratorpaaren wie begin() und end().",
              "Sie funktionieren mit Standardcontainern wie vector, list, array oder deque."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Such- und Z√§hlalgorithmen",
            "items": [
              "std::find - sucht erstes Vorkommen eins Elements",
              "std::count - z√§hlt Vorkommen eines Werts",
              "std::count_if - z√§hlt mit Pr√§dikat(Bedingungen)",
              "std::find_if - sucht mit Bedingung",
              "std::all_of / any_of / none_of - logische Pr√ºfungen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige √Ñnderungsalgorithmen",
            "items": [
              "std::sort - sortiert Elemente",
              "std::reverse - kehrt Reihenfolge um",
              "std::remove - entfernt logisch Elemente, verschiebt sie nach hinten und gibt einen Iterator auf den Beginn der entfernten Elemente zur√ºck. Containergr√∂√üe bleibt unver√§ndert",
              "std::unique - entfernt logisch aufeinanderfolgende Duplikate, verschiebt sie nach hinten und gibt einen Iterator auf den Beginn der entfernten Elemente zur√ºck. Containergr√∂√üe bleibt unver√§ndert",
              "std::transform - transformiert Elemente durch eine Funktion und speichert die Ergebnisse im Zielcontainer"
            ]
          },
          {
            "type": "code",
            "title": "Suchen und Z√§hlen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 2, 4};\n\n    auto it = std::find(v.begin(), v.end(), 2);\n    int anzahl = std::count(v.begin(), v.end(), 2);\n\n    std::cout << anzahl << std::endl; // Ausgabe: 2\n}\n"
          },
          {
            "type": "code",
            "title": "Sortieren mit sort",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {4, 1, 3, 2};\n\n    std::sort(v.begin(), v.end()); // Aufsteigend sortieren\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "remove-erase Idiom",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 2, 4};\n\n    v.erase(std::remove(v.begin(), v.end(), 2), v.end());\n\n    for (int x : v) {\n        std::cout << x << \" \"; // Ausgabe: 1 3 4\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Transformieren mit transform",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Ausgangscontainer\n    std::vector<int> v = {1, 2, 3, 4};\n\n    // std::transform arbeitet elementweise:\n    // 1. v.begin()  -> Start des Eingabebereichs\n    // 2. v.end()    -> Ende des Eingabebereichs\n    // 3. v.begin()  -> Start des Zielbereichs\n    //                 (hier: wir schreiben die Ergebnisse direkt wieder in denselben Vector)\n    // 4. Lambda     -> Funktion, die auf jedes Element angewendet wird\n    std::transform(\n        v.begin(),   // Eingabe: erstes Element\n        v.end(),     // Eingabe: letztes Element (exklusiv)\n        v.begin(),   // Ausgabe: Zielposition f√ºr das Ergebnis\n        [](int x) {  // Lambda-Funktion: nimmt ein Element x\n            return x * 2; // und gibt das transformierte Element zur√ºck\n        }\n    );\n\n    // Ausgabe des transformierten Vektors\n    for (int x : v) {\n        std::cout << x << \" \"; // Ausgabe: 2 4 6 8\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Pr√ºfen mit all_of, any_of und none_of",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Beispielcontainer\n    std::vector<int> v = {2, 4, 6, 8};\n\n    // all_of: pr√ºft, ob ALLE Elemente die Bedingung erf√ºllen\n    // ‚Üí true, wenn jedes Element die Lambda-Bedingung erf√ºllt\n    bool alleGerade = std::all_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x % 2 == 0; // Bedingung: Element ist gerade\n        }\n    );\n\n    // any_of: pr√ºft, ob MINDESTENS EIN Element die Bedingung erf√ºllt\n    bool mindestensEinsGroesserFuenf = std::any_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x > 5; // Bedingung: Element ist gr√∂√üer als 5\n        }\n    );\n\n    // none_of: pr√ºft, ob KEIN Element die Bedingung erf√ºllt\n    bool keinNegatives = std::none_of(\n        v.begin(),\n        v.end(),\n        [](int x) {\n            return x < 0; // Bedingung: Element ist negativ\n        }\n    );\n\n    // Ergebnisse ausgeben\n    std::cout << std::boolalpha;\n    std::cout << \"alle gerade: \" << alleGerade << std::endl;               // true\n    std::cout << \"mindestens eins > 5: \" << mindestensEinsGroesserFuenf << std::endl; // true\n    std::cout << \"kein negatives: \" << keinNegatives << std::endl;         // true\n}\n"
          },
          {
            "type": "comparison",
            "title": "Algorithmen vs Container-Methoden",
            "columns": ["<algorithm>", "Container-Methoden"],
            "rows": [
              {
                "aspect": "Generisch",
                "values": ["Ja", "Nein"]
              },
              {
                "aspect": "Iteratorbasiert",
                "values": ["Ja", "Nein"]
              },
              {
                "aspect": "Wiederverwendbarkeit",
                "values": ["Hoch", "Begrenzt"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "remove l√∂scht nicht wirklich",
            "text": "std::remove verschiebt Elemente nur und √§ndert nicht die Containergr√∂√üe."
          },
          {
            "type": "important",
            "text": "<algorithm> ist zentral f√ºr idiomatisches(typisch) und modernes C++ und sollte gegen√ºber manuellen Schleifen bevorzugt werden."
          },
          {
            "type": "summary",
            "points": [
              "<algorithm> bietet viele generische Algorithmen",
              "Arbeitet iteratorbasiert mit Containern",
              "F√∂rdert sauberen und wiederverwendbaren Code"
            ]
          }
        ]
      },
      {
        "title": "iterator",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<iterator>",
            "text": "Der Header <iterator> stellt Iterator-Typen, Hilfsfunktionen und Iterator-Adapter f√ºr die Arbeit mit Containern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "Iteratoren abstrahieren den Zugriff auf Container, ohne deren interne Struktur offenzulegen.",
              "Sie erm√∂glichen es Algorithmen, unabh√§ngig vom konkreten Containertyp zu arbeiten."
            ]
          },
          {
            "type": "explanation",
            "title": "Iterator-Kategorien",
            "text": [
              "Iterator-Kategorien beschreiben die F√§higkeiten eines Iterators und bestimmen, welche Operationen und Laufzeiten ein Algorithmus nutzen darf.",
              "Algorithmen aus <algorithm> setzen bestimmte Iterator-Kategorien voraus."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Iterator-Kategorien",
            "items": [
              "Input Iterator - lesender Vorw√§rtszugriff, kein Mehrfachdurchlauf garantiert",
              "Output Iterator - schreibender Zugriff, kein Lesen m√∂glich",
              "Forward Iterator - les- und schreibbar mit Mehrfachdurchlauf",
              "Bidirectional Iterator - Vorw√§rts- und R√ºckw√§rtsbewegung",
              "Random Access Iterator - direkter Sprung auf beliebige Positionen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile aus <iterator>",
            "items": [
              "std::iterator_traits - Typ- und Eigenschaftsinformationen eines Iterators",
              "std::advance - Iterator um n Positionen verschieben",
              "std::distance - Abstand zwischen zwei Iteratoren berechnen",
              "std::next / std::prev - neuen Iterator relativ zu einem bestehenden erzeugen",
              "Iterator-Adapter wie back_inserter - erm√∂glichen sicheres Einf√ºgen in Container"
            ]
          },
          {
            "type": "code",
            "title": "Iterator bewegen mit advance",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() {\n    std::vector<int> v = {10, 20, 30, 40};\n    auto it = v.begin();\n\n    std::advance(it, 2); // Bewegt Iterator zwei Positionen weiter\n    std::cout << *it << std::endl; // Ausgabe: 30\n}\n"
          },
          {
            "type": "code",
            "title": "Abstand zwischen Iteratoren",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    auto d = std::distance(v.begin(), v.end());\n    std::cout << d << std::endl; // Ausgabe: 5\n}\n"
          },
          {
            "type": "code",
            "title": "Iterator-Adapter back_inserter",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nint main() {\n    // Quellcontainer mit Daten\n    std::vector<int> a = {1, 2, 3};\n\n    // Zielcontainer ist leer\n    std::vector<int> b;\n\n    // std::copy kopiert Elemente von a nach b\n    // Problem: b ist leer und hat keinen reservierten Speicher\n    // L√∂sung: std::back_inserter erzeugt einen speziellen Iterator,\n    //          der intern b.push_back(x) aufruft\n    std::copy(\n        a.begin(),           // Start des Eingabebereichs\n        a.end(),             // Ende des Eingabebereichs\n        std::back_inserter(b) // Ziel: f√ºgt Elemente sicher mit push_back ein\n    );\n\n    // Ausgabe des Zielcontainers\n    for (int x : b) {\n        std::cout << x << \" \"; // Ausgabe: 1 2 3\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Iterator traits",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n\n// Generische Funktion, die mit beliebigen Iteratoren arbeitet\ntemplate <typename Iterator>\nvoid printFirstElement(Iterator it) {\n    // iterator_traits extrahiert Typinformationen aus dem Iterator. Hier int\n    using ValueType = typename std::iterator_traits<Iterator>::value_type;\n\n    // Jetzt kennen wir den Typ der Elemente, auf die der Iterator zeigt\n    ValueType value = *it;\n\n    std::cout << value << std::endl;\n}\n\nint main() {\n    std::vector<int> v = {10, 20, 30};\n\n    // √úbergabe eines Vector-Iterators\n    printFirstElement(v.begin()); // Ausgabe: 10\n}\n"
          },
          {
            "type": "comparison",
            "title": "Iterator-Kategorien im Vergleich",
            "columns": ["Kategorie", "F√§higkeiten"],
            "rows": [
              {
                "aspect": "Input Iterator",
                "values": ["Lesen", "Einmaliger Zugriff"]
              },
              {
                "aspect": "Bidirectional Iterator",
                "values": ["Vorw√§rts und r√ºckw√§rts", "Mehrfacher Zugriff"]
              },
              {
                "aspect": "Random Access Iterator",
                "values": ["Direkter Indexzugriff", "Arithmetik m√∂glich"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Ung√ºltige Iteratoren",
            "text": "Operationen wie Einf√ºgen oder L√∂schen k√∂nnen Iteratoren ung√ºltig machen."
          },
          {
            "type": "important",
            "text": "<iterator> ist zentral f√ºr das Zusammenspiel von Containern und Algorithmen in C++."
          },
          {
            "type": "summary",
            "points": [
              "<iterator> definiert Iterator-Konzepte und Hilfsfunktionen",
              "Iteratoren abstrahieren Containerzugriff",
              "advance und distance sind zentrale Werkzeuge",
              "Iterator-Adapter erleichtern sicheres Einf√ºgen"
            ]
          }
        ]
      },
      {
        "title": "functional",
        "difficulty": "intermediate",
        "blocks": [
          {
            "type": "definition",
            "term": "<functional>",
            "text": "Der Header <functional> stellt Funktionsobjekte, Wrapper und Hilfsmittel f√ºr funktionale Programmierung in C++ bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<functional> erm√∂glicht es, Funktionen wie Werte zu behandeln.",
              "Funktionen, Lambdas und Funktionsobjekte k√∂nnen einheitlich gespeichert und weitergereicht werden."
            ]
          },
          {
            "type": "explanation",
            "title": "Funktionsobjekte",
            "text": [
              "Ein Funktionsobjekt ist ein Objekt, das den operator() √ºberl√§dt.",
              "Viele Standard-Funktionsobjekte sind bereits in <functional> definiert."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Funktionsobjekte",
            "items": [
              "std::plus<T>: a + b, std::minus<T>: a - b, std::multiplies<T>: a * b, std::divides<T>: a / b - arithmetische Operationen",
              "std::less, std::greater - Vergleichsoperationen",
              "std::logical_and<T>: a && b, std::logical_or - logische Operationen"
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::function - typsicherer Funktionswrapper",
              "std::bind - teilweise Funktionsbindung",
              "std::ref / std::cref - Referenzen in Funktionsobjekten"
            ]
          },
          {
            "type": "code",
            "title": "std::function verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    std::function<int(int, int)> f = add;\n    std::cout << f(2, 3) << std::endl; // Ausgabe: 5\n}\n"
          },
          {
            "type": "code",
            "title": "Lambda mit std::function",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    std::function<bool(int)> ist_gerade = [](int x) {\n        return x % 2 == 0;\n    };\n\n    std::cout << ist_gerade(4) << std::endl; // Ausgabe: 1\n}\n"
          },
          {
            "type": "code",
            "title": "std::bind verwenden (mit _1 und _3)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\n// Funktion mit drei Parametern\nint combine(int a, int b, int c) {\n    return a + b * c;\n}\n\nint main() {\n    // Erstes Beispiel: einfacher bind mit einem Platzhalter\n    auto f = std::bind(\n        combine,\n        10,                     // a = 10 (fest gebunden)\n        std::placeholders::_1,  // b = erstes Argument beim Aufruf\n        2                       // c = 2 (fest gebunden)\n    );\n\n    // f(x) entspricht intern: combine(10, x, 2)\n    std::cout << f(3) << std::endl; // 10 + 3*2 = 16\n\n\n    // Zweites Beispiel: Nutzung von _3\n    auto g = std::bind(\n        combine,\n        std::placeholders::_3,  // a = drittes Argument beim Aufruf\n        5,                      // b = 5 (fest gebunden)\n        std::placeholders::_1   // c = erstes Argument beim Aufruf\n    );\n\n    // Aufruf von g mit drei Argumenten:\n    // g(x, y, z) -> combine(z, 5, x)\n    std::cout << g(2, 99, 4) << std::endl; // 4 + 5*2 = 14\n}\n"
          },
          {
            "type": "code",
            "title": "std::ref: bind kopiert sonst, ref √§ndert das",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    int x = 10;\n\n    // Ohne std::ref w√ºrde bind x kopieren.\n    // Dann w√ºrde die √Ñnderung nur die Kopie betreffen.\n    auto addToX = std::bind(\n        std::plus<int>{},        // Funktionsobjekt: plus(a, b) -> a + b\n        std::ref(x),             // a referenziert x (kein Kopieren)\n        std::placeholders::_1    // b kommt beim Aufruf\n    );\n\n    // addToX(5) berechnet x + 5\n    // Wir weisen das Ergebnis wieder x zu, um die √Ñnderung sichtbar zu machen.\n    x = addToX(5);\n\n    std::cout << x << std::endl; // Ausgabe: 15\n}\n"
          },
          {
            "type": "code",
            "title": "std::cref: bind liest aus einer Referenz, ohne zu kopieren",
            "language": "cpp",
            "code": "#include <iostream>\n#include <functional>\n\nint main() {\n    int x = 10;\n\n    // std::cref(x) speichert eine Referenz auf x, aber als const Referenz.\n    // Das ist sinnvoll, wenn du garantiert nicht √§ndern willst oder darfst.\n    auto addX = std::bind(\n        std::plus<int>{},        // a + b\n        std::cref(x),            // a ist const Referenz auf x\n        std::placeholders::_1    // b kommt beim Aufruf\n    );\n\n    // addX(7) bedeutet intern: x + 7\n    std::cout << addX(7) << std::endl; // Ausgabe: 17\n\n    // x bleibt unver√§ndert, weil wir nur gelesen haben.\n    std::cout << x << std::endl; // Ausgabe: 10\n}\n"
          },
          {
            "type": "comparison",
            "title": "std::function vs Template-Parameter",
            "columns": ["std::function", "Template"],
            "rows": [
              {
                "aspect": "Flexibilit√§t",
                "values": ["Sehr hoch", "Hoch"]
              },
              {
                "aspect": "Laufzeit-Overhead",
                "values": ["Vorhanden", "Keiner"]
              },
              {
                "aspect": "Typ-Erasure",
                "values": ["Ja", "Nein"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Overhead von std::function",
            "text": "std::function verursacht Laufzeit-Overhead und sollte in Performance-kritischem Code bewusst eingesetzt werden."
          },
          {
            "type": "important",
            "text": "<functional> ist zentral f√ºr moderne C++ APIs, Callback-Mechanismen und Algorithmen."
          },
          {
            "type": "summary",
            "points": [
              "<functional> unterst√ºtzt funktionale Programmierung",
              "std::function kapselt Funktionen typsicher",
              "Funktionsobjekte und Lambdas sind gleichwertig nutzbar",
              "std::bind erm√∂glicht partielle Funktionsbindung"
            ]
          }
        ]
      },
      {
        "title": "initializer_list",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<initializer_list>",
            "text": "Der Header <initializer_list> stellt den Typ std::initializer_list f√ºr Initialisierung mit geschweiften Klammern bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "<initializer_list> erm√∂glicht die √úbergabe einer Liste von Werten in geschweiften Klammern.",
              "Dies wird h√§ufig f√ºr Konstruktoren und Funktionsparameter genutzt."
            ]
          },
          {
            "type": "explanation",
            "title": "std::initializer_list",
            "text": [
              "std::initializer_list erlaubt es, mehrere Werte kompakt mit {} an Funktionen oder Konstruktoren zu √ºbergeben, ohne einen Container zu erzeugen.",
              "std::initializer_list repr√§sentiert eine unver√§nderliche Sequenz von Elementen gleichen Typs.",
              "Die enthaltenen Elemente sind konstant und k√∂nnen nicht ver√§ndert werden."
            ]
          },
          {
            "type": "list",
            "title": "Typische Einsatzgebiete",
            "items": [
              "Initialisierung von Containern wie std::vector oder std::set",
              "Konstruktoren mit variabler Anzahl an Argumenten",
              "Funktionsaufrufe mit Listenliteralen"
            ]
          },
          {
            "type": "code",
            "title": "Container-Initialisierung",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4};\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
          },
          {
            "type": "code",
            "title": "Konstruktor mit initializer_list",
            "language": "cpp",
            "code": "#include <iostream>\n#include <initializer_list>\n\nstruct Summe {\n    int wert = 0;\n\n    Summe(std::initializer_list<int> liste) {\n        for (int x : liste) {\n            wert += x;\n        }\n    }\n};\n\nint main() {\n    Summe s = {1, 2, 3};\n    std::cout << s.wert << std::endl; // Ausgabe: 6\n}\n"
          },
          {
            "type": "code",
            "title": "Als Funktionsparameter",
            "language": "cpp",
            "code": "#include <iostream>\n#include <initializer_list>\n\nvoid drucke(std::initializer_list<int> liste) {\n    for (int x : liste) {\n        std::cout << x << \" \";\n    }\n}\n\nint main() {\n    drucke({5, 10, 15});\n}\n"
          },
          {
            "type": "comparison",
            "title": "initializer_list vs Container",
            "columns": ["initializer_list", "Container"],
            "rows": [
              {
                "aspect": "Ver√§nderbar",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Besitzt Speicher",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Lebensdauer",
                "values": ["Kurzzeitig", "Verwaltet"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Mehrdeutige Konstruktoren",
            "text": "Konstruktoren mit initializer_list werden bei geschweiften Klammern bevorzugt und k√∂nnen andere Konstruktoren verdr√§ngen."
          },
          {
            "type": "important",
            "text": "<initializer_list> vereinfacht Initialisierung, sollte aber bewusst eingesetzt werden."
          },
          {
            "type": "summary",
            "points": [
              "<initializer_list> erm√∂glicht Initialisierung mit {}",
              "Elemente sind konstant und nicht ver√§nderbar",
              "H√§ufig in Konstruktoren und Containern",
              "Kann zu Mehrdeutigkeiten f√ºhren"
            ]
          }
        ]
      },
      {
        "title": "tuple",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<tuple>",
            "text": "Der Header <tuple> stellt den Typ std::tuple zur Speicherung einer festen Anzahl heterogener Werte bereit."
          },
          {
            "type": "explanation",
            "title": "Grundidee",
            "text": [
              "std::tuple kann mehrere Werte unterschiedlicher Typen in einem Objekt b√ºndeln.",
              "Im Gegensatz zu Structs sind die Elemente positionsbasiert und nicht benannt."
            ]
          },
          {
            "type": "explanation",
            "title": "Eigenschaften von std::tuple",
            "text": [
              "Die Anzahl und Typen der Elemente sind zur Compilezeit festgelegt.",
              "Zugriff erfolgt √ºber Indizes oder √ºber strukturierte Bindungen."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::tuple<T, S, ...> - Tupeltyp mit beliebigen Typen",
              "std::make_tuple - erstellt ein Tupel mit Typableitung",
              "std::get<I> - Zugriff auf ein Element per Index",
              "std::tie - Bindet Variablen an Tupel",
              "std::tuple_size - Anzahl der Elemente"
            ]
          },
          {
            "type": "code",
            "title": "Einfaches tuple erstellen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    std::tuple<int, double, char> t(1, 3.14, 'a');\n\n    std::cout << std::get<0>(t) << std::endl; // Ausgabe: 1\n    std::cout << std::get<1>(t) << std::endl; // Ausgabe: 3.14\n    std::cout << std::get<2>(t) << std::endl; // Ausgabe: a\n}\n"
          },
          {
            "type": "code",
            "title": "make_tuple verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    auto t = std::make_tuple(42, true, 2.5);\n\n    std::cout << std::get<1>(t) << std::endl; // Ausgabe: 1\n}\n"
          },
          {
            "type": "code",
            "title": "Strukturierte Bindung (neue Variablen)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nint main() {\n    std::tuple<int, double> t(7, 4.2);\n\n    auto [a, b] = t; // Entpacken des Tupels und binden an neue Variablen\n    std::cout << a << \" \" << b << std::endl;\n}\n"
          },
          {
            "type": "code",
            "title": "tuple mit std::tie zerlegen (bestehende Variablen)",
            "language": "cpp",
            "code": "#include <iostream>\n#include <tuple>\n\nstd::tuple<int, int> berechne() {\n    return {10, 20};\n}\n\nint main() {\n    int a;\n    int b;\n\n    // std::tie bindet die Tuple-Elemente an bestehende Variablen\n    std::tie(a, b) = berechne();\n\n    std::cout << a << \" \" << b << std::endl; // Ausgabe: 10 20\n}\n"
          },
          {
            "type": "comparison",
            "title": "tuple vs struct",
            "columns": ["std::tuple", "struct"],
            "rows": [
              {
                "aspect": "Elementnamen",
                "values": ["Nein", "Ja"]
              },
              {
                "aspect": "Typheterogen",
                "values": ["Ja", "Ja"]
              },
              {
                "aspect": "Lesbarkeit",
                "values": ["Geringer", "H√∂her"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "Un√ºbersichtlicher Code",
            "text": "Zugriff √ºber Indizes wie get<2> kann die Lesbarkeit stark verschlechtern."
          },
          {
            "type": "important",
            "text": "std::tuple eignet sich gut f√ºr R√ºckgabewerte, sollte aber nicht als Ersatz f√ºr klar benannte Structs missbraucht werden."
          },
          {
            "type": "summary",
            "points": [
              "<tuple> b√ºndelt heterogene Werte",
              "Zugriff √ºber Indizes oder strukturierte Bindungen",
              "Geeignet f√ºr R√ºckgabewerte mehrerer Werte",
              "Structs sind oft besser lesbar"
            ]
          }
        ]
      },
      {
        "title": "utility (pair, swap)",
        "difficulty": "basic",
        "blocks": [
          {
            "type": "definition",
            "term": "<utility>",
            "text": "Der Header <utility> stellt grundlegende Hilfstypen und Funktionen wie std::pair und std::swap bereit."
          },
          {
            "type": "explanation",
            "title": "Zweck des Headers",
            "text": [
              "<utility> enth√§lt kleine, aber zentrale Bausteine der Standardbibliothek.",
              "Viele Container, Algorithmen und APIs bauen intern auf diesen Typen auf."
            ]
          },
          {
            "type": "explanation",
            "title": "std::pair",
            "text": [
              "std::pair speichert genau zwei Werte, die unterschiedliche Typen haben k√∂nnen.",
              "Der Zugriff erfolgt √ºber die √∂ffentlichen Member first und second."
            ]
          },
          {
            "type": "list",
            "title": "Wichtige Bestandteile",
            "items": [
              "std::pair<T1, T2> - Tupel aus genau zwei Werten",
              "std::make_pair - erstellt ein pair mit Typableitung",
              "first / second - Zugriff auf die Elemente",
              "std::swap - tauscht zwei Werte",
              "std::move - wandelt ein Objekt in einen rvalue um, sodass ein Move m√∂glich ist"
            ]
          },
          {
            "type": "code",
            "title": "pair erstellen und verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    std::pair<int, std::string> p(1, \"eins\");\n\n    std::cout << p.first << std::endl;  // Ausgabe: 1\n    std::cout << p.second << std::endl; // Ausgabe: eins\n}\n"
          },
          {
            "type": "code",
            "title": "make_pair und strukturierte Bindung",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    auto p = std::make_pair(10, 3.14);\n\n    auto [a, b] = p; // Strukturierte Bindung\n    std::cout << a << \" \" << b << std::endl;\n}\n"
          },
          {
            "type": "code",
            "title": "swap verwenden",
            "language": "cpp",
            "code": "#include <iostream>\n#include <utility>\n\nint main() {\n    int a = 5;\n    int b = 10;\n\n    std::swap(a, b); // Werte tauschen\n\n    std::cout << a << \" \" << b << std::endl; // Ausgabe: 10 5\n}\n"
          },
          {
            "type": "code",
            "title": "std::move: Besitz von Ressourcen √ºbertragen",
            "language": "cpp",
            "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nint main() {\n    std::vector<int> a = {1, 2, 3, 4};\n\n    // a besitzt initial 4 Elemente\n    std::cout << \"a.size() vor move: \" << a.size() << std::endl;\n    // Ausgabe: a.size() vor move: 4\n\n    // std::move wandelt a in einen rvalue um\n    // Der Move-Konstruktor von std::vector wird verwendet\n    std::vector<int> b = std::move(a);\n\n    // b √ºbernimmt den Speicher von a\n    std::cout << \"b.size(): \" << b.size() << std::endl;\n    // Ausgabe: b.size(): 4\n\n    // a ist nach dem Move weiterhin g√ºltig,\n    // aber sein Inhalt ist nicht mehr definiert\n    // Bei std::vector ist a typischerweise leer\n    std::cout << \"a.size() nach move: \" << a.size() << std::endl;\n    // Typische Ausgabe: a.size() nach move: 0\n}\n"
          },
          {
            "type": "comparison",
            "title": "pair vs tuple",
            "columns": ["std::pair", "std::tuple"],
            "rows": [
              {
                "aspect": "Anzahl Elemente",
                "values": ["Genau 2", "Beliebig"]
              },
              {
                "aspect": "Lesbarkeit",
                "values": ["H√∂her", "Geringer"]
              },
              {
                "aspect": "Typableitung",
                "values": ["make_pair", "make_tuple"]
              }
            ]
          },
          {
            "type": "pitfall",
            "title": "first und second",
            "text": "Die Bedeutung von first und second ist semantisch nicht festgelegt und kann Code schwer lesbar machen."
          },
          {
            "type": "important",
            "text": "std::pair eignet sich gut f√ºr einfache Zweierkombinationen, sollte aber nicht komplexe Datenstrukturen ersetzen."
          },
          {
            "type": "summary",
            "points": [
              "<utility> stellt pair und swap bereit",
              "std::pair b√ºndelt zwei Werte",
              "swap tauscht Inhalte effizient",
              "F√ºr mehr als zwei Werte ist tuple besser geeignet"
            ]
          }
        ]
      }
        ]
      }
    ]
  },

  {
    "category": "Klassen & OOP",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "Basics",
        "icon": "üß±",
        "topics": [
        {
          "title": "Klassen Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Klasse",
              "text": "Eine Klasse ist ein benutzerdefinierter Datentyp, der Daten und zugeh√∂rige Funktionen kapselt."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Klassen",
              "text": [
                "Klassen sind das zentrale Konzept der objektorientierten Programmierung in C++.",
                "Sie b√ºndeln Daten und Verhalten und bilden reale oder logische Konzepte ab."
              ]
            },
            {
              "type": "explanation",
              "title": "Bestandteile einer Klasse",
              "text": [
                "Eine Klasse besteht aus Attributen f√ºr den Zustand und Methoden f√ºr das Verhalten.",
                "√úber Zugriffsspezifizierer wird gesteuert, welche Teile von au√üen sichtbar sind."
              ]
            },
            {
              "type": "list",
              "title": "Zugriffsspezifizierer",
              "items": [
                "public - von √ºberall zugreifbar",
                "private - nur innerhalb der Klasse zugreifbar",
                "protected - innerhalb der Klasse und abgeleiteter Klassen"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Person {\npublic:\n    void begruessen() {\n        std::cout << \"Hallo\" << std::endl;\n    }\n\nprivate:\n    int alter;\n};\n\nint main() {\n    Person p;\n    p.begruessen(); // Zugriff auf √∂ffentliche Methode\n}\n"
            },
            {
              "type": "comparison",
              "title": "class vs struct",
              "columns": ["class", "struct"],
              "rows": [
                {
                  "aspect": "Standard-Zugriff",
                  "values": ["private", "public"]
                },
                {
                  "aspect": "Einsatz",
                  "values": ["Objektorientierung", "Datenstrukturen"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Fehlende Kapselung",
              "text": "√ñffentliche Attribute verletzen die Kapselung und machen Code schwer wartbar."
            },
            {
              "type": "important",
              "text": "Klassen sollten Daten kapseln und nur notwendige Schnittstellen nach au√üen anbieten."
            },
            {
              "type": "summary",
              "points": [
                "Klassen b√ºndeln Daten und Verhalten",
                "Zugriff wird √ºber public, private und protected gesteuert",
                "Kapselung ist ein zentrales OOP-Prinzip"
              ]
            }
          ]
        },
        {
          "title": "Konstruktoren & Destruktoren",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Konstruktor und Destruktor",
              "text": "Konstruktoren initialisieren Objekte beim Erzeugen, Destruktoren r√§umen beim Zerst√∂ren auf."
            },
            {
              "type": "explanation",
              "title": "Konstruktoren",
              "text": [
                "Ein Konstruktor wird automatisch beim Erzeugen eines Objekts aufgerufen.",
                "Er hat keinen R√ºckgabetyp und tr√§gt den gleichen Namen wie die Klasse."
              ]
            },
            {
              "type": "explanation",
              "title": "Destruktoren",
              "text": [
                "Ein Destruktor wird automatisch beim Zerst√∂ren eines Objekts aufgerufen.",
                "Er wird h√§ufig genutzt, um Ressourcen wie Speicher oder Dateien freizugeben."
              ]
            },
            {
              "type": "list",
              "title": "Wichtige Eigenschaften",
              "items": [
                "Konstruktoren k√∂nnen √ºberladen werden",
                "Destruktoren haben keine Parameter",
                "Pro Klasse existiert maximal ein Destruktor"
              ]
            },
            {
              "type": "code",
              "title": "Konstruktor und Destruktor",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Test {\npublic:\n    Test() {\n        std::cout << \"Konstruktor\" << std::endl;\n    }\n\n    ~Test() {\n        std::cout << \"Destruktor\" << std::endl;\n    }\n};\n\nint main() {\n    Test t; // Konstruktor wird aufgerufen\n} // Destruktor wird hier automatisch aufgerufen\n"
            },
            {
              "type": "code",
              "title": "Konstruktor mit Parametern",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt(int x, int y) : x(x), y(y) {}\n\n    void anzeigen() {\n        std::cout << x << \", \" << y << std::endl;\n    }\n\nprivate:\n    int x;\n    int y;\n};\n\nint main() {\n    Punkt p(3, 4);\n    p.anzeigen();\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Nicht initialisierte Attribute",
              "text": "Werden Attribute nicht im Konstruktor initialisiert, k√∂nnen undefinierte Werte entstehen."
            },
            {
              "type": "important",
              "text": "Initialisierung sollte bevorzugt √ºber Initialisierungslisten erfolgen."
            },
            {
              "type": "summary",
              "points": [
                "Konstruktoren initialisieren Objekte",
                "Destruktoren geben Ressourcen frei",
                "Initialisierungslisten sind Best Practice",
                "Automatischer Aufruf durch Lebensdauer"
              ]
            }
          ]
        },
        {
          "title": "Copy-Konstruktor & Zuweisungsoperator",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Copy-Konstruktor und Copy-Zuweisungsoperator",
              "text": "Der Copy-Konstruktor erstellt ein neues Objekt als Kopie eines bestehenden, der Zuweisungsoperator √ºberschreibt ein bestehendes Objekt mit den Werten eines anderen."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Beide Mechanismen regeln, wie Objekte kopiert werden.",
                "Sie sind besonders wichtig, wenn eine Klasse Ressourcen wie Speicher oder Dateien verwaltet."
              ]
            },
            {
              "type": "explanation",
              "title": "Copy-Konstruktor",
              "text": [
                "Der Copy-Konstruktor wird beim Erzeugen eines neuen Objekts aus einem bestehenden aufgerufen.",
                "Er hat die Signatur Klasse(const Klasse& other)."
              ]
            },
            {
              "type": "explanation",
              "title": "Copy-Zuweisungsoperator",
              "text": [
                "Der Zuweisungsoperator wird aufgerufen, wenn ein existierendes Objekt einem anderen zugewiesen wird.",
                "Er hat die Signatur Klasse& operator=(const Klasse& other)."
              ]
            },
            {
              "type": "list",
              "title": "Typische Aufrufstellen",
              "items": [
                "√úbergabe von Objekten per Wert an Funktionen",
                "R√ºckgabe von Objekten per Wert",
                "Zuweisung mit dem = Operator",
                "Initialisierung aus einem bestehenden Objekt"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher Copy-Konstruktor",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    int x;\n\n    Punkt(int x) : x(x) {}\n\n    Punkt(const Punkt& other) : x(other.x) {\n        std::cout << \"Copy-Konstruktor\" << std::endl;\n    }\n};\n\nint main() {\n    Punkt a(5);\n    Punkt b = a; // Copy-Konstruktor\n}\n"
            },
            {
              "type": "code",
              "title": "Copy-Zuweisungsoperator",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    int x;\n\n    Punkt(int x) : x(x) {}\n\n    Punkt& operator=(const Punkt& other) {\n        if (this != &other) {\n            x = other.x; // Selbstzuweisung pr√ºfen\n        }\n        return *this;\n    }\n};\n\nint main() {\n    Punkt a(1);\n    Punkt b(2);\n\n    b = a; // Copy-Zuweisung\n}\n"
            },
            {
              "type": "comparison",
              "title": "Copy-Konstruktor vs Zuweisung",
              "columns": ["Copy-Konstruktor", "Zuweisungsoperator"],
              "rows": [
                {
                  "aspect": "Objekt existiert bereits",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Wird bei Initialisierung aufgerufen",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Muss Selbstzuweisung pr√ºfen",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Flache Kopie bei Ressourcen",
              "text": "Bei Klassen mit Zeigern f√ºhrt eine flache Kopie oft zu doppeltem Freigeben oder Speicherfehlern."
            },
            {
              "type": "important",
              "text": "Sobald eine Klasse Ressourcen besitzt, m√ºssen Copy-Konstruktor und Zuweisungsoperator bewusst definiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Copy-Konstruktor erzeugt neue Objekte",
                "Zuweisungsoperator √ºberschreibt bestehende Objekte",
                "Selbstzuweisung muss ber√ºcksichtigt werden",
                "Besonders wichtig bei Ressourcenverwaltung"
              ]
            }
          ]
        },
        {
          "title": "Move-Konstruktor & Move-Zuweisung & Rvalue-Referenzen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Move-Semantik",
              "text": "Move-Semantik erlaubt das effiziente √úbertragen von Ressourcen aus tempor√§ren Objekten mithilfe von Rvalue-Referenzen."
            },
            {
              "type": "explanation",
              "title": "Motivation",
              "text": [
                "Das Kopieren von Objekten mit dynamischen Ressourcen ist teuer.",
                "Move-Semantik erm√∂glicht es, Besitz zu √ºbernehmen statt Daten zu kopieren."
              ]
            },
            {
              "type": "explanation",
              "title": "Rvalue-Referenzen",
              "text": [
                "Rvalue-Referenzen werden mit && deklariert.",
                "Sie binden an tempor√§re Objekte oder an Objekte, die explizit mit std::move markiert wurden."
              ]
            },
            {
              "type": "explanation",
              "title": "Move-Konstruktor",
              "text": [
                "Der Move-Konstruktor erzeugt ein neues Objekt, indem er Ressourcen aus einem anderen Objekt √ºbernimmt.",
                "Er hat die Signatur Klasse(Klasse&& other)."
              ]
            },
            {
              "type": "explanation",
              "title": "Move-Zuweisungsoperator",
              "text": [
                "Der Move-Zuweisungsoperator √ºberschreibt ein bestehendes Objekt mit den Ressourcen eines anderen.",
                "Er hat die Signatur Klasse& operator=(Klasse&& other)."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzf√§lle",
              "items": [
                "R√ºckgabe gro√üer Objekte aus Funktionen",
                "Einf√ºgen in Container wie std::vector",
                "Explizite Verwendung von std::move",
                "Optimierung von Performance-kritischem Code"
              ]
            },
            {
              "type": "code",
              "title": "Move-Konstruktor",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    Puffer(int wert) {\n        daten = new int(wert);\n    }\n\n    Puffer(Puffer&& other) noexcept : daten(other.daten) {\n        other.daten = nullptr;\n        std::cout << \"Move-Konstruktor\" << std::endl;\n    }\n\n    ~Puffer() {\n        delete daten;\n    }\n};\n\nint main() {\n    Puffer a(5);\n    Puffer b = std::move(a); // Move-Konstruktor\n}\n"
            },
            {
              "type": "code",
              "title": "Move-Zuweisungsoperator",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    Puffer(int wert) {\n        daten = new int(wert);\n    }\n\n    Puffer& operator=(Puffer&& other) noexcept {\n        if (this != &other) {\n            delete daten;            // Alte Ressource freigeben\n            daten = other.daten;     // Ressource √ºbernehmen\n            other.daten = nullptr;   // Quelle leeren\n        }\n        return *this;\n    }\n\n    ~Puffer() {\n        delete daten;\n    }\n};\n\nint main() {\n    Puffer a(1);\n    Puffer b(2);\n\n    b = std::move(a); // Move-Zuweisung\n}\n"
            },
            {
              "type": "code",
              "title": "Rvalue-Referenz als Parameter",
              "language": "cpp",
              "code": "#include <iostream>\n#include <string>\n\nvoid verarbeite(std::string&& s) {\n    std::cout << s << std::endl;\n}\n\nint main() {\n    verarbeite(std::string(\"Hallo\")); // tempor√§res Objekt\n}\n"
            },
            {
              "type": "comparison",
              "title": "Copy vs Move",
              "columns": ["Copy", "Move"],
              "rows": [
                {
                  "aspect": "Ressourcenbehandlung",
                  "values": ["Kopieren", "√úbernehmen"]
                },
                {
                  "aspect": "Kosten",
                  "values": ["Hoch", "Sehr gering"]
                },
                {
                  "aspect": "Zustand der Quelle",
                  "values": ["Unver√§ndert", "G√ºltig aber leer"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessene Absicherung",
              "text": "Wird die Quelle nach der Move-Operation nicht korrekt geleert, kann es zu doppeltem Freigeben kommen."
            },
            {
              "type": "important",
              "text": "Move-Konstruktoren und Move-Zuweisungsoperatoren sollten noexcept sein, damit Standardcontainer sie effizient nutzen k√∂nnen."
            },
            {
              "type": "summary",
              "points": [
                "Rvalue-Referenzen erm√∂glichen Move-Semantik",
                "Move-Konstruktor erzeugt neue Objekte effizient",
                "Move-Zuweisung √ºberschreibt bestehende Objekte",
                "std::move markiert Objekte als verschiebbar"
              ]
            }
          ]
        },
        {
          "title": "Rule of Five",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Rule of Five",
              "text": "Die Rule of Five besagt, dass eine Klasse bei eigener Ressourcenverwaltung in der Regel f√ºnf spezielle Memberfunktionen explizit definieren sollte."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Sobald eine Klasse eine Ressource wie dynamischen Speicher, Dateien oder Handles besitzt, reicht das implizite Verhalten des Compilers oft nicht aus.",
                "Die Rule of Five erweitert die fr√ºhere Rule of Three um Move-Semantik."
              ]
            },
            {
              "type": "explanation",
              "title": "Die f√ºnf speziellen Memberfunktionen",
              "text": [
                "Diese Funktionen steuern Erzeugung, Kopieren, Verschieben und Zerst√∂rung von Objekten.",
                "Sie m√ºssen konsistent zusammen implementiert werden, um Fehler zu vermeiden."
              ]
            },
            {
              "type": "list",
              "title": "Bestandteile der Rule of Five",
              "items": [
                "Destruktor",
                "Copy-Konstruktor",
                "Copy-Zuweisungsoperator",
                "Move-Konstruktor",
                "Move-Zuweisungsoperator"
              ]
            },
            {
              "type": "code",
              "title": "Beispielklasse mit Ressource",
              "language": "cpp",
              "code": "#include <iostream>\n#include <utility>\n\nclass Puffer {\npublic:\n    int* daten;\n\n    // Konstruktor\n    Puffer(int wert) : daten(new int(wert)) {}\n\n    // Destruktor\n    ~Puffer() {\n        delete daten;\n    }\n\n    // Copy-Konstruktor\n    Puffer(const Puffer& other) : daten(new int(*other.daten)) {}\n\n    // Copy-Zuweisungsoperator\n    Puffer& operator=(const Puffer& other) {\n        if (this != &other) {\n            delete daten;\n            daten = new int(*other.daten);\n        }\n        return *this;\n    }\n\n    // Move-Konstruktor\n    Puffer(Puffer&& other) noexcept : daten(other.daten) {\n        other.daten = nullptr;\n    }\n\n    // Move-Zuweisungsoperator\n    Puffer& operator=(Puffer&& other) noexcept {\n        if (this != &other) {\n            delete daten;\n            daten = other.daten;\n            other.daten = nullptr;\n        }\n        return *this;\n    }\n};\n"
            },
            {
              "type": "comparison",
              "title": "Rule of Three vs Rule of Five",
              "columns": ["Rule of Three", "Rule of Five"],
              "rows": [
                {
                  "aspect": "Ber√ºcksichtigung von Move-Semantik",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Moderne C++ Relevanz",
                  "values": ["Begrenzt", "Hoch"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unvollst√§ndige Implementierung",
              "text": "Wer nur einige der f√ºnf Funktionen definiert, riskiert inkonsistentes Verhalten und Speicherfehler."
            },
            {
              "type": "important",
              "text": "Wenn keine eigene Ressource verwaltet wird, sollten diese Funktionen gar nicht definiert werden."
            },
            {
              "type": "summary",
              "points": [
                "Rule of Five gilt bei eigener Ressourcenverwaltung",
                "Umfasst Copy und Move Semantik",
                "Verhindert Speicherfehler und doppeltes Freigeben",
                "Ohne Ressourcen besser gar nicht implementieren"
              ]
            }
          ]
        },
        {
          "title": "Implizite Klassenbestandteile & = delete",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Implizite Klassenbestandteile",
              "text": "Implizite Klassenbestandteile sind spezielle Memberfunktionen, die der Compiler automatisch generiert, wenn sie nicht explizit definiert werden."
            },
            {
              "type": "explanation",
              "title": "Automatisch generierte Funktionen",
              "text": [
                "Der Compiler erzeugt bestimmte Memberfunktionen automatisch, wenn keine eigene Implementierung vorhanden ist.",
                "Dieses Verhalten kann zu unerwarteten Kopien oder Zuweisungen f√ºhren, insbesondere bei Ressourcenverwaltung."
              ]
            },
            {
              "type": "list",
              "title": "Implizit generierte Memberfunktionen",
              "items": [
                "Standardkonstruktor",
                "Destruktor",
                "Copy-Konstruktor",
                "Copy-Zuweisungsoperator",
                "Move-Konstruktor",
                "Move-Zuweisungsoperator"
              ]
            },
            {
              "type": "explanation",
              "title": "Steuerung mit = delete",
              "text": [
                "Mit = delete kann die automatische Generierung oder Nutzung bestimmter Funktionen verboten werden.",
                "Dadurch wird fehlerhafte oder unerw√ºnschte Verwendung bereits zur Compilezeit verhindert."
              ]
            },
            {
              "type": "code",
              "title": "Kopieren verbieten mit = delete",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass NichtKopierbar {\npublic:\n    NichtKopierbar() = default;\n    NichtKopierbar(const NichtKopierbar&) = delete;\n    NichtKopierbar& operator=(const NichtKopierbar&) = delete;\n};\n\nint main() {\n    NichtKopierbar a;\n    // NichtKopierbar b = a; // Fehler: Copy-Konstruktor ist gel√∂scht\n}\n"
            },
            {
              "type": "code",
              "title": "Gezielte Standardimplementierung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Einfach {\npublic:\n    Einfach() = default; // explizit erlaubter Standardkonstruktor\n};\n\nint main() {\n    Einfach e;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Implizit vs explizit gel√∂scht",
              "columns": ["Implizit generiert", "= delete"],
              "rows": [
                {
                  "aspect": "Verf√ºgbarkeit",
                  "values": ["Automatisch", "Verboten"]
                },
                {
                  "aspect": "Fehlerzeitpunkt",
                  "values": ["Zur Laufzeit m√∂glich", "Zur Compilezeit"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unerwartete Kopien",
              "text": "Ohne explizite Kontrolle kann der Compiler Kopieroperationen erzeugen, die bei Ressourcen zu Fehlern f√ºhren."
            },
            {
              "type": "important",
              "text": "= delete ist ein wichtiges Werkzeug, um Klassenschnittstellen eindeutig und sicher zu gestalten."
            },
            {
              "type": "summary",
              "points": [
                "Compiler erzeugt spezielle Memberfunktionen automatisch",
                "= delete verbietet deren Nutzung explizit",
                "Fehler werden zur Compilezeit erkannt",
                "Besonders wichtig bei Ressourcenverwaltung"
              ]
            }
          ]
        },
        {
          "title": "explicit & friend",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "explicit und friend",
              "text": "explicit verhindert implizite Typumwandlungen bei Konstruktoren, friend erlaubt gezielten Zugriff auf private Klassenbestandteile."
            },
            {
              "type": "explanation",
              "title": "explicit",
              "text": [
                "Das Schl√ºsselwort explicit wird bei Konstruktoren mit einem Parameter verwendet.",
                "Es verhindert implizite Typkonvertierungen, die sonst automatisch vom Compiler durchgef√ºhrt w√ºrden."
              ]
            },
            {
              "type": "explanation",
              "title": "Warum explicit wichtig ist",
              "text": [
                "Implizite Konvertierungen k√∂nnen zu unerwartetem Verhalten und schwer auffindbaren Fehlern f√ºhren.",
                "explicit macht Konstruktoraufrufe bewusst und eindeutig."
              ]
            },
            {
              "type": "code",
              "title": "Implizite Konvertierung ohne explicit",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zahl {\npublic:\n    Zahl(int x) : x(x) {}\n\n    int x;\n};\n\nvoid ausgabe(Zahl z) {\n    std::cout << z.x << std::endl;\n}\n\nint main() {\n    ausgabe(5); // implizite Konvertierung von int zu Zahl\n}\n"
            },
            {
              "type": "code",
              "title": "explicit verhindert implizite Konvertierung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zahl {\npublic:\n    explicit Zahl(int x) : x(x) {}\n\n    int x;\n};\n\nvoid ausgabe(Zahl z) {\n    std::cout << z.x << std::endl;\n}\n\nint main() {\n    // ausgabe(5); // Fehler: implizite Konvertierung verboten\n    ausgabe(Zahl(5)); // expliziter Aufruf\n}\n"
            },
            {
              "type": "explanation",
              "title": "friend",
              "text": [
                "Mit friend kann einer fremden Funktion oder Klasse Zugriff auf private und protected Member gew√§hrt werden.",
                "friend durchbricht gezielt die Kapselung, ohne die Member √∂ffentlich zu machen."
              ]
            },
            {
              "type": "code",
              "title": "friend Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Geheim {\n    int wert = 42;\n\n    friend void zeige(const Geheim& g);\n};\n\nvoid zeige(const Geheim& g) {\n    std::cout << g.wert << std::endl; // Zugriff erlaubt\n}\n\nint main() {\n    Geheim g;\n    zeige(g);\n}\n"
            },
            {
              "type": "code",
              "title": "friend Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass A {\n    int x = 10;\n\n    friend class B;\n};\n\nclass B {\npublic:\n    void drucke(const A& a) {\n        std::cout << a.x << std::endl; // Zugriff auf private Member\n    }\n};\n\nint main() {\n    A a;\n    B b;\n    b.drucke(a);\n}\n"
            },
            {
              "type": "comparison",
              "title": "explicit vs friend",
              "columns": ["explicit", "friend"],
              "rows": [
                {
                  "aspect": "Zweck",
                  "values": ["Verhindert implizite Konvertierung", "Erlaubt privaten Zugriff"]
                },
                {
                  "aspect": "Beeinflusst Kapselung",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "√úberm√§√üiger friend Einsatz",
              "text": "Zu viele friend Deklarationen schw√§chen die Kapselung und erschweren Wartung."
            },
            {
              "type": "important",
              "text": "explicit sollte standardm√§√üig bei Ein-Parameter-Konstruktoren verwendet werden."
            },
            {
              "type": "summary",
              "points": [
                "explicit verhindert unerw√ºnschte implizite Konvertierungen",
                "friend erlaubt gezielten Zugriff auf private Member",
                "Beide Schl√ºsselw√∂rter erh√∂hen Code-Sicherheit bei richtiger Nutzung"
              ]
            }
          ]
        },
        {
          "title": "Getter-Funktionen & Setter-Funktionen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Getter und Setter",
              "text": "Getter- und Setter-Funktionen sind Methoden, mit denen kontrolliert auf private Attribute einer Klasse zugegriffen wird."
            },
            {
              "type": "explanation",
              "title": "Zweck von Getter und Setter",
              "text": [
                "Sie kapseln den Zugriff auf interne Daten einer Klasse.",
                "Dadurch k√∂nnen Invarianten und Validierungen zentral sichergestellt werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Getter-Funktionen",
              "text": [
                "Getter liefern den aktuellen Wert eines Attributs zur√ºck.",
                "Sie sollten den Zustand des Objekts nicht ver√§ndern."
              ]
            },
            {
              "type": "explanation",
              "title": "Setter-Funktionen",
              "text": [
                "Setter setzen oder √§ndern den Wert eines Attributs.",
                "Dabei kann √ºberpr√ºft werden, ob der neue Wert g√ºltig ist."
              ]
            },
            {
              "type": "list",
              "title": "Best Practices",
              "items": [
                "Attribute private halten",
                "Getter m√∂glichst const deklarieren",
                "Validierung im Setter durchf√ºhren",
                "Nicht f√ºr jedes Attribut automatisch Setter bereitstellen"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Getter und Setter",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Person {\npublic:\n    void setAlter(int neuesAlter) {\n        if (neuesAlter >= 0) {\n            alter = neuesAlter;\n        }\n    }\n\n    int getAlter() const {\n        return alter;\n    }\n\nprivate:\n    int alter = 0;\n};\n\nint main() {\n    Person p;\n    p.setAlter(25);\n    std::cout << p.getAlter() << std::endl; // Ausgabe: 25\n}\n"
            },
            {
              "type": "comparison",
              "title": "Direkter Zugriff vs Getter/Setter",
              "columns": ["Direkter Zugriff", "Getter/Setter"],
              "rows": [
                {
                  "aspect": "Kapselung",
                  "values": ["Keine", "Vorhanden"]
                },
                {
                  "aspect": "Validierung m√∂glich",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Triviale Getter und Setter",
              "text": "Unkritische Weitergabe aller Attribute als Getter und Setter kann unn√∂tigen Boilerplate-Code erzeugen."
            },
            {
              "type": "important",
              "text": "Getter und Setter sollten Verhalten ausdr√ºcken und nicht nur als mechanischer Zugriff dienen."
            },
            {
              "type": "summary",
              "points": [
                "Getter lesen, Setter schreiben Attribute",
                "Kapselung sch√ºtzt interne Zust√§nde",
                "Validierung im Setter erh√∂ht Sicherheit",
                "Getter sollten const sein"
              ]
            }
          ]
        }
      ]
      },

      {
        "name": "Vererbung",
        "icon": "üå≥",
        "topics": [
        {
          "title": "Basisklassen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "Basisklasse",
              "text": "Eine Basisklasse ist eine Klasse, von der andere Klassen Eigenschaften und Verhalten erben."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Vererbung",
              "text": [
                "Vererbung erm√∂glicht es, gemeinsamen Code in einer Basisklasse zu b√ºndeln.",
                "Abgeleitete Klassen erweitern oder spezialisieren das Verhalten der Basisklasse."
              ]
            },
            {
              "type": "explanation",
              "title": "Basisklasse und abgeleitete Klasse",
              "text": [
                "Die Basisklasse definiert gemeinsame Attribute und Methoden.",
                "Die abgeleitete Klasse erbt diese Bestandteile und kann sie nutzen oder √ºberschreiben."
              ]
            },
            {
              "type": "list",
              "title": "Zugriff in der Vererbung",
              "items": [
                "public Member sind in abgeleiteten Klassen zugreifbar",
                "protected Member sind nur f√ºr abgeleitete Klassen sichtbar",
                "private Member sind nicht direkt zugreifbar"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Basisklasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Tier {\npublic:\n    void sprechen() const {\n        std::cout << \"Tier macht ein Ger√§usch\" << std::endl;\n    }\n\nprotected:\n    int alter = 0;\n};\n\nclass Hund : public Tier {\npublic:\n    void bellen() const {\n        std::cout << \"Hund bellt\" << std::endl;\n    }\n};\n\nint main() {\n    Hund h;\n    h.sprechen(); // geerbte Methode\n    h.bellen();   // eigene Methode\n}\n"
            },
            {
              "type": "comparison",
              "title": "Basisklasse vs abgeleitete Klasse",
              "columns": ["Basisklasse", "Abgeleitete Klasse"],
              "rows": [
                {
                  "aspect": "Rolle",
                  "values": ["Allgemein", "Spezialisiert"]
                },
                {
                  "aspect": "Code-Wiederverwendung",
                  "values": ["Definiert", "Nutzt"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Private Member",
              "text": "Private Member der Basisklasse sind in abgeleiteten Klassen nicht direkt zugreifbar."
            },
            {
              "type": "important",
              "text": "Basisklassen sollten eine klare, stabile Schnittstelle f√ºr abgeleitete Klassen bereitstellen."
            },
            {
              "type": "summary",
              "points": [
                "Basisklassen b√ºndeln gemeinsamen Code",
                "Abgeleitete Klassen erweitern Verhalten",
                "Zugriff wird durch public, protected und private gesteuert",
                "Vererbung f√∂rdert Wiederverwendbarkeit"
              ]
            }
          ]
        },
        {
          "title": "Polymorphie mit virtual & override",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Polymorphie",
              "text": "Polymorphie bezeichnet die F√§higkeit, dass unterschiedliche Objekte √ºber eine gemeinsame Basisklassen-Schnittstelle unterschiedlich reagieren."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Polymorphie basiert auf Vererbung und virtuellen Funktionen.",
                "Ein Basisklassen-Zeiger oder eine Referenz kann auf Objekte verschiedener abgeleiteter Klassen zeigen."
              ]
            },
            {
              "type": "explanation",
              "title": "virtual",
              "text": [
                "Mit virtual deklarierte Funktionen werden dynamisch gebunden.",
                "Welche Implementierung aufgerufen wird, entscheidet sich zur Laufzeit anhand des tats√§chlichen Objekttyps."
              ]
            },
            {
              "type": "explanation",
              "title": "override",
              "text": [
                "override kennzeichnet explizit das √úberschreiben einer virtuellen Funktion.",
                "Der Compiler pr√ºft die Signatur und verhindert unbeabsichtigtes √úberladen statt √úberschreiben."
              ]
            },
            {
              "type": "list",
              "title": "Voraussetzungen f√ºr Polymorphie",
              "items": [
                "Vererbung zwischen Basisklasse und abgeleiteten Klassen",
                "Virtuelle Funktion in der Basisklasse",
                "Zugriff √ºber Basisklassen-Zeiger oder Referenz"
              ]
            },
            {
              "type": "code",
              "title": "Polymorpher Aufruf mit virtual und override",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Tier {\npublic:\n    virtual void sprechen() const {\n        std::cout << \"Tier macht ein Ger√§usch\" << std::endl;\n    }\n\n    virtual ~Tier() = default; // Virtueller Destruktor\n};\n\nclass Hund : public Tier {\npublic:\n    void sprechen() const override {\n        std::cout << \"Hund bellt\" << std::endl;\n    }\n};\n\nclass Katze : public Tier {\npublic:\n    void sprechen() const override {\n        std::cout << \"Katze miaut\" << std::endl;\n    }\n};\n\nint main() {\n    Tier* t1 = new Hund();\n    Tier* t2 = new Katze();\n\n    t1->sprechen(); // Hund bellt\n    t2->sprechen(); // Katze miaut\n\n    delete t1;\n    delete t2;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Ohne virtual vs mit virtual",
              "columns": ["Ohne virtual", "Mit virtual"],
              "rows": [
                {
                  "aspect": "Bindungszeitpunkt",
                  "values": ["Compilezeit", "Laufzeit"]
                },
                {
                  "aspect": "Aufgerufene Funktion",
                  "values": ["Basisklasse", "Tats√§chlicher Objekttyp"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Fehlender virtueller Destruktor",
              "text": "Wird ein Objekt √ºber einen Basisklassen-Zeiger gel√∂scht ohne virtuellen Destruktor, entsteht undefiniertes Verhalten."
            },
            {
              "type": "important",
              "text": "Basisklassen mit virtuellen Funktionen sollten immer einen virtuellen Destruktor besitzen."
            },
            {
              "type": "summary",
              "points": [
                "Polymorphie erm√∂glicht unterschiedliches Verhalten √ºber eine gemeinsame Schnittstelle",
                "virtual aktiviert dynamische Bindung",
                "override sch√ºtzt vor falschem √úberschreiben",
                "Virtuelle Destruktoren sind essenziell"
              ]
            }
          ]
        },
        {
          "title": "Abstrakte Klassen & Schnittstellenklassen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Abstrakte Klasse",
              "text": "Eine abstrakte Klasse ist eine Klasse, die nicht instanziiert werden kann und mindestens eine reine virtuelle Funktion besitzt."
            },
            {
              "type": "explanation",
              "title": "Grundidee abstrakter Klassen",
              "text": [
                "Abstrakte Klassen definieren ein gemeinsames Verhalten f√ºr abgeleitete Klassen.",
                "Sie dienen als konzeptionelle Basis und erzwingen bestimmte Funktionen in Unterklassen."
              ]
            },
            {
              "type": "explanation",
              "title": "Reine virtuelle Funktionen",
              "text": [
                "Eine reine virtuelle Funktion wird mit = 0 deklariert.",
                "Abgeleitete Klassen m√ºssen diese Funktion implementieren, um instanziierbar zu sein."
              ]
            },
            {
              "type": "code",
              "title": "Abstrakte Klasse mit reiner virtueller Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Form {\npublic:\n    virtual double flaeche() const = 0; // reine virtuelle Funktion\n\n    virtual ~Form() = default;\n};\n\nclass Rechteck : public Form {\npublic:\n    Rechteck(double b, double h) : breite(b), hoehe(h) {}\n\n    double flaeche() const override {\n        return breite * hoehe;\n    }\n\nprivate:\n    double breite;\n    double hoehe;\n};\n\nint main() {\n    Form* f = new Rechteck(3, 4);\n    std::cout << f->flaeche() << std::endl; // Ausgabe: 12\n    delete f;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Schnittstellenklassen",
              "text": [
                "Eine Schnittstellenklasse ist eine spezielle Form der abstrakten Klasse.",
                "Sie enth√§lt ausschlie√ülich reine virtuelle Funktionen und meist keine Attribute."
              ]
            },
            {
              "type": "list",
              "title": "Merkmale von Schnittstellenklassen",
              "items": [
                "Nur reine virtuelle Funktionen",
                "Keine oder nur konstante Attribute",
                "Kein konkretes Verhalten",
                "√ñffentliche virtuelle Schnittstelle"
              ]
            },
            {
              "type": "code",
              "title": "Schnittstellenklasse Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Druckbar {\npublic:\n    virtual void drucken() const = 0;\n    virtual ~Druckbar() = default;\n};\n\nclass Bericht : public Druckbar {\npublic:\n    void drucken() const override {\n        std::cout << \"Bericht wird gedruckt\" << std::endl;\n    }\n};\n\nint main() {\n    Druckbar* d = new Bericht();\n    d->drucken();\n    delete d;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Abstrakte Klasse vs Schnittstellenklasse",
              "columns": ["Abstrakte Klasse", "Schnittstellenklasse"],
              "rows": [
                {
                  "aspect": "Enth√§lt Implementierungen",
                  "values": ["M√∂glich", "Nein"]
                },
                {
                  "aspect": "Attribute",
                  "values": ["Erlaubt", "In der Regel nicht"]
                },
                {
                  "aspect": "Ziel",
                  "values": ["Gemeinsame Basis", "Reine Schnittstelle"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Vergessene Implementierung",
              "text": "Wird eine reine virtuelle Funktion nicht implementiert, bleibt die abgeleitete Klasse abstrakt."
            },
            {
              "type": "important",
              "text": "Abstrakte Klassen und Schnittstellen f√∂rdern sauberes Design und klare Verantwortlichkeiten."
            },
            {
              "type": "summary",
              "points": [
                "Abstrakte Klassen sind nicht instanziierbar",
                "Reine virtuelle Funktionen erzwingen Implementierung",
                "Schnittstellenklassen definieren nur Vertr√§ge",
                "Virtuelle Destruktoren sind Pflicht"
              ]
            }
          ]
        },
        {
          "title": "final Klassen & Memberfunktionen",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "final",
              "text": "Das Schl√ºsselwort final verhindert weitere Vererbung von Klassen oder das √úberschreiben virtueller Memberfunktionen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von final",
              "text": [
                "final wird eingesetzt, um eine Klasse oder eine virtuelle Funktion bewusst abzuschlie√üen.",
                "Dadurch wird sichergestellt, dass bestimmtes Verhalten nicht mehr ver√§ndert werden kann."
              ]
            },
            {
              "type": "explanation",
              "title": "final bei Klassen",
              "text": [
                "Eine mit final deklarierte Klasse kann nicht mehr abgeleitet werden.",
                "Dies ist sinnvoll f√ºr Klassen mit abgeschlossener Implementierung oder sicherheitskritischem Verhalten."
              ]
            },
            {
              "type": "code",
              "title": "Finale Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Logger final {\npublic:\n    void log() const {\n        std::cout << \"Logeintrag\" << std::endl;\n    }\n};\n\n// class FileLogger : public Logger {}; // Fehler: Vererbung verboten\n\nint main() {\n    Logger l;\n    l.log();\n}\n"
            },
            {
              "type": "explanation",
              "title": "final bei Memberfunktionen",
              "text": [
                "Virtuelle Funktionen k√∂nnen mit final markiert werden.",
                "Dadurch wird verhindert, dass abgeleitete Klassen diese Funktion √ºberschreiben."
              ]
            },
            {
              "type": "code",
              "title": "Finale Memberfunktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    virtual void ausgabe() const {\n        std::cout << \"Basis\" << std::endl;\n    }\n};\n\nclass Abgeleitet : public Basis {\npublic:\n    void ausgabe() const final {\n        std::cout << \"Abgeleitet\" << std::endl;\n    }\n};\n\n// class Weiter : public Abgeleitet {\n// public:\n//     void ausgabe() const override {} // Fehler: Funktion ist final\n// };\n\nint main() {\n    Basis* b = new Abgeleitet();\n    b->ausgabe();\n    delete b;\n}\n"
            },
            {
              "type": "comparison",
              "title": "final Klasse vs final Funktion",
              "columns": ["final Klasse", "final Funktion"],
              "rows": [
                {
                  "aspect": "Vererbung verhindern",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "√úberschreiben verhindern",
                  "values": ["Indirekt", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zu restriktiver Einsatz",
              "text": "√úberm√§√üiger Einsatz von final kann Erweiterbarkeit und Testbarkeit unn√∂tig einschr√§nken."
            },
            {
              "type": "important",
              "text": "final macht Designentscheidungen explizit und verhindert unbeabsichtigte Erweiterungen."
            },
            {
              "type": "summary",
              "points": [
                "final verhindert weitere Vererbung",
                "finale Memberfunktionen d√ºrfen nicht √ºberschrieben werden",
                "Erh√∂ht Stabilit√§t und Designklarheit",
                "Sollte bewusst und sparsam eingesetzt werden"
              ]
            }
          ]
        },
        {
          "title": "Mehrfachvererbung",
          "difficulty": "advanced",
          "blocks": [
            {
              "type": "definition",
              "term": "Mehrfachvererbung",
              "text": "Mehrfachvererbung bezeichnet die Vererbung von mehr als einer Basisklasse in einer abgeleiteten Klasse."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Mehrfachvererbung",
              "text": [
                "Eine Klasse kann gleichzeitig Eigenschaften und Verhalten aus mehreren Basisklassen √ºbernehmen.",
                "Dies erm√∂glicht flexible Modellierung, erh√∂ht aber die Komplexit√§t des Designs."
              ]
            },
            {
              "type": "explanation",
              "title": "Typische Einsatzf√§lle",
              "text": [
                "Kombination unabh√§ngiger Rollen oder F√§higkeiten.",
                "Implementierung mehrerer Schnittstellen in einer Klasse."
              ]
            },
            {
              "type": "list",
              "title": "Probleme der Mehrfachvererbung",
              "items": [
                "Namenskonflikte zwischen Basisklassen",
                "Mehrdeutiger Zugriff auf Member",
                "Diamond-Problem",
                "Erh√∂hte Komplexit√§t"
              ]
            },
            {
              "type": "code",
              "title": "Einfache Mehrfachvererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Druckbar {\npublic:\n    void drucken() const {\n        std::cout << \"Drucken\" << std::endl;\n    }\n};\n\nclass Speicherbar {\npublic:\n    void speichern() const {\n        std::cout << \"Speichern\" << std::endl;\n    }\n};\n\nclass Dokument : public Druckbar, public Speicherbar {\n};\n\nint main() {\n    Dokument d;\n    d.drucken();\n    d.speichern();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Diamond-Problem",
              "text": [
                "Das Diamond-Problem entsteht, wenn zwei Basisklassen von einer gemeinsamen Oberklasse erben.",
                "Die abgeleitete Klasse enth√§lt dann mehrere Kopien der gemeinsamen Basisklasse."
              ]
            },
            {
              "type": "code",
              "title": "Diamond-Problem ohne virtuelle Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    int wert = 1;\n};\n\nclass Links : public Basis {};\nclass Rechts : public Basis {};\n\nclass Unten : public Links, public Rechts {};\n\nint main() {\n    Unten u;\n    // u.wert = 5; // Fehler: Mehrdeutig\n}\n"
            },
            {
              "type": "explanation",
              "title": "Virtuelle Vererbung",
              "text": [
                "Virtuelle Vererbung stellt sicher, dass eine gemeinsame Basisklasse nur einmal existiert.",
                "Sie wird mit virtual in der Vererbungsdeklaration angegeben."
              ]
            },
            {
              "type": "code",
              "title": "Diamond-Problem mit virtueller Vererbung",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Basis {\npublic:\n    int wert = 1;\n};\n\nclass Links : public virtual Basis {};\nclass Rechts : public virtual Basis {};\n\nclass Unten : public Links, public Rechts {};\n\nint main() {\n    Unten u;\n    u.wert = 5; // eindeutig\n    std::cout << u.wert << std::endl;\n}\n"
            },
            {
              "type": "comparison",
              "title": "Normale vs virtuelle Vererbung",
              "columns": ["Normale Vererbung", "Virtuelle Vererbung"],
              "rows": [
                {
                  "aspect": "Anzahl Basisobjekte",
                  "values": ["Mehrere", "Genau eines"]
                },
                {
                  "aspect": "Komplexit√§t",
                  "values": ["Geringer", "H√∂her"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "√úberm√§√üige Nutzung",
              "text": "Mehrfachvererbung kann Design unn√∂tig verkomplizieren und sollte gezielt eingesetzt werden."
            },
            {
              "type": "important",
              "text": "Mehrfachvererbung ist sinnvoll bei Schnittstellen, bei Klassen mit Implementierung jedoch riskant."
            },
            {
              "type": "summary",
              "points": [
                "Mehrfachvererbung erlaubt mehrere Basisklassen",
                "Kann zu Mehrdeutigkeiten f√ºhren",
                "Diamond-Problem ist zentraler Sonderfall",
                "Virtuelle Vererbung l√∂st das Diamond-Problem"
              ]
            }
          ]
        }
        ]
      }
    ]
  },





  {
    "category": "Sprachkonstrukte",
    "icon": "üß±",
    "subcategories": [
      {
        "name": "struct",
        "icon": "üì¶",
        "topics": [
        {
          "title": "struct Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "struct",
              "text": "struct ist ein benutzerdefinierter Datentyp zur B√ºndelung mehrerer zusammengeh√∂riger Daten unter einem Namen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von struct",
              "text": [
                "structs dienen dazu, einfache Daten logisch zusammenzufassen.",
                "Der Fokus liegt typischerweise auf Daten und nicht auf komplexem Verhalten."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Alle Member sind standardm√§√üig √∂ffentlich zugreifbar.",
                "structs k√∂nnen Attribute, Methoden, Konstruktoren und Destruktoren enthalten."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Zusammenfassen von Messwerten oder Koordinaten",
                "Einfache R√ºckgabestrukturen von Funktionen",
                "Plain-Data-Strukturen ohne Invarianten"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches struct",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n};\n\nint main() {\n    Punkt p{3, 4};\n    std::cout << p.x << \", \" << p.y << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "struct mit Methode",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct Rechteck {\n    int breite;\n    int hoehe;\n\n    int flaeche() const {\n        return breite * hoehe;\n    }\n};\n\nint main() {\n    Rechteck r{5, 4};\n    std::cout << r.flaeche() << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Fehlende Validierung",
              "text": "√ñffentliche Attribute erlauben unkontrollierte Zustands√§nderungen."
            },
            {
              "type": "important",
              "text": "structs eignen sich besonders f√ºr einfache, datenorientierte Typen."
            },
            {
              "type": "summary",
              "points": [
                "struct b√ºndelt zusammengeh√∂rige Daten",
                "Member sind standardm√§√üig public",
                "Geeignet f√ºr einfache Datenstrukturen"
              ]
            }
          ]
        },
        {
          "title": "struct vs class",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "struct und class",
              "text": "struct und class sind nahezu identische Sprachkonstrukte in C++ mit unterschiedlichem Standard-Zugriffsverhalten."
            },
            {
              "type": "explanation",
              "title": "Gemeinsamkeiten",
              "text": [
                "Beide k√∂nnen Attribute, Methoden, Konstruktoren und Destruktoren enthalten.",
                "Beide unterst√ºtzen Vererbung, Polymorphie und Zugriffsspezifizierer."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentraler Unterschied",
              "text": [
                "Bei struct sind Member standardm√§√üig public.",
                "Bei class sind Member standardm√§√üig private."
              ]
            },
            {
              "type": "comparison",
              "title": "Direkter Vergleich",
              "columns": ["struct", "class"],
              "rows": [
                {
                  "aspect": "Standard-Zugriff",
                  "values": ["public", "private"]
                },
                {
                  "aspect": "Typischer Einsatzzweck",
                  "values": ["Datenstruktur", "Objekt mit Logik"]
                }
              ]
            },
            {
              "type": "code",
              "title": "Standard-Zugriff bei struct",
              "language": "cpp",
              "code": "#include <iostream>\n\nstruct A {\n    int x; // public\n};\n\nint main() {\n    A a;\n    a.x = 5;\n}\n"
            },
            {
              "type": "code",
              "title": "Standard-Zugriff bei class",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass B {\n    int x; // private\n};\n\nint main() {\n    B b;\n    // b.x = 5; // Fehler: private Zugriff\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Falsche Semantik",
              "text": "Die Wahl von struct oder class sollte die beabsichtigte Bedeutung des Typs widerspiegeln."
            },
            {
              "type": "important",
              "text": "Die Wahl zwischen struct und class ist semantisch und konzeptionell, nicht technisch."
            },
            {
              "type": "summary",
              "points": [
                "struct und class sind technisch gleichwertig",
                "Unterschied liegt im Standard-Zugriff",
                "struct f√ºr Daten, class f√ºr Logik",
                "Semantik sollte klar erkennbar sein"
              ]
            }
          ]
        }
      ]
      },
      {
        "name": "enum",
        "icon": "üî¢",
        "topics": [
        {
          "title": "enum Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum",
              "text": "Ein enum ist ein benutzerdefinierter Aufz√§hlungstyp, der eine endliche Menge benannter ganzzahliger Werte definiert."
            },
            {
              "type": "explanation",
              "title": "Grundidee von enum",
              "text": [
                "enum wird verwendet, um zusammengeh√∂rige konstante Werte logisch zu gruppieren.",
                "Dadurch wird Code lesbarer und weniger fehleranf√§llig als mit reinen Ganzzahlen."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Enum-Werte sind intern Ganzzahlen.",
                "Die erste Konstante beginnt standardm√§√üig bei 0 und wird hochgez√§hlt.",
                "Enum-Namen liegen im umgebenden Namensraum."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Zust√§nde und Statuswerte",
                "Optionen oder Modi",
                "Ergebnisse von Funktionen",
                "Endliche Auswahlm√∂glichkeiten"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches enum",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Farbe {\n    Rot,\n    Gruen,\n    Blau\n};\n\nint main() {\n    Farbe f = Rot;\n\n    if (f == Rot) {\n        std::cout << \"Rot\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Enum mit expliziten Werten",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Status {\n    OK = 0,\n    Fehler = 1,\n    Unbekannt = 100\n};\n\nint main() {\n    Status s = Fehler;\n    std::cout << s << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Namenskonflikte",
              "text": "Enum-Werte liegen im gleichen Namensraum und k√∂nnen mit anderen Namen kollidieren."
            },
            {
              "type": "important",
              "text": "Enums ersetzen magische Zahlen und machen Code verst√§ndlicher."
            },
            {
              "type": "summary",
              "points": [
                "enum definiert benannte Ganzzahlwerte",
                "Standardstartwert ist 0",
                "Verbessert Lesbarkeit und Wartbarkeit",
                "Geeignet f√ºr endliche Zust√§nde"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "enum class",
        "icon": "üß©",
        "topics": [
        {
          "title": "enum class Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum class",
              "text": "enum class ist ein stark typisierter Aufz√§hlungstyp mit eigenem G√ºltigkeitsbereich und ohne implizite Umwandlung in Ganzzahlen."
            },
            {
              "type": "explanation",
              "title": "Grundidee von enum class",
              "text": [
                "enum class wurde eingef√ºhrt, um typische Probleme klassischer Enums zu vermeiden.",
                "Die Aufz√§hlungswerte sind klar gekapselt und typsicher."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Enum-Werte liegen im Namensraum des enum class Typs.",
                "Es gibt keine implizite Umwandlung zu int.",
                "Der zugrundeliegende Typ kann explizit festgelegt werden."
              ]
            },
            {
              "type": "list",
              "title": "Vorteile von enum class",
              "items": [
                "Keine Namenskonflikte",
                "Starke Typisierung",
                "Bessere Lesbarkeit",
                "H√∂here Typsicherheit"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches enum class",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Farbe {\n    Rot,\n    Gruen,\n    Blau\n};\n\nint main() {\n    Farbe f = Farbe::Rot;\n\n    if (f == Farbe::Rot) {\n        std::cout << \"Rot\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "Expliziter zugrundeliegender Typ",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Status : int {\n    OK = 0,\n    Fehler = 1,\n    Unbekannt = 100\n};\n\nint main() {\n    Status s = Status::Fehler;\n    std::cout << static_cast<int>(s) << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Vergessener Scope",
              "text": "Enum-Werte m√ºssen immer mit dem Typnamen qualifiziert werden, zum Beispiel Farbe::Rot."
            },
            {
              "type": "important",
              "text": "enum class sollte in modernem C++ dem klassischen enum vorgezogen werden."
            },
            {
              "type": "summary",
              "points": [
                "enum class ist stark typisiert",
                "Keine implizite Umwandlung zu int",
                "Eigener G√ºltigkeitsbereich",
                "Bevorzugt in modernem C++"
              ]
            }
          ]
        },
        {
          "title": "enum class vs. enum",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "enum vs enum class",
              "text": "enum ist ein klassischer Aufz√§hlungstyp mit schwacher Typisierung, enum class ist ein stark typisierter Aufz√§hlungstyp mit eigenem G√ºltigkeitsbereich."
            },
            {
              "type": "explanation",
              "title": "Grundidee des Vergleichs",
              "text": [
                "Beide Konstrukte dienen zur Definition endlicher Mengen benannter Werte.",
                "enum class wurde eingef√ºhrt, um Sicherheits- und Designprobleme klassischer Enums zu l√∂sen."
              ]
            },
            {
              "type": "explanation",
              "title": "Klassisches enum",
              "text": [
                "Enum-Werte liegen im umgebenden Namensraum.",
                "Es existiert eine implizite Umwandlung zu Ganzzahlen."
              ]
            },
            {
              "type": "explanation",
              "title": "enum class",
              "text": [
                "Enum-Werte sind im G√ºltigkeitsbereich des Typs gekapselt.",
                "Es gibt keine implizite Umwandlung zu Ganzzahlen."
              ]
            },
            {
              "type": "comparison",
              "title": "Direkter Vergleich",
              "columns": ["enum", "enum class"],
              "rows": [
                {
                  "aspect": "Typisierung",
                  "values": ["Schwach", "Stark"]
                },
                {
                  "aspect": "Namensraum",
                  "values": ["Umgebend", "Eigener Typbereich"]
                },
                {
                  "aspect": "Implizite Umwandlung zu int",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Namenskonflikte m√∂glich",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Empfehlung in modernem C++",
                  "values": ["Eingeschr√§nkt", "Bevorzugt"]
                }
              ]
            },
            {
              "type": "code",
              "title": "Klassisches enum",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum Farbe {\n    Rot,\n    Gruen\n};\n\nint main() {\n    Farbe f = Rot;\n    int x = f; // implizite Umwandlung erlaubt\n    std::cout << x << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "enum class",
              "language": "cpp",
              "code": "#include <iostream>\n\nenum class Farbe {\n    Rot,\n    Gruen\n};\n\nint main() {\n    Farbe f = Farbe::Rot;\n    // int x = f; // Fehler: keine implizite Umwandlung\n    int x = static_cast<int>(f);\n    std::cout << x << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Unbeabsichtigte Typvermischung",
              "text": "Klassische Enums k√∂nnen versehentlich mit Ganzzahlen oder anderen Enums vermischt werden."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollte enum class verwendet werden, au√üer es gibt einen triftigen Grund f√ºr enum."
            },
            {
              "type": "summary",
              "points": [
                "enum ist schwach typisiert",
                "enum class ist stark typisiert",
                "enum class vermeidet Namenskonflikte",
                "enum class ist Standard in modernem C++"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "namespace",
        "icon": "üåê",
        "topics": [
        {
          "title": "namespace Grundlagen",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "namespace",
              "text": "Ein namespace ist ein G√ºltigkeitsbereich zur Strukturierung von Namen und zur Vermeidung von Namenskonflikten."
            },
            {
              "type": "explanation",
              "title": "Grundidee von namespace",
              "text": [
                "Namespaces gruppieren zusammengeh√∂rige Funktionen, Klassen und Variablen.",
                "Sie verhindern Kollisionen gleichnamiger Bezeichner in gr√∂√üeren Programmen."
              ]
            },
            {
              "type": "explanation",
              "title": "Eigenschaften",
              "text": [
                "Namespaces k√∂nnen verschachtelt werden.",
                "Der Zugriff erfolgt √ºber den Scope-Operator \"::\".",
                "Namespaces erzeugen keinen eigenen Speicher."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Strukturierung gro√üer Codebasen",
                "Trennung von Bibliotheken",
                "Vermeidung von Namenskonflikten",
                "Klarere Schnittstellen"
              ]
            },
            {
              "type": "code",
              "title": "Einfacher namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace Mathe {\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n\nint main() {\n    std::cout << Mathe::add(2, 3) << std::endl; // Ausgabe: 5\n}\n"
            },
            {
              "type": "code",
              "title": "Verschachtelte Namespaces",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace Projekt {\n    namespace Modul {\n        void info() {\n            std::cout << \"Modul\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    Projekt::Modul::info();\n}\n"
            },
            {
              "type": "code",
              "title": "Namespaces zur Strukturierung von Code",
              "language": "cpp",
              "code": "#include <iostream>\n\n// Namespace f√ºr mathematische Funktionen\nnamespace math {\n\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    int mul(int a, int b) {\n        return a * b;\n    }\n}\n\n// Namespace f√ºr Logging-Funktionen\nnamespace log {\n\n    void print(const std::string& msg) {\n        std::cout << \"[LOG] \" << msg << std::endl;\n    }\n\n}\n\n// Verschachtelter Namespace (seit C++17 bevorzugte Schreibweise)\nnamespace util::debug {\n\n    void printValue(int x) {\n        std::cout << \"[DEBUG] Wert = \" << x << std::endl;\n    }\n\n}\n\nint main() {\n    // Zugriff mit vollqualifiziertem Namen\n    int sum = math::add(3, 4);\n    int product = math::mul(3, 4);\n\n    log::print(\"Berechnung abgeschlossen\");\n\n    util::debug::printValue(sum);\n\n    // Ausgabe:\n    // [LOG] Berechnung abgeschlossen\n    // [DEBUG] Wert = 7\n}\n"
            },
            {
              "type": "code",
              "title": "Klasse in einem Namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\n// Oberer Namespace f√ºr Hilfsfunktionen\nnamespace util {\n\n    // Klasse geh√∂rt logisch zu util\n    class Counter {\n    public:\n        Counter() : value(0) {}\n\n        void increment() {\n            ++value;\n        }\n\n        int get() const {\n            return value;\n        }\n\n    private:\n        int value;\n    };\n\n    // Unter-Namespace f√ºr Debug-Funktionen\n    namespace debug {\n\n        // Funktion arbeitet mit der Klasse aus util\n        void printCounter(const Counter& c) {\n            std::cout << \"[DEBUG] Counter = \" << c.get() << std::endl;\n        }\n\n    }\n}\n\nint main() {\n    // Vollqualifizierter Zugriff auf die Klasse\n    util::Counter c;\n\n    c.increment();\n    c.increment();\n\n    // Zugriff auf Unter-Namespace\n    util::debug::printCounter(c);\n\n    // Ausgabe:\n    // [DEBUG] Counter = 2\n}\n"
            },
            {
              "type": "pitfall",
              "title": "using namespace std",
              "text": "using namespace std kann Namenskonflikte verursachen und sollte in Header-Dateien vermieden werden."
            },
            {
              "type": "important",
              "text": "Namespaces sind essenziell f√ºr sauberen, wartbaren und modularen Code."
            },
            {
              "type": "summary",
              "points": [
                "Namespaces strukturieren Namen",
                "Verhindern Namenskonflikte",
                "Zugriff √ºber ::",
                "Wichtig f√ºr gro√üe Projekte"
              ]
            }
          ]
        },
        {
          "title": "using namespace",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "using namespace",
              "text": "using namespace bindet alle Namen eines Namespaces in den aktuellen G√ºltigkeitsbereich ein."
            },
            {
              "type": "explanation",
              "title": "Grundidee von using namespace",
              "text": [
                "using namespace erspart das wiederholte Schreiben des Namespace-Namens.",
                "Alle enthaltenen Namen werden so behandelt, als l√§gen sie im aktuellen Scope."
              ]
            },
            {
              "type": "explanation",
              "title": "Namensaufl√∂sung",
              "text": [
                "Bei mehreren gleichnamigen Bezeichnern entscheidet die Namensaufl√∂sungsregel des Compilers.",
                "Lokale Namen haben Vorrang vor eingebundenen Namespace-Namen."
              ]
            },
            {
              "type": "list",
              "title": "M√∂gliche Probleme",
              "items": [
                "Namenskonflikte bei gleichnamigen Funktionen oder Typen",
                "Unklare Herkunft von Bezeichnern",
                "Schwer wartbarer Code in gro√üen Projekten",
                "Probleme beim Einbinden mehrerer Bibliotheken"
              ]
            },
            {
              "type": "code",
              "title": "using namespace verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    cout << \"Hallo\" << endl; // std:: wird nicht ben√∂tigt\n}\n"
            },
            {
              "type": "code",
              "title": "Namenskonflikt durch using namespace",
              "language": "cpp",
              "code": "#include <iostream>\n\nnamespace A {\n    void funktion() {\n        std::cout << \"A\" << std::endl;\n    }\n}\n\nnamespace B {\n    void funktion() {\n        std::cout << \"B\" << std::endl;\n    }\n}\n\nusing namespace A;\nusing namespace B;\n\nint main() {\n    // funktion(); // Fehler: Mehrdeutig\n    A::funktion();\n    B::funktion();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Gezieltes using",
              "text": [
                "Statt ganzer Namespaces k√∂nnen einzelne Namen importiert werden.",
                "Dies reduziert das Risiko von Namenskonflikten erheblich."
              ]
            },
            {
              "type": "code",
              "title": "Gezieltes using-Deklaration",
              "language": "cpp",
              "code": "#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\nint main() {\n    cout << \"Gezielt\" << endl;\n}\n"
            },
            {
              "type": "comparison",
              "title": "using namespace vs qualifizierter Zugriff",
              "columns": ["using namespace", "Qualifizierter Zugriff"],
              "rows": [
                {
                  "aspect": "Kurzschreibweise",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Namenssicherheit",
                  "values": ["Gering", "Hoch"]
                },
                {
                  "aspect": "Empfehlung in Header-Dateien",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "using namespace in Header-Dateien",
              "text": "using namespace in Header-Dateien zwingt allen Einbindern diese Namen auf und kann massive Konflikte verursachen."
            },
            {
              "type": "important",
              "text": "using namespace sollte nur lokal und bewusst eingesetzt werden, niemals global oder in Header-Dateien."
            },
            {
              "type": "summary",
              "points": [
                "using namespace bindet alle Namen eines Namespaces ein",
                "Kann zu Namenskonflikten f√ºhren",
                "Gezieltes using ist sicherer",
                "Qualifizierter Zugriff ist Best Practice"
              ]
            }
          ]
        }

        ]
      },
      {
        "name": "Member & Attribute",
        "icon": "üß©",
        "topics": [
        {
          "title": "static Member",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "static Member",
              "text": "Static Member sind Klassenmitglieder, die zur Klasse selbst geh√∂ren und nicht zu einzelnen Objekten."
            },
            {
              "type": "explanation",
              "title": "Grundidee",
              "text": [
                "Ein static Member existiert genau einmal, unabh√§ngig davon, wie viele Objekte einer Klasse erzeugt werden.",
                "Alle Instanzen greifen auf denselben static Member zu."
              ]
            },
            {
              "type": "explanation",
              "title": "Static Attribute",
              "text": [
                "Static Attribute speichern klassenweite Zust√§nde oder Z√§hler.",
                "Sie m√ºssen genau einmal definiert werden, meist in einer Source-Datei."
              ]
            },
            {
              "type": "explanation",
              "title": "Static Memberfunktionen",
              "text": [
                "Static Memberfunktionen geh√∂ren zur Klasse und nicht zu einem Objekt.",
                "Sie k√∂nnen nur auf andere static Member zugreifen."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von static Membern",
              "items": [
                "Geh√∂ren zur Klasse, nicht zur Instanz",
                "Existieren unabh√§ngig von Objekten",
                "Zugriff √ºber Klassenname::Member",
                "N√ºtzlich f√ºr Z√§hler, Hilfsfunktionen und Konstanten"
              ]
            },
            {
              "type": "code",
              "title": "Static Attribut",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Zaehler {\npublic:\n    static int anzahl;\n};\n\nint Zaehler::anzahl = 0; // Definition des static Attributs\n\nint main() {\n    Zaehler::anzahl++;\n    Zaehler::anzahl++;\n    std::cout << Zaehler::anzahl << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "code",
              "title": "Static Memberfunktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Rechner {\npublic:\n    static int add(int a, int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    std::cout << Rechner::add(3, 4) << std::endl; // Ausgabe: 7\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Zugriff auf nicht-static Member",
              "text": "Static Memberfunktionen k√∂nnen nicht direkt auf nicht-static Attribute zugreifen."
            },
            {
              "type": "important",
              "text": "Static Member sind ideal f√ºr klassenweite Informationen und Funktionen ohne Objektbezug."
            },
            {
              "type": "summary",
              "points": [
                "Static Member geh√∂ren zur Klasse",
                "Existieren genau einmal",
                "Zugriff √ºber Klassenname::",
                "Keine Objektinstanz notwendig"
              ]
            }
          ]
        },
        
        {
          "title": "const Memberfunktionen & mutable Member",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "const und mutable",
              "text": "const Memberfunktionen sch√ºtzen den Objektzustand, mutable erlaubt gezielte √Ñnderungen einzelner Attribute trotz const."
            },
            {
              "type": "explanation",
              "title": "const Memberfunktionen",
              "text": [
                "Eine const Memberfunktion garantiert, dass der sichtbare Zustand des Objekts nicht ver√§ndert wird.",
                "Innerhalb einer const Funktion d√ºrfen keine normalen Member ge√§ndert werden."
              ]
            },
            {
              "type": "explanation",
              "title": "Logische vs physische Konstanz",
              "text": [
                "Const sch√ºtzt die logische Konstanz eines Objekts aus Sicht des Nutzers.",
                "mutable erlaubt interne, technische √Ñnderungen ohne Verletzung dieser Logik."
              ]
            },
            {
              "type": "explanation",
              "title": "mutable Member",
              "text": [
                "mutable hebt die const Einschr√§nkung f√ºr einzelne Attribute auf.",
                "Damit k√∂nnen interne Zust√§nde auch in const Memberfunktionen ge√§ndert werden."
              ]
            },
            {
              "type": "list",
              "title": "Typische Einsatzgebiete",
              "items": [
                "Caching von berechneten Werten",
                "Lazy Evaluation",
                "Zugriffs- oder Statistikz√§hler",
                "Interne Debug- oder Logging-Daten"
              ]
            },
            {
              "type": "code",
              "title": "const Memberfunktion ohne mutable",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt(int x, int y) : x(x), y(y) {}\n\n    int getX() const {\n        return x; // erlaubt\n    }\n\n    // void setX(int v) const { x = v; } // Fehler: √Ñnderung nicht erlaubt\n\nprivate:\n    int x;\n    int y;\n};\n"
            },
            {
              "type": "code",
              "title": "mutable f√ºr Cache in const Funktion",
              "language": "cpp",
              "code": "#include <iostream>\n\nclass Quadrat {\npublic:\n    Quadrat(int s) : seite(s) {}\n\n    int flaeche() const {\n        if (!cacheGueltig) {\n            cache = seite * seite; // erlaubt durch mutable\n            cacheGueltig = true;\n        }\n        return cache;\n    }\n\nprivate:\n    int seite;\n    mutable int cache = 0;\n    mutable bool cacheGueltig = false;\n};\n\nint main() {\n    const Quadrat q(4);\n    std::cout << q.flaeche() << std::endl; // Ausgabe: 16\n}\n"
            },
            {
              "type": "comparison",
              "title": "const ohne mutable vs mit mutable",
              "columns": ["const ohne mutable", "const mit mutable"],
              "rows": [
                {
                  "aspect": "√Ñnderung von Membern",
                  "values": ["Verboten", "Gezielt erlaubt"]
                },
                {
                  "aspect": "Geeignet f√ºr Cache",
                  "values": ["Nein", "Ja"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Missbrauch von mutable",
              "text": "mutable darf nicht verwendet werden, um fachlich relevante Zustands√§nderungen zu verstecken."
            },
            {
              "type": "important",
              "text": "const und mutable dienen der klaren Trennung zwischen logischer Schnittstelle und interner Implementierung."
            },
            {
              "type": "summary",
              "points": [
                "const sch√ºtzt die logische Objektkonstanz",
                "mutable erlaubt interne √Ñnderungen",
                "Typisch f√ºr Cache und Lazy Evaluation",
                "Missbrauch f√ºhrt zu unklarem Design"
              ]
            }
          ]
        }
        
        ]
      }
    ]
  },







  {
    "category": "Templates",
    "icon": "üß©",
    "subcategories": [
      {
        "name": "Grundlagen",
        "icon": "üß©",
        "topics": [
        {
          "title": "Funktionstemplates",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Funktionstemplate",
              "text": "Ein Funktionstemplate ist eine Vorlage f√ºr Funktionen, die mit verschiedenen Datentypen arbeiten kann."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Funktionstemplates",
              "text": [
                "Funktionstemplates erm√∂glichen generischen Code ohne Duplikation.",
                "Der konkrete Typ wird vom Compiler zur Compilezeit eingesetzt."
              ]
            },
            {
              "type": "explanation",
              "title": "Typinferenz",
              "text": [
                "Der Compiler leitet die Template-Typen meist automatisch aus den Funktionsargumenten ab.",
                "Explizite Typangaben sind nur in Sonderf√§llen notwendig."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von Funktionstemplates",
              "items": [
                "Typsicher zur Compilezeit",
                "Kein Laufzeit-Overhead",
                "Code-Wiederverwendung f√ºr viele Typen",
                "Fehler werden beim Instanziieren erkannt"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Funktionstemplate",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\nint main() {\n    std::cout << add(2, 3) << std::endl;       // int\n    std::cout << add(1.5, 2.5) << std::endl;   // double\n}\n"
            },
            {
              "type": "code",
              "title": "Explizite Template-Argumente",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nT quadrieren(T x) {\n    return x * x;\n}\n\nint main() {\n    std::cout << quadrieren<int>(4) << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "Mehrere Template-Typen",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T, typename U>\nauto multipliziere(T a, U b) {\n    return a * b;\n}\n\nint main() {\n    std::cout << multipliziere(3, 2.5) << std::endl; // double\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Ungeeignete Typen",
              "text": "Funktionstemplates setzen voraus, dass die verwendeten Typen die ben√∂tigten Operationen unterst√ºtzen."
            },
            {
              "type": "important",
              "text": "Funktionstemplates werden zur Compilezeit instanziiert und verursachen keinen Laufzeit-Overhead."
            },
            {
              "type": "summary",
              "points": [
                "Funktionstemplates erm√∂glichen generischen Code",
                "Typen werden zur Compilezeit eingesetzt",
                "Typinferenz erfolgt meist automatisch",
                "Fehler werden fr√ºh erkannt"
              ]
            }
          ]
        },
        {
          "title": "Klassentemplates",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Klassentemplate",
              "text": "Ein Klassentemplate ist eine Vorlage f√ºr Klassen, die mit unterschiedlichen Datentypen instanziiert werden kann."
            },
            {
              "type": "explanation",
              "title": "Grundidee von Klassentemplates",
              "text": [
                "Klassentemplates erm√∂glichen die Definition generischer Datenstrukturen.",
                "Der konkrete Typ wird beim Erzeugen der Klasse festgelegt."
              ]
            },
            {
              "type": "explanation",
              "title": "Instanziierung",
              "text": [
                "Ein Klassentemplate erzeugt erst bei der Verwendung mit einem konkreten Typ eine echte Klasse.",
                "Jede Typinstanziierung erzeugt eine eigene Klassenvariante."
              ]
            },
            {
              "type": "list",
              "title": "Eigenschaften von Klassentemplates",
              "items": [
                "Typsicher zur Compilezeit",
                "Keine Laufzeitkosten",
                "Hohe Wiederverwendbarkeit",
                "Fehler werden beim Instanziieren sichtbar"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches Klassentemplate",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T>\nclass Box {\npublic:\n    Box(T wert) : wert(wert) {}\n\n    T get() const {\n        return wert;\n    }\n\nprivate:\n    T wert;\n};\n\nint main() {\n    Box<int> a(5);\n    Box<double> b(3.14);\n\n    std::cout << a.get() << std::endl;\n    std::cout << b.get() << std::endl;\n}\n"
            },
            {
              "type": "code",
              "title": "Klassentemplate mit mehreren Typen",
              "language": "cpp",
              "code": "#include <iostream>\n\ntemplate <typename T, typename U>\nclass Paar {\npublic:\n    Paar(T erstes, U zweites) : erstes(erstes), zweites(zweites) {}\n\n    T getErstes() const {\n        return erstes;\n    }\n\n    U getZweites() const {\n        return zweites;\n    }\n\nprivate:\n    T erstes;\n    U zweites;\n};\n\nint main() {\n    Paar<int, double> p(1, 2.5);\n    std::cout << p.getErstes() << \", \" << p.getZweites() << std::endl;\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Definition im Header",
              "text": "Klassentemplates m√ºssen vollst√§ndig im Header definiert sein, da der Compiler den Code sehen muss."
            },
            {
              "type": "important",
              "text": "Klassentemplates werden zur Compilezeit instanziiert und sind vollst√§ndig typsicher."
            },
            {
              "type": "summary",
              "points": [
                "Klassentemplates definieren generische Klassen",
                "Typen werden bei der Instanziierung festgelegt",
                "Keine Laufzeitkosten",
                "Ideal f√ºr generische Datenstrukturen"
              ]
            }
          ]
        }
        ]
      }
    ]
  },






  {
    "category": "STL Container",
    "icon": "üì¶",
    "subcategories": [
      {
        "name": "Sequenzcontainer",
        "icon": "üìö",
        "topics": [
        {
          "title": "std::vector",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::vector",
              "text": "std::vector ist ein sequenzieller STL-Container, der Elemente in zusammenh√§ngendem Speicher ablegt und seine Gr√∂√üe dynamisch anpasst."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::vector verh√§lt sich wie ein dynamisches Array mit automatischer Speicherverwaltung.",
                "Die Elemente liegen zusammenh√§ngend im Speicher, was schnellen Indexzugriff erm√∂glicht."
              ]
            },
            {
              "type": "explanation",
              "title": "Speicherverhalten",
              "text": [
                "Beim Wachsen kann der Vector seinen Speicher neu allozieren.",
                "Dabei werden alle Elemente in einen neuen Speicherbereich kopiert oder verschoben."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<vector>"
              ]
            },
            {
              "type": "explanation",
              "title": "Gr√∂√üe und Kapazit√§t",
              "text": [
                "size gibt die aktuelle Anzahl der gespeicherten Elemente an.",
                "capacity beschreibt, wie viele Elemente ohne erneute Reallokation gespeichert werden k√∂nnen."
              ]
            },
            {
              "type": "code",
              "title": "size und capacity",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v;\n\n    v.push_back(1);\n    v.push_back(2);\n\n    std::cout << v.size() << std::endl;     // Anzahl Elemente\n    std::cout << v.capacity() << std::endl; // reservierter Speicher\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente hinzuf√ºgen",
              "text": [
                "push_back f√ºgt ein bereits existierendes Objekt am Ende ein.",
                "emplace_back konstruiert das Objekt direkt im Speicher des Vectors."
              ]
            },
            {
              "type": "code",
              "title": "push_back vs emplace_back",
              "language": "cpp",
              "code": "#include <vector>\n#include <string>\n\nint main() {\n    std::vector<std::string> v;\n\n    v.push_back(std::string(\"Hallo\"));\n    v.emplace_back(\"Welt\"); // effizienter\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff auf Elemente",
              "text": [
                "operator[] bietet schnellen Zugriff ohne Bereichspr√ºfung.",
                "at pr√ºft die Grenzen und wirft bei Fehlern eine Exception."
              ]
            },
            {
              "type": "code",
              "title": "operator[] vs at",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {10, 20, 30};\n\n    std::cout << v[0] << std::endl;    // kein Check\n    std::cout << v.at(1) << std::endl; // mit Check\n}\n"
            },
            {
              "type": "explanation",
              "title": "Entfernen von Elementen",
              "text": [
                "pop_back entfernt das letzte Element.",
                "clear entfernt alle Elemente, beh√§lt aber die Kapazit√§t."
              ]
            },
            {
              "type": "code",
              "title": "Elemente entfernen",
              "language": "cpp",
              "code": "#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3};\n\n    v.pop_back(); // entfernt 3\n    v.clear();    // Vector ist leer\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteratoren",
              "text": [
                "std::vector stellt begin und end Iteratoren bereit.",
                "Iteratoren erm√∂glichen die Nutzung von STL-Algorithmen."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren mit Iteratoren",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3};\n\n    for (auto it = v.begin(); it != v.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zusammenspiel mit Algorithmen",
              "text": [
                "std::vector ist optimal f√ºr STL-Algorithmen geeignet.",
                "Die zusammenh√§ngende Speicherstruktur sorgt f√ºr hohe Performance."
              ]
            },
            {
              "type": "code",
              "title": "std::sort mit vector",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {3, 1, 4, 1, 5};\n\n    std::sort(v.begin(), v.end());\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "code",
              "title": "std::vector: wichtiges im √úberblick (ausf√ºhrlich kommentiert)",
              "language": "cpp",
              "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\n// Kleine Hilfsfunktion: Vector ausgeben\nstatic void printVec(const std::vector<int>& v, const char* name) {\n    std::cout << name << \" (size=\" << v.size()\n              << \", capacity=\" << v.capacity() << \"): \";\n\n    for (int x : v) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n}\n\nint main() {\n    // 1) Erzeugen und Initialisieren\n    std::vector<int> a;                 // leer\n    std::vector<int> b(5);              // 5 Elemente, alle 0\n    std::vector<int> c(5, 7);           // 5 Elemente, alle 7\n    std::vector<int> d = {1, 2, 3, 4};  // Initializer List\n\n    printVec(a, \"a\");\n    printVec(b, \"b\");\n    printVec(c, \"c\");\n    printVec(d, \"d\");\n\n\n    // 2) size, capacity, reserve, shrink_to_fit\n    // size: Anzahl der Elemente\n    // capacity: reservierter Speicher (kann gr√∂√üer als size sein)\n   \n\n    std::vector<int> v;\n    v.reserve(10); // Speicher f√ºr mindestens 10 Elemente reservieren (verhindert h√§ufige Reallokationen)\n\n    std::cout << \"v.size()=\" << v.size() << \", v.capacity()=\" << v.capacity() << \"\\n\";\n\n\n    // 3) Elemente hinzuf√ºgen: push_back und emplace_back\n    // push_back: f√ºgt ein Element hinzu (Kopie oder Move)\n    // emplace_back: konstruiert das Element direkt im Vector (bei komplexen Typen oft sinnvoll)\n    v.push_back(10);\n    v.push_back(20);\n    v.emplace_back(30);\n\n    printVec(v, \"v nach push_back/emplace_back\");\n\n\n    // 4) Zugriff auf Elemente: operator[], at, front, back\n    // operator[]: schnell, aber kein Bounds Check\n    // at: wirft bei ung√ºltigem Index eine Exception\n    \n    std::cout << \"v[0]=\" << v[0] << \"\\n\";\n    std::cout << \"v.front()=\" << v.front() << \", v.back()=\" << v.back() << \"\\n\";\n\n    // Sicherer Zugriff mit at (hier ok)\n    std::cout << \"v.at(1)=\" << v.at(1) << \"\\n\";\n\n\n    // 5) Iterieren: begin/end, range-based for\n    \n    for (auto it = v.begin(); it != v.end(); ++it) {\n        std::cout << *it << \" \";\n    }\n    std::cout << \"\\n\";\n\n\n    // 6) insert und erase\n    // insert: f√ºgt an einer Position ein\n    // erase: entfernt an einer Position oder in einem Bereich\n    \n\n    // Einf√ºgen am Anfang\n    v.insert(v.begin(), 5);\n    printVec(v, \"v nach insert vorne\");\n\n    // Einf√ºgen in der Mitte (nach dem ersten Element)\n    v.insert(v.begin() + 1, 99);\n    printVec(v, \"v nach insert mitte\");\n\n    // Entfernen eines Elements (das eben eingef√ºgte 99)\n    v.erase(v.begin() + 1);\n    printVec(v, \"v nach erase einzel\");\n\n\n    // 7) resize, clear, empty\n    // resize vergr√∂√üert oder verkleinert size\n    // clear entfernt alle Elemente (capacity bleibt typischerweise)\n    \n\n    v.resize(6, 1); // falls gr√∂√üer, neue Elemente werden mit 1 gef√ºllt\n    printVec(v, \"v nach resize(6,1)\");\n\n    v.resize(2); // verkleinern: √ºbersch√ºssige Elemente werden entfernt\n    printVec(v, \"v nach resize(2)\");\n\n    std::cout << \"v.empty()=\" << std::boolalpha << v.empty() << \"\\n\";\n\n    v.clear();\n    std::cout << \"nach clear: v.size()=\" << v.size() << \", v.empty()=\" << v.empty() << \"\\n\";\n\n\n    // 8) assign und swap\n    // assign ersetzt kompletten Inhalt\n    // swap tauscht Inhalte effizient\n    \n\n    std::vector<int> x = {1, 2, 3};\n    std::vector<int> y = {9, 8};\n\n    x.assign(4, 7); // x wird zu {7,7,7,7}\n    printVec(x, \"x nach assign(4,7)\");\n\n    x.swap(y);\n    printVec(x, \"x nach swap\");\n    printVec(y, \"y nach swap\");\n\n\n    // 9) data: roher Pointer auf zusammenh√§ngenden Speicher\n    // n√ºtzlich f√ºr C APIs oder low level Zugriff\n    \n    const int* p = x.data();\n    if (!x.empty()) {\n        std::cout << \"x.data()[0]=\" << p[0] << \"\\n\";\n    }\n\n\n    // 10) Algorithmen mit vector: sort, find, count, remove-erase\n    \n\n    std::vector<int> z = {4, 1, 3, 2, 2, 5};\n    printVec(z, \"z start\");\n\n    std::sort(z.begin(), z.end());\n    printVec(z, \"z nach sort\");\n\n    auto it = std::find(z.begin(), z.end(), 3);\n    if (it != z.end()) {\n        std::cout << \"3 gefunden\\n\";\n    }\n\n    int cnt2 = std::count(z.begin(), z.end(), 2);\n    std::cout << \"Anzahl der 2: \" << cnt2 << \"\\n\";\n\n    // remove-erase: logisch entfernen und dann wirklich l√∂schen\n    z.erase(std::remove(z.begin(), z.end(), 2), z.end());\n    printVec(z, \"z nach remove-erase (2 entfernt)\");\n\n\n    // 11) Bonus: sum mit accumulate\n    int sum = std::accumulate(z.begin(), z.end(), 0);\n    std::cout << \"Summe von z: \" << sum << \"\\n\";\n}\n"
            },
            {
              "type": "pitfall",
              "title": "Iteratoren nach Reallokation",
              "text": "push_back oder emplace_back k√∂nnen eine Reallokation ausl√∂sen und alle Iteratoren ung√ºltig machen."
            },
            {
              "type": "important",
              "text": "std::vector ist der wichtigste und am h√§ufigsten verwendete STL-Container."
            },
            {
              "type": "summary",
              "points": [
                "std::vector speichert Elemente zusammenh√§ngend",
                "Dynamische Gr√∂√üe mit automatischer Speicherverwaltung",
                "Schneller Indexzugriff",
                "Ideal f√ºr STL-Algorithmen",
                "Standardwahl f√ºr sequenzielle Daten"
              ]
            }
          ]
        },
        {
          "title": "std::list",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::list",
              "text": "list ist ein sequenzieller STL-Container, der Elemente als doppelt verkettete Liste speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::list speichert jedes Element in einem eigenen Knoten mit Verweisen auf Vorg√§nger und Nachfolger.",
                "Die Elemente liegen nicht zusammenh√§ngend im Speicher."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Eigenschaften",
              "text": [
                "Konstante Zeit f√ºr Einf√ºgen und Entfernen an beliebiger Position.",
                "Kein direkter Indexzugriff m√∂glich.",
                "Iteratoren bleiben beim Einf√ºgen und Entfernen anderer Elemente g√ºltig."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<list>"
              ]
            },
            {
              "type": "explanation",
              "title": "Gr√∂√üe und Zustand",
              "text": [
                "size liefert die aktuelle Anzahl der Elemente.",
                "empty pr√ºft, ob die Liste leer ist."
              ]
            },
            {
              "type": "code",
              "title": "size und empty",
              "language": "cpp",
              "code": "#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> l = {1, 2, 3};\n\n    std::cout << l.size() << std::endl;\n    std::cout << l.empty() << std::endl; // false\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente einf√ºgen",
              "text": [
                "push_back und push_front f√ºgen Elemente am Ende oder Anfang ein.",
                "insert f√ºgt Elemente an einer Iteratorposition ein."
              ]
            },
            {
              "type": "code",
              "title": "push_front, push_back und insert",
              "language": "cpp",
              "code": "#include <list>\n\nint main() {\n    std::list<int> l;\n\n    l.push_back(2);\n    l.push_front(1);\n\n    auto it = l.begin();\n    ++it;\n    l.insert(it, 42); // Einf√ºgen in der Mitte\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "pop_front und pop_back entfernen das erste oder letzte Element.",
                "erase entfernt das Element an einer Iteratorposition."
              ]
            },
            {
              "type": "code",
              "title": "pop und erase",
              "language": "cpp",
              "code": "#include <list>\n\nint main() {\n    std::list<int> l = {1, 2, 3};\n\n    l.pop_front(); // entfernt 1\n    l.pop_back();  // entfernt 3\n\n    auto it = l.begin();\n    l.erase(it); // entfernt 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Spezielle Memberfunktionen",
              "text": [
                "remove entfernt alle Elemente mit einem bestimmten Wert.",
                "splice verschiebt Elemente effizient zwischen Listen.",
                "sort sortiert die Liste ohne zus√§tzliche Speicherallokation."
              ]
            },
            {
              "type": "code",
              "title": "remove, splice und sort",
              "language": "cpp",
              "code": "#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> a = {3, 1, 2, 2};\n    std::list<int> b = {10, 20};\n\n    a.remove(2);      // entfernt alle 2er\n    a.sort();         // sortiert die Liste\n    a.splice(a.end(), b); // verschiebt alle Elemente aus b nach a\n\n    for (int x : a) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::list vs std::vector",
              "columns": ["std::list", "std::vector"],
              "rows": [
                {
                  "aspect": "Speicherlayout",
                  "values": ["Nicht zusammenh√§ngend", "Zusammenh√§ngend"]
                },
                {
                  "aspect": "Einf√ºgen in der Mitte",
                  "values": ["Sehr effizient", "Teuer"]
                },
                {
                  "aspect": "Indexzugriff",
                  "values": ["Nicht m√∂glich", "O(1)"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Falsche Containerwahl",
              "text": "std::list ist f√ºr zuf√§lligen Zugriff ungeeignet und oft langsamer als std::vector durch schlechte Cache-Lokalit√§t."
            },
            {
              "type": "important",
              "text": "std::list ist ideal, wenn h√§ufiges Einf√ºgen und Entfernen an beliebigen Positionen ben√∂tigt wird."
            },
            {
              "type": "summary",
              "points": [
                "std::list ist eine doppelt verkettete Liste",
                "Kein Indexzugriff",
                "Stabile Iteratoren",
                "Effizientes Einf√ºgen und Entfernen",
                "Spezielle Funktionen wie splice und remove"
              ]
            }
          ]
        },
        {
          "title": "std::deque",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::deque",
              "text": "std::deque ist ein sequenzieller STL-Container mit effizientem Einf√ºgen und Entfernen an beiden Enden."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::deque steht f√ºr double ended queue.",
                "Die Elemente liegen in mehreren zusammenh√§ngenden Speicherbl√∂cken, nicht in einem einzigen."
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Eigenschaften",
              "text": [
                "Konstanter Zeitaufwand f√ºr push_front und push_back.",
                "Direkter Indexzugriff √§hnlich wie bei std::vector.",
                "Bessere Flexibilit√§t an den Enden als std::vector."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<deque>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zugriff und Gr√∂√üe",
              "text": [
                "operator[] und at erm√∂glichen direkten Zugriff auf Elemente.",
                "size und empty liefern Informationen √ºber den Zustand des Containers."
              ]
            },
            {
              "type": "code",
              "title": "Zugriff auf Elemente",
              "language": "cpp",
              "code": "#include <iostream>\n#include <deque>\n\nint main() {\n    std::deque<int> d = {10, 20, 30};\n\n    std::cout << d[0] << std::endl;\n    std::cout << d.at(1) << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente einf√ºgen",
              "text": [
                "push_back f√ºgt am Ende ein.",
                "push_front f√ºgt am Anfang ein.",
                "emplace_back und emplace_front konstruieren Elemente direkt."
              ]
            },
            {
              "type": "code",
              "title": "push_front und push_back",
              "language": "cpp",
              "code": "#include <deque>\n\nint main() {\n    std::deque<int> d;\n\n    d.push_back(2);\n    d.push_front(1);\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "pop_back entfernt das letzte Element.",
                "pop_front entfernt das erste Element.",
                "clear entfernt alle Elemente."
              ]
            },
            {
              "type": "code",
              "title": "pop_front und pop_back",
              "language": "cpp",
              "code": "#include <deque>\n\nint main() {\n    std::deque<int> d = {1, 2, 3};\n\n    d.pop_front(); // entfernt 1\n    d.pop_back();  // entfernt 3\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteratoren und Algorithmen",
              "text": [
                "std::deque unterst√ºtzt Random-Access-Iteratoren.",
                "Alle STL-Algorithmen k√∂nnen verwendet werden."
              ]
            },
            {
              "type": "code",
              "title": "std::sort mit deque",
              "language": "cpp",
              "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n\nint main() {\n    std::deque<int> d = {3, 1, 4, 1, 5};\n\n    std::sort(d.begin(), d.end());\n\n    for (int x : d) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::deque vs std::vector",
              "columns": ["std::deque", "std::vector"],
              "rows": [
                {
                  "aspect": "Einf√ºgen vorne",
                  "values": ["Effizient", "Teuer"]
                },
                {
                  "aspect": "Speicherlayout",
                  "values": ["Blockweise", "Zusammenh√§ngend"]
                },
                {
                  "aspect": "Cache-Lokalit√§t",
                  "values": ["Etwas schlechter", "Sehr gut"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Unn√∂tiger Einsatz",
              "text": "std::deque ist oft langsamer als std::vector, wenn kein push_front ben√∂tigt wird."
            },
            {
              "type": "important",
              "text": "std::deque ist sinnvoll, wenn h√§ufiger Zugriff an beiden Enden ben√∂tigt wird."
            },
            {
              "type": "summary",
              "points": [
                "std::deque ist eine doppelseitige Warteschlange",
                "Direkter Indexzugriff m√∂glich",
                "Effizientes Einf√ºgen an beiden Enden",
                "Random-Access-Iteratoren",
                "Alternative zu std::vector bei push_front Bedarf"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "Assoziative Container",
        "icon": "üóÇÔ∏è",
        "topics": [
        {
          "title": "std::map",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::map",
              "text": "std::map ist ein assoziativer STL-Container, der Schl√ºssel-Wert-Paare sortiert und eindeutig nach Schl√ºsseln speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::map speichert Elemente automatisch sortiert nach dem Schl√ºssel.",
                "Jeder Schl√ºssel kommt h√∂chstens einmal vor."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "std::map ist typischerweise als balancierter Suchbaum implementiert.",
                "Alle grundlegenden Operationen laufen in logarithmischer Zeit."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<map>"
              ]
            },
            {
              "type": "explanation",
              "title": "Einf√ºgen von Elementen",
              "text": [
                "insert f√ºgt ein Schl√ºssel-Wert-Paar ein, wenn der Schl√ºssel noch nicht existiert.",
                "operator[] erzeugt bei Bedarf automatisch einen Eintrag."
              ]
            },
            {
              "type": "code",
              "title": "insert und operator[]",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n    std::map<int, std::string> m;\n\n    m.insert({1, \"eins\"});\n    m[2] = \"zwei\"; // erzeugt Eintrag falls nicht vorhanden\n\n    std::cout << m[1] << std::endl;\n}\n"
            },
            {
              "type": "explanation",
              "title": "Zugriff und Suche",
              "text": [
                "find sucht nach einem Schl√ºssel und liefert einen Iterator.",
                "count pr√ºft, ob ein Schl√ºssel existiert."
              ]
            },
            {
              "type": "code",
              "title": "find und count",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n\nint main() {\n    std::map<int, int> m = {{1, 10}, {2, 20}};\n\n    auto it = m.find(2);\n    if (it != m.end()) {\n        std::cout << it->second << std::endl;\n    }\n\n    std::cout << m.count(3) << std::endl; // 0 oder 1\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "erase entfernt Elemente nach Schl√ºssel oder Iterator.",
                "clear entfernt alle Eintr√§ge."
              ]
            },
            {
              "type": "code",
              "title": "erase und clear",
              "language": "cpp",
              "code": "#include <map>\n\nint main() {\n    std::map<int, int> m = {{1, 10}, {2, 20}};\n\n    m.erase(1);\n    m.clear();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteration",
              "text": [
                "Iteration erfolgt immer in sortierter Reihenfolge der Schl√ºssel.",
                "Iteratoren liefern Zugriff auf Schl√ºssel und Wert."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren √ºber map",
              "language": "cpp",
              "code": "#include <iostream>\n#include <map>\n\nint main() {\n    std::map<int, int> m = {{2, 20}, {1, 10}};\n\n    for (const auto& p : m) {\n        std::cout << p.first << \": \" << p.second << std::endl;\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::map vs std::unordered_map",
              "columns": ["std::map", "std::unordered_map"],
              "rows": [
                {
                  "aspect": "Ordnung",
                  "values": ["Sortiert", "Nicht sortiert"]
                },
                {
                  "aspect": "Zeitkomplexit√§t",
                  "values": ["O(log n)", "√ò O(1)"]
                },
                {
                  "aspect": "Iterator-Reihenfolge",
                  "values": ["Deterministisch", "Nicht definiert"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "operator[] bei Lesen",
              "text": "operator[] erzeugt bei nicht vorhandenem Schl√ºssel automatisch einen Eintrag."
            },
            {
              "type": "important",
              "text": "std::map eignet sich f√ºr geordnete Schl√ºssel-Wert-Daten mit stabiler Iterationsreihenfolge."
            },
            {
              "type": "summary",
              "points": [
                "std::map speichert sortierte Schl√ºssel-Wert-Paare",
                "Eindeutige Schl√ºssel",
                "Logarithmische Laufzeit",
                "Sortierte Iteration",
                "Geeignet f√ºr geordnete Daten"
              ]
            }
          ]
        },
        {
          "title": "std::set",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::set",
              "text": "std::set ist ein assoziativer STL-Container, der eindeutige Elemente automatisch sortiert speichert."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::set speichert nur Schl√ºssel ohne zugeh√∂rigen Wert.",
                "Jedes Element kommt h√∂chstens einmal vor."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "std::set ist typischerweise als balancierter Suchbaum implementiert.",
                "Alle grundlegenden Operationen laufen in logarithmischer Zeit."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<set>"
              ]
            },
            {
              "type": "explanation",
              "title": "Einf√ºgen von Elementen",
              "text": [
                "insert f√ºgt ein Element ein, wenn es noch nicht existiert.",
                "Doppelte Werte werden ignoriert."
              ]
            },
            {
              "type": "code",
              "title": "insert verwenden",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s;\n\n    s.insert(3);\n    s.insert(1);\n    s.insert(3); // wird ignoriert\n\n    for (int x : s) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Suche und Zugriff",
              "text": [
                "find sucht nach einem Element und liefert einen Iterator.",
                "count pr√ºft, ob ein Element vorhanden ist."
              ]
            },
            {
              "type": "code",
              "title": "find und count",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s = {1, 2, 3};\n\n    if (s.count(2)) {\n        std::cout << \"Gefunden\" << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Elemente entfernen",
              "text": [
                "erase entfernt Elemente nach Wert oder Iterator.",
                "clear entfernt alle Elemente."
              ]
            },
            {
              "type": "code",
              "title": "erase und clear",
              "language": "cpp",
              "code": "#include <set>\n\nint main() {\n    std::set<int> s = {1, 2, 3};\n\n    s.erase(2);\n    s.clear();\n}\n"
            },
            {
              "type": "explanation",
              "title": "Iteration",
              "text": [
                "Iteration erfolgt immer in sortierter Reihenfolge.",
                "Elemente sind unver√§nderlich √ºber Iteratoren."
              ]
            },
            {
              "type": "code",
              "title": "Iterieren √ºber set",
              "language": "cpp",
              "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::set<int> s = {3, 1, 2};\n\n    for (int x : s) {\n        std::cout << x << \" \";\n    }\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::set vs std::vector",
              "columns": ["std::set", "std::vector"],
              "rows": [
                {
                  "aspect": "Eindeutige Elemente",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Sortiert",
                  "values": ["Ja", "Nein"]
                },
                {
                  "aspect": "Zugriff per Index",
                  "values": ["Nicht m√∂glich", "O(1)"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Elemente √§ndern",
              "text": "Elemente d√ºrfen nicht direkt ver√§ndert werden, da dies die Sortierung zerst√∂ren w√ºrde."
            },
            {
              "type": "important",
              "text": "std::set ist ideal f√ºr eindeutige, sortierte Datenmengen."
            },
            {
              "type": "summary",
              "points": [
                "std::set speichert eindeutige Werte",
                "Automatisch sortiert",
                "Logarithmische Laufzeit",
                "Kein Indexzugriff",
                "Geeignet f√ºr Mengen"
              ]
            }
          ]
        }
        ]
      },
      {
        "name": "Adapter",
        "icon": "üóÉÔ∏è",
        "topics": [
        {
          "title": "std::stack",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::stack",
              "text": "std::stack ist ein Container-Adapter, der das LIFO-Prinzip verwendet, bei dem das zuletzt eingef√ºgte Element zuerst entfernt wird."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::stack stellt eine Stapelstruktur bereit.",
                "Der Zugriff ist nur auf das oberste Element erlaubt."
              ]
            },
            {
              "type": "explanation",
              "title": "Container-Adapter",
              "text": [
                "std::stack ist kein eigenst√§ndiger Container.",
                "Er nutzt intern standardm√§√üig std::deque als Speicherstruktur."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<stack>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push legt ein Element oben auf den Stack.",
                "pop entfernt das oberste Element.",
                "top liefert Zugriff auf das oberste Element.",
                "empty und size liefern Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::stack",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stack>\n\nint main() {\n    std::stack<int> s;\n\n    s.push(1);\n    s.push(2);\n    s.push(3);\n\n    std::cout << s.top() << std::endl; // Ausgabe: 3\n    s.pop();\n    std::cout << s.top() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Es gibt keinen direkten Zugriff auf andere Elemente als das oberste.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "code",
              "title": "empty und size",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stack>\n\nint main() {\n    std::stack<int> s;\n\n    std::cout << s.empty() << std::endl; // true\n    s.push(5);\n    std::cout << s.size() << std::endl;  // 1\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::stack vs std::vector",
              "columns": ["std::stack", "std::vector"],
              "rows": [
                {
                  "aspect": "Zugriff",
                  "values": ["Nur oberstes Element", "Beliebiger Index"]
                },
                {
                  "aspect": "Datenstruktur",
                  "values": ["LIFO", "Sequenziell"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zugriff nach pop",
              "text": "Nach pop darf top nicht mehr verwendet werden, da das Element entfernt wurde."
            },
            {
              "type": "important",
              "text": "std::stack eignet sich f√ºr Algorithmen mit R√ºckverfolgung oder verschachtelten Aufrufen."
            },
            {
              "type": "summary",
              "points": [
                "std::stack arbeitet nach dem LIFO-Prinzip",
                "Zugriff nur auf das oberste Element",
                "Kein direkter Iteratorzugriff",
                "Container-Adapter auf Basis von std::deque"
              ]
            }
          ]
        },
        {
          "title": "std::queue",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "std::queue",
              "text": "std::queue ist ein Container-Adapter, der das FIFO-Prinzip verwendet, bei dem das zuerst eingef√ºgte Element zuerst entfernt wird."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::queue modelliert eine Warteschlange.",
                "Elemente werden hinten eingef√ºgt und vorne entfernt."
              ]
            },
            {
              "type": "explanation",
              "title": "Container-Adapter",
              "text": [
                "std::queue ist kein eigenst√§ndiger Container.",
                "Intern wird standardm√§√üig std::deque verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<queue>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push f√ºgt ein Element am Ende ein.",
                "pop entfernt das vorderste Element.",
                "front und back liefern Zugriff auf Anfang und Ende.",
                "empty und size geben Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::queue",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::queue<int> q;\n\n    q.push(1);\n    q.push(2);\n    q.push(3);\n\n    std::cout << q.front() << std::endl; // Ausgabe: 1\n    q.pop();\n    std::cout << q.front() << std::endl; // Ausgabe: 2\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Kein direkter Zugriff auf mittlere Elemente.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "code",
              "title": "front, back, empty und size",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::queue<int> q;\n\n    std::cout << q.empty() << std::endl; // true\n    q.push(10);\n    q.push(20);\n\n    std::cout << q.front() << std::endl; // 10\n    std::cout << q.back() << std::endl;  // 20\n    std::cout << q.size() << std::endl;  // 2\n}\n"
            },
            {
              "type": "comparison",
              "title": "std::queue vs std::deque",
              "columns": ["std::queue", "std::deque"],
              "rows": [
                {
                  "aspect": "Zugriff",
                  "values": ["FIFO eingeschr√§nkt", "Voller Zugriff"]
                },
                {
                  "aspect": "Abstraktion",
                  "values": ["Warteschlange", "Sequenzieller Container"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Zugriff nach pop",
              "text": "Nach pop darf front nicht mehr verwendet werden, da das Element entfernt wurde."
            },
            {
              "type": "important",
              "text": "std::queue ist ideal f√ºr Breitensuche, Scheduling und Producer-Consumer-Modelle."
            },
            {
              "type": "summary",
              "points": [
                "std::queue arbeitet nach dem FIFO-Prinzip",
                "Zugriff nur vorne und hinten",
                "Kein direkter Zugriff auf mittlere Elemente",
                "Container-Adapter auf Basis von std::deque"
              ]
            }
          ]
        },
        {
          "title": "std::priority_queue",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "std::priority_queue",
              "text": "std::priority_queue ist ein Container-Adapter, der stets das Element mit der h√∂chsten Priorit√§t bereitstellt."
            },
            {
              "type": "explanation",
              "title": "Grundkonzept",
              "text": [
                "std::priority_queue organisiert Elemente nach Priorit√§t.",
                "Der Zugriff erfolgt immer auf das aktuell wichtigste Element."
              ]
            },
            {
              "type": "explanation",
              "title": "Interne Struktur",
              "text": [
                "Intern basiert std::priority_queue auf einem Heap.",
                "Standardm√§√üig wird ein Max-Heap verwendet."
              ]
            },
            {
              "type": "list",
              "title": "Ben√∂tigter Header",
              "items": [
                "<queue>"
              ]
            },
            {
              "type": "explanation",
              "title": "Zentrale Operationen",
              "text": [
                "push f√ºgt ein Element ein.",
                "pop entfernt das Element mit der h√∂chsten Priorit√§t.",
                "top liefert Zugriff auf das wichtigste Element.",
                "empty und size geben Zustandsinformationen."
              ]
            },
            {
              "type": "code",
              "title": "Grundlegende Nutzung von std::priority_queue",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n\nint main() {\n    std::priority_queue<int> pq;\n\n    pq.push(3);\n    pq.push(1);\n    pq.push(5);\n\n    std::cout << pq.top() << std::endl; // Ausgabe: 5\n    pq.pop();\n    std::cout << pq.top() << std::endl; // Ausgabe: 3\n}\n"
            },
            {
              "type": "explanation",
              "title": "Min-Heap erstellen",
              "text": [
                "Durch einen Comparator kann die Ordnung umgekehrt werden.",
                "So l√§sst sich ein Min-Heap realisieren."
              ]
            },
            {
              "type": "code",
              "title": "priority_queue als Min-Heap",
              "language": "cpp",
              "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nint main() {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;\n\n    pq.push(3);\n    pq.push(1);\n    pq.push(5);\n\n    std::cout << pq.top() << std::endl; // Ausgabe: 1\n}\n"
            },
            {
              "type": "explanation",
              "title": "Einschr√§nkungen",
              "text": [
                "Es gibt keinen direkten Zugriff auf alle Elemente.",
                "Iteratoren werden nicht bereitgestellt."
              ]
            },
            {
              "type": "comparison",
              "title": "std::priority_queue vs std::queue",
              "columns": ["std::priority_queue", "std::queue"],
              "rows": [
                {
                  "aspect": "Ordnungsprinzip",
                  "values": ["Priorit√§t", "FIFO"]
                },
                {
                  "aspect": "Zugriff",
                  "values": ["H√∂chste Priorit√§t", "Vorderstes Element"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Reihenfolge missverstehen",
              "text": "Die priority_queue ist nicht vollst√§ndig sortiert, nur das oberste Element ist garantiert korrekt."
            },
            {
              "type": "important",
              "text": "std::priority_queue ist ideal f√ºr Scheduling, Dijkstra und Ereignisverwaltung."
            },
            {
              "type": "summary",
              "points": [
                "std::priority_queue stellt immer das wichtigste Element bereit",
                "Basiert auf einem Heap",
                "Standardm√§√üig Max-Heap",
                "Min-Heap √ºber Comparator m√∂glich",
                "Kein direkter Iteratorzugriff"
              ]
            }
          ]
        }
        ]
      }
    ]
  },

  {
    "category": "Extras",
    "icon": "‚≠ê",
    "subcategories": [
      {
        "name": "Fortgeschritten",
        "icon": "‚≠ê",
        "topics": [
        {
          "title": "Fehlerbehandlung (try, catch und Exceptions)",
          "difficulty": "intermediate",
          "blocks": [
            {
              "type": "definition",
              "term": "Exception",
              "text": "Eine Exception ist ein Mechanismus zur Behandlung von Laufzeitfehlern durch Werfen und Abfangen von Fehlerobjekten."
            },
            {
              "type": "explanation",
              "title": "Grundidee der Fehlerbehandlung",
              "text": [
                "Exceptions trennen Fehlerbehandlung vom normalen Programmablauf.",
                "Fehler werden nicht √ºber R√ºckgabewerte signalisiert, sondern explizit geworfen."
              ]
            },
            {
              "type": "explanation",
              "title": "try, throw und catch",
              "text": [
                "try umschlie√üt Code, in dem Fehler auftreten k√∂nnen.",
                "throw l√∂st eine Exception aus.",
                "catch f√§ngt eine geworfene Exception ab und behandelt sie."
              ]
            },
            {
              "type": "list",
              "title": "Vorteile von Exceptions",
              "items": [
                "Saubere Trennung von Logik und Fehlerbehandlung",
                "Keine Fehlercodes n√∂tig",
                "Fehler k√∂nnen √ºber Funktionsgrenzen hinweg propagiert werden",
                "Zentrale Behandlung m√∂glich"
              ]
            },
            {
              "type": "code",
              "title": "Einfaches try catch Beispiel",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nint teilen(int a, int b) {\n    if (b == 0) {\n        throw std::runtime_error(\"Division durch null\");\n    }\n    return a / b;\n}\n\nint main() {\n    try {\n        std::cout << teilen(10, 2) << std::endl;\n        std::cout << teilen(10, 0) << std::endl; // wirft Exception\n    }\n    catch (const std::runtime_error& e) {\n        std::cout << \"Fehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Ablauf bei einer Exception",
              "text": [
                "Beim throw wird der normale Kontrollfluss sofort verlassen.",
                "Der Stack wird abgebaut, bis ein passender catch-Block gefunden wird."
              ]
            },
            {
              "type": "explanation",
              "title": "Standard-Exception-Hierarchie",
              "text": [
                "C++ stellt eine Hierarchie von Exception-Typen bereit.",
                "std::exception ist die Basisklasse vieler Standard-Exceptions."
              ]
            },
            {
              "type": "list",
              "title": "H√§ufige Exception-Typen",
              "items": [
                "std::runtime_error",
                "std::logic_error",
                "std::out_of_range",
                "std::invalid_argument"
              ]
            },
            {
              "type": "code",
              "title": "Mehrere catch-Bl√∂cke",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Index au√üerhalb des Bereichs\");\n    }\n    catch (const std::out_of_range& e) {\n        std::cout << \"Out of range: \" << e.what() << std::endl;\n    }\n    catch (const std::exception& e) {\n        std::cout << \"Allgemeiner Fehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "catch Reihenfolge",
              "text": [
                "Spezifische Exceptions m√ºssen vor allgemeineren gefangen werden.",
                "Andernfalls werden sie nie erreicht."
              ]
            },
            {
              "type": "code",
              "title": "Eigene Exception-Klasse",
              "language": "cpp",
              "code": "#include <iostream>\n#include <stdexcept>\n\nclass DateiFehler : public std::runtime_error {\npublic:\n    explicit DateiFehler(const std::string& msg)\n        : std::runtime_error(msg) {}\n};\n\nint main() {\n    try {\n        throw DateiFehler(\"Datei konnte nicht ge√∂ffnet werden\");\n    }\n    catch (const DateiFehler& e) {\n        std::cout << \"Dateifehler: \" << e.what() << std::endl;\n    }\n}\n"
            },
            {
              "type": "explanation",
              "title": "Exceptions und RAII",
              "text": [
                "Beim Stack-Unwinding werden lokale Objekte korrekt zerst√∂rt.",
                "RAII stellt sicher, dass Ressourcen auch bei Fehlern freigegeben werden."
              ]
            },
            {
              "type": "pitfall",
              "title": "Exceptions f√ºr normale Kontrolle",
              "text": "Exceptions sollten nicht f√ºr normalen Programmfluss oder h√§ufige F√§lle verwendet werden."
            },
            {
              "type": "important",
              "text": "Exceptions signalisieren au√üergew√∂hnliche Fehlerzust√§nde und keine regul√§ren Ergebnisse."
            },
            {
              "type": "summary",
              "points": [
                "try umschlie√üt fehleranf√§lligen Code",
                "throw l√∂st eine Exception aus",
                "catch behandelt den Fehler",
                "Exceptions propagieren √ºber Funktionsgrenzen",
                "RAII sorgt f√ºr sichere Ressourcenfreigabe"
              ]
            }
          ]
        },
        {
          "title": "Pr√§prozessor und #define",
          "difficulty": "basic",
          "blocks": [
            {
              "type": "definition",
              "term": "#define",
              "text": "#define ist eine Pr√§prozessor-Anweisung zur Ersetzung von Text vor der eigentlichen Kompilierung."
            },
            {
              "type": "explanation",
              "title": "Grundidee des Pr√§prozessors",
              "text": [
                "Der Pr√§prozessor arbeitet vor dem Compiler und ver√§ndert den Quelltext.",
                "#define ersetzt symbolische Namen rein textuell, ohne Typpr√ºfung."
              ]
            },
            {
              "type": "explanation",
              "title": "Einfache Makros",
              "text": [
                "Konstanten k√∂nnen mit #define definiert werden.",
                "Die Ersetzung erfolgt √ºberall im Code, wo der Name vorkommt."
              ]
            },
            {
              "type": "code",
              "title": "Konstantes Makro",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define PI 3.14159\n\nint main() {\n    std::cout << PI << std::endl; // wird durch 3.14159 ersetzt\n}\n"
            },
            {
              "type": "explanation",
              "title": "Funktions√§hnliche Makros",
              "text": [
                "Makros k√∂nnen Parameter besitzen und wie Funktionen aussehen.",
                "Es findet keine Typpr√ºfung statt."
              ]
            },
            {
              "type": "code",
              "title": "Funktions√§hnliches Makro",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define QUADRAT(x) ((x) * (x))\n\nint main() {\n    int a = 3;\n    std::cout << QUADRAT(a + 1) << std::endl; // (a + 1) * (a + 1)\n}\n"
            },
            {
              "type": "explanation",
              "title": "Typische Probleme von Makros",
              "text": [
                "Mehrfachauswertung von Argumenten kann zu Fehlern f√ºhren.",
                "Debugging ist erschwert, da Makros keine echten Funktionen sind."
              ]
            },
            {
              "type": "list",
              "title": "Weitere Pr√§prozessor-Anweisungen",
              "items": [
                "#undef zum Entfernen eines Makros",
                "#ifdef / #ifndef f√ºr bedingte Kompilierung",
                "#if / #else / #endif f√ºr Bedingungen"
              ]
            },
            {
              "type": "code",
              "title": "Bedingte Kompilierung",
              "language": "cpp",
              "code": "#include <iostream>\n\n#define DEBUG\n\nint main() {\n#ifdef DEBUG\n    std::cout << \"Debug-Modus aktiv\" << std::endl;\n#endif\n}\n"
            },
            {
              "type": "comparison",
              "title": "#define vs const",
              "columns": ["#define", "const"],
              "rows": [
                {
                  "aspect": "Typpr√ºfung",
                  "values": ["Nein", "Ja"]
                },
                {
                  "aspect": "Sichtbarkeit",
                  "values": ["Textuell", "G√ºltigkeitsbereich"]
                },
                {
                  "aspect": "Debugging",
                  "values": ["Schwierig", "Einfach"]
                }
              ]
            },
            {
              "type": "pitfall",
              "title": "Makros statt moderner Alternativen",
              "text": "#define sollte nicht f√ºr Konstanten oder Funktionen verwendet werden, wenn constexpr oder inline m√∂glich sind."
            },
            {
              "type": "important",
              "text": "In modernem C++ sollten constexpr, const und inline Funktionen #define weitgehend ersetzen."
            },
            {
              "type": "summary",
              "points": [
                "#define f√ºhrt textuelle Ersetzung durch",
                "Keine Typpr√ºfung",
                "Funktions√§hnliche Makros sind fehleranf√§llig",
                "Bedingte Kompilierung ist ein Hauptanwendungsfall",
                "Moderne Alternativen bevorzugen"
              ]
            }
          ]
        },
          { "title": "CMake Basics", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Vorlagen",
    "icon": "üìù",
    "subcategories": [
      {
        "name": "Basis Vorlagen",
        "icon": "üìò",
        "topics": [
          { "title": "main.cpp Grundger√ºst", "content": { "text": [], "code": [] } },
          { "title": "Hello World Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Input/Output Vorlage", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Klassen Vorlagen",
        "icon": "üß±",
        "topics": [
          { "title": "Klasse mit Header & cpp", "content": { "text": [], "code": [] } },
          { "title": "Getter & Setter", "content": { "text": [], "code": [] } },
          { "title": "Konstruktoren Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "STL Vorlagen",
        "icon": "üì¶",
        "topics": [
          { "title": "vector Beispiel", "content": { "text": [], "code": [] } },
          { "title": "map Beispiel", "content": { "text": [], "code": [] } },
          { "title": "tuple / pair Beispiel", "content": { "text": [], "code": [] } }
        ]
      },
      {
        "name": "Projekt Vorlagen",
        "icon": "üóÇÔ∏è",
        "topics": [
          { "title": "CMakeLists.txt Minimal", "content": { "text": [], "code": [] } },
          { "title": "Ordnerstruktur Vorlage", "content": { "text": [], "code": [] } },
          { "title": "Modulares Projekt Setup", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  },





  {
    "category": "Datenbanken",
    "icon": "üóÑÔ∏è",
    "subcategories": [
      {
        "name": "SQLite",
        "icon": "üß±",
        "topics": [
          { "title": "SQLite Grundlagen", "content": { "text": [], "code": [] } },
          { "title": "prepare / bind / step / finalize", "content": { "text": [], "code": [] } },
          { "title": "CRUD Operationen", "content": { "text": [], "code": [] } }
        ]
      }
    ]
  }

]
