[
  {
    "category": "Grundlagen",
    "subtopics": [
      {
        "title": "Console Ausgabe UTF-8 Windows",
        "content": {
          "text": [
            "\n\n### === Console Ausgabe UTF-8 in Clion Windows ===\n\n\n",
            "In Clion auf Windows, zeigt die Console keine Ü,Ä,Ö usw. an, wenn man nicht bestimmte Dinge beachtet und einstellt.\n\n",
            "---\n",
            "## 🔹 FONT Einstellen:",
            "Zudem ist zu empfehlen, die Schriftart umzustellen, damit keine Formatierungsfehler erscheinen.\n",
            "### 🔹 Einstellung in CLion\n",
            "Einstellungen / Editor / General / Font dort \"Font: Consolar Size: 13.0 Line height: 1.2\"\n\n\n",
            "---\n",
            "### CODE in main.lua:"
          ],
          "code": [
            "#include <windows.h> \n#include <io.h> \n#include <fcntl.h> \n\n\nint main() {\n SetConsoleOutputCP(CP_UTF8); \n return 0; \n}"
          ]
        }
      },
      {
  "title": "Working Directory in CLion",
  "content": {
    "text": [
      "### === Dateien richtig speichern mit eigenem `data/`-Ordner ===\n",
      "Standardmäßig speichert CLion Programme ihre Ausgabedateien im `cmake-build-debug/`-Ordner. Wenn du stattdessen möchtest, dass Dateien in einem eigenen `data/`-Ordner **im Projektverzeichnis** landen (z.B. `data/info.txt`), musst du das Arbeitsverzeichnis („Working Directory“) ändern.\n",
      "\n",
      "### 🔹 Zielstruktur\n",
      "```",
      "Projektordner/\n",
      "├── CMakeLists.txt\n",
      "├── data/\n",
      "└── cmake-build-debug/",
      "```",
      "\n",
      "### 🔹 Einstellung in CLion\n",
      "1. Klicke oben rechts auf das Dropdown mit dem Projektnamen.\n",
      "2. Wähle **„Edit Configurations…“**.\n",
      "3. Wähle deine aktuelle Run-Konfiguration (z.B. dein Projekt).\n",
      "4. Im Feld **„Working directory“** trägst du ein: `$ProjectFileDir$`\n",
      "   → Das sorgt dafür, dass Pfade wie `data/info.txt` aus dem Projektordner gelesen/geschrieben werden.\n",
      "\n",
      "### 🔹 Prüfen im Code\n",
      "- Nutze `std::filesystem::current_path()` um den aktuellen Pfad im Programm zu sehen:",
      "\n",
      "```cpp",
      "std::cout << \"Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;",
      "```",
      "\n",
      "---\n",
      "### 🔹 Hinweis\n",
      "- Erstelle den Ordner `data/` manuell im Projektverzeichnis oder per Code:",
      "```cpp",
      "std::filesystem::create_directories(\"data\");",
      "```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <filesystem>\n\nint main() {\n  std::cout << \"Aktuelles Arbeitsverzeichnis: \" << std::filesystem::current_path() << std::endl;\n\n  std::string pfad = \"data/test.txt\";\n  std::filesystem::create_directories(\"data\");\n  std::ofstream out(pfad);\n  out << \"Testzeile\\n\";\n  out.close();\n\n  std::cout << \"Datei erfolgreich erstellt unter: \" << pfad << std::endl;\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Begriffe",
        "content": {
          "text": [
          "### === Wichtige Begriffe in C++ erklärt ===\n",
          "Hier findest du eine Übersicht zentraler Begriffe in der C++-Programmierung, kompakt erklärt.\n",
          "\n",
          "#### Compiler\n",
          "- Übersetzt C++-Code in Maschinenprogramm, das dein Computer ausführen kann\n",
          "\n",
          "#### Präprozessor\n",
          "- Führt Anweisungen wie `#include` und `#define` vor dem Kompilieren aus\n",
          "\n",
          "#### Header-Datei\n",
          "- Datei mit Deklarationen von Funktionen, Klassen oder Konstanten (`.hpp`)\n",
          "\n",
          "#### Deklaration vs. Definition\n",
          "- Deklaration: Nur Ankündigung (z.B. `int x;`)\n",
          "- Definition: Speicher wird wirklich zugewiesen (z.B. `int x = 5;`)\n",
          "\n",
          "#### Variable\n",
          "- Speicherstelle mit Namen, die Daten aufnehmen kann (z.B. `int zahl = 10;`)\n",
          "\n",
          "#### Funktion\n",
          "- Codeblock, der mehrfach ausführbar ist - mit `return`-Wert und Parametern\n",
          "\n",
          "#### Rückgabewert\n",
          "- Der Wert, den eine Funktion mit `return` zurückliefert\n",
          "\n",
          "#### Parameter vs. Argument\n",
          "- Parameter: Platzhalter in der Funktionsdefinition (`int add(int a, int b)`)\n",
          "- Argument: Konkreter Wert beim Aufruf (`add(5, 7)` → 5 und 7)\n",
          "\n",
          "#### Block / Scope\n",
          "- Bereich mit `{}` - darin gelten lokale Variablen\n",
          "\n",
          "#### Gültigkeitsbereich (Scope)\n",
          "- Gibt an, wo im Code eine Variable sichtbar/nutzbar ist (z.B. lokal vs. global)\n",
          "\n",
          "#### Initialisierung\n",
          "- Erstmalige Zuweisung eines Werts an eine Variable (`int x = 5;`)\n",
          "\n",
          "#### Operatoren\n",
          "- Rechenzeichen oder Symbole zur Verarbeitung (`+`, `-`, `==`, `&&`, `++`, `<<`)\n",
          "\n",
          "#### Kontrollstrukturen\n",
          "- Anweisungen zur Ablaufsteuerung: `if`, `while`, `for`, `switch`\n",
          "\n",
          "#### Schleife\n",
          "- Wiederholt Anweisungen: `while`, `for`, `do-while`\n",
          "\n",
          "#### Bedingung\n",
          "- Ausdruck, der `true` oder `false` ergibt (z.B. `x > 5`)\n",
          "\n",
          "#### Klasse / Objekt\n",
          "- Klasse: Bauplan für Objekte (enthält Daten + Funktionen)\n",
          "- Objekt: Konkrete Instanz einer Klasse\n",
          "\n",
          "#### Konstruktor / Destruktor\n",
          "- Konstruktor: Wird beim Erzeugen eines Objekts automatisch aufgerufen\n",
          "- Destruktor: Wird beim Löschen automatisch aufgerufen (`~Klassenname()`)\n",
          "\n",
          "#### this-Zeiger\n",
          "- Zeigt innerhalb einer Klasse auf das aktuelle Objekt (`this->variable`)\n",
          "\n",
          "#### new / delete\n",
          "- `new`: Reserviert Speicher auf dem Heap (`int* p = new int;`)\n",
          "- `delete`: Gibt diesen Speicher wieder frei\n",
          "\n",
          "#### Referenz (&)\n",
          "- Alias auf eine bestehende Variable (z.B. `int& r = x;`)\n",
          "\n",
          "#### Zeiger (*)\n",
          "- Variable, die eine Speicheradresse speichert (`int* p = &x;`)\n",
          "\n",
          "#### nullptr\n",
          "- Null-Zeiger, zeigt auf „nichts“ (`int* p = nullptr;`)\n",
          "\n",
          "#### Überladung\n",
          "- Mehrere Funktionen mit gleichem Namen, aber unterschiedlicher Signatur\n",
          "\n",
          "#### Vererbung\n",
          "- Eine Klasse übernimmt Eigenschaften einer anderen Klasse\n",
          "\n",
          "#### Polymorphie\n",
          "- Fähigkeit, Objekte über gemeinsame Schnittstellen unterschiedlich zu behandeln\n",
          "\n",
          "#### Template\n",
          "- Ermöglicht generischen Code (z.B. Funktionen für beliebige Typen)\n",
          "\n",
          "#### Lambda\n",
          "- Anonyme Funktion, oft für kurze Aktionen in `std::for_each`, `sort`, ...\n",
          "\n",
          "#### Iterator\n",
          "- Zeiger-ähnliches Objekt zum Durchlaufen von Containern (`v.begin()`, `v.end()`)\n",
          "---\n"
        ],
          "code": []
        }
      },
      {
        "title": "Typen",
        "content": {
          "text": [
            "### === Datentypen in C++ ===\n",
            "C++ kennt viele eingebaute Typen und erlaubt die Definition eigener Typen.\n",
            "\n",
            "---\n",
            "### Standard-Datentypen\n",
            "- `int`: Ganzzahl (z.B. `int x = 5;`)\n",
            "- `float`: Fließkommazahl mit einfacher Genauigkeit\n",
            "- `double`: Fließkommazahl mit doppelter Genauigkeit\n",
            "- `char`: Einzelnes Zeichen (z.B. `'A'`)\n",
            "- `bool`: Wahrheitswert (`true` / `false`)\n",
            "- `void`: Kein Rückgabewert (z.B. bei `void funktion()`)\n",
            "\n",
            "---\n",
            "### Erweiterte Grundtypen\n",
            "- `long`, `long long`, `unsigned`, `short`: Varianten von `int`\n",
            "- `wchar_t`, `char16_t`, `char32_t`: Unicode-Zeichentypen\n",
            "- `std::string`: String-Klasse (aus `<string>`)\n",
            "- `std::size_t`: Unsigned Ganzzahl für Größen (z.B. `v.size()`)\n",
            "- `nullptr_t`: Typ des Literals `nullptr`\n",
            "\n",
            "---\n",
            "### Automatische Typableitung\n",
            "- `auto`: Typ wird automatisch aus dem Ausdruck ermittelt\n",
            "- `decltype(...)`: Liefert den Typ eines Ausdrucks\n",
            "- Beispiel:\n",
            "```cpp\nint x = 5;\nauto y = x * 2;         // y ist int\ndecltype(y) z = 10;      // z ist auch int\n```\n",
            "\n",
            "---\n",
            "### Eigene Typen\n",
            "- `struct`: Für einfache Strukturen mit mehreren Feldern\n",
            "- `class`: Für Klassen mit Methoden und Zugriffskontrolle (public/private)\n",
            "- `enum`: Für aufzählbare Werte\n",
            "\n",
            "#### `enum` Erklärung:\n",
            "- `enum` erstellt eigene ganzzahlige Werte (standardmäßig beginnend bei 0)\n",
            "- Beispiel:\n",
            "```cpp\nenum Farbe { Rot, Gruen, Blau };  // Rot = 0, Gruen = 1, Blau = 2\n```\n",
            "- Man kann Werte auch selbst zuweisen:\n",
            "```cpp\nenum Status { OK = 1, FEHLER = 404, NICHT_GEFUNDEN = 4040 };\n```\n",
            "- Zugriff auf Zahlwert mit `static_cast<int>(enumWert)`:\n",
            "```cpp\nStatus s = FEHLER;\nstd::cout << static_cast<int>(s);  // Ausgabe: 404\n```\n",
            "- `enum class` (modernes C++): Streng typisiert, Zugriff nur mit `Status::FEHLER`\n",
            "\n",
            "---\n",
            "### `using/typedef` Erklärung:\n",
            "- `typedef` (alt) und `using` (modern): Eigene Namen für bestehende Typen\n",
            "- Beispiel:\n",
            "```cpp\ntypedef unsigned int uint;\nusing Score = double;\n```",
            "\n",
            "---\n",
            "### Typumwandlung (Casting)\n",
            "- `static_cast<T>(wert)`: Sicherer Cast zwischen kompatiblen Typen\n",
            "- `const_cast<T>`: Entfernt `const`\n",
            "\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <typeinfo>\n\n// Eigene Struktur\nstruct Person {\n    std::string name;\n    int alter;\n};\n\n// Typalias\nusing Zahl = unsigned int;\n\nenum Farbe { Rot, Gruen, Blau };           // Rot = 0, Gruen = 1, Blau = 2\nenum Status { OK = 1, FEHLER = 404 };      // eigene Werte\n\nint main() {\n    int a = 10;\n    auto b = 3.14;                          // automatisch double\n    decltype(a) c = 5;                      // ebenfalls int\n\n    Person p = {\"Kilian\", 21};\n    Zahl punkte = 150;\n\n    Farbe f = Gruen;\n    Status s = FEHLER;\n\n    std::cout << \"Name: \" << p.name << \", Alter: \" << p.alter << std::endl;         // Ausgabe: Name: Kilian, Alter: 21\n    std::cout << \"Punkte: \" << punkte << std::endl;                                  // Ausgabe: Punkte: 150\n    std::cout << \"Typ von b: \" << typeid(b).name() << std::endl;                     // Ausgabe: Typ von b: double (compilerabhängig)\n    std::cout << \"Fehlercode: \" << static_cast<int>(s) << std::endl;                // Ausgabe: Fehlercode: 404\n\n    return 0;\n}"
          ]
        }
      },
      {
        "title": "Header",
        "content": {
          "text": [
            "### === Wichtige Header-Dateien in C++ ===\n",
            "Header-Dateien enthalten Deklarationen von Funktionen, Klassen und Datentypen. Standard-Header kommen aus der C++-Standardbibliothek, eigene erstellt man selbst.\n",
            "\n",
            "---\n",
            "### Arten von `#include`\n",
            "- `#include <...>`: Für Standardbibliothek (z.B. `<iostream>`, `<vector>`, ...)\n",
            "- `#include \"...\"`: Für eigene Dateien (z.B. `\"meinmodul.hpp\"`)\n",
            "\n",
            "---\n",
            "### Eigene Header-Dateien\n",
            "- Eigene Header enden mit `.hpp`\n",
            "- Sie enthalten **Deklarationen**, keine Implementierungen\n",
            "- Die zugehörige `.cpp`-Datei enthält dann die **Definitionen**\n",
            "\n",
            "#### Beispiel - Header-Datei: `meinmodul.hpp`\n",
            "```cpp\n#ifndef MEINMODUL_HPP\n#define MEINMODUL_HPP\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n```\n",
            "\n",
            "#### Beispiel - Implementierung: `meinmodul.cpp`\n",
            "```cpp\n#include <iostream>\n#include \"meinmodul.hpp\"\n\nvoid begruessung() {\n    std::cout << \"Hallo!\";\n}\n```\n",
            "\n",
            "#### In `main.cpp` verwenden:\n",
            "```cpp\n#include \"meinmodul.hpp\"\n\nint main() {\n    begruessung();\n    return 0;\n}\n```\n",
            "\n",
            "👉 Vorteil: strukturierter Code, Wiederverwendbarkeit und Trennung von Schnittstelle & Implementierung\n",
            "\n",
            "---\n",
            "### Include Guards (Schutz vor Mehrfacheinbindung)\n",
            "- Jeder eigene Header sollte mit einem **Include Guard** versehen werden:\n",
            "```cpp\n#ifndef MEIN_HEADER_HPP\n#define MEIN_HEADER_HPP\n\n// Inhalte des Headers\n\n#endif\n```\n",
            "- Verhindert doppelte Definitionen beim mehrfachen Einbinden. In CLion automatisch!\n",
            "\n",
            "---\n",
            "### Übersicht wichtiger Standard-Header:\n",
            "\n",
            "#### Ein- und Ausgabe\n",
            "- `<iostream>`: `std::cin`, `std::cout`, `std::cerr`\n",
            "- `<iomanip>`: `std::setw`, `std::setprecision`, `std::fixed`, `std::put_time`\n",
            "- `<fstream>`: Datei-I/O mit `ifstream`, `ofstream`, `fstream`\n",
            "\n",
            "#### Strings und Streams\n",
            "- `<string>`: `std::string`\n",
            "- `<sstream>`: `std::stringstream` für String-Parsing und Umwandlungen\n",
            "\n",
            "#### Mathematisches\n",
            "- `<cmath>`: `sqrt`, `pow`, `abs`, `round`, `sin`, `log`\n",
            "- `<cstdlib>`: `rand`, `srand`, `atoi`, `atof`\n",
            "- `<limits>`: `numeric_limits<T>::max()` / `min()`\n",
            "\n",
            "#### Zeit und Threads\n",
            "- `<ctime>`: `std::time`, `std::localtime`\n",
            "- `<chrono>`: Zeitmessung (z.B. `high_resolution_clock`)\n",
            "- `<thread>`: `std::this_thread::sleep_for()`\n",
            "\n",
            "#### Container & Algorithmen\n",
            "- `<vector>`, `<array>`, `<set>`, `<map>`\n",
            "- `<stack>`, `<queue>`\n",
            "- `<algorithm>`: `sort`, `find`, `remove`, `for_each`, ...\n",
            "- `<iterator>`: Iteratorfunktionen wie `begin()`/`end()`\n",
            "\n",
            "#### Weitere nützliche Header\n",
            "- `<exception>`: `std::exception`, `std::runtime_error`\n",
            "- `<typeinfo>`: Laufzeittypinfo (`typeid`)\n",
            "- `<utility>`: `std::pair`, `std::swap`, `std::move`\n",
            "- `<memory>`: Smart Pointers wie `unique_ptr`, `shared_ptr`\n",
            "---\n"
          ],
          "code": [
            "#ifndef MEINMODUL_HPP\n#define MEINMODUL_HPP\n\nvoid begruessung(); // Funktionsdeklaration\n\n#endif\n\n// -----------------------------\n#include <iostream>\n#include \"meinmodul.hpp\"\n\nvoid begruessung() {\n  std::cout << \"Hallo!\";\n}\n\nint main() {\n  begruessung(); // Ausgabe: Hallo!\n  return 0;\n}"

          ]
        }
      },
      {
  "title": "Initialisierung  : vs. {}",
  "content": {
    "text": [
      "### === Initialisierung mit `:` vs. `{}` in C++ ===\n",
      "C++ bietet verschiedene Möglichkeiten, wie Variablen und Klassenmitglieder initialisiert werden können. Besonders wichtig sind:\n",
      "---\n",
      "- `:` → Initialisierungsliste bei Konstruktoren\n",
      "- `{}` → Einheitliche Initialisierung (Brace-Initialization / Uniform Initialization)\n",
      "\n",
      "---\n",
      "### Initialisierungsliste mit `:`\n",
      "- Wird in Konstruktoren verwendet, um Member **direkt zu initialisieren**, bevor der Body ausgeführt wird\n",
      "- **Effizienter** als Zuweisung im Konstruktorblock (insbesondere bei `const`- oder Referenz-Membern)\n",
      "\n",
      "```cpp\nclass Auto {\nprivate:\n    int ps;\npublic:\n    Auto(int p) : ps(p) {}   // Initialisierung mit Doppelpunkten\n};\n```\n",
      "\n",
      "---\n",
      "### Warum `:` statt `=` im Body?\n",
      "- `:` initialisiert direkt beim Erzeugen → **vermeidet unnötige Standardinitialisierung + spätere Zuweisung**\n",
      "- Pflicht bei `const` oder Referenzen:\n",
      "```cpp\nclass Test {\n    const int wert;\npublic:\n    Test(int w) : wert(w) {}  // Muss so gemacht werden\n};\n```\n",
      "\n",
      "---\n",
      "### Einheitliche Initialisierung mit `{}`\n",
      "- Eingeführt mit C++11\n",
      "- Kann **Konstruktoren**, **Arrays**, **STL-Container** und **structs** initialisieren\n",
      "- **Vermeidet Verwechslungen** mit Funktionsdeklarationen (Most Vexing Parse)\n",
      "\n",
      "```cpp\nint a{5};                  // Direktinitialisierung\nstd::vector<int> zahlen{1, 2, 3};\nAuto b{150};                // ruft Konstruktor mit `int` auf\n```\n",
      "\n",
      "---\n",
      "### Kombination\n",
      "- Beides lässt sich kombinieren:\n",
      "```cpp\nclass Zahl {\n    int wert;\npublic:\n    Zahl(int w) : wert{w} {}  // Doppelt sicher: Initialisierungsliste + {}\n};\n```\n",
      "\n",
      "👉 Faustregel:\n",
      "- **Konstruktoren mit `:` initialisieren Member**\n",
      "- **`{}` ist sicherer, universeller Stil ab C++11**\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Beispiel {\nprivate:\n    const int wert;\n    std::vector<int> zahlen;\n\npublic:\n    // Initialisierung mit : und {}\n    Beispiel(int w) : wert(w), zahlen{1, 2, 3} {}\n\n    void anzeigen() {\n        std::cout << \"Wert: \" << wert << \" | Erster Wert: \" << zahlen[0] << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b{42};      // Konstruktor-Aufruf mit {} Initialisierung\n    b.anzeigen();         // Ausgabe: Wert: 42 | Erster Wert: 1\n\n    int x{10};            // Brace-Initialisierung einer einfachen Variable\n    std::cout << \"x: \" << x << std::endl;\n\n    return 0;\n}"
    ]
        }
      }
    ]
  },







  {
    "category": "Ein-/Ausgabe",
    "subtopics": [
      {
        "title": "Eingabe",
        "content": {
          "text": [
            "### === Benutzereingabe in C++ ===\n",
            "Für die Eingabe in C++ wird meist `std::cin` verwendet. Dabei wird direkt aus der Konsole gelesen.\n",
            "\n",
            "---\n",
            "### `std::cin`\n",
            "- Liest eine Eingabe **bis zum ersten Leerzeichen**\n",
            "- Nur für einzelne Wörter oder Zahlen geeignet\n",
            "\n",
            "---\n",
            "### `std::getline`\n",
            "- Liest eine ganze **Zeile** (inklusive Leerzeichen)\n",
            "- Ideal für Namen, Adressen, ganze Sätze usw.\n",
            "- Wichtig: vorher `std::cin.ignore()` nutzen, wenn zuvor `cin` verwendet wurde\n",
            "\n",
            "---\n",
            "### `std::cin.ignore()`\n",
            "- Leert den Eingabepuffer, z.B. nach `cin` vor `getline`\n",
            "- Typisch: `std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');`\n",
            "\n",
            "---\n",
            "### `std::stringstream`\n",
            "- Konvertiert zwischen Strings und Zahlen\n",
            "- Nützlich für Eingaben mit vielen Werten in einer Zeile\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <limits> // für std::numeric_limits\n\nint main() {\n  std::string name;\n  int alter;\n\n  // Eingabe eines einzelnen Werts\n  std::cout << \"Wie alt bist du? \";\n  std::cin >> alter;\n\n  // Eingabepuffer leeren (wichtig vor getline)\n  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n  // Eingabe einer ganzen Zeile\n  std::cout << \"Wie heißt du? \";\n  std::getline(std::cin, name);\n\n  std::cout << \"Hallo \" << name << \", du bist \" << alter << \" Jahre alt.\" << std::endl;\n\n  // Stringstream Beispiel\n  std::string eingabe = \"23 42 99\";\n  std::stringstream ss(eingabe);\n  int zahl1, zahl2, zahl3;\n  ss >> zahl1 >> zahl2 >> zahl3;\n  std::cout << \"Zahlen aus dem String: \" << zahl1 << \", \" << zahl2 << \", \" << zahl3 << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Ausgabe",
        "content": {
          "text": [
            "### === Ausgabe mit `std::cout` in C++ ===\n",
            "`std::cout` ist die Standardausgabe in C++ und wird für Konsolenausgaben verwendet.\n",
            "\n",
            "---\n",
            "### Grundlegende Ausgabe\n",
            "`std::cout << \"Text\" << variable;`\n",
            "- Die `<<`-Operatoren hängen Inhalte aneinander\n",
            "- Mit `\\n` oder `std::endl` wird eine Zeile beendet\n",
            "\n",
            "---\n",
            "### Formatierung mit `<iomanip>`\n",
            "- `std::setw(n)`: Feldbreite setzen\n",
            "- `std::setprecision(n)`: Genauigkeit für Nachkommastellen\n",
            "- `std::fixed`: Kommazahlen mit fester Nachkommastellenzahl\n",
            "- `std::left` / `std::right`: Ausrichtung\n",
            "\n",
            "---\n",
            "### Fehlerausgabe mit `std::cerr` und `std::clog`\n",
            "- `std::cerr`: Wird für **Fehlermeldungen** verwendet (ungespeichert)\n",
            "- `std::clog`: Wird für **Logmeldungen** verwendet (gepuffert)\n",
            "- Beide gehen wie `std::cout` in die Konsole, können aber **umgeleitet** werden\n",
            "\n",
            "---\n",
            "### Führende Nullen bei Zahlen\n",
            "- Mit `std::setw(n)` und `std::setfill('0')` lassen sich Zahlen mit führenden Nullen formatieren:\n",
            "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // Ausgabe: 00017\n```\n",
            "- Mit `std::string`: Umwandlung und manuelles Auffüllen:\n",
            "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17); // \"00017\"\n```\n",
            "- Ab C++20: `std::format` macht es besonders einfach:\n",
            "```cpp\nstd::cout << std::format(\"{:05}\", 17); // Ausgabe: 00017\n```\n",
            "\n",
            "---\n",
            "### Zahlenformat: `dec`, `hex`, `oct`\n",
            "- `std::dec`: Ausgabe als Dezimalzahl (Standard)\n",
            "- `std::hex`: Ausgabe als Hexadezimalzahl\n",
            "- `std::oct`: Ausgabe als Oktalzahl\n",
            "- Wichtig bei Binärformaten, Flags oder Speicheradressen\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int alter = 21;\n  double kontostand = 1234.56789;\n\n  // Einfache Begrüßung\n  std::cout << \"Hallo, \" << name << \"!\\n\"; // Ausgabe: Hallo, Kilian!\n\n  // Formatierte Tabelle\n  std::cout << std::left << std::setw(10) << \"Name\"\n            << std::right << std::setw(10) << \"Alter\"\n            << std::setw(15) << \"Kontostand\" << std::endl;\n\n  std::cout << std::left << std::setw(10) << name\n            << std::right << std::setw(10) << alter\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl;\n\n  // Zahlenformat\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;\n\n  // Führende Nullen mit iomanip\n  int nummer = 17;\n  std::cout << \"Führende Nullen (iomanip): \" << std::setw(5) << std::setfill('0') << nummer << std::endl; // Ausgabe: 00017\n\n  // Mit std::string auffüllen\n  std::string gepolstert = std::string(5 - std::to_string(nummer).length(), '0') + std::to_string(nummer);\n  std::cout << \"Mit std::string: \" << gepolstert << std::endl; // Ausgabe: 00017\n\n#if __cpp_lib_format\n  // C++20: std::format\n  std::cout << \"Mit std::format: \" << std::format(\"{:05}\", nummer) << std::endl; // Ausgabe: 00017\n#endif\n\n  // Fehlermeldung und Logausgabe\n  std::cerr << \"Dies ist eine Fehlermeldung!\" << std::endl;\n  std::clog << \"Dies ist eine Logmeldung.\" << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
  "title": "Datei",
  "content": {
    "text": [
      "### === Datei-Ein-/Ausgabe in C++ ===\n",
      "`<fstream>` wird für klassische Dateiarbeit verwendet, `<filesystem>` für moderne Pfad- und Existenzprüfungen.\n",
      "\n",
      "---\n",
      "### 🔹 Typen aus `<fstream>`\n",
      "- `std::ofstream`: Schreiben (`output file stream`)\n",
      "- `std::ifstream`: Lesen (`input file stream`)\n",
      "- `std::fstream`: Beides\n",
      "\n",
      "---\n",
      "### 🔹 Datei öffnen\n",
      "- `std::ofstream f(\"name.txt\");` - zum Schreiben (überschreibt!)\n",
      "- `std::ofstream f(\"name.txt\", std::ios::app);` - **zum Anhängen**\n",
      "- `std::ifstream f(\"name.txt\");` - zum Lesen\n",
      "\n",
      "---\n",
      "### 🔹 Datei prüfen\n",
      "- Mit `.is_open()` oder über `if (stream)`\n",
      "- Mit `std::filesystem::exists(pfad)` prüft man, ob eine Datei/Ordner **existiert**\n",
      "- `std::filesystem::is_regular_file(pfad)`: prüft auf **normale Datei**\n",
      "- `std::filesystem::is_directory(pfad)`: prüft auf **Verzeichnis**\n",
      "\n",
      "---\n",
      "### 🔹 Zeilenweise lesen und verändern\n",
      "- Mit `std::getline()` Zeilen einlesen\n",
      "- In `std::vector<std::string>` zwischenspeichern\n",
      "- Änderungen durchführen und danach Datei neu schreiben\n",
      "\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <filesystem>\n\nint main() {\n  std::string dateiname = \"daten.txt\";\n\n  // Prüfen, ob Datei bereits existiert\n  if (std::filesystem::exists(dateiname)) {\n    std::cout << \"Datei existiert bereits.\" << std::endl;\n  } else {\n    std::cout << \"Datei existiert NICHT. Wird erstellt...\" << std::endl;\n  }\n\n  // Neue Datei anlegen\n  std::ofstream out(dateiname);\n  if (out) {\n    out << \"Zeile 1\\n\" << \"Zeile 2\\n\" << \"Zeile 3\\n\";\n    out.close();\n  }\n\n  // Zeile anhängen\n  std::ofstream append(dateiname, std::ios::app);\n  append << \"Neue Zeile am Ende\\n\";\n  append.close();\n\n  // Datei einlesen\n  std::ifstream in(dateiname);\n  std::vector<std::string> inhalt;\n  std::string zeile;\n  while (std::getline(in, zeile)) {\n    inhalt.push_back(zeile);\n  }\n  in.close();\n\n  // Zeile 2 bearbeiten (Index 1)\n  if (inhalt.size() >= 2) {\n    inhalt[1] = \"[GEÄNDERT] \" + inhalt[1];\n  }\n\n  // Datei überschreiben\n  std::ofstream out2(dateiname);\n  for (const std::string& z : inhalt) {\n    out2 << z << \"\\n\";\n  }\n  out2.close();\n\n  // Prüfung auf Verzeichnis\n  if (std::filesystem::is_directory(\".\")) {\n    std::cout << \"Aktuelles Verzeichnis ist gültig.\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Date/Time",
        "content": {
          "text": [
            "### === Datum und Uhrzeit in C++ ===\n",
            "C++ bietet mehrere Möglichkeiten, um mit Datum und Zeit zu arbeiten.\n",
            "\n",
            "---\n",
            "### `std::time` & `std::localtime`\n",
            "- `std::time(nullptr)` liefert aktuelle Zeit (Sekunden seit 01.01.1970)\n",
            "- `std::localtime()` wandelt sie in eine `tm`-Struktur für lesbares Datum um\n",
            "\n",
            "---\n",
            "### `std::put_time()` (aus `<iomanip>`) für Formatierung\n",
            "- `std::put_time()` funktioniert wie `strftime`\n",
            "- Beispiel-Formate: `%d.%m.%Y`, `%H:%M:%S`, `%Y-%m-%d_%H-%M`\n",
            "- Mit `std::ostringstream` kann man Datum/Zeit auch als `std::string` speichern\n",
            "\n",
            "---\n",
            "### Zeitmessung mit `<chrono>`\n",
            "- Nutze `std::chrono::high_resolution_clock` für präzise Messungen\n",
            "- `std::this_thread::sleep_for(...)` pausiert das Programm gezielt\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <ctime>        // time, localtime\n#include <iomanip>      // put_time\n#include <sstream>      // ostringstream für string-Formate\n#include <chrono>       // chrono für Zeitmessung\n#include <thread>       // sleep_for\n\nint main() {\n  // 1. Aktuelle Uhrzeit formatieren und anzeigen\n  std::time_t jetzt = std::time(nullptr);               // Sekunden seit 1970\n  std::tm* lokal = std::localtime(&jetzt);              // lokale Zeitstruktur\n\n  std::cout << \"Aktuelle Uhrzeit: \"\n            << std::put_time(lokal, \"%d.%m.%Y %H:%M:%S\") << std::endl; // Ausgabe: 28.05.2025 19:45:12\n\n  // 2. Zeit als String speichern\n  std::ostringstream oss;\n  oss << std::put_time(lokal, \"%Y-%m-%d_%H-%M-%S\");\n  std::string zeitString = oss.str();\n  std::cout << \"Als String gespeichert: \" << zeitString << std::endl; // Ausgabe: 2025-05-28_19-45-12\n\n  // 3. Kurze Pause (Thread schlafen lassen)\n  std::cout << \"Warte 1 Sekunde...\" << std::endl;\n  std::this_thread::sleep_for(std::chrono::seconds(1)); // Pause für 1 Sekunde\n  std::cout << \"Weiter!\" << std::endl; // Ausgabe: Weiter!\n\n  // 4. Zeitmessung mit chrono\n  auto start = std::chrono::high_resolution_clock::now();\n\n  std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 0,5 Sek warten\n\n  auto ende = std::chrono::high_resolution_clock::now();\n  auto dauer = std::chrono::duration_cast<std::chrono::milliseconds>(ende - start);\n\n  std::cout << \"Verstrichene Zeit: \" << dauer.count() << \" ms\" << std::endl; // Ausgabe: Verstrichene Zeit: 500 ms\n\n  return 0;\n}"
          ]
        }
      }
    ]
  },









  


  {
    "category": "Struktur",
    "subtopics": [
    {
   "title": "Schleifen / Loops",
   "content": {
    "text": [
      "### === Schleifen in C++ ===\n",
      "Schleifen ermöglichen **wiederholte Ausführung** von Code, solange eine Bedingung erfüllt ist.\n",
      "\n",
      "---\n",
      "### 🔁 `while`-Schleife\n",
      "- Führt Code **solange** aus, wie die Bedingung **wahr** ist\n",
      "- **Kopfgesteuert** (Bedingung wird **vorher** geprüft)\n",
      "```cpp\nint i = 0;\nwhile (i < 3) {\n  std::cout << i << std::endl;\n  i++;\n}\n```\n",
      "\n",
      "---\n",
      "### 🔁 `do-while`-Schleife\n",
      "- Führt den Block **mindestens einmal** aus\n",
      "- **Fußgesteuert** (Bedingung wird **nachher** geprüft)\n",
      "```cpp\nint j = 0;\ndo {\n  std::cout << j << std::endl;\n  j++;\n} while (j < 3);\n```\n",
      "\n",
      "---\n",
      "### 🔁 `for`-Schleife\n",
      "- Ideal für Schleifen mit **Zähler**\n",
      "- Besteht aus Initialisierung, Bedingung, Inkrement\n",
      "```cpp\nfor (int k = 0; k < 3; ++k) {\n  std::cout << k << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### 🔁 `range-based for` (seit C++11)\n",
      "- Für **Container, Arrays** oder **Strings**\n",
      "```cpp\nstd::string text = \"Hi\";\nfor (char c : text) {\n  std::cout << c << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### 🔁 Schleifensteuerung:\n",
      "- `break;` → Schleife **sofort beenden**\n",
      "- `continue;` → Nächste Iteration überspringen\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n  // while-Schleife\n  int i = 0;\n  while (i < 3) {\n    std::cout << \"while: \" << i << std::endl; // Ausgabe: 0, 1, 2\n    i++;\n  }\n\n  // do-while-Schleife\n  int j = 0;\n  do {\n    std::cout << \"do-while: \" << j << std::endl; // Ausgabe: 0, 1, 2\n    j++;\n  } while (j < 3);\n\n  // for-Schleife\n  for (int k = 0; k < 3; ++k) {\n    std::cout << \"for: \" << k << std::endl; // Ausgabe: 0, 1, 2\n  }\n\n  // range-based for\n  std::vector<std::string> namen = {\"Anna\", \"Bob\", \"Clara\"};\n  for (const std::string& name : namen) {\n    std::cout << \"range-for: \" << name << std::endl; // Ausgabe: Anna, Bob, Clara\n  }\n\n  // break und continue\n  for (int x = 0; x < 5; ++x) {\n    if (x == 2) continue; // überspringt 2\n    if (x == 4) break;    // bricht bei 4 ab\n    std::cout << \"x: \" << x << std::endl; // Ausgabe: 0, 1, 3\n  }\n\n  return 0;\n}"
    ]
        }
      },
      {
  "title": "if / else und switch",
  "content": {
    "text": [
      "### === Bedingungen mit `if` / `else` und `switch` ===\n",
      "In C++ werden Bedingungen mit `if`, `else if`, `else` und `switch` verwendet, um **Entscheidungen** im Programmablauf zu treffen.\n",
      "\n",
      "---\n",
      "### 🔸 `if` / `else if` / `else`\n",
      "- Führt Code aus, wenn eine **Bedingung erfüllt** ist\n",
      "- `else if` für weitere Alternativen, `else` für den Standardfall\n",
      "```cpp\nif (x > 0) {\n  std::cout << \"Positiv\";\n} else if (x == 0) {\n  std::cout << \"Null\";\n} else {\n  std::cout << \"Negativ\";\n}\n```\n",
      "\n",
      "---\n",
      "### 🔸 Vergleichsoperatoren\n",
      "- `==`, `!=`, `<`, `>`, `<=`, `>=`\n",
      "- Kombinieren mit `&&`, `||`, `!` für UND/ODER/NICHT\n",
      "\n",
      "---\n",
      "### 🔸 `switch`-Anweisung\n",
      "- Prüft **einen konkreten Wert** (ganzzahlig oder `enum`)\n",
      "- Jeder `case` ist ein möglicher Wert; `default` ist der Standardfall\n",
      "- `break;` beendet den jeweiligen Fall - sonst wird weiter ausgeführt (**Fallthrough**!)\n",
      "```cpp\nswitch (auswahl) {\n  case 1: std::cout << \"Eins\"; break;\n  case 2: std::cout << \"Zwei\"; break;\n  default: std::cout << \"Unbekannt\";\n}\n```\n",
      "\n",
      "---\n",
      "### 💡 Tipp\n",
      "Bei mehreren Optionen, die das gleiche tun, kann man **Fallthrough** bewusst einsetzen:\n",
      "```cpp\ncase 1:\ncase 2: std::cout << \"Eins oder Zwei\"; break;\n```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nint main() {\n  int x = -3;\n\n  // if / else if / else\n  if (x > 0) {\n    std::cout << \"x ist positiv\" << std::endl; // (nicht ausgeführt)\n  } else if (x == 0) {\n    std::cout << \"x ist Null\" << std::endl; // (nicht ausgeführt)\n  } else {\n    std::cout << \"x ist negativ\" << std::endl; // Ausgabe: x ist negativ\n  }\n\n  // Vergleich mit logischen Operatoren\n  int a = 10, b = 20;\n  if (a < b && b < 30) {\n    std::cout << \"a ist kleiner als b und b < 30\" << std::endl; // Ausgabe\n  }\n\n  // switch-Anweisung\n  int wahl = 2;\n  switch (wahl) {\n    case 1:\n      std::cout << \"Du hast Eins gewählt.\" << std::endl;\n      break;\n    case 2:\n      std::cout << \"Du hast Zwei gewählt.\" << std::endl; // Ausgabe\n      break;\n    case 3:\n      std::cout << \"Du hast Drei gewählt.\" << std::endl;\n      break;\n    default:\n      std::cout << \"Ungültige Auswahl.\" << std::endl;\n  }\n\n  // Fallthrough bewusst\n  int note = 1;\n  switch (note) {\n    case 1:\n    case 2:\n      std::cout << \"Sehr gut oder gut!\" << std::endl; // Ausgabe bei 1 oder 2\n      break;\n    case 3:\n      std::cout << \"Befriedigend\" << std::endl;\n      break;\n    default:\n      std::cout << \"Andere Note\" << std::endl;\n  }\n\n  return 0;\n}"
    ]
  }
},
      {
  "title": "Zeiger & this-Zeiger / Pointer",
  "content": {
    "text": [
      "### === Zeiger in C++ ===\n",
      "Ein Zeiger ist eine Variable, die die Adresse eines anderen Objekts speichert.\n",
      "\n",
      "---\n",
      "### Zeiger-Grundlagen:\n",
      "- `int* ptr;` → zeigt auf eine `int`-Variable\n",
      "- `*ptr` → greift auf den Wert zu\n",
      "- `&x` → gibt die Adresse von `x` zurück\n",
      "\n",
      "```cpp\nint x = 10;\nint* ptr = &x;\n*ptr = 20;  // x wird geändert\n```\n",
      "\n",
      "---\n",
      "### Dynamischer Speicher:\n",
      "- Mit `new` wird Speicher auf dem Heap reserviert\n",
      "- Mit `delete` muss er wieder freigegeben werden\n",
      "```cpp\nint* p = new int(5);\ndelete p;\n```\n",
      "\n",
      "---\n",
      "### Zeiger auf Objekte:\n",
      "- Klassenobjekte können ebenfalls per Zeiger angesprochen werden\n",
      "- Zugriff über `->`\n",
      "```cpp\nPerson* p = new Person(\"Kilian\");\np->anzeigen();\ndelete p;\n```\n",
      "\n",
      "---\n",
      "### === `this`-Zeiger ===\n",
      "- Jede Memberfunktion hat automatisch Zugriff auf `this`\n",
      "- `this` ist ein Zeiger auf das **aktuelle Objekt**\n",
      "- Wird z.B. für Vergleich, Rückgabe oder Methodenkette genutzt\n",
      "\n",
      "```cpp\nclass Test {\n    int wert;\npublic:\n    Test(int w) : wert(w) {}\n\n    Test& setWert(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n```\n",
      "\n",
      "👉 So kann man z.B. Methoden verkettet aufrufen: `obj.setWert(5).setWert(10);`\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\nprivate:\n    int wert;\n\npublic:\n    Zahl(int w) : wert(w) {}\n\n    void verdoppeln() {\n        wert *= 2;\n        std::cout << \"[this: \" << this << \"] Wert: \" << wert << std::endl;\n    }\n\n    Zahl& setze(int w) {\n        this->wert = w;\n        return *this;\n    }\n};\n\nint main() {\n    int x = 5;\n    int* ptr = &x;\n    std::cout << \"Zeiger: \" << *ptr << std::endl;  // 5\n\n    *ptr = 10;\n    std::cout << \"x: \" << x << std::endl;           // 10\n\n    Zahl z(7);\n    z.verdoppeln();          // 14\n    z.setze(3).verdoppeln(); // 6\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Smart Pointer",
  "content": {
    "text": [
      "### === Smart Pointer in C++ ===\n",
      "Smart Pointer verwalten dynamischen Speicher **automatisch** und verhindern typische Fehler wie **Speicherlecks**, **doppelte `delete`s** oder **Zugriffe auf ungültige Speicherbereiche**.\n",
      "Sie gehören zum Header `<memory>` und sind seit **C++11** verfügbar.\n",
      "\n",
      "---\n",
      "### Warum Smart Pointer?\n",
      "- Kein manuelles `delete` nötig\n",
      "- Klare Besitzverhältnisse\n",
      "- Automatische Speicherfreigabe beim Verlassen des Scopes\n",
      "\n",
      "---\n",
      "### 🔹 `std::unique_ptr<T>`\n",
      "- **Exklusiver Besitz**: Nur ein Zeiger kann auf das Objekt zeigen\n",
      "- **Nicht kopierbar**, aber **verschiebbar** (`std::move`)\n",
      "- Objekt wird beim Verlassen des Scopes automatisch gelöscht\n",
      "```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(10);\nptr.reset(); // manuelles Löschen möglich\n```\n",
      "\n",
      "---\n",
      "### 🔹 `std::shared_ptr<T>`\n",
      "- **Mehrere Besitzer** teilen sich das Objekt\n",
      "- Automatische Löschung, wenn **alle Kopien** verschwinden\n",
      "- Intern wird ein **Referenzzähler** verwaltet (`use_count()`)\n",
      "```cpp\nstd::shared_ptr<int> a = std::make_shared<int>(5);\nstd::shared_ptr<int> b = a; // b zeigt ebenfalls auf das Objekt\nstd::cout << a.use_count(); // 2\nb.reset(); // b gibt das Objekt frei\nstd::cout << a.use_count(); // 1\n```\n",
      "- `reset()` löscht den eigenen Bezug, nicht das Objekt, solange noch andere `shared_ptr` existieren\n",
      "\n",
      "---\n",
      "### 🔹 `std::weak_ptr<T>`\n",
      "- Beobachtet ein Objekt von `shared_ptr`, **ohne den Zähler zu erhöhen**\n",
      "- Kann ungültig werden → **immer mit `.lock()` prüfen**\n",
      "```cpp\nstd::weak_ptr<int> w = a;\nif (auto sp = w.lock()) { std::cout << *sp; }\n```\n",
      "\n",
      "---\n",
      "### 🔍 Vergleichstabelle:\n",
      "| Typ           | Besitz       | Kopierbar? | Besonderheit                     |\n",
      "| `unique_ptr`  | exklusiv     | ❌ nein     | nur mit `std::move` übertragbar  |\n",
      "| `shared_ptr`  | gemeinsam    | ✅ ja       | Zähler zählt aktive Referenzen   |\n",
      "| `weak_ptr`    | kein Besitz  | ✅ ja       | Beobachtet ohne mitzuzählen      |\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Beispiel {\npublic:\n    Beispiel() { std::cout << \"Konstruktor\\n\"; }\n    ~Beispiel() { std::cout << \"Destruktor\\n\"; }\n    void anzeigen() { std::cout << \"Hallo Welt\\n\"; }\n};\n\nint main() {\n    // unique_ptr\n    std::unique_ptr<Beispiel> up = std::make_unique<Beispiel>();\n    up->anzeigen(); // Hallo Welt\n    up.reset();     // Speicher freigeben\n\n    // shared_ptr\n    std::shared_ptr<Beispiel> sp1 = std::make_shared<Beispiel>();\n    std::shared_ptr<Beispiel> sp2 = sp1; // Referenzzähler = 2\n    std::cout << \"shared_ptr Zähler: \" << sp1.use_count() << std::endl; // 2\n\n    sp2.reset(); // sp2 gibt das Objekt frei\n    std::cout << \"nach reset Zähler: \" << sp1.use_count() << std::endl; // 1\n\n    // weak_ptr\n    std::weak_ptr<Beispiel> wp = sp1;\n    if (auto temp = wp.lock()) {\n        temp->anzeigen(); // Hallo Welt\n    }\n\n    sp1.reset(); // Letzter shared_ptr gibt frei → Destruktor wird aufgerufen\n\n    return 0;\n}"
    ]
  }
},
   {
   "title": "Namespaces",
   "content": {
   "text": [
      "### === Namespaces in C++ ===\n",
      "`namespace` dient zur Gruppierung von Funktionen, Klassen und Variablen unter einem gemeinsamen Namen, um Namenskonflikte zu vermeiden.\n",
      "\n",
      "---\n",
      "### Warum Namespaces?\n",
      "- Zwei Funktionen mit gleichem Namen können in unterschiedlichen Namespaces existieren\n",
      "- Große Projekte (oder Bibliotheken wie `std`) nutzen Namespaces zur Trennung von Modulen\n",
      "\n",
      "---\n",
      "### Verwendung von Namespaces\n",
      "- Definition:\n",
      "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n```\n",
      "- Aufruf:\n",
      "```cpp\nint ergebnis = Mathe::addiere(3, 4);\n```\n",
      "\n",
      "---\n",
      "### `using namespace` (nicht immer empfohlen)\n",
      "- Mit `using namespace std;` kann man `std::cout` einfach als `cout` schreiben\n",
      "- Nachteil: Alle Namen des Namespace werden global sichtbar → Konfliktgefahr\n",
      "- Besser: Nur gezielt importieren\n",
      "```cpp\nusing std::cout;\nusing std::endl;\n```\n",
      "\n",
      "---\n",
      "### Anonyme Namespaces (Datei-spezifisch)\n",
      "- Alles in einem anonymen Namespace ist **nur in der aktuellen Datei sichtbar**\n",
      "```cpp\nnamespace {\n    int geheim() { return 42; }\n}\n```\n",
      "\n",
      "---\n",
      "### Verschachtelte Namespaces (modernes C++)\n",
      "```cpp\nnamespace Projekt::Modul {\n    void machWas() {}\n}\n```\n",
      "\n",
      "👉 `std` ist das bekannteste Beispiel: `std::cout`, `std::string`, `std::vector`, ...\n",
      "👉 Namespaces verbessern Struktur, Lesbarkeit und Wartbarkeit von Code\n",
      "---\n"
    ],
    "code": [
            "#include <iostream>\n\n// Eigener Namespace\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\n// Verschachtelter Namespace\nnamespace Projekt::Modul {\n    void info() {\n        std::cout << \"Modul aktiv\" << std::endl;\n    }\n}\n\nint main() {\n    int summe = Mathe::addiere(3, 4);\n    std::cout << \"Summe: \" << summe << std::endl;          // Ausgabe: Summe: 7\n\n    Projekt::Modul::info();                                 // Ausgabe: Modul aktiv\n\n    // using-Anweisung (gezielt)\n    using std::cout;\n    using std::endl;\n    cout << \"Hallo aus main()\" << endl;                      // Ausgabe: Hallo aus main()\n\n    return 0;\n}"
          ]
        }
      },
      {
      "title": "Namespace vs. Class",
      "content": {
      "text": [
            "### === Unterschied: Namespace vs. Class ===\n",
            "`namespace` und `class` dienen beide zur Strukturierung, haben aber völlig unterschiedliche Funktionen:\n",
            "\n",
            "---\n",
            "| Merkmal              | `namespace`                            | `class` / `struct`                        |\n",
            "| Zweck                | Gruppierung von Code                   | Bauplan für Objekte (Daten + Methoden)    |\n",
            "| Objekte erzeugbar?   | ❌ Nein                                 | ✅ Ja                                      |\n",
            "| Zugriff              | `Mathe::addiere()`                     | `objekt.methode()` oder `Klasse::static()`|\n",
            "| Sichtbarkeit         | Alles `public`                         | Zugriffskontrolle mit `public/private`    |\n",
            "| Typ im Code?         | Kein eigener Typ                       | Eigener Datentyp                          |\n",
            "| Nutzung              | Organisation, Modularisierung          | Modellierung realer Dinge                 |\n",
            "\n",
            "---\n",
            "### Beispiel zur Verdeutlichung:\n",
            "```cpp\nnamespace Mathe {\n    int addiere(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Person {\npublic:\n    std::string name;\n    int alter;\n};\n\nint main() {\n    int summe = Mathe::addiere(2, 3);       // Namespace-Funktion\n    Person p = {\"Kilian\", 22};              // Objekt einer Klasse\n    return 0;\n}\n```\n",
            "\n",
            "### 👉 Merksatz",
            "`namespace` ist **eine Ordnungsbox**, `class` ist **der Inhalt mit Logik und Zustand**.\n",
            "---\n"
          ],
          "code": []
        }
      },
{
  "title": "Const",
  "content": {
    "text": [
      "### === `const` in C++ ===\n",
      "`const` schützt vor ungewollten Änderungen und je nach Position bedeutet es etwas anderes:\n",
      "\n",
      "---\n",
      "### 🔹 `const` bei Variablen:\n",
      "- Der Wert darf **nicht verändert** werden\n",
      "```cpp\nconst int x = 5;\n// x = 10; // ❌ Fehler\n```\n",
      "\n",
      "---\n",
      "### 🔹 `const` bei Funktionsparametern:\n",
      "- Verhindert Änderungen am Übergabewert\n",
      "```cpp\nvoid zeige(const std::string& text);\n```\n",
      "- spart **Kopieraufwand** + schützt Daten\n",
      "\n",
      "---\n",
      "### 🔹 `const`-Methoden:\n",
      "- Garantie, dass innerhalb der Methode **nichts verändert wird**\n",
      "```cpp\nclass Person {\n    std::string name;\npublic:\n    std::string getName() const; // ❌ darf name nicht ändern\n};\n```\n",
      "\n",
      "---\n",
      "### 🔹 `const` bei Zeigern:\n",
      "| Schreibweise           | Bedeutung                               |\n",
      "| `const int* p`        | Zeiger auf **konstante Daten**           |\n",
      "| `int* const p`        | **Konstanter Zeiger** auf Daten          |\n",
      "| `const int* const p`  | **Beides konstant**                      |\n",
      "\n",
      "```cpp\nconst int* p = &x;   // *p darf nicht geändert werden\nint* const q = &x;   // q darf nicht woanders hinzeigen\n```\n",
      "\n",
      "---\n",
      "### 🔹 `const` bei Rückgabewerten:\n",
      "- Schutz vor Modifikation des Rückgabewerts\n",
      "```cpp\nconst std::string& getName() const;  // Rückgabe nicht modifizierbar\n```\n",
      "\n",
      "---\n",
      "### Merksatz:\n",
      "- Lies `const` **von rechts nach links**:\n",
      "    - `int* const` = konstanter Zeiger auf int\n",
      "    - `const int*` = Zeiger auf konstantes int\n",
      "\n",
      "👉 `const` hilft, **Bugs zu vermeiden**, **Lesbarkeit zu erhöhen** und ist **Best Practice** in modernem C++\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n    std::string name;\n\npublic:\n    Person(const std::string& n) : name(n) {}\n\n    // const-Methode: darf nichts verändern\n    std::string getName() const {\n        return name;\n    }\n\n    // const-Rückgabe + const-Parameter\n    void begruessung(const std::string& begrussung) const {\n        std::cout << begrussung << \", \" << name << \"!\" << std::endl;\n    }\n};\n\nint main() {\n    const int x = 5;\n    // x = 10; // ❌ nicht erlaubt\n\n    const int* ptr1 = &x;    // Zeiger auf konstanten Wert\n    // *ptr1 = 20; // ❌ nicht erlaubt\n\n    int y = 8;\n    int* const ptr2 = &y;    // Konstanter Zeiger\n    *ptr2 = 12;              // ✅ erlaubt\n\n    Person p(\"Kilian\");\n    p.begruessung(\"Hallo\");\n    std::cout << \"Name: \" << p.getName() << std::endl;\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Const Overloading",
  "content": {
    "text": [
      "### === `const` Overloading ===\n",
      "In C++ kann man Funktionen **überladen**, indem man einmal eine `const`- und einmal eine **nicht-`const`-Version** erstellt.\n",
      "\n",
      "---\n",
      "### Warum?\n",
      "- `const`-Objekte dürfen nur `const`-Funktionen aufrufen.\n",
      "- So kann dieselbe Funktion **unterschiedliches Verhalten** haben - je nach `const`-Zustand des Objekts.\n",
      "\n",
      "---\n",
      "### `const` am Ende einer Methode:\n",
      "- Bedeutet: Diese Funktion **verändert keine Membervariablen** (außer `mutable`)\n",
      "- Wichtig für **Zugriffsmethoden (Getter)** oder bei Funktionen, die nur lesen\n",
      "\n",
      "👉 `const` ist Teil der Funktionssignatur und wird bei der Überladung beachtet.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Person {\nprivate:\n  std::string name;\n\npublic:\n  Person(std::string n) : name(n) {}\n\n  // Nicht-const-Version\n  std::string& getName() {\n    std::cout << \"Nicht-const Version\" << std::endl;\n    return name;\n  }\n\n  // Const-Version (für const Objekte)\n  const std::string& getName() const {\n    std::cout << \"Const-Version\" << std::endl;\n    return name;\n  }\n};\n\nint main() {\n  Person p1(\"Kilian\");\n  const Person p2(\"Lisa\");\n\n  std::cout << p1.getName() << std::endl;  // Ausgabe: Nicht-const Version\\nKilian\n  std::cout << p2.getName() << std::endl;  // Ausgabe: Const-Version\\nLisa\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Mutable",
  "content": {
    "text": [
      "### === `mutable` in C++ ===\n",
      "`mutable` erlaubt es, einen Member einer Klasse **trotz `const`-Funktion zu verändern**.\n",
      "\n",
      "---\n",
      "### Wann braucht man das?\n",
      "- Normalerweise dürfen `const`-Funktionen **keine Membervariablen verändern**.\n",
      "- Mit `mutable` kann man **gezielt Ausnahmen** machen, z.B. für Logging, Caching oder Zugriffszähler.\n",
      "\n",
      "---\n",
      "### Auch ohne `const` nützlich:\n",
      "- `mutable`-Member sind **immer unabhängig von `const`**, also z.B. nicht betroffen von `const`-Zustand anderer Objekte.\n",
      "- Sie können **immer verändert werden**, auch außerhalb von `const`-Kontexten - z.B. als interne Zähler oder Zustände.\n",
      "\n",
      "---\n",
      "### Wichtig:\n",
      "- `mutable` funktioniert **nur bei Membervariablen**.\n",
      "- Hat **nichts** mit `const` Variablen zu tun - es ist ein **Zugriffs-Modifier** für Klassenmitglieder.\n",
      "\n",
      "👉 Vorsicht beim Einsatz: `mutable` kann das `const`-Versprechen brechen!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Datei {\nprivate:\n  std::string inhalt;\n  mutable int leseZähler = 0;  // darf auch in const-Funktion verändert werden\n\npublic:\n  Datei(std::string i) : inhalt(i) {}\n\n  std::string lesen() const {\n    leseZähler++;  // erlaubt, da mutable\n    return inhalt;\n  }\n\n  int getLeseZähler() const {\n    return leseZähler;\n  }\n};\n\nint main() {\n  const Datei d(\"Hallo Welt\");\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << d.lesen() << std::endl;  // Ausgabe: Hallo Welt\n  std::cout << \"Anzahl Lesezugriffe: \" << d.getLeseZähler() << std::endl;  // Ausgabe: 2\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Static",
  "content": {
    "text": [
      "### === `static` in C++ ===\n",
      "`static` hat in C++ mehrere Bedeutungen - je nachdem, **wo** es verwendet wird:\n",
      "\n",
      "---\n",
      "### 🔹 `static` innerhalb einer Funktion:\n",
      "- Variable wird **nur einmal erstellt** (beim ersten Aufruf)\n",
      "- Bleibt zwischen Aufrufen **erhalten**\n",
      "```cpp\nvoid zähler() {\n    static int x = 0;\n    x++;\n    std::cout << x << std::endl;\n}\n```\n",
      "\n",
      "---\n",
      "### 🔹 `static` in Klassen (statisch für alle Objekte):\n",
      "- Variable gehört **zur Klasse, nicht zum Objekt**\n",
      "- Wird **außerhalb der Klasse** definiert\n",
      "- Gleicher Wert für **alle Instanzen**\n",
      "```cpp\nclass Test {\npublic:\n    static int anzahl;\n};\n\nint Test::anzahl = 0;\n```\n",
      "\n",
      "---\n",
      "### 🔹 `static` bei Klassenfunktionen:\n",
      "- Funktion gehört **nicht zu einem Objekt**, sondern zur **Klasse selbst**\n",
      "- Kein Zugriff auf `this` oder andere Nicht-static-Member\n",
      "- Wird über `Klassenname::Funktion()` aufgerufen\n",
      "```cpp\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\nint y = Utils::verdoppeln(5);  // 10\n```\n",
      "\n",
      "---\n",
      "### 🔹 `static` bei Funktionen (außerhalb von Klassen):\n",
      "- Funktion ist **nur innerhalb derselben Datei sichtbar** (file-scope)\n",
      "- Nützlich zur Kapselung beim Modularisieren\n",
      "```cpp\nstatic int intern() {\n    return 123;\n}\n```\n",
      "\n",
      "👉 `static` hilft, **Lebensdauer zu steuern**, **Speicher zu sparen** und **Sichtbarkeit einzuschränken**.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Test {\npublic:\n    static int zähler;\n    void erhöhen() {\n        zähler++;\n    }\n};\n\nint Test::zähler = 0;\n\nvoid funktionMitStatic() {\n    static int x = 0;\n    x++;\n    std::cout << \"static in Funktion: \" << x << std::endl; // 1, dann 2\n}\n\n// statische Klassenfunktion\nclass Utils {\npublic:\n    static int verdoppeln(int x) {\n        return x * 2;\n    }\n};\n\n// statische Funktion außerhalb einer Klasse\nstatic void dateiLokal() {\n    std::cout << \"Nur in dieser Datei sichtbar.\" << std::endl;\n}\n\nint main() {\n    Test a, b;\n    a.erhöhen();\n    b.erhöhen();\n    std::cout << \"static in Klasse: \" << Test::zähler << std::endl; // Ausgabe: 2\n\n    funktionMitStatic(); // Ausgabe: 1\n    funktionMitStatic(); // Ausgabe: 2\n\n    std::cout << \"Utils::verdoppeln: \" << Utils::verdoppeln(7) << std::endl; // Ausgabe: 14\n\n    dateiLokal(); // Ausgabe: Nur in dieser Datei sichtbar.\n\n    return 0;\n}"
    ]
  }
}
    ]
  },







  {
    "category": "Speicherverwaltung",
    "subtopics": [
      {
  "title": "Heap (new / new[])",
  "content": {
    "text": [
      "### === Heap-Speicher in C++ (new / delete) ===\n",
      "Mit `new` kann man in C++ **manuell Speicher auf dem Heap** anfordern. Dieser bleibt bestehen, **bis er explizit mit `delete` freigegeben wird**.\n",
      "\n",
      "---\n",
      "### 🔹 Warum Heap?\n",
      "- Stack ist nur für **kurzlebige, kleine** Daten\n",
      "- Heap erlaubt **dynamische Größe** und **längere Lebenszeit**\n",
      "- Wird manuell mit `new` / `delete` oder automatisch mit Smart Pointern verwaltet\n",
      "\n",
      "---\n",
      "### 🔸 `new` für EIN Objekt:\n",
      "```cpp\nint* zahl = new int(42);\n*zahl = 100;\ndelete zahl; // wichtig!\n```\n",
      "- Speicher für genau **ein Objekt** wird angefordert\n",
      "- **`delete`** muss aufgerufen werden, um den Speicher freizugeben\n",
      "\n",
      "---\n",
      "### 🔸 `new[]` für MEHRERE Objekte (Array):\n",
      "```cpp\nint* arr = new int[5];\narr[0] = 1; arr[1] = 2;\ndelete[] arr; // wichtig!\n```\n",
      "- Reserviert **zusammenhängenden Speicherplatz** für mehrere Objekte\n",
      "- Muss mit **`delete[]`** freigegeben werden!\n",
      "\n",
      "---\n",
      "### ❗ Vorsicht bei falscher Kombination:\n",
      "- `new[]` → `delete[]`\n",
      "- `new` → `delete`\n",
      "- Niemals `delete[]` auf `new` oder umgekehrt!\n",
      "\n",
      "---\n",
      "### 🔹 Klassen & Konstruktoren:\n",
      "```cpp\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gelöscht\\n\"; }\n};\n\nPunkt* p1 = new Punkt;      // 1x Konstruktor\nPunkt* p2 = new Punkt[3];   // 3x Konstruktor\n\ndelete p1;      // 1x Destruktor\ndelete[] p2;    // 3x Destruktor\n```\n",
      "\n",
      "---\n",
      "### 🔹 Wann `new[]` statt `new`?\n",
      "- Wenn du mehrere gleichartige Objekte brauchst → `new[]`\n",
      "- Wenn du nur ein einzelnes Objekt brauchst → `new`\n",
      "\n",
      "---\n",
      "### ❗ Besser: `std::vector`, `std::unique_ptr<T[]>`, `std::make_shared<T[]>`\n",
      "👉 Manuelles `new[]` sollte **nur ausnahmsweise** genutzt werden\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Punkt {\npublic:\n    Punkt() { std::cout << \"Punkt erstellt\\n\"; }\n    ~Punkt() { std::cout << \"Punkt gelöscht\\n\"; }\n};\n\nint main() {\n    // new für EIN Objekt\n    int* zahl = new int(42);\n    std::cout << \"Einzelwert: \" << *zahl << std::endl; // 42\n    delete zahl; // Speicher freigeben\n\n    // new[] für MEHRERE Objekte\n    int* array = new int[3];\n    array[0] = 10;\n    array[1] = 20;\n    array[2] = 30;\n    std::cout << \"Array[1]: \" << array[1] << std::endl; // 20\n    delete[] array; // korrekt löschen\n\n    // new / delete mit Klassen\n    Punkt* p1 = new Punkt();    // Punkt erstellt\n    Punkt* pArr = new Punkt[2]; // 2x Punkt erstellt\n\n    delete p1;      // Punkt gelöscht\n    delete[] pArr;  // 2x Punkt gelöscht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Heap vs. Stack",
  "content": {
    "text": [
      "### === Speicherverwaltung in C++: Stack vs. Heap ===\n",
      "In C++ unterscheidet man bei der Speichervergabe zwischen **Stack** und **Heap**:\n",
      "\n",
      "---\n",
      "### 🔹 Stack-Speicher (automatisch)\n",
      "- Wird für **lokale Variablen** verwendet\n",
      "- Speicher wird **automatisch** freigegeben, wenn der Block verlassen wird\n",
      "- Sehr schnell & sicher, aber begrenzt (Stack Overflow bei großen Arrays)\n",
      "\n",
      "```cpp\nvoid funktion() {\n    int a = 10;        // auf dem Stack\n} // a wird automatisch gelöscht\n```\n",
      "\n",
      "---\n",
      "### 🔹 Heap-Speicher (dynamisch)\n",
      "- Wird bei Bedarf mit `new` reserviert und mit `delete` freigegeben\n",
      "- Muss **manuell** verwaltet werden → Gefahr von Speicherlecks\n",
      "- Größer, aber langsamer als der Stack\n",
      "\n",
      "```cpp\nint* ptr = new int(5);  // Speicher im Heap\n*ptr = 42;\ndelete ptr;             // Speicher freigeben\n```\n",
      "\n",
      "---\n",
      "### 🔹 Vergleich:\n",
      "| Merkmal     | Stack                     | Heap                          |\n",
      "| Geschwindigkeit | Sehr schnell              | Langsamer                    |\n",
      "| Lebensdauer | Block-lokal (automatisch) | Manuell, bis `delete`        |\n",
      "| Speichergröße | Begrenzter Speicher       | Größerer Speicher verfügbar  |\n",
      "| Fehlerquellen | Stack Overflow möglich    | Speicherlecks, Dangling Ptr  |\n",
      "\n",
      "---\n",
      "### 🔸 Modern C++ Tipp:\n",
      "- Statt `new` / `delete` → besser `std::unique_ptr`, `std::shared_ptr`\n",
      "- Smart Pointer übernehmen Speicherverwaltung automatisch\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory> // für Smart Pointer\n\nvoid stackBeispiel() {\n    int zahl = 10;                    // Stack-Speicher\n    std::cout << \"Stack: \" << zahl << std::endl;\n} // zahl wird automatisch gelöscht\n\nvoid heapBeispiel() {\n    int* ptr = new int(42);           // Heap-Speicher\n    std::cout << \"Heap: \" << *ptr << std::endl;\n    delete ptr;                       // manuell löschen\n}\n\nvoid smartPointerBeispiel() {\n    std::unique_ptr<int> sp = std::make_unique<int>(100);\n    std::cout << \"SmartPointer: \" << *sp << std::endl;\n} // wird automatisch gelöscht\n\nint main() {\n    stackBeispiel();\n    heapBeispiel();\n    smartPointerBeispiel();\n    return 0;\n}"
    ]
  }
}

    ]
  },



  {
    "category": "Container",
    "subtopics": [
      {
        "title": "Strings",
        "content": {
          "text": [
            "### === String-Funktionen in C++ ===\n",
            "",
            "```cpp",
            "std::string example = \"Hello, World\";\n",
            "std::string number = \"42\";",
            "```\n",
            "---\n",
            "",
            "-> `.size()` - Gibt die Länge des Strings zurück\n",
            "```cpp",
            "example.size(); // 12",
            "```\n",
            "---\n",
            "",
            "-> `.substr(start, length)` - Teilstring ab Startindex\n",
            "```cpp",
            "example.substr(3, 5); // \"lo, W\"",
            "```\n",
            "---\n",
            "",
            "-> `.replace(start, count, string)` - Ersetzt einen Teil des Strings\n",
            "```cpp",
            "example.replace(7, 5, \"Universe\"); // Hello, Universe",
            "```\n",
            "---\n",
            "",
            "-> `.empty()` - Prüft ob der String leer ist\n",
            "-> `example[1]` - Zugriff auf Zeichen an Position\n",
            "-> `.find(\"text\")` - Sucht ein Teilwort im String\n",
            "",
            "---\n",
            "### === String <-> Zahl ===\n",
            "",
            "```cpp",
            "int i = std::stoi(\"42\");     // → 42\n",
            "double d = std::stod(\"3.14\"); // → 3.14\n",
            "std::string s = std::to_string(100); // → \"100\"",
            "```\n",
            "",
            "---\n",
            "### === String-Konkatenation & Vergleich ===\n",
            "",
            "```cpp",
            "std::string s1 = \"Hello\";\n",
            "std::string s2 = \"World\";\n",
            "std::string s3 = s1 + \" \" + s2; // \"Hello World\"\n",
            "s1.compare(s2); // < 0 → s1 < s2",
            "```\n",
            "",
            "---\n",
            "### === Groß- und Kleinschreibung ===\n",
            "",
            "-> `#include <cctype>`, `#include <algorithm>` für toupper/tolower\n",
            "",
            "```cpp",
            "std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n",
            "std::transform(str.begin(), str.end(), str.begin(), ::tolower);",
            "```\n",
            "",
            "#### -> Einzelzeichen:\n",
            "```cpp",
            "std::toupper('a'); // → 'A'\n",
            "std::islower('B'); // → false\n",
            "std::isalpha('x'); // → true\n",
            "std::isdigit('9'); // → true",
            "```\n",
            "",
            "---\n",
            "### === istringstream: String analysieren ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::string zeile = \"3 Apfel 1.99\";\n",
            "std::istringstream iss(zeile);\n",
            "int menge; std::string produkt; double preis;\n",
            "iss >> menge >> produkt >> preis;\n",
            "// menge = 3, produkt = Apfel, preis = 1.99",
            "```\n",
            "",
            "---\n",
            "### === ostringstream: String zusammensetzen ===\n",
            "",
            "```cpp",
            "#include <sstream>\n",
            "std::ostringstream oss;\n",
            "oss << menge << \" \" << produkt << \" kosten \" << (menge * preis);\n",
            "std::string ausgabe = oss.str();",
            "```",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n\nint main() {\n  std::string text = \"C++ macht Spaß!\";\n\n  // Länge\n  std::cout << \"Länge: \" << text.length() << std::endl; // Ausgabe: 15\n\n  // Teilstring\n  std::string teil = text.substr(4, 5);\n  std::cout << \"Teilstring: \" << teil << std::endl; // Ausgabe: macht\n\n  // finden\n  size_t pos = text.find(\"Spaß\");\n  if (pos != std::string::npos)\n    std::cout << \"\\\"Spaß\\\" gefunden an Position: \" << pos << std::endl; // Ausgabe: 11\n\n  // ersetzen\n  text.replace(4, 5, \"ist cool\");\n  std::cout << \"Nach replace: \" << text << std::endl; // Ausgabe: C++ ist cool Spaß!\n\n  // anhängen\n  text += \" :)\";\n  std::cout << \"Nach Anfügen: \" << text << std::endl; // Ausgabe: C++ ist cool Spaß! :)\n\n  // einfügen\n  text.insert(0, \"[INFO] \");\n  std::cout << \"Mit Prefix: \" << text << std::endl; // Ausgabe: [INFO] C++ ist cool Spaß! :)\n\n  // löschen\n  text.erase(0, 7);\n  std::cout << \"Ohne Prefix: \" << text << std::endl; // Ausgabe: C++ ist cool Spaß! :)\n\n  // vergleichen\n  std::string a = \"Apfel\", b = \"Banane\";\n  if (a.compare(b) < 0)\n    std::cout << a << \" kommt vor \" << b << std::endl; // Ausgabe: Apfel kommt vor Banane\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Vektor",
        "content": {
          "text": [
            "### === Vector-Funktionen in C++ ===\n",
            "-> `std::vector<int> zahlen = {5, 3, 8, 1};` // Initialisierung eines Vektors\n",
            "-> `zahlen.push_back(element);` // Fügt ein Element hinten an (kopiert oder verschiebt es)\n",
            "-> `zahlen.emplace_back(argumente);` // Baut das Element direkt im Vektor (konstruiert es vor Ort)\n",
            "---\n",
            "### Unterschied `push_back` und `emplace_back`",
            "`push_back` erwartet ein fertiges Objekt,\n",
            "`emplace_back` übernimmt die Konstruktion direkt im Speicher des Vektors.\n",
            "Besonders nützlich bei komplexen Typen wie `std::pair` oder eigenen Klassen.\n",
            "```cpp",
            "Beispiel: v.emplace_back(\"Text\", 42); statt: v.push_back(std::make_pair(\"Text\", 42));",
            "```\n",
            "---\n",
            "-> `zahlen.size();` // Gibt die Anzahl der Elemente im Vektor zurück\n",
            "-> `zahlen[2];` // Greift direkt auf das Element mit Index 2 zu (kein Bounds-Check)\n",
            "-> `zahlen.at(1);` // Greift sicher auf Index 1 zu (mit Bounds-Check)\n",
            "-> `zahlen.front();` // Gibt das erste Element im Vektor zurück\n",
            "-> `zahlen.back();` // Gibt das letzte Element im Vektor zurück\n",
            "-> `zahlen.empty();` // Prüft, ob der Vektor leer ist (true/false)\n",
            "-> `std::find(zahlen.begin(), zahlen.end(), 3);` // Sucht nach Wert 3 im Vektor\n",
            "-> `zahlen.insert(zahlen.begin() + 1, 42);` // Fügt 42 an Position 1 ein\n",
            "-> `std::sort(zahlen.begin(), zahlen.end());` // Sortiert den Vektor aufsteigend\n",
            "-> `std::reverse(zahlen.begin(), zahlen.end());` // Dreht die Reihenfolge um\n",
            "\n",
            "---\n",
            "-> `zahlen.erase(zahlen.begin());` // Löscht das erste Element\n",
            "-> `zahlen.erase(zahlen.begin(), zahlen.begin() + 2);` // Löscht die ersten zwei Elemente\n",
            "-> `zahlen.erase(zahlen.begin() + 2);` // Löscht das Element an Index 2\n",
            "-> `zahlen.clear();` // Löscht alle Elemente aus dem Vektor\n",
            "-> `zahlen.pop_back();` // Entfernt das letzte Element im Vektor\n",
            "\n",
            "---\n",
            "-> `zahlen.assign(5, 7);` // Setzt den Vektor auf 5 Elemente mit dem Wert 7\n",
            "-> `std::remove(zahlen.begin(), zahlen.end(), 5);` // Entfernt alle Vorkommen von 5 (nutzt erase danach!)\n",
            "-> `std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x; });` // Wendet eine Funktion auf alle Elemente an\n",
            "\n",
            "---\n",
            "### === 2D Vektor in C++ ===\n",
            "-> `std::vector<std::vector<int>> v3 = {{1}, {2, 3}, {4, 5, 6}};` // 2D vector\n",
            "Erstellt 2D-Vektor (Vektoren von Vektoren)\n",
            "`v3` hat drei Zeilen: `v3[0] = {1}; v3[1] = {2, 3}; v3[2] = {4, 5, 6}`\n",
            "`v3[2][2]` gibt `6` zurück (Zeile 3, Spalte 3)\n",
            "---\n",
            "### === Unterschied: std::vector vs. std::tuple ===\n",
            "-> `std::vector<T>` speichert **beliebig viele Werte vom gleichen Typ** (z.B. `int`). Die Größe ist dynamisch und zur Laufzeit veränderbar.\n",
            "-> `std::tuple<T1, T2, ...>` speichert **eine feste Anzahl unterschiedlich typisierter Werte**. Die Größe ist zur Compile-Zeit festgelegt.\n",
            "\n",
            "---\n",
            "### Beispiel:\n",
            "- `std::vector<int> v = {1, 2, 3};` → Liste von Zahlen\n",
            "- `std::tuple<int, std::string> t = {42, \"Text\"};` → Kombination aus Zahl & Text\n",
            "\n",
            "**Merksatz:** `vector = Liste gleicher Typen`, `tuple = Paket verschiedener Typen`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // für sort()\n\nint main() {\n  // Vektor mit Werten initialisieren\n  std::vector<int> zahlen = {4, 2, 7};\n\n  // Element hinzufügen\n  zahlen.push_back(5); // Vektor = {4, 2, 7, 5}\n\n  // Größe des Vektors\n  std::cout << \"Anzahl Elemente: \" << zahlen.size() << std::endl; // Ausgabe: 4\n\n  // Zugriff auf Elemente\n  std::cout << \"Erstes Element: \" << zahlen[0] << std::endl; // Ausgabe: 4\n  std::cout << \"Zweites Element: \" << zahlen.at(1) << std::endl; // Ausgabe: 2\n  std::cout << \"Letztes Element: \" << zahlen.back() << std::endl; // Ausgabe: 5\n\n  // Ausgabe mit Schleife\n  std::cout << \"Alle Elemente: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 4 2 7 5\n  std::cout << std::endl;\n\n  // Element entfernen (letztes)\n  zahlen.pop_back(); // entfernt 5\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end()); // Vektor = {2, 4, 7}\n\n  // Ausgabe nach Sortierung\n  std::cout << \"Sortiert: \";\n  for (size_t i = 0; i < zahlen.size(); ++i) {\n    std::cout << zahlen[i] << \" \";\n  } // Ausgabe: 2 4 7\n  std::cout << std::endl;\n\n  // leeren Vektor prüfen\n  if (!zahlen.empty()) {\n    std::cout << \"Vektor ist NICHT leer\" << std::endl;\n  }\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Sets",
        "content": {
          "text": [
            "### === Sets in C++ ===\n",
            "-> `#include <set>`       // Für std::set\n",
            "\n",
            "---\n",
            "### --- Grundlagen ---\n",
            "-> `std::set<char> s1 = {'H', 'E', 'L', 'L', 'O'};`\n",
            "   Ein Set speichert nur eindeutige Elemente - doppelte 'L' werden entfernt\n",
            "   Ergebnis: `{ 'E', 'H', 'L', 'O' }` (automatisch sortiert nach ASCII)\n",
            "-> `s1.size()` Gibt die Anzahl der eindeutigen Elemente zurück → 4\n",
            "-> `s1.contains('E')` Prüft, ob 'E' im Set enthalten ist → true (1)\n",
            "-> `s1.contains('X')` Prüft, ob 'X' im Set enthalten ist → false (0)\n",
            "\n",
            "---\n",
            "### --- Elemente hinzufügen/entfernen ---\n",
            "-> `s1.insert('!')` Fügt ein neues Element hinzu → `{ '!', 'E', 'H', 'L', 'O' }`\n",
            "-> `s1.erase('O')` Entfernt das Element 'O' aus dem Set\n",
            "-> `s1.clear()` Entfernt alle Elemente aus dem Set\n",
            "-> `s1.empty()` Prüft, ob das Set leer ist → true (1)\n",
            "\n",
            "---\n",
            "### --- Vergleich von Sets ---\n",
            "-> `std::set<int> a = {1, 2};`\n",
            "-> `std::set<int> b = {2, 1};`\n",
            "-> `a == b` → true (1), Reihenfolge ist egal, nur Inhalte zählen\n",
            "\n",
            "-> `std::set<int> c = {1, 2, 2};`\n",
            "-> `std::set<int> d = {1, 1, 2};`\n",
            "-> `c == d` → true (1), da doppelte Einträge ignoriert werden\n",
            "\n",
            "_Hinweis: `std::set` speichert die Elemente automatisch sortiert,_\n",
            "_Erlaubt keine Duplikate und bietet schnellen Zugriff._\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  // Set mit Ganzzahlen\n  std::set<int> zahlen;\n\n  // Elemente einfügen (werden automatisch sortiert)\n  zahlen.insert(5);\n  zahlen.insert(2);\n  zahlen.insert(8);\n  zahlen.insert(2); // Duplikat - wird ignoriert\n\n  // Ausgabe der Elemente\n  std::cout << \"Inhalt des Sets: \";\n  for (int x : zahlen) {\n    std::cout << x << \" \";\n  } // Ausgabe: 2 5 8\n  std::cout << std::endl;\n\n  // Prüfen, ob ein Element enthalten ist\n  if (zahlen.count(5) > 0) {\n    std::cout << \"5 ist enthalten\" << std::endl;\n  }\n\n  // Alternative mit find()\n  if (zahlen.find(3) == zahlen.end()) {\n    std::cout << \"3 ist NICHT enthalten\" << std::endl;\n  }\n\n  // Anzahl der Elemente\n  std::cout << \"Set-Größe: \" << zahlen.size() << std::endl; // Ausgabe: 3\n\n  // Element löschen\n  zahlen.erase(2);\n  std::cout << \"Nach Löschen von 2: \";\n  for (int x : zahlen) std::cout << x << \" \"; // Ausgabe: 5 8\n  std::cout << std::endl;\n\n  // Set leeren\n  zahlen.clear();\n  std::cout << \"Nach clear(): Größe = \" << zahlen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Maps",
        "content": {
          "text": [
            "### === Maps in C++ ===\n",
            "-> `#include <map>`       // Für std::map\n",
            "-> `#include <string>`    // Für std::string als Schlüssel/Wert\n",
            "\n",
            "---\n",
            "### --- Grundlagen ---\n",
            "-> `std::map<std::string, int> m1;` Leere Map von string → int\n",
            "-> `m1[\"C++\"] = 100;` Fügt Schlüssel \"C++\" mit Wert 100 ein\n",
            "-> `m1[\"Java\"] = 90; m1[\"Python\"] = 85;` Weitere Einträge\n",
            "   Map speichert Schlüssel-Wert-Paare, automatisch sortiert nach Schlüssel\n",
            "\n",
            "---\n",
            "### --- Zugriff & Erstellung ---\n",
            "-> `std::map<std::string, std::string> m2 = {{\"de\", \"Berlin\"}, {\"fr\", \"Paris\"}, {\"opf\", \"Regensburg\"}};`\n",
            "-> `m2.size()` → Anzahl der Paare in der Map → 3\n",
            "-> `m2[\"de\"]` → Zugriff auf den Wert zu \"de\" → \"Berlin\"\n",
            "-> `m2[\"en\"]` → Nicht vorhanden → erstellt Eintrag mit leerem String als Wert\n",
            "\n",
            "---\n",
            "### --- Sichere Abfrage mit at() ---\n",
            "-> `m1.at(\"C++\")` → Gibt den Wert zu \"C++\" zurück → 100\n",
            "`// m1.at(\"C\")` würde abstürzen (throw std::out_of_range), wenn Schlüssel nicht existiert!\n",
            "\n",
            "---\n",
            "### --- Existenz prüfen mit count() ---\n",
            "-> `m1.count(\"Java\")` → Gibt 1 zurück, wenn vorhanden\n",
            "-> `m1.count(\"Cobol\")` → Gibt 0 zurück, wenn nicht vorhanden\n",
            "\n",
            "---\n",
            "### --- Entfernen & Prüfen ---\n",
            "-> `m1.clear()` → Entfernt alle Schlüssel-Wert-Paare\n",
            "-> `m1.empty()` → Prüft, ob Map leer ist → true (1)\n",
            "\n",
            "---\n",
            "### --- Vergleich von Maps ---\n",
            "-> `std::map<int, char> mA = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mB = {{1, 'x'}, {2, 'z'}};`\n",
            "-> `mA == mB` → false, da Werte unterschiedlich\n",
            "\n",
            "-> `std::map<int, char> mC = {{1, 'x'}, {2, 'y'}};`\n",
            "-> `std::map<int, char> mD = {{2, 'y'}, {1, 'x'}};`\n",
            "-> `mC == mD` → true, Reihenfolge ist egal, Inhalte gleich\n",
            "\n",
            "-> `std::map<int, char> mE = {{2, 'y'}, {1, 'x'}, {1, 'x'}};`\n",
            "-> `mC == mE` → true, mehrfacher identischer Eintrag zählt nicht doppelt\n",
            "\n",
            "_Hinweis: `std::map` speichert die Schlüssel automatisch sortiert — bei `int` aufsteigend (1, 2, 3, ...), bei `string` alphabetisch (a, b, c, ...) und erlaubt keine Duplikate._\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  // Map von Namen zu Alter\n  std::map<std::string, int> personen;\n\n  // Einträge hinzufügen\n  personen[\"Anna\"] = 23;\n  personen[\"Bob\"] = 30;\n  personen.insert({\"Clara\", 27});\n\n  // Werte lesen\n  std::cout << \"Anna ist \" << personen[\"Anna\"] << \" Jahre alt.\" << std::endl; // Ausgabe: Anna ist 23 Jahre alt.\n\n  // Map durchgehen (automatisch sortiert nach Schlüssel)\n  std::cout << \"Alle Einträge:\\n\";\n  for (const auto& eintrag : personen) {\n    std::cout << eintrag.first << \": \" << eintrag.second << std::endl;\n  } // Ausgabe: Anna: 23 / Bob: 30 / Clara: 27 (alphabetisch)\n\n  // Existenz prüfen\n  if (personen.count(\"Bob\") > 0) {\n    std::cout << \"Bob ist vorhanden.\" << std::endl; // Ausgabe: Bob ist vorhanden.\n  }\n\n  // Mit find() prüfen und Zugriff\n  auto it = personen.find(\"Dora\");\n  if (it == personen.end()) {\n    std::cout << \"Dora ist NICHT vorhanden.\" << std::endl;\n  }\n\n  // Wert ändern\n  personen[\"Anna\"] = 24; // Anna hat jetzt Geburtstag\n\n  // Eintrag löschen\n  personen.erase(\"Bob\");\n\n  // Ausgabe nach Änderungen\n  std::cout << \"Nach Änderungen:\\n\";\n  for (const auto& p : personen) {\n    std::cout << p.first << \": \" << p.second << std::endl;\n  } // Ausgabe: Anna: 24 / Clara: 27\n\n  // Größe der Map\n  std::cout << \"Anzahl Personen: \" << personen.size() << std::endl; // Ausgabe: 2\n\n  // Map leeren\n  personen.clear();\n  std::cout << \"Nach clear(): \" << personen.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Stack/Queue",
        "content": {
          "text": [
            "### === Stack/Queue in C++ ===\n",
            "-> `#include <stack>`   // Für std::stack\n",
            "-> `#include <queue>`   // Für std::queue\n",
            "-> `#include <string>`  // Für std::string\n",
            "\n",
            "---\n",
            "### --- STACK (LIFO - Last In, First Out) ---\n",
            "-> `std::stack<std::string> s1;` Erstellt einen leeren Stack vom Typ std::string\n",
            "-> `s1.push(\"Hello\");` Fügt 'Hello' oben auf den Stack\n",
            "-> `s1.push(\"World\");` Fügt 'World' oben auf den Stack\n",
            "   Stack-Inhalt (von unten nach oben): [`Hello`, `World`]\n",
            "-> `s1.top();` Gibt das oberste Element zurück → \"World\"\n",
            "-> `s1.pop();` Entfernt das oberste Element (\"World\")\n",
            "-> `s1.size();` Gibt die Anzahl der Elemente im Stack zurück → 1\n",
            "-> `s1.empty();` Prüft, ob der Stack leer ist (true/false)\n",
            "\n",
            "---\n",
            "### --- QUEUE (FIFO - First In, First Out) ---\n",
            "-> `std::queue<std::string> q1;` Erstellt eine leere Queue für std::string\n",
            "-> `q1.push(\"Hello\");` Fügt 'Hello' hinten in die Queue ein\n",
            "-> `q1.push(\"World\");` Fügt 'World' hinten in die Queue ein\n",
            "   Reihenfolge: front → back = [`Hello`, `World`]\n",
            "-> `q1.front();` Gibt das erste (älteste) Element zurück → \"Hello\"\n",
            "-> `q1.back();` Gibt das letzte (neueste) Element zurück → \"World\"\n",
            "-> `q1.pop();` Entfernt das erste Element (\"Hello\")\n",
            "-> `q1.size();` Gibt die Anzahl der Elemente in der Queue zurück → 1\n",
            "-> `q1.empty();` Prüft, ob die Queue leer ist (true/false)\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n\nint main() {\n  // -------- STACK (LIFO) --------\n  std::stack<int> stapel;\n  stapel.push(10);\n  stapel.push(20);\n  stapel.push(30); // Stapel: 10, 20, 30 (oben)\n\n  std::cout << \"[STACK] Oberstes Element: \" << stapel.top() << std::endl; // Ausgabe: 30\n  stapel.pop();\n  std::cout << \"[STACK] Nach pop(): \" << stapel.top() << std::endl; // Ausgabe: 20\n\n  std::cout << \"[STACK] Größe: \" << stapel.size() << std::endl; // Ausgabe: 2\n  if (!stapel.empty()) {\n    std::cout << \"[STACK] Nicht leer.\" << std::endl;\n  }\n\n  // -------- QUEUE (FIFO) --------\n  std::queue<std::string> warteschlange;\n  warteschlange.push(\"Anna\");\n  warteschlange.push(\"Bob\");\n  warteschlange.push(\"Clara\"); // Reihenfolge: Anna, Bob, Clara\n\n  std::cout << \"[QUEUE] Vorne: \" << warteschlange.front() << std::endl; // Ausgabe: Anna\n  std::cout << \"[QUEUE] Hinten: \" << warteschlange.back() << std::endl; // Ausgabe: Clara\n\n  warteschlange.pop();\n  std::cout << \"[QUEUE] Nach pop(): Vorne ist jetzt \" << warteschlange.front() << std::endl; // Ausgabe: Bob\n\n  std::cout << \"[QUEUE] Größe: \" << warteschlange.size() << std::endl; // Ausgabe: 2\n  if (!warteschlange.empty()) {\n    std::cout << \"[QUEUE] Nicht leer.\" << std::endl;\n  }\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Pairs/Tuples",
        "content": {
          "text": [
            "### === Pairs & Tuples in C++ ===\n",
            "-> `#include <utility>`   // Für std::pair\n",
            "-> `#include <tuple>`     // Für std::tuple\n",
            "-> `#include <string>`    // Für std::string\n",
            "-> `#include <vector>`    // Für std::vector\n",
            "\n",
            "---\n",
            "### std::pair\n",
            "-> `std::pair<std::string, int> p1 = std::make_pair(\"Regensburg\", 199000);`\n",
            "-> `std::pair<std::string, int> p2 = std::make_pair(\"Weiden\", 43000);`\n",
            "-> `std::pair<std::string, int> p3 = std::make_pair(\"Amberg\", 42000);`\n",
            "####   Ein Pair enthält genau zwei Werte unterschiedlichen Typs\n",
            "-> `p1.first` → Gibt das erste Element zurück → \"Regensburg\"\n",
            "-> `p1.second` → Gibt das zweite Element zurück → 199000\n",
            "-> `std::vector<std::pair<std::string, int>> cities = {p1, p2, p3};` // Liste von Städten mit Einwohnern\n",
            "-> `cities[1].first` → Zugriff auf den Namen der zweiten Stadt → \"Weiden\"\n",
            "\n",
            "---\n",
            "### std::tuple\n",
            "-> `std::tuple<std::string, int, double> t1 = std::make_tuple(\"Lisa\", 123, 1.0);`\n",
            "-> `std::tuple<std::string, int, double> t2 = std::make_tuple(\"Bart\", 456, 3.7);`\n",
            "-> `std::tuple<std::string, int, double> t3 = std::make_tuple(\"Nelson\", 666, 5.0);`\n",
            "####   Ein Tuple kann beliebig viele Werte enthalten\n",
            "-> `std::get<0>(t1)` → Zugriff auf das erste Element → \"Lisa\"\n",
            "-> `std::get<1>(t2)` → Zugriff auf das zweite Element → 456\n",
            "-> `std::get<2>(t3)` → Zugriff auf das dritte Element → 5.0\n",
            "\n",
            "`std::tuple<T1, T2, T3>`: Bei Tuples muss der Index zur Compilezeit bekannt sein → `std::get<1>(...)`\n",
            "   Das bedeutet: `std::get<0>(...)` gibt das erste Element vom Typ `T1` zurück\n",
            "---\n",
            "### === Unterschied: std::vector vs. std::tuple ===\n",
            "-> `std::vector<T>` speichert **beliebig viele Werte vom gleichen Typ** (z.B. `int`). Die Größe ist dynamisch und zur Laufzeit veränderbar.\n",
            "-> `std::tuple<T1, T2, ...>` speichert **eine feste Anzahl unterschiedlich typisierter Werte**. Die Größe ist zur Compile-Zeit festgelegt.\n",
            "\n",
            "---\n",
            "**Beispiel:**\n",
            "- `std::vector<int> v = {1, 2, 3};` → Liste von Zahlen\n",
            "- `std::tuple<int, std::string> t = {42, \"Text\"};` → Kombination aus Zahl & Text\n",
            "\n",
            "**Merksatz:** `vector = Liste gleicher Typen`, `tuple = Paket verschiedener Typen`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <string>\n#include <utility>  // für pair, make_pair\n#include <tuple>    // für tuple, make_tuple, get, tie\n\nint main() {\n  // -------- PAIR --------\n  std::pair<std::string, int> person = {\"Anna\", 25};\n  std::cout << \"[PAIR] Name: \" << person.first << \", Alter: \" << person.second << std::endl; // Ausgabe: Anna, 25\n\n  // Alternative mit make_pair\n  auto student = std::make_pair(\"Bob\", 30);\n  std::cout << \"[PAIR] Student: \" << student.first << \" - \" << student.second << std::endl;\n\n  // Vergleich\n  std::pair<int, int> a = {1, 2};\n  std::pair<int, int> b = {1, 3};\n  if (a < b) {\n    std::cout << \"[PAIR] a < b (lexikografisch)\" << std::endl;\n  }\n\n  // -------- TUPLE --------\n  std::tuple<std::string, int, double> daten = {\"Clara\", 28, 1.65};\n  std::cout << \"\\n[TUPLE] Name: \" << std::get<0>(daten)\n            << \", Alter: \" << std::get<1>(daten)\n            << \", Größe: \" << std::get<2>(daten) << std::endl; // Ausgabe: Clara, 28, 1.65\n\n  // Alternative mit make_tuple\n  auto eintrag = std::make_tuple(\"David\", 32, 1.80);\n\n  // Entpacken mit tie\n  std::string name;\n  int alter;\n  double groesse;\n  std::tie(name, alter, groesse) = eintrag;\n  std::cout << \"[TUPLE] Entpackt: \" << name << \", \" << alter << \", \" << groesse << std::endl;\n\n  // Größe des Tupels\n  std::cout << \"[TUPLE] Anzahl Elemente: \" << std::tuple_size<decltype(eintrag)>::value << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Iteratoren",
        "content": {
          "text": [
            "### === Iteratoren in C++ ===\n",
            "-> `#include <vector>`   // Für std::vector\n",
            "-> `#include <list>`     // Für std::list\n",
            "-> `#include <set>`      // Für std::set\n",
            "-> `#include <algorithm>`// Für std::copy, std::sort, std::merge\n",
            "-> `#include <iterator>` // Für std::back_inserter\n",
            "\n",
            "---\n",
            "### === Iteratoren - Grundlagen in C++ ===\n",
            "-> Iteratoren sind bewegliche Zeiger, die auf ein Element eines Containers zeigen.\n",
            "-> Typbeispiel: `std::vector<std::string>::iterator`\n",
            "\n",
            "---\n",
            "### --- Iterator-Zugriff & Navigation ---\n",
            "-> `container.begin()` → Iterator auf das erste Element\n",
            "-> `container.end()` → Iterator auf das Element *nach* dem letzten\n",
            "-> `*it` → aktuelles Element\n",
            "-> `it->member` entspricht `(*it).member`\n",
            "-> `++it`, `--it` → nächstes/vorheriges Element (nur rückwärts bei bidirektional)\n",
            "-> `it += x` → x Schritte vor (nur Random-Access, z.B. bei `std::vector`)\n",
            "\n",
            "---\n",
            "### --- Iterator-Vergleich ---\n",
            "-> `it == it2`, `it != it2` → Vergleich\n",
            "-> `it < it2` → Nur bei Random-Access möglich\n",
            "\n",
            "---\n",
            "### --- Iterator-Arten nach Container ---\n",
            "`std::vector`, `std::array` → Random-Access\n",
            "`std::list`, `std::set`, `std::map` → Bidirektional\n",
            "`std::forward_list` → Forward-only\n",
            "\n",
            "---\n",
            "### --- Klassischer Iterator-Loop ---\n",
            "```cpp\nstd::vector<int> v = {1, 2, 3};\nfor (auto it = v.begin(); it != v.end(); ++it)\n  std::cout << *it << std::endl;\n```\n",
            "\n",
            "---\n",
            "### --- Laufindex (C-Style) ---\n",
            "```cpp\nfor (int i = 0; i < v.size(); i++) std::cout << v[i];\n```\n",
            "\n",
            "---\n",
            "### --- Range-based for loop ---\n",
            "```cpp\nfor (int vi : v) std::cout << vi;\n```\n",
            "\n",
            "---\n",
            "### --- Iterator für jedes 2. Element ---\n",
            "```cpp\nfor (auto it = v.begin() + 1; it < v.end(); it += 2)\n  std::cout << *it;\n```\n",
            "\n",
            "---\n",
            "### --- Iterator für Kopieren, Sortieren ---\n",
            "```cpp\nstd::copy(v.begin(), v.end(), std::back_inserter(l));\nv.erase(v.begin() + 3);\nstd::sort(v.begin() + 1, v.end() - 1);\n```\n",
            "\n",
            "---\n",
            "### --- Iterator bei set: find() ---\n",
            "```cpp\nstd::set<int> s = {2, 4, 6};\nauto it = s.find(4);\nif (it != s.end()) std::cout << *it;\n```\n",
            "-> `find()` gibt `end()` zurück, wenn das Element nicht vorhanden ist\n",
            "-> Sets haben keine Indexe, nur Iteratoren\n",
            "\n",
            "---\n",
            "### --- std::merge (zwei Container zusammenführen) ---\n",
            "```cpp\nstd::merge(s.begin(), s.end(), v.begin(), v.end(), std::back_inserter(l));\n```\n",
            "-> Fügt sortiert alle Elemente aus `s` und `v` in `l` ein\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <iterator>  // für advance, distance\n#include <algorithm>\n\nint main() {\n  std::vector<int> zahlen = {10, 20, 30, 40, 50};\n\n  // Iteration mit explizitem Iterator\n  std::cout << \"Normale Iteration: \";\n  for (std::vector<int>::iterator it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  } // Ausgabe: 10 20 30 40 50\n  std::cout << std::endl;\n\n  // Iteration mit auto\n  std::cout << \"Mit auto: \";\n  for (auto it = zahlen.begin(); it != zahlen.end(); ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\n  // Rückwärts iterieren\n  std::cout << \"Rückwärts: \";\n  for (auto rit = zahlen.rbegin(); rit != zahlen.rend(); ++rit) {\n    std::cout << *rit << \" \";\n  } // Ausgabe: 50 40 30 20 10\n  std::cout << std::endl;\n\n  // Zugriff & Änderung über Iterator\n  auto it = zahlen.begin();\n  *it = 100; // Ändert erstes Element\n  std::cout << \"Nach Änderung: \" << zahlen[0] << std::endl; // Ausgabe: 100\n\n  // std::advance: verschiebe Iterator um 3 Positionen\n  std::advance(it, 3);\n  std::cout << \"Iterator +3: \" << *it << std::endl; // Ausgabe: 40\n\n  // std::distance: Abstand zwischen zwei Iteratoren\n  int abstand = std::distance(zahlen.begin(), it);\n  std::cout << \"Abstand: \" << abstand << std::endl; // Ausgabe: 3\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Allgemeine Funktionen für STL-Container ===\n",
            "#### -> `begin()`: Gibt Iterator zum ersten Element zurück.\n",
            "   Beispiel: `auto it = container.begin();`\n",
            "#### -> `end()`: Iterator hinter dem letzten Element.\n",
            "   Beispiel: `for (auto it = c.begin(); it != c.end(); ++it)`\n",
            "#### -> `size()`: Gibt Anzahl der Elemente zurück.\n",
            "   Beispiel: `std::cout << v.size();`\n",
            "#### -> `empty()`: Prüft, ob Container leer ist.\n",
            "   Beispiel: `if (v.empty()) std::cout << \"leer\";`\n",
            "#### -> `clear()`: Löscht alle Elemente.\n",
            "   Beispiel: `v.clear();`\n",
            "#### -> `erase()`: Entfernt ein Element (Iterator oder Wert).\n",
            "   Beispiel: `v.erase(v.begin());`\n",
            "#### -> `insert()`: Fügt Element(e) hinzu.\n",
            "   Beispiel: `s.insert(42);`\n",
            "#### -> `find()`: Sucht Element (bei set/map).\n",
            "   Beispiel: `if (s.find(3) != s.end()) { ... }`\n",
            "#### -> `front()`: Erstes Element (z.B. bei vector, queue).\n",
            "   Beispiel: `std::cout << v.front();`\n",
            "#### -> `back()`: Letztes Element (z.B. bei vector).\n",
            "   Beispiel: `std::cout << v.back();`\n",
            "#### -> `at()`: Zugriff mit Bounds-Check.\n",
            "   Beispiel: `v.at(2);`\n",
            "#### -> `operator[]`: Zugriff ohne Check (nur bei vector, string, map).\n",
            "   Beispiel: `v[0] = 42;`\n",
            "#### -> `swap()`: Tauscht Inhalt zweier Container.\n",
            "   Beispiel: `v1.swap(v2);`\n",
            "#### -> `assign()`: Ersetzt Inhalt (z.B. bei vector oder string).\n",
            "   Beispiel: `v.assign(5, 0); // 5 Nullen`\n",
            "#### -> `resize()`: Größe ändern (nur bei Sequenzcontainern).\n",
            "   Beispiel: `v.resize(10);`\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <set>\n\nint main() {\n  std::set<int> s = {1, 2, 3};\n\n  // empty()\n  if (!s.empty()) {\n    std::cout << \"Set ist NICHT leer\" << std::endl; // Ausgabe: Set ist NICHT leer\n  }\n\n  // size()\n  std::cout << \"Anzahl Elemente: \" << s.size() << std::endl; // Ausgabe: 3\n\n  // insert()\n  s.insert(4);\n  s.insert(2); // 2 ist bereits enthalten, wird ignoriert\n\n  // erase()\n  s.erase(3); // entfernt 3, falls vorhanden\n\n  // find()\n  auto it = s.find(2);\n  if (it != s.end()) {\n    std::cout << \"2 gefunden\" << std::endl;\n  }\n\n  // count()\n  if (s.count(5) == 0) {\n    std::cout << \"5 ist NICHT enthalten\" << std::endl;\n  }\n\n  // swap()\n  std::set<int> s2 = {10, 20};\n  s.swap(s2); // jetzt enthält s die Elemente von s2\n\n  std::cout << \"Nach swap(): Set enthält: \";\n  for (int x : s) std::cout << x << \" \"; // Ausgabe: 10 20\n  std::cout << std::endl;\n\n  // clear()\n  s.clear();\n  std::cout << \"Nach clear(): Größe = \" << s.size() << std::endl; // Ausgabe: 0\n\n  return 0;\n}"

          ]
        }
      }
    ]
  },








  {
    "category": "Klassen",
    "subtopics": [
      {
        "title": "Allgemein",
        "content": {
          "text": [
            "### === Klassen in C++ ===\n",
            "Eine Klasse ist ein Bauplan für Objekte. Sie definiert Eigenschaften (Attribute) und Fähigkeiten (Methoden), die ein Objekt haben kann.\n",
            "-> Mit einer Klasse kann man eigene Datentypen erstellen, die sowohl Daten als auch Funktionen enthalten.\n",
            "-> Klassen helfen beim Strukturieren von Code und sind ein zentrales Konzept der objektorientierten Programmierung.\n",
            "\n",
            "---\n",
            "### Aufbau einer Klasse\n",
            "`class Klassenname { ... };` definiert eine Klasse. Darin legt man Member-Variablen (Attribute) und Member-Funktionen (Methoden) fest.\n",
            "Die Sichtbarkeit wird mit `public`, `private` oder `protected` gesteuert:\n",
            "- `private`: Nur innerhalb der Klasse sichtbar (Standard)\n",
            "- `public`: Von außen sichtbar\n",
            "- `protected`: Kein Zugriff von z.B main. Zugriff aus abgeleiteten Klassen und aus eigener Klasse ist erlaubt.\n",
            "\n",
            "---\n",
            "### Objekt-Erzeugung\n",
            "Mit `Klassenname objektname;` wird ein Objekt erstellt. Danach kann man mit `objektname.funktion()` Methoden aufrufen.\n",
            "\n",
            "---\n",
            "### Konstruktor\n",
            "Ein Konstruktor ist eine spezielle Methode, die automatisch beim Erzeugen eines Objekts aufgerufen wird. Er trägt den Namen der Klasse.\n",
            "\n",
            "---\n",
            "### this-Zeiger\n",
            "`this` ist ein Zeiger auf das aktuelle Objekt. Wird oft in Methoden verwendet, wenn man auf die eigene Instanz zugreifen möchte.\n",
            "---\n"
          ],
            "code": [
            "#include <iostream>\n\n// Definition einer Klasse\nclass Auto {\nprivate:\n  std::string marke;\n  int baujahr;\n\npublic:\n  // Konstruktor\n  Auto(std::string m, int bj) {\n    marke = m;\n    baujahr = bj;\n  }\n\n  // Methode zur Ausgabe\n  void anzeigen() {\n    std::cout << \"Marke: \" << marke << \", Baujahr: \" << baujahr << std::endl;\n  }\n};",
            "int main() {\n  // Objekt erzeugen\n  Auto meinAuto(\"BMW\", 2020);\n  meinAuto.anzeigen(); // Ausgabe: Marke: BMW, Baujahr: 2020\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Public / Private / Protected",
  "content": {
    "text": [
      "### === Zugriffsmodifizierer: `public`, `private`, `protected` ===\n",
      "In C++ bestimmt man mit Zugriffsmodifizierern, welche Teile einer Klasse **von außen sichtbar** oder **geschützt** sind.\n",
      "\n",
      "-> **Standard in `class`** ist: `private` (bei `struct` dagegen `public`)\n",
      "\n",
      "---\n",
      "### 🔒 `private:` (Standard)\n",
      "- Nur innerhalb der Klasse sichtbar\n",
      "- Gut für: Datenkapselung, interne Logik\n",
      "- Nicht sichtbar in Unterklassen\n",
      "\n",
      "---\n",
      "### 🔓 `public:`\n",
      "- Frei von überall zugänglich\n",
      "- Wird verwendet für Schnittstellen (z.B. Methoden wie `anzeigen()`)\n",
      "\n",
      "---\n",
      "### 🟨 `protected:`\n",
      "- Wie `private`, aber auch **in Unterklassen sichtbar**\n",
      "- Von **außen weiterhin nicht zugreifbar**\n",
      "- Gut, wenn **abgeleitete Klassen** auf interne Daten zugreifen sollen\n",
      "\n",
      "---\n",
      "### ➕ Vergleich:\n",
      "| Modifizierer | Sichtbar in Klasse | Sichtbar in Unterklasse | Sichtbar außerhalb |\n",
      "| private      | ✅                 | ❌                       | ❌                  |\n",
      "| protected    | ✅                 | ✅                       | ❌                  |\n",
      "| public       | ✅                 | ✅                       | ✅                  |\n",
      "\n",
      "👉 `protected` wird v. a. bei Vererbung verwendet, wenn man Unterklassen erweiterten, aber kontrollierten Zugriff geben möchte.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Konto {\nprivate:\n  int kontoNummer = 12345;        // Nur innerhalb der Klasse sichtbar\n\nprotected:\n  double kontostand = 100.0;      // Für Unterklassen sichtbar\n\npublic:\n  void einzahlen(double betrag) {\n    kontostand += betrag;\n  }\n\n  void anzeigen() {\n    std::cout << \"Kontostand: \" << kontostand << \" EUR\" << std::endl;\n  }\n};\n\nclass KinderKonto : public Konto {\npublic:\n  void abheben(double betrag) {\n    kontostand -= betrag; // Zugriff auf protected-Mitglied erlaubt\n  }\n\n  void kontoInfo() {\n    // std::cout << kontoNummer; // ❌ Fehler: private in Basisklasse\n    std::cout << \"Zugriff auf geschützten Kontostand möglich: \" << kontostand << std::endl;\n  }\n};\n\nint main() {\n  KinderKonto k;\n  k.einzahlen(50);\n  k.abheben(30);\n  k.anzeigen(); // Ausgabe: Kontostand: 120 EUR\n\n  // k.kontostand = 999;      // ❌ Fehler: protected von außen nicht sichtbar\n  // k.kontoNummer = 11111;   // ❌ Fehler: private von außen nicht sichtbar\n\n  k.kontoInfo(); // Zugriff auf protected innerhalb der Unterklasse\n\n  return 0;\n}"
    ]
  }
},
      {
        "title": "Konstruktor / Destruktor",
        "content": {
          "text": [
            "### === Konstruktoren & Destruktoren in C++ ===\n",
            "Konstruktoren und Destruktoren sind spezielle Methoden, die automatisch beim Erzeugen bzw. Zerstören eines Objekts aufgerufen werden.\n",
            "\n",
            "---\n",
            "### Konstruktor\n",
            "-> Wird beim Erzeugen eines Objekts aufgerufen\n",
            "-> Hat den **gleichen Namen wie die Klasse**, kein Rückgabewert (auch kein `void`)\n",
            "-> Wird oft verwendet, um Startwerte zu setzen oder Ressourcen zu reservieren\n",
            "\n",
            "---\n",
            "### Destruktor\n",
            "-> Wird beim Löschen eines Objekts aufgerufen (z.B. am Ende des Gültigkeitsbereichs)\n",
            "-> Hat den gleichen Namen wie die Klasse, aber mit einem **Tilde-Zeichen `~`** davor\n",
            "-> Wird genutzt, um Ressourcen wie Speicher oder Dateien freizugeben\n",
            "\n",
            "---\n",
            "### Wichtig\n",
            "- Es kann mehrere Konstruktoren geben (Überladung), aber **nur einen Destruktor** pro Klasse\n",
            "- In modernen C++-Projekten ist der Destruktor vor allem bei dynamischem Speicher wichtig\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Tier {\nprivate:\n  std::string name;\n\npublic:\n  // Konstruktor\n  Tier(std::string n) {\n    name = n;\n    std::cout << \"Tier erstellt: \" << name << std::endl;\n  }\n\n  // Destruktor\n  ~Tier() {\n    std::cout << \"Tier gelöscht: \" << name << std::endl;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht Geräusche.\" << std::endl;\n  }\n};",
            "int main() {\n  Tier katze(\"Miezi\");\n  katze.sprich();\n\n  // Am Ende von main wird automatisch der Destruktor aufgerufen\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Friend",
        "content": {
          "text": [
            "### === `friend` in C++ ===\n",
            "Ein `friend` erlaubt einer Funktion oder einer anderen Klasse den **Zugriff auf private oder protected Member** einer Klasse.\n",
            "Damit kann gezielt und kontrolliert eine Ausnahme von der Kapselung gemacht werden.\n",
            "\n",
            "---\n",
            "### friend-Funktion\n",
            "-> Wird **außerhalb** der Klasse definiert,\n",
            "-> hat aber Zugriff auf private Member,\n",
            "-> muss **innerhalb** der Klasse mit `friend` deklariert werden.\n",
            "\n",
            "---\n",
            "### friend-Klasse\n",
            "-> Eine ganze Klasse kann als `friend` einer anderen Klasse deklariert werden,\n",
            "-> Sie bekommt vollen Zugriff auf alle privaten Elemente der Klasse.\n",
            "\n",
            "---\n",
            "### Wann verwendet man `friend`?\n",
            "- Wenn bestimmte Funktionen eng mit der Klasse zusammenarbeiten müssen,\n",
            "- z.B. für Vergleichsfunktionen oder externe Operatorüberladungen.\n",
            "- Sollte **sparsam und gezielt** verwendet werden, da es die Kapselung aufbricht.\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\nclass Geheimnis {\nprivate:\n  int geheimerWert = 42;\n\n  // friend-Funktion erlauben\n  friend void zeigeGeheimnis(const Geheimnis& g);\n};\n\n// Definition der friend-Funktion\nvoid zeigeGeheimnis(const Geheimnis& g) {\n  std::cout << \"Geheimer Wert: \" << g.geheimerWert << std::endl;\n}",
            "int main() {\n  Geheimnis objekt;\n  zeigeGeheimnis(objekt); // Ausgabe: Geheimer Wert: 42\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Copy Constructor & Assignment",
  "content": {
    "text": [
      "### === Copy Constructor & Copy Assignment ===\n",
      "Wenn Objekte kopiert oder zugewiesen werden, kommen spezielle Funktionen ins Spiel:\n",
      "\n",
      "- **Copy Constructor**: Wird aufgerufen bei z.B. `Objekt b = a;`\n",
      "- **Copy Assignment Operator**: Wird aufgerufen bei `b = a;`, wenn `b` schon existiert\n",
      "\n",
      "---\n",
      "### Warum ist das wichtig?\n",
      "Standardmäßig macht C++ eine **flache Kopie** (Shallow Copy):\n",
      "- Zeiger werden 1:1 übernommen\n",
      "- Führt bei `delete` oft zu Abstürzen oder doppelt gelöschtem Speicher\n",
      "\n",
      "Daher sollte man bei dynamischem Speicher (z.B. `new`) eine **tiefe Kopie (Deep Copy)** schreiben:\n",
      "- Es wird ein **neuer Speicher** erstellt und der Inhalt kopiert\n",
      "\n",
      "---\n",
      "### Die Rule of 3:\n",
      "Wenn du eins dieser 3 selbst schreibst, solltest du alle schreiben:\n",
      "- Destruktor (`~Klasse()`)\n",
      "- Copy Constructor\n",
      "- Copy Assignment Operator\n",
      "\n",
      "👉 Ab C++11 gibt es auch die Rule of 5 (inkl. Move Constructor und Move Assignment)\n",
      "\n",
      "---\n",
      "### ❗ `if (this != &other)` - warum?\n",
      "Beim Zuweisungsoperator **kann es passieren**, dass ein Objekt sich selbst zugewiesen wird:\n",
      "```cpp\nobj = obj;\n```\n",
      "Ohne `if (this != &other)` würde man:\n",
      "- Speicher **löschen**, der gleich danach **benutzt** wird → ❌ Absturz!\n",
      "- Oder unnötig neu kopieren\n",
      "✅ Mit dem Vergleich wird sichergestellt, dass bei **Selbstzuweisung** nichts passiert.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n    }\n\n    // Copy Constructor (tiefe Kopie)\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n    }\n\n    // Copy Assignment Operator (tiefe Kopie)\n    Person& operator=(const Person& andere) {\n        if (this != &andere) { // wichtig bei Selbstzuweisung!\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Person p1(\"Kilian\");\n    Person p2 = p1;         // Copy Constructor wird genutzt\n    Person p3(\"Test\");\n    p3 = p1;                // Copy Assignment wird genutzt\n\n    p1.anzeigen();          // Name: Kilian\n    p2.anzeigen();          // Name: Kilian\n    p3.anzeigen();          // Name: Kilian\n\n    p1 = p1;                // Selbstzuweisung → geschützt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Move Constructor & Rvalue-Referenz",
  "content": {
    "text": [
  "### === Rvalue-Referenzen & Move-Semantik (C++11+) ===\n",
  "Mit C++11 kamen Rvalue-Referenzen (`T&&`) und die Move-Semantik. Damit kannst du **große Objekte effizient übertragen**, ohne sie teuer zu kopieren.\n",
  "\n",
  "---\n",
  "### ❓ Warum überhaupt \"move\"?\n",
  "- Normale Kopien (`obj2 = obj1;`) machen **teuren Speicheraufwand**: neuer Speicher, Daten kopieren.\n",
  "- Viele Kopien sind **unnötig**, z. B. bei temporären Rückgaben (`return ...`).\n",
  "- Der Move-Konstruktor **klaut** einfach den Speicher → schneller & effizienter.\n",
  "\n",
  "---\n",
  "### 🧱 Move Constructor\n",
  "- Hat die Signatur: `ClassName(ClassName&& other)`\n",
  "- Wird aufgerufen bei z. B. `Objekt b = std::move(a);`\n",
  "- **Übernimmt Ressourcen** von `a`, ohne Kopie\n",
  "- `a` wird danach in einen \"leeren\" Zustand versetzt (z. B. `pointer = nullptr`)\n",
  "\n",
  "---\n",
  "### 📤 Move Assignment Operator\n",
  "- Hat die Signatur: `ClassName& operator=(ClassName&& other)`\n",
  "- Wird aufgerufen bei z. B. `b = std::move(a);` (wenn `b` schon existiert)\n",
  "- **Löscht eigene Ressourcen** und übernimmt die von `a`\n",
  "\n",
  "---\n",
  "### ❗ Wichtig bei Move Assignment!\n",
  "Wenn du schreibst: `obj = std::move(obj);` → ist das eine **Selbst-Zuweisung**!\n",
  "- Ohne Prüfung: Objekt zerstört sich selbst → ❌ Absturz\n",
  "- Mit Prüfung: \n",
  "```cpp\nif (this != &other) {\n  // sicher verschieben\n}\n```\n",
  "✅ Damit wird Move korrekt übersprungen, wenn `this` und `other` identisch sind.\n",
  "\n",
  "---\n",
  "### 🆚 Copy vs. Move – Was passiert wann?\n",
  "| Ausdruck                   | Ergebnis                   |\n",
  "| `Person p = p2;`           | Copy Constructor            |\n",
  "| `Person p = std::move(p2);`| ✅ Move Constructor         |\n",
  "| `p = p2;`                  | Copy Assignment             |\n",
  "| `p = std::move(p2);`       | ✅ Move Assignment          |\n",
  "\n",
  "---\n",
  "### 🔍 Was ist ein Rvalue?\n",
  "- Ein **temporäres, namenloses Objekt**.\n",
  "- Beispiele: `Person(\"Max\")`, `return Person(...)`, `std::move(p)`\n",
  "- Nur solche dürfen an `T&&` übergeben werden.\n",
  "\n",
  "---\n",
  "### 🔧 `std::move`\n",
  "- `std::move(obj)` **verschiebt nicht direkt** – es markiert das Objekt als \"Rvalue\".\n",
  "- Nur damit erkennt der Compiler: Jetzt darf der Move-Konstruktor benutzt werden.\n",
  "\n",
  "---\n",
  "### 📌 Wann braucht man Move?\n",
  "- Bei **großen Klassen mit dynamischem Speicher** (z. B. `char*`, `std::vector`)\n",
  "- Wenn du Objekte **zurückgibst** (`return`) oder weitergibst\n",
  "- Wenn du weißt: *\"Das alte Objekt brauche ich nicht mehr – das neue darf alles übernehmen\"*\n",
  "\n",
  "---\n",
  "### 🧠 Merksatz:\n",
  "> **Kopieren:** Ich brauche beide Objekte.\n",
  "> **Verschieben:** Ich brauche nur noch eins – das andere darf leer sein.\n",
  "---\n"
],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) { // wichtig bei Selbst-Zuweisung!\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n\n    void anzeigen() {\n        std::cout << \"Name: \" << (name ? name : \"[leer]\") << std::endl;\n    }\n};\n\nPerson erzeugePerson() {\n    return Person(\"Kilian\");\n}\n\nint main() {\n    Person p1 = erzeugePerson();    // Move Constructor\n    Person p2(\"Test\");\n    p2 = std::move(p1);             // Move Assignment\n\n    p2.anzeigen();                  // Name: Kilian\n    p1.anzeigen();                  // Name: [leer]\n\n    p2 = std::move(p2);             // Selbstzuweisung → geschützt durch `this != &andere`\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Rule of 5",
  "content": {
    "text": [
      "### === Rule of 5 (C++11+) ===\n",
      "Die **Rule of 5** beschreibt, welche Funktionen du in einer Klasse mit Ressourcen (z.B. `new`) implementieren solltest.\n",
      "\n",
      "Sie erweitert die **Rule of 3** (Copy Constructor, Copy Assignment, Destruktor) um zwei neue Funktionen:\n",
      "\n",
      "---\n",
      "### Die fünf Funktionen:\n",
      "1. **Destruktor** (`~Klasse()`)\n",
      "2. **Copy Constructor** (`Klasse(const Klasse&)`)\n",
      "3. **Copy Assignment Operator** (`operator=(const Klasse&)`)\n",
      "4. **Move Constructor** (`Klasse(Klasse&&)`)\n",
      "5. **Move Assignment Operator** (`operator=(Klasse&&)`)\n",
      "\n",
      "---\n",
      "### Warum das Ganze?\n",
      "- Wenn du eine Funktion manuell schreibst (z.B. Copy Constructor), deaktiviert C++ die automatische Generierung der anderen → du musst sie selbst implementieren\n",
      "- Besonders bei dynamischem Speicher wichtig (deep copy & safe move)\n",
      "\n",
      "---\n",
      "### Wann ist die Rule of 5 wichtig?\n",
      "- Wenn deine Klasse **Zeiger oder Ressourcen verwaltet** (z.B. mit `new`, `malloc`, Datei-Handles)\n",
      "- Wenn du **Kopie und Verschiebung erlauben oder verhindern** willst\n",
      "\n",
      "👉 Alternativen: **Rule of 0** bei reinem Value-Semantik-Code (z.B. `std::vector`, keine `new`) oder Rule of 6 (mit `operator==()`)\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <cstring>\n\nclass Person {\nprivate:\n    char* name;\n\npublic:\n    // Konstruktor\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n        std::cout << \"Konstruktor\\n\";\n    }\n\n    // Destruktor\n    ~Person() {\n        delete[] name;\n        std::cout << \"Destruktor\\n\";\n    }\n\n    // Copy Constructor\n    Person(const Person& andere) {\n        name = new char[strlen(andere.name) + 1];\n        strcpy(name, andere.name);\n        std::cout << \"Copy Constructor\\n\";\n    }\n\n    // Copy Assignment\n    Person& operator=(const Person& andere) {\n        if (this != &andere) {\n            delete[] name;\n            name = new char[strlen(andere.name) + 1];\n            strcpy(name, andere.name);\n        }\n        std::cout << \"Copy Assignment\\n\";\n        return *this;\n    }\n\n    // Move Constructor\n    Person(Person&& andere) noexcept {\n        name = andere.name;\n        andere.name = nullptr;\n        std::cout << \"Move Constructor\\n\";\n    }\n\n    // Move Assignment\n    Person& operator=(Person&& andere) noexcept {\n        if (this != &andere) {\n            delete[] name;\n            name = andere.name;\n            andere.name = nullptr;\n        }\n        std::cout << \"Move Assignment\\n\";\n        return *this;\n    }\n};\n\nint main() {\n    Person a(\"Max\");\n    Person b = a;             // Copy Constructor\n    Person c(\"Test\");\n    c = a;                    // Copy Assignment\n    Person d = std::move(a);  // Move Constructor\n    b = std::move(c);         // Move Assignment\n    return 0;\n}"
    ]
  }
},
{
  "title": "Implizite Klassenbestandteile & = delete",
  "content": {
    "text": [
      "### === Implizite Klassenbestandteile in C++ ===\n",
      "C++ erzeugt für jede Klasse automatisch bestimmte Methoden, wenn du sie nicht selbst definierst:\n",
      "\n",
      "---\n",
      "### Diese Methoden werden (standardmäßig) automatisch generiert:\n",
      "- Standard-Konstruktor (`MyClass()`)\n",
      "- Destruktor (`~MyClass()`)\n",
      "- Copy Constructor (`MyClass(const MyClass&)`)\n",
      "- Copy Assignment (`operator=(const MyClass&)`)\n",
      "- Move Constructor (`MyClass(MyClass&&)`) *(ab C++11)*\n",
      "- Move Assignment (`operator=(MyClass&&)`) *(ab C++11)*\n",
      "\n",
      "---\n",
      "### Warum `= delete`?\n",
      "- Verhindert, dass eine bestimmte Methode automatisch generiert oder verwendet wird\n",
      "- Beispiel: Kopieren verhindern (z.B. bei Singleton- oder Handle-Klassen)\n",
      "```cpp\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n",
      "\n",
      "---\n",
      "### Warum `= default`?\n",
      "- Erzwingt die automatische Standard-Erstellung (z.B. wenn du trotzdem was anderes schreibst)\n",
      "```cpp\nMyClass() = default;\n```\n",
      "\n",
      "---\n",
      "### Wann ist das wichtig?\n",
      "- Wenn deine Klasse z.B. Zeiger enthält und **tiefe Kopie nötig** ist\n",
      "- Wenn du **kopieren bewusst verbieten** willst\n",
      "- Wenn du eine Methode **nur deklarieren willst, aber ohne eigene Logik** (z.B. bei APIs)\n",
      "\n",
      "---\n",
      "👉 Moderne Klassen (z.B. mit Ressourcenbesitz) sollten Copy/Move bewusst steuern\n",
      "👉 In Prüfungen wird oft gefragt: \"Was macht `= delete`?\" oder \"Was wird implizit generiert?\"\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Beispiel {\npublic:\n    Beispiel() = default; // Standard-Konstruktor explizit erlaubt\n\n    // Copy-Vorgänge deaktivieren\n    Beispiel(const Beispiel&) = delete;\n    Beispiel& operator=(const Beispiel&) = delete;\n\n    void hallo() {\n        std::cout << \"Hallo!\" << std::endl;\n    }\n};\n\nint main() {\n    Beispiel b1;      // OK\n    b1.hallo();\n\n    // Beispiel b2 = b1;        // Fehler: Copy Constructor ist gelöscht\n    // Beispiel b3;\n    // b3 = b1;                  // Fehler: Copy Assignment ist gelöscht\n\n    return 0;\n}"
    ]
  }
},
{
  "title": "Struct vs. Class",
  "content": {
    "text": [
      "### === struct vs. class in C++ ===\n",
      "`struct` und `class` sind sich in C++ sehr ähnlich - beide können Memberfunktionen, Konstruktoren, Vererbung und vieles mehr enthalten.\n",
      "---\n",
      "#### Der einzige technische Unterschied ist die Standard-Sichtbarkeit:\n",
      "\n",
      "| Merkmal                     | `struct` (Standard: public)   | `class` (Standard: private)   |\n",
      "| Standard-Sichtbarkeit       | `public`                      | `private`                    |\n",
      "| Wird verwendet für...       | Datencontainer, PODs          | OOP-Klassen, Kapselung       |\n",
      "| Methoden möglich?           | ✅ Ja                          | ✅ Ja                         |\n",
      "| Vererbung möglich?          | ✅ Ja                          | ✅ Ja                         |\n",
      "| Konstruktoren, Operatoren?  | ✅ Ja                          | ✅ Ja                         |\n",
      "\n",
      "---\n",
      "### Beispiel: Unterschied in der Sichtbarkeit\n",
      "```cpp\nstruct A {\n    int x;       // automatisch public\n};\n\nclass B {\n    int x;       // automatisch private\n};\n\nint main() {\n    A a;\n    a.x = 10;    // ✅ erlaubt\n\n    B b;\n    // b.x = 10; // ❌ Fehler: x ist private\n    return 0;\n}\n```\n",
      "\n",
      "---\n",
      "### Merksatz:\n",
      "- Verwende `struct`, wenn du **nur Daten speichern willst** (wie bei C-Strukturen)\n",
      "- Verwende `class`, wenn du **Verhalten, Kapselung, Logik** einbauen willst\n",
      "\n",
      "👉 Aber technisch gesehen sind beide fast identisch - nur der Standardzugriff unterscheidet sich!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nstruct Punkt {\n    int x;\n    int y;\n\n    void anzeigen() {\n        std::cout << \"x: \" << x << \", y: \" << y << std::endl;\n    }\n};\n\nclass Person {\nprivate:\n    std::string name;\npublic:\n    Person(const std::string& n) : name(n) {}\n    void anzeigen() {\n        std::cout << \"Name: \" << name << std::endl;\n    }\n};\n\nint main() {\n    Punkt p = {3, 5};\n    p.anzeigen();   // x: 3, y: 5\n\n    Person pers(\"Kilian\");\n    pers.anzeigen(); // Name: Kilian\n\n    return 0;\n}"
    ]
        }
      },
    {
  "title": "explicit",
  "content": {
    "text": [
        "### === `explicit` in C++ ===\n",
        "Das Schlüsselwort `explicit` wird verwendet, um **automatische (implizite) Typumwandlungen** zu verhindern – vor allem bei **einparametrigen Konstruktoren**.\n",
        "\n",
        "---\n",
        "### ❗ Problem ohne `explicit`\n",
        "Ein Konstruktor mit nur einem Argument kann **automatisch aufgerufen werden**, wenn ein Wert vom passenden Typ übergeben wird. Das führt oft zu **unerwartetem Verhalten**:\n",
        "```cpp\nclass Zahl {\npublic:\n  Zahl(int wert); // kein explicit!\n};\n\nZahl z = 5;  // OK: int wird implizit zu Zahl\n```\n",
        "Auch bei Funktionsaufrufen ist das problematisch:\n",
        "```cpp\nvoid verarbeite(Zahl z);\nverarbeite(5); // ⚠️ int wird still zu Zahl\n```\n",
        "➡️ Die Konvertierung passiert im Hintergrund, obwohl du sie nie bewusst im Code angegeben hast.\n",
        "\n",
        "---\n",
        "### ✅ Lösung mit `explicit`\n",
        "Durch `explicit` wird der Konstruktor **nur dann aufgerufen**, wenn du ihn **direkt und bewusst** verwendest:\n",
        "```cpp\nclass Zahl {\npublic:\n  explicit Zahl(int wert);\n};\n\nZahl z(5);        // ✅ OK: direkte Initialisierung\nverarbeite(z);     // ✅ erlaubt\nverarbeite(5);     // ❌ Fehler: keine implizite Umwandlung\n```\n",
        "\n",
        "---\n",
        "### 📌 Auch nützlich bei `operator`-Funktionen\n",
        "`explicit` kann z. B. auch vor `operator bool()` stehen, damit ein Objekt **nicht automatisch in `bool` umgewandelt** wird – etwa in `if`-Bedingungen:\n",
        "```cpp\nexplicit operator bool() const;\n```\n",
        "\n",
        "---\n",
        "### 🧠 Merksatz:\n",
        "> Hast du einen **Konstruktor mit genau einem Argument**?\n",
        "> Dann verwende **immer `explicit`**, außer du willst die automatische Konvertierung **wirklich ganz bewusst zulassen**.\n",
        "---\n"
      ],
    "code": [
      "#include <iostream>\n\nclass Zahl {\npublic:\n  explicit Zahl(int wert) {\n    std::cout << \"Konstruktor aufgerufen mit: \" << wert << std::endl;\n  }\n};\n\nvoid printZahl(Zahl z) {\n  std::cout << \"printZahl() aufgerufen\" << std::endl;\n}\n\nint main() {\n  Zahl z(42);      // ✅ erlaubt: direkte Initialisierung\n  printZahl(z);    // ✅ erlaubt\n\n  // printZahl(42); // ❌ Fehler: implizite Konvertierung verboten durch 'explicit'\n  return 0;\n}\n\n// Beispielausgabe:\n// Konstruktor aufgerufen mit: 42\n// printZahl() aufgerufen"
    ]
  }
},
{
  "title": "Getter- und Setter-Funktionen",
  "content": {
    "text": [
      "### === Getter- und Setter-Funktionen ===\n",
      "Getter und Setter sind spezielle Funktionen, die den **Zugriff auf private Membervariablen** einer Klasse ermöglichen.\n",
      "\n",
      "👉 Sie sind ein Teil des **Kapselungskonzepts** in der objektorientierten Programmierung.\n",
      "\n",
      "---\n",
      "### Getter:\n",
      "- Lesen den Wert eines privaten Members.\n",
      "- Haben oft den Namen `getXYZ()`.\n",
      "- Rückgabetyp entspricht dem Membertyp.\n",
      "\n",
      "---\n",
      "### Setter:\n",
      "- Setzen oder ändern den Wert eines privaten Members.\n",
      "- Haben oft den Namen `setXYZ()`.\n",
      "- Können zusätzliche Prüfungen enthalten (z.B. Wertebereich).\n",
      "\n",
      "---\n",
      "### Warum verwenden?\n",
      "- Direkter Zugriff auf `private` Variablen ist nicht erlaubt.\n",
      "- Getter/Setter ermöglichen **kontrollierten Zugriff**.\n",
      "- So bleibt die **Datenintegrität** erhalten.\n",
      "\n",
      "---\n",
      "📌 In modernen C++-Projekten ist es üblich, nur dann Getter/Setter zu schreiben, wenn sie **wirklich gebraucht werden**\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Person {\nprivate:\n  int alter;\n\npublic:\n  // Getter\n  int getAlter() const {\n    return alter;\n  }\n\n  // Setter mit Prüfung\n  void setAlter(int a) {\n    if (a >= 0)\n      alter = a;\n  }\n};\n\nint main() {\n  Person p;\n  p.setAlter(25); // setzt Alter auf 25\n  std::cout << \"Alter: \" << p.getAlter() << std::endl;\n  return 0;\n}\n\n// Beispielausgabe:\n// Alter: 25"
    ]
  }
}



    ]
  },








{
    "category": "Klassen Vererbung",
    "subtopics": [
{
  "title": "Allgemein",
  "content": {
    "text": [
      "### === Vererbung in C++ ===\n",
      "Vererbung ist ein zentrales Konzept der objektorientierten Programmierung.\n",
      "Damit kann eine neue Klasse (`Kindklasse`) die Eigenschaften und Methoden einer bestehenden Klasse (`Basisklasse`) übernehmen.\n",
      "\n",
      "---\n",
      "### Vorteile\n",
      "- Code-Wiederverwendung\n",
      "- Erweiterbarkeit\n",
      "- Strukturierte Hierarchien\n",
      "\n",
      "---\n",
      "### Syntax\n",
      "`class Kindklasse : public Basisklasse { ... };`\n",
      "-> `public` bedeutet: öffentliche Mitglieder der Basisklasse bleiben auch in der Kindklasse öffentlich.\n",
      "-> `protected` bedeutet: öffentliche Mitglieder der Basisklasse werden in der Kindklasse protected.\n",
      "-> `private` bedeutet: öffentliche Mitglieder der Basisklasse werden in der Kindklasse private.\n",
      "\n",
      "---\n",
      "### Konstruktoren in Vererbung\n",
      "-> Konstruktor der Basisklasse wird **automatisch zuerst** aufgerufen.\n",
      "-> Kann im Initialisierungsbereich der Kindklasse explizit aufgerufen werden.\n",
      "\n",
      "---\n",
      "### Vererbungsmodi in C++\n",
      "C++ kennt drei Vererbungsmodi: `public`, `protected` und `private`.\n",
      "- Sie bestimmen, wie sich die Sichtbarkeit von geerbten Attributen und Methoden in der abgeleiteten Klasse verändert.\n",
      "- Der Modus ist eine **obere Schranke**: `public` lässt alles wie es ist, `private` versteckt fast alles.\n",
      "\n",
      "---\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n",
      "---\n"
    ],
"code": [
  "#include <iostream>\n\n// Basisklasse\nclass Tier {\nprotected:\n  std::string name;\n\npublic:\n  Tier(std::string n) {\n    name = n;\n  }\n\n  void sprich() {\n    std::cout << name << \" macht ein Geräusch.\" << std::endl;\n  }\n};\n\n// Abgeleitete Klasse\nclass Hund : public Tier {\npublic:\n  Hund(std::string n) : Tier(n) {}\n\n  void bell() {\n    std::cout << name << \" bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  rex.sprich(); // Ausgabe: Rex macht ein Geräusch.\n  rex.bell();   // Ausgabe: Rex bellt.\n\n  return 0;\n}",
  "// Zusätzliche Beispiele zur Vererbungsart:\n\nclass base {\npublic:\n  void f() {}\nprotected:\n  void g() {}\nprivate:\n  int x;\n};\n\nclass derived_1 : public base {\n  // f() bleibt public\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_2 : protected base {\n  // f() wird protected\n  // g() bleibt protected\n  // x ist nicht zugreifbar\n};\n\nclass derived_3 : private base {\n  // f() wird private\n  // g() wird private\n  // x ist nicht zugreifbar\n};"
]
        }
      },
{
  "title": "Vererbungsmodi",
  "content": {
    "text": [
      "### === Vererbungsmodi in C++ ===\n",
      "Wenn eine Klasse von einer anderen Klasse erbt, kannst du den **Vererbungsmodus** festlegen:\n",
      "- `public`\n",
      "- `protected`\n",
      "- `private`\n",
      "\n",
      "Der Modus bestimmt, **wie die Zugriffsrechte** (`public` / `protected` / `private`) der Basisklasse in der abgeleiteten Klasse weitervererbt werden.\n",
      "\n",
      "---\n",
      "### Vergleichstabelle:\n",
      "| Basisklassen-Member | public-Vererbung | protected-Vererbung | private-Vererbung |\n",
      "| `public`            | `public`         | `protected`          | `private`         |\n",
      "| `protected`         | `protected`      | `protected`          | `private`         |\n",
      "| `private`           | nicht geerbt     | nicht geerbt         | nicht geerbt      |\n",
      "\n",
      "👉 **private Mitglieder werden nie vererbt**, egal welcher Modus.\n",
      "\n",
      "---\n",
      "### Wann welchen Modus?\n",
      "- `public`: Die abgeleitete Klasse ist eine vollwertige „ist-ein“-Variante (z.B. `Hund ist ein Tier`)\n",
      "- `protected`: Meist intern genutzt, selten in Praxis\n",
      "- `private`: Wenn Vererbung nur als Implementierungshilfe dient und von außen verborgen bleiben soll\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass base {\npublic:\n  void f() { std::cout << \"f()\\n\"; }\nprotected:\n  void g() { std::cout << \"g()\\n\"; }\nprivate:\n  int x = 42; // nicht vererbbar\n};\n\nclass derived_public : public base {\npublic:\n  void test() {\n    f(); // OK (public bleibt public)\n    g(); // OK (protected bleibt protected)\n    // x; ❌ nicht zugreifbar\n  }\n};\n\nclass derived_protected : protected base {\npublic:\n  void test() {\n    f(); // OK (public wird protected)\n    g(); // OK (protected bleibt protected)\n  }\n};\n\nclass derived_private : private base {\npublic:\n  void test() {\n    f(); // OK (public wird private)\n    g(); // OK (protected wird private)\n  }\n};\n\nint main() {\n  derived_public dp;\n  dp.f(); // OK\n  // dp.g(); ❌ nicht erlaubt (geschützt)\n\n  derived_protected dpr;\n  // dpr.f(); ❌ nicht erlaubt (geschützt)\n\n  derived_private dpi;\n  // dpi.f(); ❌ nicht erlaubt (privat)\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Konstruktorvererbung & -übernahme",
  "content": {
    "text": [
      "### === Konstruktorvererbung & -weitergabe in C++ ===\n",
      "Normalerweise werden Konstruktoren **nicht automatisch** an abgeleitete Klassen vererbt.\n",
      "Das bedeutet: Die Unterklasse muss eigene Konstruktoren definieren und dabei die Konstruktoren der Basisklasse explizit aufrufen.\n",
      "\n",
      "---\n",
      "### 🔧 Konstruktorweitergabe mit Initialisierungsliste\n",
      "- Ein Konstruktor der Unterklasse kann per `: Basisklasse(...)` den Konstruktor der Oberklasse aufrufen.\n",
      "\n",
      "```cpp\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  Hund(std::string name) : Tier(name) {}\n};\n```\n",
      "\n",
      "---\n",
      "### 🔁 Konstruktorvererbung mit `using` (ab C++11)\n",
      "- Mit `using Basisklasse::Basisklasse;` können Konstruktoren **automatisch übernommen** werden.\n",
      "- Spart Schreibaufwand, wenn man nichts zusätzlich initialisieren muss.\n",
      "\n",
      "👉 Achtung: Funktioniert **nicht**, wenn die Unterklasse zusätzliche Member/Attribute initialisieren muss oder andere Logik enthält.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  Tier(std::string name) {\n    std::cout << name << \" wird erschaffen.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  // Weitergabe an Basiskonstruktor\n  Hund(std::string name) : Tier(name) {\n    std::cout << \"Hund-Konstruktor läuft.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  // Konstruktorvererbung ab C++11\n  using Tier::Tier;\n};\n\nint main() {\n  Hund rex(\"Rex\");\n  // Ausgabe:\n  // Rex wird erschaffen.\n  // Hund-Konstruktor läuft.\n\n  Katze mimi(\"Mimi\");\n  // Ausgabe:\n  // Mimi wird erschaffen.\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Destruktorvererbung",
  "content": {
    "text": [
      "### === Destruktorvererbung ===\n",
      "Wenn Klassen **vererbt** werden und über Zeiger auf die **Basisklasse** gelöscht wird, ist es wichtig, den Destruktor **virtuell** zu machen.\n",
      "\n",
      "👉 Nur dann wird der Destruktor der **abgeleiteten Klasse korrekt aufgerufen**.\n",
      "\n",
      "---\n",
      "### Warum `virtual` beim Destruktor?\n",
      "- Ohne `virtual` wird beim Löschen über einen Basisklassenzeiger **nur der Basisklassen-Destruktor** aufgerufen.\n",
      "- Das führt zu **undefiniertem Verhalten** oder **Speicherlecks**, wenn die abgeleitete Klasse Ressourcen verwaltet.\n",
      "\n",
      "---\n",
      "### Best Practice:\n",
      "- In jeder Klasse mit virtuellen Funktionen sollte der Destruktor ebenfalls `virtual` sein.\n",
      "- Auch Interfaceklassen (mit `= 0`) sollten **einen virtuellen Destruktor** haben.\n",
      "\n",
      "📌 Ein `virtual`-Destruktor sorgt dafür, dass beim Löschen über einen Zeiger auf die Basisklasse **alle Destruktoren korrekt und vollständig** ausgeführt werden.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual ~Tier() {\n    std::cout << \"Tier-Destruktor\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  ~Hund() {\n    std::cout << \"Hund-Destruktor\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  ~Katze() {\n    std::cout << \"Katze-Destruktor\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  delete t1; // Ausgabe: Hund-Destruktor, Tier-Destruktor\n  delete t2; // Ausgabe: Katze-Destruktor, Tier-Destruktor\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Redefinition von Memberfunktionen",
  "content": {
    "text": [
      "### === Redefinition von Memberfunktionen ===\n",
      "In der objektorientierten Programmierung mit C++ ist es möglich, **Funktionen in Unterklassen neu zu definieren**.\n",
      "Dabei überschreibt die Unterklasse die gleichnamige Funktion der Oberklasse. Das nennt man auch **„Redefinition“** oder **„Überschreiben“** (nicht zu verwechseln mit Überladung).\n",
      "\n",
      "---\n",
      "### Wann macht man das?\n",
      "- Wenn eine abgeleitete Klasse ein **eigenes Verhalten** für eine Methode braucht\n",
      "- Beispiel: `Tier` hat `sprich()`, aber `Hund` bellt und `Katze` miaut\n",
      "\n",
      "---\n",
      "### Ohne `virtual` = statisch gebunden\n",
      "- Wenn die Methode **nicht** als `virtual` deklariert ist, entscheidet sich beim **Compilieren**, welche Funktion verwendet wird (statisch)\n",
      "\n",
      "---\n",
      "### Mit `virtual` = dynamisch gebunden\n",
      "- Nur wenn die Methode in der Basisklasse als `virtual` markiert ist, wird sie **zur Laufzeit** (dynamisch) aufgelöst - wichtig für **Polymorphie**\n",
      "\n",
      "👉 `virtual` sollte bei der Basisklasse verwendet werden, wenn man möchte, dass Unterklassen eigene Versionen implementieren\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void sprich() {\n    std::cout << \"Ein Tier macht ein Geräusch.\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() { // überschreibt, aber nicht virtuell\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nint main() {\n  Hund h;\n  h.sprich(); // Ausgabe: Ein Hund bellt.\n\n  Tier* t = new Hund();\n  t->sprich(); // Ausgabe: Ein Tier macht ein Geräusch. (weil kein virtual!)\n\n  delete t;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Virtuelle Funktionen",
  "content": {
    "text": [
      "### === Virtuelle Funktionen ===\n",
      "Virtuelle Funktionen ermöglichen es in C++, dass die **richtige Funktion zur Laufzeit aufgerufen wird**, wenn mit Zeigern oder Referenzen auf Basisklassen gearbeitet wird.\n",
      "\n",
      "👉 Dieses Verhalten nennt man **dynamisches Binden** oder **Laufzeit-Polymorphie**.\n",
      "\n",
      "---\n",
      "### Was passiert ohne `virtual`?\n",
      "- Es wird immer die Funktion der **Basisklasse** aufgerufen, selbst wenn das Objekt eigentlich zur Unterklasse gehört.\n",
      "\n",
      "---\n",
      "### Mit `virtual`:\n",
      "- Die Entscheidung, **welche Funktion** aufgerufen wird, erfolgt **zur Laufzeit** (dynamisch), basierend auf dem tatsächlichen Objekttyp.\n",
      "- Ideal für Oberklassen mit gemeinsamem Interface, das von Unterklassen **spezialisiert** wird.\n",
      "\n",
      "---\n",
      "### Wichtig:\n",
      "- Wird in einer Klasse `virtual` verwendet, sollte in abgeleiteten Klassen `override` verwendet werden (seit C++11).\n",
      "- Der Destruktor einer Basisklasse sollte fast immer `virtual` sein, wenn Vererbung verwendet wird!\n",
      "\n",
      "---\n",
      "### 🔒 Pur-virtuelle Funktionen (`= 0`)\n",
      "- Eine Funktion kann als **rein virtuell** deklariert werden:\n",
      "```cpp\nvirtual void sprich() = 0;\n```\n",
      "- Die Klasse wird dadurch **abstrakt** - es können **keine Objekte davon erstellt** werden.\n",
      "- Jede abgeleitete Klasse **muss** diese Funktion implementieren, sonst ist auch sie abstrakt.\n",
      "- Wird oft für **Interfaces** genutzt (z.B. gemeinsame Schnittstelle für viele Untertypen).\n",
      "\n",
      "#### 🚫 Nicht erlaubt:\n",
      "- Es ist **nicht erlaubt**, direkt ein Objekt einer abstrakten Klasse zu erzeugen:\n",
      "```cpp\nLebewesen l; // ❌ Fehler: Objekt von abstrakter Klasse\n```\n",
      "- Auch das Erzeugen eines Zeigers oder einer Referenz ist **nur erlaubt**, wenn kein Konstruktor direkt aufgerufen wird:\n",
      "```cpp\nLebewesen* ptr; // ✅ erlaubt, solange kein Objekt erstellt wird\n```",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein Geräusch.\" << std::endl;\n  }\n\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* t1 = new Hund();\n  Tier* t2 = new Katze();\n\n  t1->sprich(); // Ausgabe: Ein Hund bellt.\n  t2->sprich(); // Ausgabe: Eine Katze miaut.\n\n  delete t1;\n  delete t2;\n  return 0;\n}",
      "\n// Beispiel mit rein virtueller Funktion:\n#include <iostream>\n\nclass Lebewesen {\npublic:\n  virtual void bewegung() = 0; // rein virtuelle Funktion\n  virtual ~Lebewesen() {}\n};\n\nclass Fisch : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Fisch schwimmt.\" << std::endl;\n  }\n};\n\nclass Vogel : public Lebewesen {\npublic:\n  void bewegung() override {\n    std::cout << \"Ein Vogel fliegt.\" << std::endl;\n  }\n};\n\nint main() {\n  // Lebewesen l; // ❌ Fehler: Kann nicht instanziiert werden (abstrakte Klasse)\n\n  Lebewesen* l1 = new Fisch();\n  Lebewesen* l2 = new Vogel();\n\n  l1->bewegung(); // Ausgabe: Ein Fisch schwimmt.\n  l2->bewegung(); // Ausgabe: Ein Vogel fliegt.\n\n  delete l1;\n  delete l2;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Statisches vs. dynamisches Binden",
  "content": {
    "text": [
      "### === Statisches vs. dynamisches Binden ===\n",
      "**Binden** bedeutet, dass der Compiler entscheidet, **welche Funktion** bei einem Funktionsaufruf verwendet wird.\n",
      "---\n",
      "## In C++ gibt es zwei Arten:\n",
      "\n",
      "### 🔒 Statisches Binden (Compile-Time Binding)\n",
      "- Der **Compiler** entscheidet zur **Übersetzungszeit**, welche Funktion aufgerufen wird.\n",
      "- Gilt für **nicht-virtuelle Funktionen**.\n",
      "- Schneller, aber **nicht polymorph**.\n",
      "\n",
      "---\n",
      "### 🔓 Dynamisches Binden (Run-Time Binding)\n",
      "- Die Entscheidung erfolgt zur **Laufzeit**.\n",
      "- Nur möglich bei **virtuellen Funktionen** über **Zeiger oder Referenzen** auf die Basisklasse.\n",
      "- Ermöglicht **Polymorphie**.\n",
      "\n",
      "---\n",
      "### Vergleich:\n",
      "| Merkmal              | Statisch (`default`)    | Dynamisch (`virtual`)      |\n",
      "| Zeitpunkt der Bindung| Kompilierzeit          | Laufzeit                    |\n",
      "| Geschwindigkeit      | Schnell                | Etwas langsamer             |\n",
      "| Polymorphie möglich? | ❌                     | ✅                          |\n",
      "| Anwendbar auf        | normale Funktionen     | virtuelle Funktionen        |\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Tier\" << std::endl;\n  }\n\n  virtual void sprich() {\n    std::cout << \"[dynamisch] Tier macht ein Geräusch\" << std::endl;\n  }\n};\n\nclass Hund : public Tier {\npublic:\n  void info() {\n    std::cout << \"[statisch] Hund\" << std::endl;\n  }\n\n  void sprich() override {\n    std::cout << \"[dynamisch] Hund bellt\" << std::endl;\n  }\n};\n\nint main() {\n  Tier* tierPtr = new Hund();\n\n  tierPtr->info();   // Ausgabe: [statisch] Tier (keine virtuelle Methode)\n  tierPtr->sprich(); // Ausgabe: [dynamisch] Hund bellt (virtuell)\n\n  delete tierPtr;\n  return 0;\n}"
    ]
  }
},
{
  "title": "Polymorphie",
  "content": {
    "text": [
      "### === Polymorphie in C++ ===\n",
      "Polymorphie bedeutet, dass ein Objekt **unterschiedliche Formen annehmen** kann - also dass **eine Schnittstelle viele Implementierungen** zulässt.\n",
      "\n",
      "👉 In C++ tritt Polymorphie oft in Verbindung mit **Vererbung und virtuellen Funktionen** auf.\n",
      "\n",
      "---\n",
      "### Vorteile der Polymorphie:\n",
      "- Ermöglicht flexiblen und erweiterbaren Code\n",
      "- Funktionen können auf **Basisklassen zeigen**, aber das Verhalten **von Unterklassen ausführen**\n",
      "- Wichtig für Designmuster wie Strategy, Factory, etc.\n",
      "\n",
      "---\n",
      "### Voraussetzungen für Polymorphie:\n",
      "- Eine **Basisklasse** mit mindestens einer `virtual`-Funktion\n",
      "- Funktionen werden über **Zeiger oder Referenzen** aufgerufen\n",
      "\n",
      "👉 Polymorphie funktioniert **nicht bei Werten**, sondern nur über Zeiger oder Referenz!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <vector>\n\nclass Tier {\npublic:\n  virtual void sprich() {\n    std::cout << \"Ein Tier macht ein Geräusch.\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Ein Hund bellt.\" << std::endl;\n  }\n};\n\nclass Katze : public Tier {\npublic:\n  void sprich() override {\n    std::cout << \"Eine Katze miaut.\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Tier*> tiere;\n  tiere.push_back(new Hund());\n  tiere.push_back(new Katze());\n  tiere.push_back(new Hund());\n\n  for (Tier* t : tiere) {\n    t->sprich();\n    // Ausgabe:\n    // Ein Hund bellt.\n    // Eine Katze miaut.\n    // Ein Hund bellt.\n  }\n\n  for (Tier* t : tiere) {\n    delete t;\n  }\n\n  return 0;\n}"
    ]
  }
},
{
  "title": "Abstrakte Klassen und Schnittstellenklassen",
  "content": {
    "text": [
      "### === Abstrakte Klassen und Schnittstellenklassen ===\n",
      "Abstrakte Klassen dienen als **Basisklassen**, von denen **kein direktes Objekt erstellt** werden kann.\n",
      "\n",
      "👉 Sie enthalten mindestens **eine rein virtuelle Funktion** (`= 0`).\n",
      "\n",
      "---\n",
      "### Eigenschaften abstrakter Klassen:\n",
      "- Können normale Memberfunktionen und Membervariablen enthalten.\n",
      "- Können **teilweise implementiert** sein (z.B. gemeinsames Verhalten).\n",
      "- Können als **Basisklasse** für konkrete Unterklassen dienen.\n",
      "\n",
      "---\n",
      "### Schnittstellenklassen (Interfaces):\n",
      "- Eine Sonderform der abstrakten Klasse.\n",
      "- Enthalten **nur rein virtuelle Funktionen** (und evtl. einen virtuellen Destruktor).\n",
      "- Dienen nur als **Vertrag**, was eine Klasse können muss.\n",
      "- Kein Zustand, keine Implementierung - nur Methoden ohne Körper.\n",
      "\n",
      "🧩 In C++ gibt es keine eigene `interface`-Syntax wie in Java oder C#, stattdessen nutzt man reine virtuelle Funktionen.\n",
      "\n",
      "---\n",
      "### Beispiel für eine Interfaceklasse:\n",
      "```cpp\nclass Druckbar {\npublic:\n  virtual void drucke() = 0;\n  virtual ~Druckbar() {}\n};\n```\n",
      "\n",
      "---\n",
      "### Warum verwenden?\n",
      "- Um **Verhalten festzulegen**, das von mehreren Klassen auf **unterschiedliche Weise** umgesetzt wird.\n",
      "- Um **Polymorphie** zu ermöglichen.\n",
      "- Um **Abhängigkeiten zu entkoppeln** (z.B. bei Plugins, Testbarkeit usw.).\n",
      "---\n"
    ],
    "code": [
  "// Abstrakte Klasse mit gemeinsamer Logik\n#include <iostream>\n#include <vector>\n\nclass Form {\npublic:\n  virtual double flaeche() = 0; // rein virtuelle Funktion\n  void zeige() {\n    std::cout << \"Fläche: \" << flaeche() << std::endl;\n  }\n  virtual ~Form() {}\n};\n\nclass Kreis : public Form {\n  double radius;\npublic:\n  Kreis(double r) : radius(r) {}\n  double flaeche() override {\n    return 3.14159 * radius * radius;\n  }\n};\n\nclass Quadrat : public Form {\n  double seite;\npublic:\n  Quadrat(double s) : seite(s) {}\n  double flaeche() override {\n    return seite * seite;\n  }\n};\n\nint main() {\n  std::vector<Form*> formen;\n  formen.push_back(new Kreis(2));     // Kreis mit Radius 2 → Fläche ≈ 12.56636\n  formen.push_back(new Quadrat(3));   // Quadrat mit Seite 3 → Fläche = 9\n\n  for (Form* f : formen) {\n    f->zeige();                        // Ausgabe:\n                                      // Fläche: 12.56636\n                                      // Fläche: 9\n  }\n\n  for (Form* f : formen) {\n    delete f;\n  }\n  return 0;\n}"
]

  }
},
{
  "title": "Finale Klassen und Memberfunktionen",
  "content": {
    "text": [
      "### === Finale Klassen und Memberfunktionen ===\n",
      "Mit dem Schlüsselwort `final` kann man in C++ **Vererbung oder Überschreiben verhindern**.\n",
      "\n",
      "👉 Das ist nützlich, wenn du sicherstellen willst, dass bestimmte Funktionen oder Klassen **nicht mehr verändert** werden dürfen.\n",
      "\n",
      "---\n",
      "### Finale Memberfunktionen:\n",
      "- Eine `virtual`-Funktion kann mit `final` markiert werden:\n",
      "```cpp\nvirtual void machEtwas() final;\n```\n",
      "- Dadurch **kann sie in abgeleiteten Klassen nicht mehr überschrieben** werden.\n",
      "- Wird oft verwendet, um bestimmte Methoden **festzulegen und abzusichern**.\n",
      "\n",
      "---\n",
      "### Finale Klassen:\n",
      "- Eine ganze Klasse kann mit `final` markiert werden:\n",
      "```cpp\nclass A final { ... };\n```\n",
      "- Dadurch **kann von dieser Klasse nicht mehr geerbt** werden.\n",
      "- Ideal, wenn die Klasse **vollständig abgeschlossen** ist oder keine weitere Spezialisierung erwünscht ist.\n",
      "\n",
      "📌 `final` wurde mit **C++11** eingeführt. Es erhöht die **Lesbarkeit**, verbessert die **Fehlersicherheit** und kann dem Compiler sogar **Optimierungen** ermöglichen.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Basis {\npublic:\n  virtual void begruessung() {\n    std::cout << \"Hallo aus Basis\" << std::endl;\n  }\n  virtual void fixMethode() final {\n    std::cout << \"Diese Methode ist final und kann nicht überschrieben werden.\" << std::endl;\n  }\n  virtual ~Basis() {}\n};\n\nclass Abgeleitet : public Basis {\npublic:\n  void begruessung() override {\n    std::cout << \"Hallo aus Abgeleitet\" << std::endl;\n  }\n  // void fixMethode() override {} // ❌ Fehler: Methode ist final in der Basisklasse\n};\n\n// === Finale Klasse ===\nclass Endklasse final {\npublic:\n  void info() {\n    std::cout << \"Dies ist eine finale Klasse.\" << std::endl;\n  }\n};\n\n// class Versuch : public Endklasse {}; // ❌ Fehler: Endklasse ist final, kann nicht geerbt werden\n\nint main() {\n  Basis* b = new Abgeleitet();\n  b->begruessung(); // Ausgabe: Hallo aus Abgeleitet\n  b->fixMethode();  // Ausgabe: Diese Methode ist final und kann nicht überschrieben werden.\n\n  Endklasse e;\n  e.info(); // Ausgabe: Dies ist eine finale Klasse.\n\n  delete b;\n  return 0;\n"
    ]
  }
},
{
  "title": "Kovariante Rückgabetypen",
  "content": {
    "text": [
      "### === Kovariante Rückgabetypen ===\n",
      "Kovariante Rückgabetypen ermöglichen es in C++, dass eine **überschriebene virtuelle Funktion** in einer abgeleiteten Klasse **einen spezielleren Rückgabetyp** liefert.\n",
      "\n",
      "👉 Der Rückgabetyp darf sich ändern, **wenn er ein Zeiger oder eine Referenz auf einen abgeleiteten Typ** ist.\n",
      "\n",
      "---\n",
      "### Beispiel:\n",
      "- In der Basisklasse wird eine Funktion deklariert, die `Basis*` zurückgibt.\n",
      "- In der abgeleiteten Klasse kann dieselbe Funktion dann `Abgeleitet*` zurückgeben.\n",
      "\n",
      "✅ Das ist erlaubt, **solange die Rückgabetypen kompatibel vererbt** sind (also `Abgeleitet*` ist ein Spezialfall von `Basis*`).\n",
      "\n",
      "---\n",
      "### Vorteile:\n",
      "- Ermöglicht **präzisere Typen** bei polymorphem Verhalten.\n",
      "- Spart **unnötige Casts** im Code.\n",
      "\n",
      "📌 Achtung: Kovarianz gilt **nur** für Rückgabetypen bei **virtuellen Funktionen**, nicht bei Parametern.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <memory>\n\nclass Tier {\npublic:\n  virtual Tier* klonen() const {\n    std::cout << \"Tier wird geklont\" << std::endl;\n    return new Tier(*this); // Kopiert das aktuelle Objekt (Kopierkonstruktor)\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  Hund* klonen() const override { // ✅ kovarianter Rückgabetyp: Hund* statt Tier*\n    std::cout << \"Hund wird geklont\" << std::endl;\n    return new Hund(*this); // ✅ korrekt: erstellt Kopie des aktuellen Hund-Objekts\n    // return *(new Hund()); // ❌ Fehler: ergibt Objekt (Hund), kein Zeiger (Hund*)\n  }\n\n  // int klonen() const override { return 1; } // ❌ Fehler: inkompatibler Rückgabetyp (int ≠ Tier*)\n};\n\n// === Beispiel für Rückgabe als Referenz ===\nclass Fog {\npublic:\n  std::string name = \"Fog\";\n};\n\nclass DemoRef {\npublic:\n  Fog& getFog() const {\n    return *(new Fog()); // ✅ erlaubt: Rückgabe als Referenz (&), Objekt lebt auf dem Heap\n  }\n};\n\nint main() {\n  Tier* t = new Hund();\n  Tier* neu = t->klonen(); // Ausgabe: Hund wird geklont\n\n  DemoRef d;\n  Fog& f = d.getFog();\n  std::cout << f.name << std::endl; // Ausgabe: Fog\n\n  delete t;\n  delete neu;\n  delete &f; // ❗️manuell löschen, da mit new erzeugt\n  return 0;\n"
    ]
  }
},
{
  "title": "Object Slicing",
  "content": {
    "text": [
      "### === Object Slicing ===\n",
      "Beim **Object Slicing** (Objektabschneiden) geht Information **verloren**, wenn ein Objekt einer abgeleiteten Klasse in ein Objekt einer Basisklasse **kopiert** wird - **ohne Zeiger oder Referenz**.\n",
      "\n",
      "👉 Dabei werden **nur die Mitglieder der Basisklasse** übernommen - alles, was zur Unterklasse gehört, **geht verloren**.\n",
      "\n",
      "---\n",
      "### Wann passiert Slicing?\n",
      "- Wenn ein Objekt **per Wert** (also nicht per Zeiger oder Referenz) übergeben oder zugewiesen wird.\n",
      "- Typisch bei: `Base b = Derived();`\n",
      "\n",
      "---\n",
      "### Warum ist das ein Problem?\n",
      "- Virtuelle Funktionen verhalten sich dann **nicht mehr polymorph**.\n",
      "- Das Objekt \"vergisst\", dass es eigentlich ein Unterklassen-Objekt war.\n",
      "\n",
      "---\n",
      "### Wie vermeidet man Slicing?\n",
      "- Arbeite immer mit **Zeigern (`*`) oder Referenzen (`&`)**, nicht mit Objekten per Wert.\n",
      "- Übergib Objekte polymorph:\n",
      "```cpp\nvoid verarbeite(const Base& b);\n```\n",
      "\n",
      "📌 C++ selbst erkennt Slicing **nicht als Fehler** - du musst es **bewusst vermeiden**!\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n#include <string>\n\nclass Tier {\npublic:\n  std::string name = \"Tier\";\n\n  virtual void sprich() const {\n    std::cout << name << \" spricht\" << std::endl;\n  }\n  virtual ~Tier() {}\n};\n\nclass Hund : public Tier {\npublic:\n  std::string rasse = \"Schäferhund\";\n\n  void sprich() const override {\n    std::cout << name << \" bellt. Rasse: \" << rasse << std::endl;\n  }\n};\n\nvoid machGeräusch(Tier t) { // ❌ Slicing: Hund wird zu Tier kopiert\n  std::cout << \"[Slicing] Name: \" << t.name << std::endl;\n  t.sprich(); // Ausgabe: Tier spricht\n}\n\nvoid machGeräuschRichtig(const Tier& t) { // ✅ korrekt per Referenz\n  std::cout << \"[Kein Slicing] Name bleibt erhalten\" << std::endl;\n  t.sprich(); // Ausgabe: Hund bellt. Rasse: Schäferhund\n}\n\nint main() {\n  Hund h;\n  h.name = \"Bello\";\n  h.rasse = \"Labrador\";\n\n  machGeräusch(h);        // ❌ slicing: nur Tier-Teil bleibt übrig\n  machGeräuschRichtig(h); // ✅ korrekt: vollständiges Objekt erhalten\n\n  return 0;\n"
    ]
  }
},
{
  "title": "Mehrfachvererbung",
  "content": {
    "text": [
      "### === Mehrfachvererbung ===\n",
      "In C++ ist es möglich, dass eine Klasse **von mehreren Basisklassen gleichzeitig erbt**.\n",
      "\n",
      "👉 Das nennt man **Mehrfachvererbung** und sie kann nützlich sein - aber auch schnell zu Problemen führen.\n",
      "\n",
      "---\n",
      "### Syntax:\n",
      "- Eine Klasse kann mehrere Basisklassen angeben:\n",
      "```cpp\nclass C : public A, public B { ... };\n```\n",
      "\n",
      "---\n",
      "### Vorteile:\n",
      "- Kombinieren von Funktionalität aus verschiedenen Klassen.\n",
      "- Kann helfen, **Code zu teilen**, z.B. bei Interfaceklassen.\n",
      "\n",
      "---\n",
      "### Probleme (Diamond Problem):\n",
      "- Wenn **mehrere Basisklassen** von **derselben Oberklasse** erben, kann es zu **Mehrdeutigkeiten** kommen.\n",
      "- Beispiel: Beide Elternklassen erben von `Grundklasse`, Kindklasse erbt von beiden → `Grundklasse` ist **zweimal** vorhanden!\n",
      "\n",
      "---\n",
      "### Lösung: `virtual`-Vererbung\n",
      "- Mit `virtual` wird sichergestellt, dass es **nur eine gemeinsame Instanz** der Basisklasse gibt:\n",
      "```cpp\nclass A : virtual public Grundklasse { };\n```\n",
      "- Wird auch **virtuelle Vererbung** genannt.\n",
      "\n",
      "---\n",
      "### Reihenfolge: Konstruktoren & Destruktoren\n",
      "- Die Konstruktoren der **Basisklassen** werden in der Reihenfolge aufgerufen, wie sie **in der Klassendeklaration** erscheinen - **nicht nach Reihenfolge im Initialisierungslisten-Code**.\n",
      "- Destruktoren laufen **in umgekehrter Reihenfolge** (von abgeleitet nach oben).\n",
      "- Bei **virtueller Vererbung** wird der virtuelle Basisklassenkonstruktor **nur einmal** aufgerufen - von der **untersten Klasse** im Hierarchiebaum.\n",
      "\n",
      "📌 Mehrfachvererbung ist mächtig, sollte aber **mit Bedacht eingesetzt** werden. Oft sind Komposition oder Interfaces die bessere Wahl.\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Lebewesen {\npublic:\n  Lebewesen() { std::cout << \"[Konstruktor] Lebewesen\" << std::endl; }\n  ~Lebewesen() { std::cout << \"[Destruktor] Lebewesen\" << std::endl; }\n  void atme() { std::cout << \"Lebewesen atmet\" << std::endl; }\n};\n\nclass Schwimmer : virtual public Lebewesen {\npublic:\n  Schwimmer() { std::cout << \"[Konstruktor] Schwimmer\" << std::endl; }\n  ~Schwimmer() { std::cout << \"[Destruktor] Schwimmer\" << std::endl; }\n  void schwimme() { std::cout << \"Ich schwimme\" << std::endl; }\n};\n\nclass Läufer : virtual public Lebewesen {\npublic:\n  Läufer() { std::cout << \"[Konstruktor] Läufer\" << std::endl; }\n  ~Läufer() { std::cout << \"[Destruktor] Läufer\" << std::endl; }\n  void laufe() { std::cout << \"Ich laufe\" << std::endl; }\n};\n\nclass Triathlet : public Schwimmer, public Läufer {\npublic:\n  Triathlet() { std::cout << \"[Konstruktor] Triathlet\" << std::endl; }\n  ~Triathlet() { std::cout << \"[Destruktor] Triathlet\" << std::endl; }\n  void wettkampf() {\n    atme();\n    schwimme();\n    laufe();\n  }\n};\n\nint main() {\n  Triathlet t;\n  t.wettkampf();\n  return 0;\n}\n\n// Beispielausgabe:\n// [Konstruktor] Lebewesen\n// [Konstruktor] Schwimmer\n// [Konstruktor] Läufer\n// [Konstruktor] Triathlet\n// Lebewesen atmet\n// Ich schwimme\n// Ich laufe\n// [Destruktor] Triathlet\n// [Destruktor] Läufer\n// [Destruktor] Schwimmer\n// [Destruktor] Lebewesen"
    ]
  }
}






      
    ]
  },







  {
    "category": "Überladung",
    "subtopics": [
      {
        "title": "Funktionen",
        "content": {
          "text": [
            "### === Funktionsüberladung in C++ ===\n",
            "Funktionsüberladung bedeutet, dass mehrere Funktionen **denselben Namen**, aber **unterschiedliche Parameterlisten** haben können.\n",
            "\n",
            "Der Compiler wählt beim Aufruf die passende Funktion anhand der übergebenen Argumente.\n",
            "\n",
            "---\n",
            "### Regeln\n",
            "- Funktionen müssen sich in der Anzahl oder dem Typ der Parameter unterscheiden\n",
            "- Rückgabewert allein reicht **nicht** zur Unterscheidung!\n",
            "\n",
            "---\n",
            "### Vorteile\n",
            "- Lesbarkeit: Gleicher Funktionsname für ähnliche Aufgaben\n",
            "- Flexibilität: Funktion kann mit verschiedenen Datentypen arbeiten\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n\n// Funktionsüberladungen\nvoid begruessung() {\n  std::cout << \"Hallo!\" << std::endl;\n}\n\nvoid begruessung(std::string name) {\n  std::cout << \"Hallo, \" << name << \"!\" << std::endl;\n}\n\nvoid begruessung(int stunde) {\n  if (stunde < 12)\n    std::cout << \"Guten Morgen!\" << std::endl;\n  else\n    std::cout << \"Guten Tag!\" << std::endl;\n}\n\nint main() {\n  begruessung();              // Ausgabe: Hallo!\n  begruessung(\"Kilian\");     // Ausgabe: Hallo, Kilian!\n  begruessung(9);             // Ausgabe: Guten Morgen!\n\n  return 0;\n}"

          ]
        }
      },
      {
        "title": "Operatoren",
        "content": {
          "text": [
            "### === Operatorüberladung in C++ ===\n",
            "Operatorüberladung erlaubt es, **eigene Klassen** so zu definieren, dass Standard-Operatoren (`+`, `==`, `<<`, usw.) auch mit diesen Klassen funktionieren.\n",
            "\n",
            "---\n",
            "### Warum Operatoren überladen?\n",
            "- Mehr Lesbarkeit: `a + b` statt `a.addiere(b)`\n",
            "- Natürlichere Verwendung eigener Typen\n",
            "\n",
            "---\n",
            "### Syntax\n",
            "`Rückgabetyp operator<OPERATOR>(Parameter)`\n",
            "-> Wird innerhalb oder außerhalb der Klasse definiert\n",
            "-> Kann fast jeder Operator überladen werden (außer z.B. `.` oder `::`)\n",
            "---\n"
          ],
          "code": [
  "#include <iostream>\n\nclass Punkt {\nprivate:\n  int x, y;\n\npublic:\n  Punkt(int x, int y) : x(x), y(y) {}\n\n  // Operatorüberladung für +\n  Punkt operator+(const Punkt& other) {\n    return Punkt(x + other.x, y + other.y);\n  }\n\n  // Operatorüberladung für -\n  Punkt operator-(const Punkt& other) {\n    return Punkt(x - other.x, y - other.y);\n  }\n\n  // Gleichheitsoperator ==\n  bool operator==(const Punkt& other) const {\n    return x == other.x && y == other.y;\n  }\n\n  // Ausgabeoperator überladen (als friend)\n  friend std::ostream& operator<<(std::ostream& os, const Punkt& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n  }\n};\n\nclass Zähler {\nprivate:\n  int wert;\n\npublic:\n  Zähler(int w) : wert(w) {}\n\n  // Präfix-Inkrement ++z\n  Zähler& operator++() {\n    ++wert;\n    return *this;\n  }\n\n  // Postfix-Inkrement z++\n  Zähler operator++(int) {\n    Zähler temp = *this;\n    ++wert;\n    return temp;\n  }\n\n  // Ausgabeoperator\n  friend std::ostream& operator<<(std::ostream& os, const Zähler& z) {\n    os << z.wert;\n    return os;\n  }\n};\n\nint main() {\n  Punkt a(2, 3);\n  Punkt b(4, 1);\n  Punkt c = a + b;\n  Punkt d = a - b;\n\n  std::cout << \"a + b = \" << c << std::endl;  // (6, 4)\n  std::cout << \"a - b = \" << d << std::endl;  // (-2, 2)\n\n  std::cout << std::boolalpha;\n  std::cout << \"a == b: \" << (a == b) << std::endl; // false\n\n  Zähler z(10);\n  std::cout << \"z: \" << z << std::endl;      // 10\n  std::cout << \"++z: \" << ++z << std::endl;   // 11\n  std::cout << \"z++: \" << z++ << std::endl;   // 11 (zeigt alten Wert)\n  std::cout << \"nach z++: \" << z << std::endl; // 12\n\n  return 0;\n}"
]
        }
      }
    ]
  },







  {
    "category": "Extras",
    "subtopics": [
      {
  "title": "Formatierung",
  "content": {
    "text": [
      "### === Formatierung in C++ ===\n",
      "In C++ gibt es verschiedene Möglichkeiten, Ausgaben optisch zu formatieren - z.B. für Tabellen, Zahlen, Texte und Spezialformate.\n",
      "\n",
      "---\n",
      "### 📏 Feldbreite und Ausrichtung (`<iomanip>`)\n",
      "- `std::setw(n)`: Legt die Breite eines Felds fest\n",
      "- `std::left`, `std::right`: Textausrichtung (nur in Verbindung mit `std::setw()`)\n",
      "- `std::setfill(c)`: Zeichen zum Auffüllen (z.B. `0` oder `-`)\n",
      "\n",
      "---\n",
      "### 🔢 Nachkommastellen und Gleitkommaformat\n",
      "- `std::fixed`: Feste Anzahl Nachkommastellen\n",
      "- `std::setprecision(n)`: Anzahl Nachkommastellen\n",
      "- `std::scientific`: Wissenschaftliche Notation\n",
      "\n",
      "---\n",
      "### 🔣 Zahlenformate\n",
      "- `std::dec` → dezimal (Standard)\n",
      "- `std::hex` → hexadezimal\n",
      "- `std::oct` → oktal\n",
      "- Praktisch für Debug-Ausgaben oder Speicheradressen\n",
      "\n",
      "---\n",
      "### 🔐 Führende Nullen\n",
      "- Mit `std::setw()` und `std::setfill('0')`:\n",
      "```cpp\nstd::cout << std::setw(5) << std::setfill('0') << 17; // 00017\n```\n",
      "- Mit `std::string` manuell:\n",
      "```cpp\nstd::string s = std::string(5 - std::to_string(17).length(), '0') + std::to_string(17);\n```\n",
      "- Ab C++20 mit `std::format`:\n",
      "```cpp\nstd::format(\"{:05}\", 17); // 00017\n```\n",
      "\n",
      "---\n",
      "### 🆕 `std::format` (C++20)\n",
      "- Moderner, leistungsfähiger Formatter\n",
      "- Nutzt Python-ähnliche Syntax\n",
      "- Beispiele:\n",
      "```cpp\nstd::format(\"{} hat {} Punkte\", name, punkte);\nstd::format(\"{:>10}\", \"rechts\"); // rechtsbündig\n```\n",
      "- Erfordert Compiler mit C++20 + Format-Unterstützung (`<format>`)\n",
      "---\n"
    ],
    "code": [
  "#include <iostream>\n#include <iomanip>\n#include <string>\n#if __cpp_lib_format\n  #include <format>\n#endif\n\nint main() {\n  std::string name = \"Kilian\";\n  int punkte = 42;\n  double kontostand = 1234.56789;\n\n  // Feldbreite und Ausrichtung\n  std::cout << std::left << std::setw(12) << \"Name\"\n            << std::right << std::setw(8) << \"Punkte\"\n            << std::setw(15) << \"Kontostand\" << std::endl; // Ausgabe: Name            Punkte     Kontostand\n  std::cout << std::left << std::setw(12) << name\n            << std::right << std::setw(8) << punkte\n            << std::setw(15) << std::fixed << std::setprecision(2) << kontostand << std::endl; // Ausgabe: Kilian             42         1234.57\n\n  // Zahlenformate\n  int zahl = 42;\n  std::cout << \"Dezimal: \" << std::dec << zahl << std::endl;        // Ausgabe: Dezimal: 42\n  std::cout << \"Hexadezimal: \" << std::hex << zahl << std::endl;   // Ausgabe: Hexadezimal: 2a\n  std::cout << \"Oktal: \" << std::oct << zahl << std::endl;          // Ausgabe: Oktal: 52\n\n  // Führende Nullen mit iomanip\n  std::cout << \"Führende Nullen: \" << std::setw(5) << std::setfill('0') << zahl << std::endl; // Ausgabe: Führende Nullen: 00042\n\n  // Mit std::string\n  std::string gepolstert = std::string(5 - std::to_string(zahl).length(), '0') + std::to_string(zahl);\n  std::cout << \"Manuell gepolstert: \" << gepolstert << std::endl; // Ausgabe: Manuell gepolstert: 00042\n\n#if __cpp_lib_format\n  // Mit std::format (C++20)\n  std::cout << std::format(\"std::format führend: {:05}\\n\", zahl); // Ausgabe: std::format führend: 00042\n  std::cout << std::format(\"Name: {}, Punkte: {}\\n\", name, punkte); // Ausgabe: Name: Kilian, Punkte: 42\n  std::cout << std::format(\"{:>10}\\n\", \"rechts\"); // Ausgabe:     rechts\n#endif\n\n  return 0;\n"
]

  }
},
    {
  "title": "Casting",
  "content": {
    "text": [
      "### === Casting in C++ ===\n",
      "Casting ist die Umwandlung eines Ausdrucks von einem Datentyp in einen anderen.\n",
      "In C++ gibt es sowohl **C-Style Casts** als auch **C++-spezifische Casts**:\n",
      "\n",
      "---\n",
      "### 🟥 C-Style Cast (unsicher!)\n",
      "```cpp\nint x = (int)3.14;   // Ergebnis: 3\n```\n",
      "- Alt, kompakt, aber **unsicher**\n",
      "- Kann **gefährliche Typumwandlungen** stillschweigend zulassen\n",
      "\n",
      "---\n",
      "### ✅ C++ Casts (sicherer & spezifischer):\n",
      "\n",
      "#### 🔹 static_cast<T>(expr)\n",
      "- Für **sichere, logische Konvertierungen** (z.B. `double` → `int`, `Base*` → `Derived*` bei Vererbung ohne RTTI)\n",
      "```cpp\nint x = static_cast<int>(3.7);  // x = 3\n```\n",
      "\n",
      "---\n",
      "#### 🔹 dynamic_cast<T>(expr)\n",
      "- Für **sichere Konvertierung bei Vererbung** mit `virtual`\n",
      "- Funktioniert nur mit **Polymorphie** (mind. eine `virtual`-Methode)\n",
      "- Gibt `nullptr` zurück, wenn Cast fehlschlägt\n",
      "```cpp\nBase* b = new Derived();\nDerived* d = dynamic_cast<Derived*>(b);  // OK\n```\n",
      "\n",
      "---\n",
      "#### 🔹 const_cast<T>(expr)\n",
      "- Entfernt oder fügt `const` hinzu (z.B. um schreibende Funktion auf `const`-Objekte anzuwenden)\n",
      "- Nur erlaubt, wenn Ursprungsobjekt nicht wirklich `const` war\n",
      "```cpp\nconst int* p = ...;\nint* mod = const_cast<int*>(p);\n```\n",
      "\n",
      "---\n",
      "### 👇 Empfehlung:\n",
      "- Verwende **`static_cast` für fast alles**, wenn du den Typ kennst\n",
      "- **Vermeide `C-Style`-Casts**, wenn möglich\n",
      "- **Nutze `dynamic_cast` nur bei Vererbung**, sonst bringt es nichts\n",
      "- **Vermeide `const_cast`**, außer in Spezialfällen\n",
      "---\n"
    ],
    "code": [
      "#include <iostream>\n\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\" << std::endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\" << std::endl; }\n};\n\nint main() {\n    double pi = 3.14;\n    int x = static_cast<int>(pi);               // static_cast: 3\n    std::cout << \"x: \" << x << std::endl;\n\n    Base* base = new Derived();\n    Derived* d = dynamic_cast<Derived*>(base);  // dynamic_cast: OK\n    if (d) d->show();                           // Ausgabe: Derived\n\n    const int a = 42;\n    int* b = const_cast<int*>(&a);              // const_cast: ⚠️ gefährlich\n    std::cout << \"b: \" << *b << std::endl;\n\n    delete base;\n    return 0;\n}"
    ]
  }
},
      {
        "title": "Algorithmen",
        "content": {
          "text": [
            "### === STL-Algorithmen in C++ ===\n",
            "Die Standard Template Library (STL) bietet viele nützliche Algorithmen zur Bearbeitung von Containern wie `vector`, `set`, `map`, etc.\n",
            "\n",
            "---\n",
            "### Wichtige Algorithmen:\n",
            "- `std::sort`: Sortiert Elemente (benötigt `<algorithm>`)\n",
            "- `std::reverse`: Dreht die Reihenfolge um\n",
            "- `std::find`: Sucht ein bestimmtes Element\n",
            "- `std::count`: Zählt, wie oft ein bestimmter Wert vorkommt\n",
            "- `std::for_each`: Führt eine Funktion auf jedem Element aus\n",
            "- `std::remove`: Entfernt (logisch) ein Element - mit `erase` kombinieren\n",
            "\n",
            "---\n",
            "### Allgemein\n",
            "- Alle Algorithmen arbeiten mit **Iteratoren** (z.B. `begin()` / `end()`)\n",
            "- STL-Algorithmen verändern nicht den Container direkt (außer `sort`, `reverse`, etc.)\n",
            "- Viele Algorithmen nutzen **Lambdas** oder Funktionsobjekte\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // für sort, find, etc.\n\nint main() {\n  std::vector<int> zahlen = {4, 2, 7, 2, 9};\n\n  // sortieren\n  std::sort(zahlen.begin(), zahlen.end());\n\n  // ausgeben\n  std::cout << \"Sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \";\n  std::cout << std::endl; // Ausgabe: 2 2 4 7 9\n\n  // zählen\n  int anz = std::count(zahlen.begin(), zahlen.end(), 2);\n  std::cout << \"Die Zahl 2 kommt \" << anz << \" mal vor.\" << std::endl;\n\n  // suchen\n  auto it = std::find(zahlen.begin(), zahlen.end(), 7);\n  if (it != zahlen.end()) {\n    std::cout << \"7 gefunden an Position \" << (it - zahlen.begin()) << std::endl; //(it - zahlen.begin()) == Abstand im Container\n  }\n\n  // for_each mit Lambda\n  std::cout << \"Alle Werte verdoppelt: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x * 2 << \" \"; });\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
      {
        "title": "Templates",
        "content": {
          "text": [
            "### === Templates in C++ ===\n",
            "Templates ermöglichen es, **generischen Code** zu schreiben, der mit beliebigen Datentypen funktioniert.\n",
            "\n",
            "---\n",
            "### Warum Templates?\n",
            "- Wiederverwendbarkeit: gleiche Funktion/Klasse für viele Datentypen\n",
            "- Flexibilität: z.B. `int`, `double`, `std::string`, eigene Typen\n",
            "- Kein mehrfacher Code nötig für unterschiedliche Typen\n",
            "\n",
            "---\n",
            "### Funktions-Template\n",
            "```cpp\n template <typename T>\n T max(T a, T b) {\n   return (a > b) ? a : b;\n }\n```\n",
            "`T` ist ein Platzhalter für einen beliebigen Typ.\n",
            "Beim Aufruf wird automatisch der passende Typ eingesetzt (Typinferenz).\n",
            "\n",
            "---\n",
            "### Einschränkung bei Operatoren\n",
            "Ein Funktions-Template wie `addiere(T a, T b)` funktioniert **nur, wenn für `T` der `+`-Operator definiert ist**.\n",
            "Beispiele, wo es funktioniert:\n",
            "- `int`, `double`, `std::string`\n",
            "Bei eigenen Typen (z.B. `struct Person`) musst du den `operator+` **selbst überladen**, damit das Template funktioniert.\n",
            "\n",
            "---\n",
            "### Klassen-Template\n",
            "```cpp\n template <typename T>\n class Box {\n   T inhalt;\n   // ...\n };\n```\n",
            "Auch Klassen lassen sich so für beliebige Typen definieren.\n",
            "---\n",
            "\n### Typ muss bei Klassen-Templates immer angegeben werden\n",
            "Im Gegensatz zu Funktions-Templates kann der Compiler bei Klassen **nicht automatisch den Typ ableiten**.\n",
            "Du musst beim Erstellen eines Objekts **immer den gewünschten Typ explizit angeben**:\n",
            "```cpp\nBehälter<int> b(10);   // ✅ korrekt\nBehälter b(10);        // ❌ Fehler - Typ fehlt\n```\n",
            "Der Compiler kann aus den Konstruktorargumenten **nicht selbst schließen**, welchen Typ `T` annehmen soll.\n",
            "\n",
            "---\n",
            "### `typename` oder `class`?\n",
            "Beide Varianten sind bei Templates **gleichwertig** und funktionieren identisch:\n",
            "```cpp\ntemplate <typename T>   // bevorzugt in moderner C++-Schreibweise\ntemplate <class T>      // historisch häufiger verwendet\n```\n",
            "Du kannst die Variante frei wählen - in modernen Projekten ist `typename` oft üblicher, weil es semantisch klarer ist.\n",
            "---\n",
            "\n### Methoden außerhalb von Template-Klassen definieren\n",
            "Wenn eine Methode **außerhalb** einer Template-Klasse definiert wird, muss der Compiler genau wissen, dass auch die Methode ein Template ist.\n",
            "Dazu muss man:\n",
            "- die `template <typename T>`-Zeile **vor jeder Methode** wiederholen\n",
            "- beim Klassennamen den **Typparameter mit angeben**\n",
            "```cpp\n// Klassendeklaration\ntemplate <typename T>\nclass Complex {\n  T re();\n};\n\n// Methodendefinition außerhalb\ntemplate <typename T>\nT Complex<T>::re() {\n  // ...\n}\n```\n",
            "Ohne diese Angaben kann der Compiler die Funktion nicht korrekt zuordnen und meldet einen Fehler.\n",
            "---\n",    
            "\n### Templates und Dateiaufteilung\n",
            "Bei normalen Klassen ist es üblich, Deklaration und Definition auf `.hpp` und `.cpp` aufzuteilen.\n",
            "→ Bei Template-Klassen funktioniert das **nicht**, weil der Compiler beim Verwenden (z.B. `Complex<int>`) **alle Methoden kennen muss**.\n",
            "\n",
            "---\n",
            "### Lösung: `.tpp`-Datei\n",
            "Um den Code trotzdem übersichtlich zu halten, wird die Implementierung oft in eine `.tpp`-Datei ausgelagert.\n",
            "Diese wird **ausnahmsweise in der Header-Datei eingebunden**:\n",
            "```cpp\n// complex.hpp\n#ifndef COMPLEX_HPP\n#define COMPLEX_HPP\n\ntemplate <typename T>\nclass Complex {\n  // ...\n  T re();\n  T im();\n};\n\n#include \"complex.tpp\"  // Wichtig: im Header einbinden!\n\n#endif\n```\n",
            "```cpp\n// complex.tpp\ntemplate <typename T>\nT Complex<T>::re() { return re_; }\n\ntemplate <typename T>\nT Complex<T>::im() { return im_; }\n```\n",
            "So bleibt der Code sauber getrennt, aber der Compiler kann beim Instanziieren alle Definitionen sehen.\n",
            "---\n",
            "\n### Statische Member in Template-Klassen\n",
            "Statische Variablen in Template-Klassen werden **für jede Typ-Instanziierung separat erzeugt**.\n",
            "Das bedeutet: `complex<int>` und `complex<long>` haben **unabhängige** eigene `counter_`-Werte.\n",
            "Will man statisch **typübergreifend** zählen, muss man eine **globale Variable außerhalb** der Klasse verwenden.\n",
            "---\n",
            "\n### Templates mit Wertparametern\n",
            "Templates können neben Typen auch **konstante Werte als Parameter** annehmen - sogenannte **Nicht-Typ-Template-Parameter**.\n",
            "Diese werden wie normale Parameter in der Template-Liste angegeben, z.B. `int offset`:\n",
            "```cpp\ntemplate <typename T, int offset = 42>\nT shiftedMax(T x, T y) {\n  return offset + (x > y ? x : y);\n}\n```\n",
            "Aufrufbeispiele:\n",
            "- `shiftedMax<int, 10>(2, 3)` → ergibt `13`\n",
            "- `shiftedMax<double>(2.0, 3.0)` → ergibt `45.0` (Default-Offset 42)\n",
            "- `shiftedMax(2, 3)` → ergibt `45` (Typ und Offset abgeleitet)\n",
            "\n",
            "📌 Zulässig sind nur **integrale Datentypen** wie `int`, `char`, `bool` oder `enum`.\n",
            "👉 Integrale Datentypen sind alle **ganzzahligen Typen**, also ohne Nachkommastellen.\n",
            "Für **jede Kombination von Typ und Wert** wird beim Kompilieren **neuer Code generiert**.\n",
            "---\n",
            "\n### Template-Klassen mit Wert- und Typ-Defaults\n",
            "Auch Klassen-Templates können **konstante Wertparameter** enthalten - z.B. zur Festlegung von Array-Größen.\n",
            "Zusätzlich können **Standardwerte für Typen und Werte** angegeben werden:\n",
            "```cpp\ntemplate <class T = int, unsigned int size = 2>\nstruct my_array {\n  T data[size];\n};\n```\n",
            "Verwendung:\n",
            "- `my_array<> a;` → ergibt `my_array<int, 2>`\n",
            "- `my_array<double> b;` → ergibt `my_array<double, 2>`\n",
            "- `my_array<double, 10> c;` → ergibt `my_array<double, 10>`\n",
            "\n",
            "📌 Der Wertparameter `size` muss ein **konstanter Ausdruck** sein, z.B. `unsigned int`.\n",
            "So lassen sich Klassen flexibel anpassen, ohne jedes Detail beim Aufruf anzugeben.\n",
            "---\n",
            "\n### Template-Template-Parameter\n",
            "Templates können auch **andere Templates als Parameter** annehmen. Das nennt man **Template-Template-Parameter** oder kurz: **Template-Templates**.\n",
            "\n",
            "Ein typisches Beispiel ist ein generischer Container-Wrapper:\n",
            "```cpp\ntemplate <class T,\n          template<typename, typename> class C,\n          template<typename> class A = std::allocator>\nclass container_wrapper {\n  C<T, A<T>> container;\npublic:\n  void insert(const T& t) { container.push_back(t); }\n  const T& get(unsigned int i) { return container[i]; }\n};\n```\n",
            "\n",
            "#### 🔍 Was passiert hier?\n",
            "- `T` ist der Typ der Elemente, z.B. `int` oder `std::string`\n",
            "- `C` ist ein Container-Template wie `std::vector` oder `std::list`, das **zwei Typen erwartet** (`T`, `Allocator<T>`) → deshalb `template<typename, typename>`\n",
            "- `A` ist der **Allocator**, also eine Speicherverwaltungsklasse, z.B. `std::allocator` (Standardwert)\n",
            "\n",
            "➡️ Der Ausdruck `C<T, A<T>> container;` wird z.B. zu `std::vector<int, std::allocator<int>>`.\n",
            "\n",
            "---\n",
            "#### ✅ Beispiel:\n",
            "```cpp\ncontainer_wrapper<std::string, std::vector> cw;\ncw.insert(\"Hello\");\nstd::cout << cw.get(0);  // Ausgabe: Hello\n```\n",
            "\n",
            "#### 📌 Warum ist das so aufgebaut?\n",
            "- Container wie `std::vector` benötigen zwei Parameter: den Datentyp und den Allocator\n",
            "- Deshalb muss `C` so definiert sein: `template<typename, typename>`\n",
            "- Der extra `A`-Parameter erlaubt es, den Allocator gezielt zu setzen oder den Standard zu verwenden\n",
            "\n",
            "💡 Ein **Allocator** kümmert sich intern um die Speicherverwaltung - in der Praxis brauchst du ihn meist nicht aktiv zu benutzen.\n",
            "\n",
            "**Template-Template-Parameter** sind ein mächtiges Werkzeug für sehr flexible, generische Konstrukte - aber sie können schnell komplex wirken.\n",
            "---\n",
            "\n### Abhängige Typen und `typename`\n",
            "In Template-Klassen können auch **Typen auftreten, die vom Typparameter abhängen** - z.B. `T*` oder `std::vector<T>::iterator`.\n",
            "Solche Typen nennt man **abhängige Typen** (*dependent types*), weil sie erst beim Instantiieren des Templates eindeutig sind.\n",
            "\n",
            "📌 Wichtig: Wenn du innerhalb eines Templates auf einen solchen abhängigen Typ zugreifst, **musst du `typename` davor schreiben**, damit der Compiler weiß, dass es sich um einen Typ handelt:\n",
            "```cpp\ntypename std::vector<T>::iterator iter;\n```\n",
            "Ohne `typename` denkt der Compiler eventuell, es handelt sich um ein Datenmitglied oder eine Funktion - und gibt einen Fehler aus.\n",
            "---\n",    
            "\n### Vererbung mit Template-Klassen\n",
            "Template-Klassen können als **Basisklassen** in Vererbungshierarchien dienen.\n",
            "Sie eignen sich z.B. für generische Schnittstellen mit Memberfunktionen, die verschiedene Typen verarbeiten sollen.\n",
            "Wenn eine **nicht-template Unterklasse** davon ableitet, muss sie den **Typparameter festlegen**:\n",
            "```cpp\nclass add_double : invertible_operation<double> { ... };\n```\n",
            "So kann man z.B. mit einer Basisklasse `operation<T>` die Methode `T apply(T, T)` vorschreiben - unabhängig vom konkreten Typ.\n",
            "Mit virtuellen oder rein virtuellen Methoden lassen sich dabei flexible, generische Interfaces bauen.\n",
            "---\n",
            "\n### Template-Metaprogrammierung\n",
            "Templates können in C++ nicht nur für generischen Code verwendet werden - man kann damit auch **Werte zur Compile-Zeit berechnen**. Das nennt man **Template-Metaprogrammierung**.\n",
            "\n",
            "Ein klassisches Beispiel ist die Fakultät (n!) als rekursive Template-Variable:\n",
            "```cpp\ntemplate<unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\n\ntemplate<>\nconstexpr unsigned long long factorial<0> = 1;\n```\n",
            "Diese Definition berechnet z.B. `factorial<5>` schon beim Übersetzen als `120`.\n",
            "\n",
            "Überprüfen lässt sich das mit `static_assert`, das bei einem falschen Ergebnis einen Compilerfehler auslöst:\n",
            "```cpp\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n```\n",
            "Das Programm führt diese Berechnung **nicht zur Laufzeit aus**, sondern ersetzt `factorial<5>` direkt mit dem Wert.\n",
            "---\n",    
            "\n### SFINAE mit `std::enable_if` (Typabhängige Spezialisierung)\n",
            "Mithilfe von `std::enable_if` und `type_traits` wie `std::is_integral` oder `std::is_floating_point` lassen sich **Funktionen gezielt nur für bestimmte Typen definieren**.\n",
            "Das funktioniert über das Prinzip **SFINAE** (Substitution Failure Is Not An Error): Wenn eine Typbedingung nicht zutrifft, wird die Funktion einfach ignoriert - ohne Compilerfehler.\n",
            "\n",
            "Beispiel: Eine Funktion, die einen Wert mit 2ⁿ multipliziert - einmal für Ganzzahlen mit Bitshift, einmal für Fließkommazahlen mit `std::pow`:\n",
            "```cpp\n// für Ganzzahlen (schnell via Bitshift)\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\n\n// für Gleitkommazahlen\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n```\n",
            "Je nach übergebenem Typ (`int` oder `double`) wird die passende Version der Funktion instanziiert.\n",
            "---\n",    
            "\n### Concepts (ab C++20)\n",
            "Templates können fehlschlagen, wenn bestimmte Operationen mit einem Typ nicht erlaubt sind - z.B. wenn ein Typ nicht durchlaufbar ist oder kein `+=` unterstützt.\n",
            "Mit **Concepts** kann man diese Voraussetzungen **explizit machen**.\n",
            "\n",
            "Beispiel: Das Concept `Sequence` prüft, ob ein Typ `.begin()` und `.end()` besitzt:\n",
            "```cpp\ntemplate<typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\n```\n",
            "Damit kann man eine Funktion nur für passende Typen zulassen:\n",
            "```cpp\ntemplate<Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n```\n",
            "Wenn ein ungeeigneter Typ übergeben wird (z.B. ein String-Literal), gibt der Compiler eine **klare Fehlermeldung** - z.B.:\n",
            "- `ERROR: constraints not satisfied: the required expression 's.begin()' is invalid`\n",
            "\n",
            "📌 Concepts helfen dabei, Templates **zu beschränken**, **Fehler verständlicher zu machen** und sind eine moderne Alternative zu `std::enable_if` und `type_traits`.\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <array>\n#include <type_traits>\n#include <cmath>\n#include <string>\n#include <memory>\n#include <concepts>\n\n// === Funktions-Template ===\ntemplate <typename T>\nT maxValue(T a, T b) {\n  return (a > b) ? a : b;\n}\n\n// === Klassen-Template mit statischem Member ===\ntemplate <typename T>\nclass CounterBox {\npublic:\n  static int count;\n  T value;\n  CounterBox(T v) : value(v) { ++count; }\n};\ntemplate <typename T>\nint CounterBox<T>::count = 0;\n\n// === Template mit Wertparameter ===\ntemplate <typename T, int offset = 0>\nT shiftedMax(T a, T b) {\n  return offset + ((a > b) ? a : b);\n}\n\n// === Template-Klasse mit Typ- und Wert-Default ===\ntemplate <typename T = int, size_t N = 3>\nstruct MyArray {\n  T data[N];\n};\n\n// === Template-Template-Parameter ===\ntemplate <typename T, template<typename, typename> class Container, template<typename> class Alloc = std::allocator>\nclass ContainerWrapper {\n  Container<T, Alloc<T>> items;\npublic:\n  void add(const T& t) { items.push_back(t); }\n  const T& get(size_t i) { return items[i]; }\n};\n\n// === Abhängiger Typ mit typename ===\ntemplate <typename T>\nclass WithIterator {\npublic:\n  typename std::vector<T>::iterator it;\n};\n\n// === Vererbung mit Templates ===\ntemplate <typename T>\nclass Operation {\npublic:\n  virtual T apply(T, T) const = 0;\n};\ntemplate <typename T>\nclass InvertibleOperation : public Operation<T> {\npublic:\n  virtual T apply_inverse(T, T) const = 0;\n};\nclass AddDouble : public InvertibleOperation<double> {\npublic:\n  double apply(double a, double b) const override { return a + b; }\n  double apply_inverse(double a, double b) const override { return a - b; }\n};\n\n// === Template-Metaprogrammierung ===\ntemplate <unsigned long long N>\nconstexpr unsigned long long factorial = N * factorial<N - 1>;\ntemplate <>\nconstexpr unsigned long long factorial<0> = 1;\nstatic_assert(factorial<5> == 120, \"factorial<5> failed\");\n\n// === SFINAE mit enable_if ===\ntemplate <typename T>\nstd::enable_if_t<std::is_integral<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x << n;\n}\ntemplate <typename T>\nstd::enable_if_t<std::is_floating_point<T>::value, T>\nmultByPow2(T x, unsigned int n) {\n  return x * std::pow(2.0, n);\n}\n\n// === Concepts ===\ntemplate <typename S>\nconcept Sequence = requires(S s) {\n  { s.begin() };\n  { s.end() };\n};\ntemplate <Sequence S, typename T>\nT accum(S seq, T value) {\n  for (const auto& x : seq) value += x;\n  return value;\n}\n\nint main() {\n  std::cout << maxValue(4, 7) << std::endl;\n  CounterBox<int> a(1), b(2);\n  std::cout << \"Anzahl CounterBox<int>: \" << CounterBox<int>::count << std::endl;\n  std::cout << shiftedMax<int, 10>(3, 5) << std::endl;\n  MyArray<> arr1;\n  MyArray<double, 5> arr2;\n  ContainerWrapper<std::string, std::vector> cw;\n  cw.add(\"Hello\");\n  std::cout << cw.get(0) << std::endl;\n  AddDouble ad;\n  std::cout << ad.apply(3.5, 2.5) << \", \" << ad.apply_inverse(3.5, 2.5) << std::endl;\n  std::cout << multByPow2(2, 3) << \" | \" << multByPow2(0.5, 4) << std::endl;\n  std::vector<int> v = {1, 2, 3};\n  std::cout << accum(v, 0) << std::endl;\n  return 0;\n}"
          ]
        }
      },
            {
        "title": "Lambdas",
        "content": {
          "text": [
            "### === Lambda-Ausdrücke in C++ ===\n",
            "Ein Lambda ist eine **anonyme Funktion**, die direkt im Code definiert und z.B. an Algorithmen übergeben werden kann.\n",
            "\n",
            "---\n",
            "### Warum Lambdas?\n",
            "- Wenn man **kleine Funktionen nur einmalig** braucht (z.B. in `sort`, `for_each`), ist es **unnötig**, extra eine benannte Funktion zu schreiben.\n",
            "- Lambdas machen den Code **kürzer, klarer und direkt an Ort und Stelle**.\n",
            "- Sie lassen sich auch mit lokalen Variablen verknüpfen (über `[]`-Capture).\n",
            "\n",
            "---\n",
            "### Syntax\n",
            "`[capture](parameter) -> rückgabetyp { body }`\n",
            "- `capture`: Welche Variablen von außen verwendet werden dürfen (z.B. `[x]`, `[&]`, `[=]`, `[]`)\n",
            "- `parameter`: Übergabeparameter wie bei normalen Funktionen\n",
            "- `rückgabetyp` ist optional (oft automatisch erkannt)\n",
            "\n",
            "---\n",
            "### Beispiel - einfache Lambda-Funktion\n",
            "```cpp\n auto quadrat = [](int x) { return x * x; };\n quadrat(5); // ergibt 25\n```\n",
            "\n",
            "---\n",
            "### Lambdas mit Algorithmen\n",
            "Sehr praktisch in Verbindung mit `std::for_each`, `std::sort`, usw.\n",
            "```cpp\n std::for_each(v.begin(), v.end(), [](int x){ std::cout << x << \" \"; });\n```\n",
            "---\n"
          ],
          "code": [
            "#include <iostream>\n#include <vector>\n#include <algorithm> // für for_each, sort\n\nint main() {\n  std::vector<int> zahlen = {5, 2, 8, 1};\n\n  // Lambda speichern und benutzen\n  auto quadrat = [](int x) { return x * x; };\n  std::cout << \"Quadrat von 4: \" << quadrat(4) << std::endl; // Ausgabe: 16\n\n  // for_each mit Lambda\n  std::cout << \"Zahlen: \";\n  std::for_each(zahlen.begin(), zahlen.end(), [](int x){ std::cout << x << \" \"; });\n  std::cout << std::endl;\n\n  // sortieren mit Lambda (absteigend)\n  std::sort(zahlen.begin(), zahlen.end(), [](int a, int b){ return a > b; });\n\n  std::cout << \"Absteigend sortiert: \";\n  for (int z : zahlen) std::cout << z << \" \"; // Ausgabe: 8 5 2 1\n  std::cout << std::endl;\n\n  return 0;\n}"
          ]
        }
      },
{
  "title": "Exceptions",
  "content": {
    "text": [
      "### === Exceptions in C++ - Fehler sauber behandeln ===\n",
      "**Exceptions** (Ausnahmen) sind das C++-System, um **Fehler zu erkennen** und **sauber darauf zu reagieren**, ohne den gesamten Code mit `if`-Abfragen vollzustopfen.\n",
      "\n",
      "---\n",
      "### 🧠 Grundidee\n",
      "- Du prüfst, ob etwas schief läuft → mit `if`\n",
      "- Du meldest den Fehler → mit `throw`\n",
      "- Du behandelst ihn **zentral** → mit `catch`\n",
      "\n",
      "---\n",
      "### ✅ Warum Exceptions verwenden?\n",
      "- Dein **Hauptcode bleibt übersichtlich**\n",
      "- Du hast die **Fehlerbehandlung zentral an einem Ort** (z.B. in `main()`)\n",
      "- Lokale Objekte werden bei Fehlern **automatisch gelöscht** (Stack-Unwinding)\n",
      "\n",
      "---\n",
      "### 🔧 Grundstruktur\n",
      "```cpp\ntry {\n  // Problematischer Code, z.B. Funktion, die throw verwendet\n} catch (const std::exception& e) {\n  // Hier behandelst du den Fehler zentral\n}\n```\n",
      "\n",
      "---\n",
      "### 📌 Beispiel: Funktion wirft Fehler, `main` fängt ihn\n",
      "```cpp\n#include <iostream>\n#include <stdexcept>\nint teile(int a, int b) {\n  if (b == 0) throw std::runtime_error(\"Division durch 0 nicht erlaubt\");\n  return a / b;\n}\nint main() {\n  try {\n    int x = teile(10, 0);\n    std::cout << \"Ergebnis: \" << x << \"\\n\";\n  } catch (const std::exception& e) {\n    std::cerr << \"Fehler aufgetreten: \" << e.what() << \"\\n\";\n  }\n  return 0;\n}\n```\n",
      "\n",
      "---\n",
      "### 🔍 Was passiert im `catch`-Block?\n",
      "**Hier kommt dein Plan B.** Du kannst z.B.:\n",
      "- Eine **Fehlermeldung ausgeben** (`std::cerr`)\n",
      "- Das **Programm beenden** (`return` oder `exit`)\n",
      "- **Benutzereingaben nochmal abfragen**\n",
      "- Eine **Ersatzdatei öffnen** oder **Alternativweg** gehen\n",
      "- Etwas **aufräumen** (z.B. Speicher, Datei schließen)\n",
      "\n",
      "---\n",
      "### 📦 Häufige Exception-Typen (aus `<stdexcept>`)\n",
      "**`std::logic_error`** (Fehler durch falschen Code):\n",
      "- `std::invalid_argument` - ungültiger Parameter\n",
      "- `std::domain_error` - mathematisch unsinniger Wert\n",
      "- `std::length_error` - Datenstruktur zu groß\n",
      "- `std::out_of_range` - Index zu groß\n",
      "\n",
      "**`std::runtime_error`** (Fehler zur Laufzeit):\n",
      "- `std::overflow_error` - Überlauf (z.B. Zahl zu groß)\n",
      "- `std::underflow_error` - Unterlauf\n",
      "- `std::range_error` - Bereichsproblem\n",
      "- `std::system_error` - Betriebssystemfehler (Dateien, Threads)\n",
      "- `std::bad_alloc` - kein Speicher verfügbar\n",
      "- `std::bad_cast` - falscher Cast\n",
      "\n",
      "---\n",
      "### 💡 Merksatz\n",
      "> `if` erkennt den Fehler, `throw` wirft ihn weiter, `catch` reagiert darauf.\n",
      "\n",
      "---\n",
      "### 🎯 Tipp für deinen Code-Stil\n",
      "- Schreibe **`throw` in deinen Funktionen**, z.B. `throw std::invalid_argument(...)`\n",
      "- Schreibe **`try` und `catch` in `main()`**, um die Fehler an einer Stelle zu behandeln\n",
      "\n",
      "---\n",
      "### 🎁 Bonus: RAII schützt vor Speicherlecks\n",
      "- Bei Exceptions werden automatisch **alle lokalen Objekte** gelöscht\n",
      "- Aber: **manuell mit `new` erstellte Objekte nicht!**\n",
      "- Lösung: Verwende **Smart Pointer** oder RAII-Klassen (z.B. `std::unique_ptr`)\n",
      "---\n"
    ],
    "code": [
  "#include <iostream> // Ein- und Ausgabe\n#include <memory>    // Für smart pointer\n#include <stdexcept>  // Für Exception-Typen\n\nint main() {\n    try {\n        // Speicher dynamisch anfordern, aber mit RAII sicher verwalten\n        std::unique_ptr<int[]> daten(new int[100]);\n\n        // Stell dir vor, hier passiert ein Problem zur Laufzeit\n        throw std::runtime_error(\"Ein Fehler ist aufgetreten!\");\n\n        // Dieser Code wird nie erreicht - wäre aber sicher\n        std::cout << \"Berechnung abgeschlossen.\" << std::endl;\n\n    } catch (const std::runtime_error& e) {\n        // Exception behandeln und Fehlermeldung anzeigen\n        std::cerr << \"Fehler: \" << e.what() << std::endl;\n    }\n\n    // Programmende, Speicher wurde automatisch durch unique_ptr freigegeben\n    return 0;\n}"
    ]
  }
},
       {
        "title": "Doxygen",
        "content": {
          "text": [
      "### === Doxygen - Automatische Dokumentation für C++ ===\n",
      "Doxygen ist ein Tool, mit dem man aus speziell kommentiertem C++-Code automatisch eine HTML- oder PDF-Dokumentation erzeugen kann - ähnlich wie Javadoc bei Java.\n",
      "\n",
      "---\n",
      "### Vorteile von Doxygen:\n",
      "- Übersichtliche Dokumentation für große Projekte\n",
      "- Besseres Verständnis für andere Entwickler (oder dich selbst später)\n",
      "- Funktioniert direkt aus dem C++-Quellcode\n",
      "\n",
      "---\n",
      "### Grundprinzip:\n",
      "- Man kommentiert Klassen, Funktionen, Variablen mit speziellen `/** ... */`- oder `///`-Blöcken\n",
      "- Doxygen liest diese Kommentare und erzeugt daraus eine strukturierte Dokumentation\n",
      "\n",
      "---\n",
      "### Wichtige Doxygen-Kommentare:\n",
      "- `@brief`: Kurzbeschreibung\n",
      "- `@param`: Beschreibung eines Parameters\n",
      "- `@return`: Rückgabewert\n",
      "- `@author`, `@version`, `@date`, ...\n",
      "\n",
      "---\n",
      "### Beispiel für eine dokumentierte Funktion:\n",
      "```cpp\n/**\n * @brief Addiert zwei Zahlen\n * @param a Erste Zahl\n * @param b Zweite Zahl\n * @return Summe von a und b\n */\nint addiere(int a, int b) {\n    return a + b;\n}\n```\n",
      "\n",
      "---\n",
      "### So benutzt du Doxygen:\n",
      "1. Lade dir Doxygen von https://www.doxygen.nl/download.html herunter\n",
      "2. Starte das Tool (`doxygen -g`) und bearbeite die `Doxyfile`\n",
      "3. Füge deinen Projektpfad ein\n",
      "4. Führe Doxygen aus: `doxygen Doxyfile`\n",
      "5. Dokumentation wird im `html/` oder `latex/`-Ordner erstellt\n",
      "\n",
      "---\n",
      "👉 Doxygen wird besonders im Beruf, in Open-Source-Projekten oder bei Bibliotheken verwendet\n",
      "👉 Du kannst es auch lokal nutzen, um dein Projekt ordentlich zu strukturieren\n",
      "---\n"
    ],
          "code": []
  }
}

    ]
  }
  
]

